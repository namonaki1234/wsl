!*******************************************************************************************************
!*******************************************************************************************************
!******** ƒpƒbƒP[ƒWŒ^ƒ‚ƒWƒ…[ƒ‹                                    				********
!******** ‰t“H‹O“¹ŒvZ—pƒTƒuƒ‹[ƒ`ƒ“ŒQ                              				********
!********  				              2013.05.15  PROGRAMMED BY RYOSKUE HAYASHI	********
!********					      2013.06.18     UPDATED BY RYOSKUE HAYASHI	********
!********					      2013.06.24     UPDATED BY RYOSKUE HAYASHI	********
!********					      2013.07.21     UPDATED BY RYOSKUE HAYASHI	********
!********					      2014.04.15     UPDATED BY RYOSKUE HAYASHI	********
!********					      2014.12.08     UPDATED BY MIKI	SHIMURA	********
!********					      2015.04.29     UPDATED BY MIKI	SHIMURA	********
!********					      2015.05.04     UPDATED BY MIKI	SHIMURA	********
!******** ‹…‚ÌR—ÍŒW”‚ğ“ˆê									********
!******** Schiller and Naumman			      2015.05.11     UPDATED BY MIKI    SHIMURA ********
!******** 											********
!******** ûWŒø—¦‚ğÕ“Ë—Ê‚©‚çŒvZ                    2015.05.27     UPDATED BY MIKI    SHIMURA ********
!*******************************************************************************************************
!*******************************************************************************************************
!*******************************************************************************************************
module Package_Droplet
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 private
 ! ƒTƒuƒ‹[ƒ`ƒ“éŒ¾ ************************************************************************************
 ! ‹¤—LƒTƒuƒ‹[ƒ`ƒ“ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 public :: DropletBreakup        , CalAspectRatio
 public :: Drag2D                , Drag3D           
 public :: WiegandDrag           , WebernumberDrag
 public :: DragGennaro           , VargasFeoDrag
 public :: GravityBuoyancy2D     , GravityBuoyancy3D
 public :: Rotation2D            , Rotation3D       
 public :: TimeEuler2D           , TimeEuler3D      
 public :: TimeEulerTemperature2D, TimeEulerTemperature3D
 public :: Velocity2D            , Velocity3D       
 public :: dt2D       	         , dt3D          
 public :: ImpingementJudge3D
 public :: ImpingementArea3D
 public :: ImpingementVelocity3D
 public :: ImpingementTemperature3D
 public :: CollectionEfficiency3D
 public :: SplashLEWICE3D        , SplashSamenfink
 public :: MakeMAVSFileDroplet3D
 public :: MakeMAVSFileDropletTemperature3D
 public :: MakeMAVSFileDropletWe3D
 public :: MakeMAVSFileSLD3D
 ! ‹¤—L’è” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real, parameter :: pi   = 3.1415926535897932
 real, parameter :: zero = 1.0e-20
 ! “à•”è‘±‚« ******************************************************************************************
contains
!*******************************************************************************************************
!******** ‰t“H•ª—ôƒ‚ƒfƒ‹									********
!******** LEWICE‚Ég‚Á‚Ä‚éƒ‚ƒfƒ‹H								********
!*******************************************************************************************************
subroutine DropletBreakup( &
&            dp1, rhop, up, vp, wp, rhof, uf, vf, wf, mup, sigp, fBreakup, nBrk, &
&            dp2 )
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 ! ˆø”•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! ‰t“H‚Ìƒpƒ‰ƒ[ƒ^ ------------------------------------------------------------------------------------
 real, intent(in)  :: dp1
 real, intent(in)  :: up, vp, wp
 real, intent(in)  :: rhop, mup, sigp
 ! —¬‘Ì‚Ìƒpƒ‰ƒ[ƒ^ ------------------------------------------------------------------------------------
 real, intent(in)  :: uf, vf, wf
 real, intent(in)  :: rhof
 ! ‰t“H•ª—ô‚Ìƒtƒ‰ƒO‚Æ‰t“H” ----------------------------------------------------------------------------
 logical, intent(out) :: fBreakup
 integer, intent(inout) :: nBrk
 ! •ª—ôŒã‚Ì‰t“HŒa --------------------------------------------------------------------------------------
 real, intent(out) :: dp2
 ! ‹ÇŠ•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: Vel, We, Rep
 ! ˆ—ŠJn ********************************************************************************************
 Vel = sqrt((uf - up)**2 + (vf - vp)**2 + (wf - wp)**2)
 ! ƒEƒF[ƒo[” ----------------------------------------------------------------------------------------
 We = rhof * Vel**2 * dp1 / sigp
 ! ‰t“H‚ÌƒŒƒCƒmƒ‹ƒY” ----------------------------------------------------------------------------------
 Rep = rhop * Vel * dp1 / mup
 ! •ª—ôŒã‚Ì‰t“HŒa --------------------------------------------------------------------------------------
 if(We > 13.0)then
  fBreakup = .true.
  dp2 = 6.2 * (rhop / rhof)**0.25 * Rep**(-0.5) * dp1
  nBrk = nBrk + 1
 else
  fBreakup = .false.
  dp2 = dp1
 endif
 ! ˆ—I—¹ ********************************************************************************************
 return
end subroutine DropletBreakup
!*******************************************************************************************************
!******** ‰t“H‚Ì•ÏŒ`‚ÌƒAƒXƒyƒNƒg”ä‚ÌŒvZ							********
!******** Quasi-steady deformation and drag of uncontaminated liquid drops			********
!******** B.T.Helenbrook, C.F.Edward (2002)							********
!*******************************************************************************************************
subroutine CalAspectRatio( &
&            dp, rhop, up, vp, wp, rhof, uf, vf, wf, mup, sigp, muf, &
&            AsRatio )
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 ! ˆø”•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! ‰t“H‚Ìƒpƒ‰ƒ[ƒ^ ------------------------------------------------------------------------------------
 real, intent(in)  :: dp
 real, intent(in)  :: up, vp, wp
 real, intent(in)  :: rhop, mup, sigp
 ! —¬‘Ì‚Ìƒpƒ‰ƒ[ƒ^ ------------------------------------------------------------------------------------
 real, intent(in)  :: uf, vf, wf
 real, intent(in)  :: rhof, muf
 ! ƒAƒXƒyƒNƒg”ä ----------------------------------------------------------------------------------------
 real, intent(out) :: AsRatio
 ! ‹ÇŠ•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: Vel, We, Oh
 ! ˆ—ŠJn ********************************************************************************************
 Vel = sqrt((uf - up)**2 + (vf - vp)**2 + (wf - wp)**2)
 ! ƒEƒF[ƒo[” ----------------------------------------------------------------------------------------
 We = rhof * Vel**2 * dp / sigp
 ! ƒI[ƒlƒ]ƒ‹ƒQ” --------------------------------------------------------------------------------------
 Oh = mup / sqrt(rhop * sigp * dp)
 ! ƒAƒXƒyƒNƒg”ä ----------------------------------------------------------------------------------------
 AsRatio = 1.0 - 0.11 * We**0.82 + 0.013 * sqrt(rhop / rhof) * muf / mup * Oh**0.55 * We**1.1
 ! ˆ—I—¹ ********************************************************************************************
 return
end subroutine CalAspectRatio
!*******************************************************************************************************
!******** ’èíR—Í (“ñŸŒ³)    		                               				********
!*******************************************************************************************************
subroutine Drag2D( &
&            dp, rhop, up, vp, rhof, uf, vf, muf, &
&            fx, fy, Cd )
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 ! ˆø”•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! ‰t“H‚Ìƒpƒ‰ƒ[ƒ^ ------------------------------------------------------------------------------------
 real, intent(in)  :: dp                      				! ’¼Œa
 real, intent(in)  :: rhop                    				! –§“x
 real, intent(in)  :: up, vp                  				! ‘¬“x
 ! —¬‘Ì‚Ìƒpƒ‰ƒ[ƒ^ ------------------------------------------------------------------------------------
 real, intent(in)  :: rhof                 				! –§“x
 real, intent(in)  :: uf, vf                  				! ‘¬“x
 real, intent(in)  :: muf                  				! ”S«ŒW”
 ! ’èíR—Í --------------------------------------------------------------------------------------------
 real, intent(out) :: fx, fy, Cd
 ! ‹ÇŠ•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: vel, Rep, f
 ! ˆ—ŠJn ********************************************************************************************
 ! ‰t“HƒŒƒCƒmƒ‹ƒY” ------------------------------------------------------------------------------------
 vel = sqrt((uf - up)**2 + (vf - vp)**2)
 Rep = vel * dp * rhof / max(zero, muf)
 Rep = min(1000.0, max(0.01, Rep))
 ! ’ïRŒW” --------------------------------------------------------------------------------------------
 cd = 24.0 / Rep * (1.0 + 0.15 * Rep**0.687)
 ! ’PˆÊ¿—Ê‚Ì‰t“H‚É“­‚­R—Í ----------------------------------------------------------------------------
 f  = 3.0 * cd * rhof / (4.0 * rhop * dp)
 fx = f * vel * (uf - up)
 fy = f * vel * (vf - vp)
 ! ˆ—I—¹ ********************************************************************************************
 return
end subroutine Drag2D
!*******************************************************************************************************
!******** ’èíR—Í (OŸŒ³) 	                				                ********
!*******************************************************************************************************
subroutine Drag3D( &
&            dp, rhop, up, vp, wp, rhof, uf, vf, wf, muf, &
&            fx, fy, fz, Cd )
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 ! ˆø”•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! ‰t“H‚Ìƒpƒ‰ƒ[ƒ^ ------------------------------------------------------------------------------------
 real, intent(in)  :: dp                      				! ’¼Œa
 real, intent(in)  :: rhop                    				! –§“x
 real, intent(in)  :: up, vp, wp              				! ‘¬“x
 ! —¬‘Ì‚Ìƒpƒ‰ƒ[ƒ^ ------------------------------------------------------------------------------------
! real, intent(in)  :: ReRef       				        ! ‘ã•\ƒŒƒCƒmƒ‹ƒY”
 real, intent(in)  :: rhof        				        ! –§“x
 real, intent(in)  :: uf, vf, wf  				        ! ‘¬“x
 real, intent(in)  :: muf         				        ! ”S«ŒW”
 ! ’èíR—Í --------------------------------------------------------------------------------------------
 real, intent(out) :: fx, fy, fz, Cd
 ! ‹ÇŠ•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: vel, Rep, f
 ! ˆ—ŠJn ********************************************************************************************
 ! ‰t“HƒŒƒCƒmƒ‹ƒY” ------------------------------------------------------------------------------------
 vel = sqrt((uf - up)**2 + (vf - vp)**2 + (wf - wp)**2)
 Rep = vel * dp * rhof / max(zero, muf)
 Rep = min(1000.0, max(0.01, Rep))
 ! ’ïRŒW” --------------------------------------------------------------------------------------------
 cd = 24.0 / Rep * (1.0 + 0.15 * Rep**0.687)
 ! ’PˆÊ¿—Ê‚Ì‰t“H‚É“­‚­R—Í ----------------------------------------------------------------------------
 f  = 3.0 * cd * rhof / (4.0 * rhop * dp)
 fx = f * vel * (uf - up)
 fy = f * vel * (vf - vp)
 fz = f * vel * (wf - wp)
 ! ˆ—I—¹ ********************************************************************************************
 return
end subroutine Drag3D
! R—Í *************************************************************************************************
! De Gennaro (2009) , Mingione (2012) 
subroutine DragGennaro( &
&            dp, rhop, up, vp, wp, rhof, uf, vf, wf, muf, &
&            fx, fy, fz, Cd )
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 ! ˆø”•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! ‰t“H‚Ìƒpƒ‰ƒ[ƒ^ ------------------------------------------------------------------------------------
 real, intent(in)  :: dp                      				! ’¼Œa
 real, intent(in)  :: rhop                    				! –§“x
 real, intent(in)  :: up, vp, wp              				! ‘¬“x
 ! —¬‘Ì‚Ìƒpƒ‰ƒ[ƒ^ ------------------------------------------------------------------------------------
! real, intent(in)  :: ReRef       				        ! ‘ã•\ƒŒƒCƒmƒ‹ƒY”
 real, intent(in)  :: rhof        				        ! –§“x
 real, intent(in)  :: uf, vf, wf  				        ! ‘¬“x
 real, intent(in)  :: muf         				        ! ”S«ŒW”
 ! ’èíR—Í --------------------------------------------------------------------------------------------
 real, intent(out) :: fx, fy, fz, Cd
 ! ‹ÇŠ•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: vel, Rep, f
 ! ˆ—ŠJn ********************************************************************************************
 ! ‰t“HƒŒƒCƒmƒ‹ƒY” ------------------------------------------------------------------------------------
 vel = sqrt((uf - up)**2 + (vf - vp)**2 + (wf - wp)**2)
 Rep = vel * dp * rhof / max(zero, muf)
 Rep = min(1000.0, max(0.01, Rep))
 ! ’ïRŒW” --------------------------------------------------------------------------------------------
 if( Rep <= 345.0 ) then
  cd = 24.0 / Rep * (1.0 + 0.15 * Rep**0.687)
 else if( (345.0 < Rep) .and. (Rep <= 385.0) ) then 
  cd = 24.0 / Rep * (-0.00355 * Rep + 3.760)
 else if( (385.0 < Rep) .and. (Rep <= 442.0) ) then 
  cd = 24.0 / Rep * (-0.00517 * Rep + 4.782)
 else if( (442.0 < Rep) .and. (Rep <= 475.0) ) then 
  cd = 24.0 / Rep * (-0.00255 * Rep + 3.425)
 else if( (475.0 < Rep) .and. (Rep <= 518.0) ) then 
  cd = 24.0 / Rep * ( 0.0318  * Rep - 12.903)
 else if( (518.0 < Rep) .and. (Rep <= 630.0) ) then 
  cd = 24.0 / Rep * ( 0.00333 * Rep - 0.313)
 else if( (630.0 < Rep) .and. (Rep <= 720.0) ) then 
  cd = 24.0 / Rep * (-0.00325 * Rep + 2.221)
 else if(720.0 < Rep)then
  cd = 24.0 / Rep * (1.0 + 0.15 * Rep**0.687)
 endif
 ! ’PˆÊ¿—Ê‚Ì‰t“H‚É“­‚­R—Í ----------------------------------------------------------------------------
 f  = 3.0 * cd * rhof / (4.0 * rhop * dp)
 fx = f * vel * (uf - up)
 fy = f * vel * (vf - vp)
 fz = f * vel * (wf - wp)
 ! ˆ—I—¹ ********************************************************************************************
 return
end subroutine DragGennaro
! R—Í *************************************************************************************************
! Wiegand (1987)
! Schmehl "Tropfendeformation und Nachzerfall bei der technischen Gemischaufbereitung" 2003
! ******************************************************************************************************
subroutine WiegandDrag( &
&            dp, rhop, up, vp, wp, rhof, uf, vf, wf, muf, sigp, &
&            fx, fy, fz, Cd )
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 ! ˆø”•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! ‰t“H‚Ìƒpƒ‰ƒ[ƒ^ ------------------------------------------------------------------------------------
 real, intent(in)  :: dp                      				! ’¼Œa
 real, intent(in)  :: rhop                    				! –§“x
 real, intent(in)  :: up, vp, wp              				! ‘¬“x
 ! —¬‘Ì‚Ìƒpƒ‰ƒ[ƒ^ ------------------------------------------------------------------------------------
! real, intent(in)  :: ReRef       				        ! ‘ã•\ƒŒƒCƒmƒ‹ƒY”
 real, intent(in)  :: rhof        				        ! –§“x
 real, intent(in)  :: uf, vf, wf  				        ! ‘¬“x
 real, intent(in)  :: muf         				        ! ”S«ŒW”
 ! ’èíR—Í --------------------------------------------------------------------------------------------
 real, intent(out) :: fx, fy, fz, Cd
 real, intent(in)  :: sigp
 ! ‹ÇŠ•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: vel, Rep, f, We, cdin, cddef
 ! ˆ—ŠJn ********************************************************************************************
 ! ‰t“HƒŒƒCƒmƒ‹ƒY” ------------------------------------------------------------------------------------
 vel = sqrt((uf - up)**2 + (vf - vp)**2 + (wf - wp)**2)
 Rep = vel * dp * rhof / max(zero, muf)
 Rep = min(1000.0, max(0.01, Rep))
 ! Weber Number ----------------------------------------------------------------------------------------
 We = rhof * vel**2 * dp / sigp
 ! ’ïRŒW” --------------------------------------------------------------------------------------------
 !if(Rep <= 1000.0) then
 cdin = 24.0 / Rep * (1.0 + 0.15 * Rep**0.687)
 !else if (1000.0 < Rep) then
 !cdin = 0.424
 !endif
 cddef = We * ( 0.2319 - 0.1579 * log(Rep) + 0.0471 * (log(Rep))**2 - 0.0042 * (log(Rep))**3)
 cd = cdin + cddef
 ! ’PˆÊ¿—Ê‚Ì‰t“H‚É“­‚­R—Í ----------------------------------------------------------------------------
 f  = 3.0 * cd * rhof / (4.0 * rhop * dp)
 fx = f * vel * (uf - up)
 fy = f * vel * (vf - vp)
 fz = f * vel * (wf - wp)
 ! ˆ—I—¹ ********************************************************************************************
 return
end subroutine WiegandDrag
! R—Í *************************************************************************************************
! Shpere ‚Æ Disk ‚Ì”ä (ƒEƒF[ƒo[”)
! ******************************************************************************************************
subroutine WebernumberDrag( &
&            dp, rhop, up, vp, wp, rhof, uf, vf, wf, muf, sigd, &
&            fx, fy, fz, Cd )
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 ! ˆø”•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! ‰t“H‚Ìƒpƒ‰ƒ[ƒ^ ------------------------------------------------------------------------------------
 real, intent(in)  :: dp                      				! ’¼Œa
 real, intent(in)  :: rhop                    				! –§“x
 real, intent(in)  :: up, vp, wp              				! ‘¬“x
 real, intent(in)  :: Sigd						! •\–Ê’£—Í
 ! —¬‘Ì‚Ìƒpƒ‰ƒ[ƒ^ ------------------------------------------------------------------------------------
! real, intent(in)  :: ReRef       				        ! ‘ã•\ƒŒƒCƒmƒ‹ƒY”
 real, intent(in)  :: rhof        				        ! –§“x
 real, intent(in)  :: uf, vf, wf  				        ! ‘¬“x
 real, intent(in)  :: muf         				        ! ”S«ŒW”
 ! ’èíR—Í --------------------------------------------------------------------------------------------
 real, intent(out) :: fx, fy, fz, Cd
 ! ‹ÇŠ•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: vel, Rep, f
 real :: We, Cdsph, Cddisk, e
 ! ˆ—ŠJn ********************************************************************************************
 ! ‰t“HƒŒƒCƒmƒ‹ƒY” ------------------------------------------------------------------------------------
 vel = sqrt((uf - up)**2 + (vf - vp)**2 + (wf - wp)**2)
 Rep = vel * dp * rhof / max(zero, muf)
 Rep = min(1000.0, max(0.01, Rep))
 ! Weber Number ----------------------------------------------------------------------------------------
 We = rhof * vel**2 * dp / sigd
 ! parameter e -----------------------------------------------------------------------------------------
 e = 1.0 - ( 1.0 / (1.0 + 0.007 * We**0.5)**6.0 )
 ! ’ïRŒW” --------------------------------------------------------------------------------------------
 Cdsph  = 24.0 / Rep * (1.0 + 0.15 * Rep**0.687)
 Cddisk = 1.1 + 64.0 / (pi * Rep)
 Cd = (1.0 - e) * Cdsph + e * Cddisk
 ! ’PˆÊ¿—Ê‚Ì‰t“H‚É“­‚­R—Í ----------------------------------------------------------------------------
 f  = 3.0 * cd * rhof / (4.0 * rhop * dp)
 fx = f * vel * (uf - up)
 fy = f * vel * (vf - vp)
 fz = f * vel * (wf - wp)
 ! ˆ—I—¹ ********************************************************************************************
 return
end subroutine WebernumberDrag
!*******************************************************************************************************
! Drag
! Varcas and Fro NASA/TM-2011-216946
!*******************************************************************************************************
subroutine VargasFeoDrag( &
&            dp, rhop, up, vp, wp, dv, rhof, uf, vf, wf, muf, dt, &
&            fx, fy, fz )
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 ! ˆø”•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! ‰t“H‚Ìƒpƒ‰ƒ[ƒ^ ------------------------------------------------------------------------------------
 real, intent(in)  :: dp                      				! ’¼Œa
 real, intent(in)  :: rhop                    				! –§“x
 real, intent(in)  :: up, vp, wp  				        ! ‘¬“x
 real, intent(in)  :: dv		              			! ‘¬“x·
 real, intent(in)  :: dt						! ŠÔ‚İ
 ! —¬‘Ì‚Ìƒpƒ‰ƒ[ƒ^ ------------------------------------------------------------------------------------
! real, intent(in)  :: ReRef       				        ! ‘ã•\ƒŒƒCƒmƒ‹ƒY”
 real, intent(in)  :: rhof        				        ! –§“x
 real, intent(in)  :: uf, vf, wf  				        ! ‘¬“x
 real, intent(in)  :: muf         				        ! ”S«ŒW”
 ! ’èíR—Í --------------------------------------------------------------------------------------------
 real, intent(out) :: fx, fy, fz
 ! ‹ÇŠ•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: vel, cd, f
 ! ˆ—ŠJn ********************************************************************************************
 vel = sqrt((uf - up)**2 + (vf - vp)**2 + (wf - wp)**2)
 ! ’ïRŒW” --------------------------------------------------------------------------------------------
 cd = 4.0 / 3.0 * rhof / rhop * dp / vel**2 * dv / dt
 ! ’PˆÊ¿—Ê‚Ì‰t“H‚É“­‚­R—Í ----------------------------------------------------------------------------
 f  = 3.0 * cd * rhof / (4.0 * rhop * dp)
 fx = f * vel * (uf - up)
 fy = f * vel * (vf - vp)
 fz = f * vel * (wf - wp)
 ! ˆ—I—¹ ********************************************************************************************
 return
end subroutine VargasFeoDrag
!*******************************************************************************************************
!******** d—Í‚Æ•‚—Í (“ñŸŒ³)    					                        ********
!*******************************************************************************************************
subroutine GravityBuoyancy2D( &
&            rhop, rhof, gx, gy, &
&            fx, fy )
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 ! ˆø”•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real, intent(in)  :: rhop                   				! ‰t“H–§“x
 real, intent(in)  :: rhof                   				! —¬‘Ì–§“x
 real, intent(in)  :: gx, gy                 				! d—Í‰Á‘¬“x
 real, intent(out) :: fx, fy                 				! d—Í‚Æ•‚—Í‚Ì‡—Í
 ! ˆ—ŠJn ********************************************************************************************
 ! ’PˆÊ¿—Ê‚Ì‰t“H‚É“­‚­d—Í‚Æ•‚—Í ----------------------------------------------------------------------
 fx = (1.0 - rhof / rhop) * gx
 fy = (1.0 - rhof / rhop) * gy
 ! ˆ—I—¹ ********************************************************************************************
 return
end subroutine GravityBuoyancy2D
!*******************************************************************************************************
!******** d—Í‚Æ•‚—Í (OŸŒ³)  					                                ********
!*******************************************************************************************************
subroutine GravityBuoyancy3D( &
&            rhop, rhof, gx, gy, gz, &
&            fx, fy, fz )
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 ! ˆø”•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real, intent(in)  :: rhop      					! ‰t“H–§“x
 real, intent(in)  :: rhof      				        ! —¬‘Ì–§“x
 real, intent(in)  :: gx, gy, gz				        ! d—Í‰Á‘¬“x
 real, intent(out) :: fx, fy, fz				        ! d—Í‚Æ•‚—Í‚Ì‡—Í
 ! ˆ—ŠJn ********************************************************************************************
 ! ’PˆÊ¿—Ê‚Ì‰t“H‚É“­‚­d—Í‚Æ•‚—Í ----------------------------------------------------------------------
 fx = (1.0 - rhof / rhop) * gx
 fy = (1.0 - rhof / rhop) * gy
 fz = (1.0 - rhof / rhop) * gz
 ! ˆ—I—¹ ********************************************************************************************
 return
end subroutine GravityBuoyancy3D
!*******************************************************************************************************
!******** ‰ñ“]À•WŒn‚ÌŠµ«—Í (“ñŸŒ³)   							********
!*******************************************************************************************************
subroutine Rotation2D( &
&            OmegaZ, xp, yp, up, vp, &
&            fx, fy )
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 ! ˆø”•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real, intent(in)  :: OmegaZ 				                ! À•WŒn‚ÌŠp‘¬“x
 real, intent(in)  :: xp, yp 				                ! ‰t“H‚ÌÀ•W
 real, intent(in)  :: up, vp 				                ! ‰t“H‚Ì‘¬“x
 real, intent(out) :: fx, fy 				                ! Šµ«—Í
 ! ‹ÇŠ•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: CoriolisX, CoriolisY
 real :: CentrifugalX, CentrifugalY
 ! ˆ—ŠJn ********************************************************************************************
 CoriolisX    = - 2.0 * OmegaZ * vp
 CoriolisY    =   2.0 * OmegaZ * up
 CentrifugalX = - OmegaZ**2 * xp
 CentrifugalY = - OmegaZ**2 * yp
 fx = - CoriolisX - CentrifugalX
 fy = - CoriolisY - CentrifugalY
 ! ˆ—I—¹ ********************************************************************************************
 return
end subroutine Rotation2D
!*******************************************************************************************************
!******** ‰ñ“]À•WŒn‚ÌŠµ«—Í (OŸŒ³) 	                         				********
!*******************************************************************************************************
subroutine Rotation3D( &
&            OmegaX, OmegaY, OmegaZ, xp, yp, zp, up, vp, wp, &
&            fx, fy, fz )
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 ! ˆø”•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real, intent(in)  :: OmegaX, OmegaY, OmegaZ  				! À•WŒn‚ÌŠp‘¬“x
 real, intent(in)  :: xp, yp, zp              				! ‰t“H‚ÌÀ•W
 real, intent(in)  :: up, vp, wp              				! ‰t“H‚Ì‘¬“x
 real, intent(out) :: fx, fy, fz              				! Šµ«—Í
 ! ‹ÇŠ•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: CoriolisX, CoriolisY, coriolisz
 real :: CentrifugalX, CentrifugalY, centrifugalz
 ! ˆ—ŠJn ********************************************************************************************
 CoriolisX    = 2.0 * (OmegaY * wp - OmegaZ * vp)
 CoriolisY    = 2.0 * (OmegaZ * up - OmegaX * wp)
 Coriolisz    = 2.0 * (OmegaX * vp - OmegaY * up)
 CentrifugalX = OmegaY * (OmegaX * yp - OmegaY * xp) &
 &            - OmegaZ * (OmegaZ * xp - OmegaX * zp)
 CentrifugalY = OmegaZ * (OmegaY * zp - OmegaZ * yp) &
 &            - OmegaX * (OmegaX * yp - OmegaY * xp)
 Centrifugalz = OmegaX * (OmegaZ * xp - OmegaX * zp) &
 &            - OmegaY * (OmegaY * zp - OmegaZ * yp)
 fx = - CoriolisX - CentrifugalX
 fy = - CoriolisY - CentrifugalY
 fz = - Coriolisz - Centrifugalz
 ! ˆ—I—¹ ********************************************************************************************
 return
end subroutine Rotation3D
!********************************************************************************************************
!******** ‰t“H‹O“¹ŒvZŠÔis (“ñŸŒ³CEuler —z‰ğ–@) 	  				         ********
!********************************************************************************************************
subroutine TimeEuler2D( &
&            dtp, fx0, fy0, xp0, yp0, up0, vp0, &
&            xp1, yp1, up1, vp1)
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 ! ˆø”•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! ŠÔ‚İ --------------------------------------------------------------------------------------------
 real, intent(in)  :: dtp
 ! ‘OƒXƒeƒbƒv‚Ì‰t“H•Ï” --------------------------------------------------------------------------------
 real, intent(in)  :: fx0, fy0      					! ‰t“H‚É“­‚­—Í
 real, intent(in)  :: xp0, yp0      					! ‰t“HˆÊ’u
 real, intent(in)  :: up0, vp0      					! ‰t“H‘¬“x
 ! ŠÔisŒã‚Ì‰t“H•Ï” --------------------------------------------------------------------------------
 real, intent(out) :: xp1, yp1          				! ‰t“HˆÊ’u
 real, intent(out) :: up1, vp1          				! ‰t“H‘¬“x
 ! ˆ—ŠJn ********************************************************************************************
 xp1 = xp0 + up0 * dtp
 yp1 = yp0 + vp0 * dtp
 up1 = up0 + fx0 * dtp
 vp1 = vp0 + fy0 * dtp
 ! ˆ—I—¹ ********************************************************************************************
 return
end subroutine TimeEuler2D
!*******************************************************************************************************
!******** ‰t“H‹O“¹ŒvZŠÔis (OŸŒ³CEuler —z‰ğ–@) 					        ********
!*******************************************************************************************************
subroutine TimeEuler3D( &
&            dtp, fx0, fy0, fz0, xp0, yp0, zp0, up0, vp0, wp0, &
&            xp1, yp1, zp1, up1, vp1, wp1 )
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 ! ˆø”•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! ŠÔ‚İ --------------------------------------------------------------------------------------------
 real, intent(in)  :: dtp
 ! ‘OƒXƒeƒbƒv‚Ì‰t“H•Ï” --------------------------------------------------------------------------------
 real, intent(in)  :: fx0, fy0, fz0     				! ‰t“H‚É“­‚­—Í
 real, intent(in)  :: xp0, yp0, zp0     				! ‰t“HˆÊ’u
 real, intent(in)  :: up0, vp0, wp0     				! ‰t“H‘¬“x
 ! ŠÔisŒã‚Ì‰t“H•Ï” --------------------------------------------------------------------------------
 real, intent(out) :: xp1, yp1, zp1     				! ‰t“HˆÊ’u
 real, intent(out) :: up1, vp1, wp1     				! ‰t“H‘¬“x
 ! ˆ—ŠJn ********************************************************************************************
 xp1 = xp0 + up0 * dtp
 yp1 = yp0 + vp0 * dtp
 zp1 = zp0 + wp0 * dtp
 up1 = up0 + fx0 * dtp
 vp1 = vp0 + fy0 * dtp
 wp1 = wp0 + fz0 * dtp
 ! ˆ—I—¹ ********************************************************************************************
 return
end subroutine TimeEuler3D
!********************************************************************************************************
!******** ‰t“H‹O“¹ŒvZŠÔis (“ñŸŒ³CEuler —z‰ğ–@C‰·“x•Ï‰»)				         ********
!********************************************************************************************************
subroutine TimeEulerTemperature2D( &
&            dtp, rhop, dp, Cpw, kw, Prt, &
&            rhof, uf, vf, muf, tf, fx0, fy0, xp0, yp0, up0, vp0, tp0, &
&            xp1, yp1, up1, vp1, tp1)
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 ! ˆø”•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real, intent(in)  :: dtp						! ŠÔ‚İ
 real, intent(in)  :: rhop						! ‰t“H–§“x
 real, intent(in)  :: Cpw						! ‰t“H‚Ì’èˆ³”ä”M
 real, intent(in)  :: kw						! ‰t“H‚Ì”M“`“±—¦
 real, intent(in)  :: Prt						! ƒvƒ‰ƒ“ƒgƒ‹”
 real, intent(in)  :: dp						! ‰t“H’¼Œa
 real, intent(in)  :: rhof, uf, vf, muf, tf				! üˆÍ—¬‘Ì‚Ìî•ñ
 real, intent(in)  :: fx0, fy0      					! ‰t“H‚É“­‚­—Í
 real, intent(in)  :: xp0, yp0      					! ‰t“HˆÊ’u
 real, intent(in)  :: up0, vp0      					! ‰t“H‘¬“x
 real, intent(in)  :: tp0	      					! ‰t“H‰·“x
 real, intent(out) :: xp1, yp1          				! ‰t“HˆÊ’u
 real, intent(out) :: up1, vp1          				! ‰t“H‘¬“x
 real, intent(out) :: tp1	          				! ‰t“H‰·“x
 ! ‹ÇŠ•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: vel, Nup, Rep, mp
 ! ˆ—ŠJn ********************************************************************************************
 ! ‰t“HˆÊ’u ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 xp1 = xp0 + up0 * dtp
 yp1 = yp0 + vp0 * dtp
 ! ‰t“H‘¬“x ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 up1 = up0 + fx0 * dtp
 vp1 = vp0 + fy0 * dtp
 ! ‰t“H‰·“x ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! ‰t“HƒŒƒCƒmƒ‹ƒY”
 vel = sqrt((uf - up0)**2 + (vf - vp0)**2)
 Rep = vel * dp * rhof / max(zero, muf)
 Rep = min(1000.0, max(0.01, Rep))
 ! ‰t“HƒkƒbƒZƒ‹ƒg”
 Nup = 2.0 + 0.6 * Rep**(1.0/2.0) * Prt**(1.0/3.0)
 ! ‰t“H¿—Ê
 mp  = rhop * pi * (0.5 * dp)**2
 ! ‰t“H‰·“x
 tp1 = tp0 + dtp / (mp * Cpw) * (pi * dp * kw * (tf - tp0) * Nup)
 ! ˆ—I—¹ ********************************************************************************************
 return
end subroutine TimeEulerTemperature2D
!********************************************************************************************************
!******** ‰t“H‹O“¹ŒvZŠÔis (OŸŒ³CEuler —z‰ğ–@C‰·“x•Ï‰»)				         ********
!********************************************************************************************************
subroutine TimeEulerTemperature3D( &
&            dtp, rhop, dp, Cpw, kw, Prt, &
&            rhof, uf, vf, wf, muf, tf, fx0, fy0, fz0, xp0, yp0, zp0, up0, vp0, wp0, tp0, &
&            xp1, yp1, zp1, up1, vp1, wp1, tp1)
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 ! ˆø”•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real, intent(in)  :: dtp						! ŠÔ‚İ
 real, intent(in)  :: rhop						! ‰t“H–§“x
 real, intent(in)  :: Cpw						! ‰t“H‚Ì’èˆ³”ä”M
 real, intent(in)  :: kw						! ‰t“H‚Ì”M“`“±—¦
 real, intent(in)  :: Prt						! ƒvƒ‰ƒ“ƒgƒ‹”
 real, intent(in)  :: dp						! ‰t“H’¼Œa
 real, intent(in)  :: rhof, uf, vf, wf, muf, tf				! üˆÍ—¬‘Ì‚Ìî•ñ
 real, intent(in)  :: fx0, fy0, fz0    					! ‰t“H‚É“­‚­—Í
 real, intent(in)  :: xp0, yp0, zp0    					! ‰t“HˆÊ’u
 real, intent(in)  :: up0, vp0, wp0    					! ‰t“H‘¬“x
 real, intent(in)  :: tp0	      					! ‰t“H‰·“x
 real, intent(out) :: xp1, yp1, zp1          				! ‰t“HˆÊ’u
 real, intent(out) :: up1, vp1, wp1          				! ‰t“H‘¬“x
 real, intent(out) :: tp1	          				! ‰t“H‰·“x
 ! ‹ÇŠ•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: vel, Nup, Rep, mp
 ! ˆ—ŠJn ********************************************************************************************
 ! ‰t“HˆÊ’u ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 xp1 = xp0 + up0 * dtp
 yp1 = yp0 + vp0 * dtp
 zp1 = zp0 + wp0 * dtp
 ! ‰t“H‘¬“x ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 up1 = up0 + fx0 * dtp
 vp1 = vp0 + fy0 * dtp
 wp1 = wp0 + fz0 * dtp
 ! ‰t“H‰·“x ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! ‰t“HƒŒƒCƒmƒ‹ƒY”
 vel = sqrt((uf - up0)**2 + (vf - vp0)**2 + (wf - wp0)**2)
 Rep = vel * dp * rhof / max(zero, muf)
 Rep = min(1000.0, max(0.01, Rep))
 ! ‰t“HƒkƒbƒZƒ‹ƒg”
 Nup = 2.0 + 0.6 * Rep**(1.0/2.0) * Prt**(1.0/3.0)
 ! ‰t“H¿—Ê
 mp  = rhop * 4.0 / 3.0 * pi * (0.5 * dp)**3
 ! ‰t“H‰·“x
 tp1 = tp0 + dtp / (mp * Cpw) * (pi * dp * kw * (tf - tp0) * Nup)
 ! ˆ—I—¹ ********************************************************************************************
 return
end subroutine TimeEulerTemperature3D
!*******************************************************************************************************
!******** ‰t“H‘¬“x (“ñŸŒ³CŒvZ‹óŠÔ : ”½•Ï‘¬“x)        				@      ********
!*******************************************************************************************************
subroutine Velocity2D( &
&            xix, xiy, etx, ety, up, vp, &
&            uxp, vep )
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 ! ˆø”•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! À•W•ÏŠ·ƒpƒ‰ƒ[ƒ^ ----------------------------------------------------------------------------------
 real, intent(in)  :: xix, xiy, etx, ety
 ! ‰t“H‘¬“x --------------------------------------------------------------------------------------------
 real, intent(in)  :: up, vp               				! ‰t“H‘¬“x (•¨—À•WŒn)
 real, intent(out) :: uxp, vep             				! ‰t“H‘¬“x (ŒvZÀ•WŒn)
 ! ˆ—ŠJn ********************************************************************************************
 uxp = xix * up + xiy * vp
 vep = etx * up + ety * vp
 ! ˆ—I—¹ ********************************************************************************************
 return
end subroutine Velocity2D
!*******************************************************************************************************
!******** ‰t“H‘¬“x (OŸŒ³CŒvZ‹óŠÔ : ”½•Ï‘¬“x)                   				********
!*******************************************************************************************************
subroutine Velocity3D( &
&            xix, xiy, xiz, etx, ety, etz, zex, zey, zez, up, vp, wp, &
&            uxp, vep, wzp )
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 ! ˆø”•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! À•W•ÏŠ·ƒpƒ‰ƒ[ƒ^ ----------------------------------------------------------------------------------
 real, intent(in)  :: xix, xiy, xiz, etx, ety, etz, zex, zey, zez
 ! ‰t“H‘¬“x --------------------------------------------------------------------------------------------
 real, intent(in)  :: up, vp, wp       					! ‰t“H‘¬“x (•¨—À•WŒn)
 real, intent(out) :: uxp, vep, wzp    					! ‰t“H‘¬“x (ŒvZÀ•WŒn)
 ! ˆ—ŠJn ********************************************************************************************
 uxp = xix * up + xiy * vp + xiz * wp
 vep = etx * up + ety * vp + etz * wp
 wzp = zex * up + zey * vp + zez * wp
 ! ˆ—I—¹ ********************************************************************************************
 return
end subroutine Velocity3D
!*******************************************************************************************************
!******** ‰t“H‹N“®ŒvZŠÔ‚İ (“ñŸŒ³)        				                        ********
!*******************************************************************************************************
subroutine dt2D( &
&            uxp, vep, cnp, dtp )
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 ! ‹ÇŠ’è” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real, parameter :: almin = 1.0e-08
 ! ˆø”•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real, intent(in)  :: uxp, vep        					! ‰t“H‘¬“x (ŒvZÀ•WŒn)
 real, intent(in)  :: cnp             					! ‰t“H‚ÌƒN[ƒ‰ƒ“”
 real, intent(out) :: dtp             					! ŠÔ‚İ
 ! ‹ÇŠ•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: alxi, alet, almax
 ! ˆ—ŠJn ********************************************************************************************
 alxi  = abs(uxp)
 alet  = abs(vep)
 almax = max(alxi, alet, almin)
 dtp   = cnp / almax
 ! ˆ—I—¹ ********************************************************************************************
 return
end subroutine dt2D
!*******************************************************************************************************
!******** ‰t“H‹N“®ŒvZŠÔ‚İ (OŸŒ³)                                				********
!*******************************************************************************************************
subroutine dt3D( &
&            uxp, vep, wzp, cnp, dtp )
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 ! ‹ÇŠ’è” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real, parameter :: almin = 1.0e-08
 ! ˆø”•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real, intent(in)  :: uxp, vep, wzp   					! ‰t“H‘¬“x (ŒvZÀ•WŒn)
 real, intent(in)  :: cnp             					! ‰t“H‚ÌƒN[ƒ‰ƒ“”
 real, intent(out) :: dtp             					! ŠÔ‚İ
 ! ‹ÇŠ•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: alxi, alet, alze, almax
 ! ˆ—ŠJn ********************************************************************************************
 alxi  = abs(uxp)
 alet  = abs(vep)
 alze  = abs(wzp)
 almax = max(alxi, alet, alze, almin)
 dtp   = cnp / almax
 ! ˆ—I—¹ ********************************************************************************************
 return
end subroutine dt3D
!*******************************************************************************************************
!******** •Ç–ÊÕ“Ë”»’è (OŸŒ³)                                        				********
!********@¦ –@üƒxƒNƒgƒ‹‚ÌŒü‚«‚É’ˆÓ								********
!*******************************************************************************************************
subroutine ImpingementJudge3D( &
&            xp, yp, zp, x1, y1, z1, x2, y2, z2, x3, y3, z3, dp, &
&            fImp, Rhow, ImpMass )
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 ! ˆø”•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real   , intent(in)  :: x1, y1, z1
 real   , intent(in)  :: x2, y2, z2
 real   , intent(in)  :: x3, y3, z3
 real   , intent(in)  :: xp, yp, zp
 real   , intent(in)  :: dp
 logical, intent(out) :: fImp
 real   , intent(in)  :: Rhow
 real   , intent(out) :: ImpMass
 ! ‹ÇŠ•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: ax, ay, az, bx, by, bz, cx, cy, cz
 real :: nx, ny, nz, ni							! •Ç–Ê–@üƒxƒNƒgƒ‹
 real :: dl                   						! Õ“Ë–Ê‚Ü‚Å‚Ì‹——£
 ! ˆ—ŠJn ********************************************************************************************
 ! Õ“Ë–Ê‚Ì’PˆÊ–@üƒxƒNƒgƒ‹ (ŠOÏ‚©‚ç“±o) -------------------------------------------------------------
 ax = x2 - x1
 ay = y2 - y1
 az = z2 - z1
 bx = x3 - x1
 by = y3 - y1
 bz = z3 - z1
 nx = ay * bz - az * by
 ny = az * bx - ax * bz
 nz = ax * by - ay * bx
 ni = 1.0 / max(zero, sqrt(nx**2 + ny**2 + nz**2))
 nx = nx * ni
 ny = ny * ni
 nz = nz * ni
 ! ‰t“H‚ÆÕ“Ë–Ê‚Ì‹——£ (“àÏ‚©‚ç“±o) -------------------------------------------------------------------
 dl = (xp - x1) * nx + (yp - y1) * ny + (zp - z1) * nz
 ! ‰t“H‚ÆÕ“Ë–Ê‚Æ‚Ì‹——£‚ª‰t“HŒaˆÈ‰º‚Å‚ ‚ê‚ÎÕ“Ë‚Æ”»’è --------------------------------------------------
 if(dl <= 0.5 * dp) then
   fImp = .true.
   ImpMass = Rhow * 4.0 / 3.0 * pi * (0.5 * dp)**3.0
  else
   fImp = .false.
 endif
 ! ˆ—I—¹ ********************************************************************************************
 return
end subroutine ImpingementJudge3D
!*******************************************************************************************************
!******** •Ç–ÊÕ“Ë‘¬“x (OŸŒ³)	                                        			********
!******** ¦ ‰t“HŒa•ª•z–³‹                                         				********
!*******************************************************************************************************
subroutine ImpingementVelocity3D( &
&            is, ie, ks, ke, nimp, uimp, vimp, wimp )
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 ! ˆø”•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer, intent(in)    :: is, ie, ks, ke				! Šiq”
 real   , intent(in)    :: nimp(is:ie, ks:ke)				! ‰t“HÕ“Ë”
 real   , intent(inout) :: uimp(is:ie, ks:ke), &
 &			   vimp(is:ie, ks:ke), &
 &			   wimp(is:ie, ks:ke)				! Õ“Ë‘¬“x
 ! ‹ÇŠ•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i, k
 ! ˆ—ŠJn ********************************************************************************************
 do k = ks, ke
 do i = is, ie
  if( nimp(i,k) == 0.0 ) cycle
  uimp(i,k) = uimp(i,k) / nimp(i,k)
  vimp(i,k) = vimp(i,k) / nimp(i,k)
  wimp(i,k) = wimp(i,k) / nimp(i,k)
 enddo
 enddo
 ! ˆ—I—¹ ********************************************************************************************
 return
end subroutine ImpingementVelocity3D
!*******************************************************************************************************
!******** •Ç–ÊÕ“Ë‘¬“x (OŸŒ³)	                                        			********
!******** ¦ ‰t“HŒa•ª•z–³‹                                         				********
!*******************************************************************************************************
subroutine ImpingementTemperature3D( &
&            is, ie, ks, ke, nimp, timp )
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 ! ˆø”•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer, intent(in)    :: is, ie, ks, ke				! Šiq”
 real   , intent(in)    :: nimp(is:ie, ks:ke)				! ‰t“HÕ“Ë”
 real   , intent(inout) :: timp(is:ie, ks:ke)				! Õ“Ë‰·“x
 ! ‹ÇŠ•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i, k
 ! ˆ—ŠJn ********************************************************************************************
 do k = ks, ke
 do i = is, ie
  if( nimp(i,k) == 0.0 ) cycle
  timp(i,k) = timp(i,k) / nimp(i,k)
 enddo
 enddo
 ! ˆ—I—¹ ********************************************************************************************
 return
end subroutine ImpingementTemperature3D
!*******************************************************************************************************
!******** Õ“Ë•Ç–ÊÏ (OŸŒ³)		      					                ********
!*******************************************************************************************************
subroutine ImpingementArea3D( &
&            is, ie, ks, ke, x, y, z, &
&            SA )
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 ! ˆø”•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer, intent(in)  :: is, ie, ks, ke					! Šiq”
 real   , intent(in)  :: x(is:ie, ks:ke), &
 &                       y(is:ie, ks:ke), &
 &                       z(is:ie, ks:ke)
 real   , intent(out) :: SA(is:ie, ks:ke)				! ƒZƒ‹–ÊÏ
 ! ‹ÇŠ•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real   , pointer :: s1(:, :), s2(:, :), s3(:, :)
 integer :: i, k
 real    :: a1, a2, a3, b1, b2, b3, c1, c2, c3
 ! ˆ—ŠJn ********************************************************************************************
 ! ‰Šúİ’è ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 allocate( s1(is:ie, ks:ke), s2(is:ie, ks:ke), s3(is:ie, ks:ke) )
 s1(:,:) = 0.0; s2(:,:) = 0.0; s3(:,:) = 0.0
 ! ƒZƒ‹–ÊÏ (Šiq“_ü‚è‚SƒZƒ‹‚Ì•½‹Ï) +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! OŠpŒ`‚Ì–ÊÏ
 do k = ks, ke - 1
 do i = is, ie - 1
  a1 = x(i+1,k  ) - x(i,k)
  a2 = y(i+1,k  ) - y(i,k)
  a3 = z(i+1,k  ) - z(i,k)
  b1 = x(i  ,k+1) - x(i,k)
  b2 = y(i  ,k+1) - y(i,k)
  b3 = z(i  ,k+1) - z(i,k)
  c1 = a2 * b3 - a3 * b2
  c2 = a3 * b1 - a1 * b3
  c3 = a1 * b2 - a2 * b1
  s1(i,k) = 0.5 * sqrt(c1**2 + c2**2 + c3**2)
 enddo
 enddo
 do k = ks + 1, ke
 do i = is + 1, ie
  a1 = x(i-1,k  ) - x(i,k)
  a2 = y(i-1,k  ) - y(i,k)
  a3 = z(i-1,k  ) - z(i,k)
  b1 = x(i  ,k-1) - x(i,k)
  b2 = y(i  ,k-1) - y(i,k)
  b3 = z(i  ,k-1) - z(i,k)
  c1 = a2 * b3 - a3 * b2
  c2 = a3 * b1 - a1 * b3
  c3 = a1 * b2 - a2 * b1
  s2(i,k) = 0.5 * sqrt(c1**2 + c2**2 + c3**2)
 enddo
 enddo
 ! OŠpŒ`–ÊÏ‚Ì˜a
 do k = ks, ke - 1
 do i = is, ie - 1
  s3(i,k) = s1(i,k) + s2(i+1,k+1)
 enddo
 enddo
 do k = ks +1, ke -1
  s3(ie,k) = s3(ie-1,k)
 enddo
 do i = is + 1, ie -1
  s3(i,ke) = s3(i,ke-1)
 enddo
 s3(is,ke) = s3(is,ke-1)
 s3(ie,ks) = s3(ie-1,ks)
 s3(ie,ke) = s3(ie-1,ke-1)
 ! Šiq“_ü‚è‚S“_‚Ì•½‹Ï
 do k = ks + 1, ke - 1
 do i = is + 1, ie - 1
  SA(i,k) = 0.25 * ( s3(i,k) + s3(i-1,k) + s3(i,k-1) + s3(i-1,k-1) )
 enddo
 enddo
 do k = ks + 1, ke - 1
  SA(is,k) = 0.5 * ( S3(is,k-1) + S3(is,k) )
  SA(ie,k) = 0.5 * ( S3(ie,k-1) + S3(ie,k) )
 enddo
 do i = is + 1, ie - 1
  SA(i,ks) = 0.5 * ( S3(i-1,ks) + S3(i,ks) )
  SA(i,ke) = 0.5 * ( S3(i-1,ke) + S3(i,ks) )
 enddo
 SA(is,ks) = S3(is,ks)
 SA(ie,ks) = S3(ie,ks)
 SA(is,ke) = S3(is,ke)
 SA(ie,ke) = S3(ie,ke)
 ! ƒƒ‚ƒŠ‰ğ•ú ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 deallocate(s1, s2, s3)
 ! ˆ—I—¹ ********************************************************************************************
 return
end subroutine ImpingementArea3D
!*******************************************************************************************************
!******** ûWŒø—¦ (OŸŒ³)		                              				********
!******** ¦ ‰t“HŒa•ª•z–³‹                                        				********
!*******************************************************************************************************
subroutine CollectionEfficiency3D( &
&            is, ie, ks, ke, nDrp, MVD, LWC, Rhod, Ain, Uin, Nimp, SA, Mim, &
&            bet )
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 ! ˆø”•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer, intent(in)  :: is, ie, ks, ke					! Šiq”
 integer, intent(in)  :: nDrp						! ‰t“H”
 real   , intent(in)  :: MVD						! •½‹Ï‰t“HŒa
 real   , intent(in)  :: LWC						! …•ªŠÜ—L—Ê
 real   , intent(in)  :: Rhod						! ‰t“H–§“x
 real   , intent(in)  :: Ain						! ‰t“H“Š“ü–ÊÏ
 real   , intent(in)  :: Uin						! ‰t“H“Š“ü‘¬“x
 real   , intent(in)  :: Nimp(is:ie, ks:ke)				! ‰t“HÕ“Ë”
 real   , intent(in)  :: SA  (is:ie, ks:ke)				! ƒZƒ‹–ÊÏ
 real   , intent(in)  :: Mim (is:ie, ks:ke)				! Õ“Ë¿—Ê
 real   , intent(out) :: bet (is:ie, ks:ke)				! ûWŒø—¦
 ! ‹ÇŠ•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real   , pointer :: Ns(:, :)						! ‰t“HÕ“Ë—¦
 real   , pointer :: ImpN(:, :)						! ‰t“HÕ“Ë”
 integer :: i, k
 real    :: Qm, vMVD, Nin, Np
 ! ˆ—ŠJn ********************************************************************************************
 ! ‰Šúİ’è ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 allocate( Ns(is:ie, ks:ke), ImpN(is:ie, ks:ke) )
 Ns(:,:) = 0.0; ImpN(:,:) = 0.0
 vMVD = 4.0 / 3.0 * pi * (0.5 * MVD)**3.0
 ! ŠeŠiq“_‚É 1 s “–‚è‚ÉÕ“Ë‚·‚é‰t“H‚ÌŠ„‡ Ns [s^-1] +++++++++++++++++++++++++++++++++++++++++++++++++++
 ! ŒŸ¸‘ÌÏ“à‚É—¬“ü‚·‚é‰t“H‚Ì¿—Ê—¬—Ê Qm [kg / s] ------------------------------------------------------
 Qm = Ain * Uin * LWC
 ! 1 s “–‚è‚É—¬“ü‚·‚é‰t“H” Nin [s^-1] -----------------------------------------------------------------
 Nin = Qm / (vMVD * Rhod)
 do k = ks, ke
 do i = is, ie
!  write(*, '(a, i3, i3, e16.8e3)')' * i, k, Mim(i,k)',i, k, Mim(i,k)
!  write(*, '(a, i3, i3, e16.8e3)')' * i, k, Nimp(i,k)',i, k, Nimp(i,k)
 ! Õ“Ë¿—Ê‚©‚çÕ“Ë”‚ğŒvZ ImpN -----------------------------------------------------------------------
  ImpN(i,k) = Mim(i,k) / ( vMVD * Rhod )
!  write(*,*)'* ImpN(', i, ',' ,k, ') = ',ImpN(i,k)
!  write(*,*)'* ImpN(', i, ',' ,k, ') = ',Nimp(i,k)
!  write(*,'(a, i3, i3, e16.8e3)')'* i, k, Nimp(i,k) = ',i, k, Nimp(i,k)
  ! Šiq“_‚ÉÕ“Ë‚·‚é‰t“H‚ÌŠ„‡ Np [*]
  Np = Nimp(i,k) / real(nDrp)
!  Np = ImpN(i,k) / real(nDrp)
  ! 1 s “–‚è‚ÉŠiq“_‚ÉÕ“Ë‚·‚é‰t“H‚ÌŠ„‡ [s^-1]
  Ns(i,k) = Np * Nin
 enddo
 enddo
 ! ûWŒø—¦ bet [m^-2 * s^-1] ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 do k = ks, ke
 do i = is, ie
  bet(i,k) = Ns(i,k) / SA(i,k)
 enddo
 enddo
 deallocate(Ns)
 ! ˆ—I—¹ ********************************************************************************************
 return
end subroutine CollectionEfficiency3D
!*******************************************************************************************************
!******** ƒXƒvƒ‰ƒbƒVƒ…ƒ‚ƒfƒ‹ (OŸŒ³CLEWICECNASA/TM 2008-215174)				********
!*******************************************************************************************************
subroutine SplashLEWICE3D( &
&            xp, yp, zp, up1, vp1, wp1, dp1, mr1, x1, y1, z1, x2, y2, z2, x3, y3, z3, &
&            LWC, Rhow, Sigw, muw, SLDLim, &
&            fImpi, up2, vp2, wp2, dp2, mr2, nSpl, nBou, n2Imp, ImpMass, Ohw, Rew, fSplash, fBounce, fImpi2 )
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 ! ˆø”•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real   , intent(in)    :: xp, yp, zp					! ‰t“HÀ•W
 real   , intent(in)    :: up1, vp1, wp1				! ‰t“HÕ“Ë‘¬“x
 real   , intent(in)    :: dp1						! Õ“Ë‘O‚Ì‰t“HŒa
 real   , intent(in)    :: mr1						! Õ“Ë‘O‚Ì‰t“H¿—Ê”ä
 real   , intent(in)    :: x1, y1, z1					! •Ç–ÊÀ•W1
 real   , intent(in)    :: x2, y2, z2					! •Ç–ÊÀ•W2
 real   , intent(in)    :: x3, y3, z3					! •Ç–ÊÀ•W3
 real   , intent(in)    :: LWC						! ‰t“H…•ªŠÜ—L—¦
 real   , intent(in)    :: Rhow						! …‚Ì–§“x
 real   , intent(in)    :: Sigw						! …‚Ì•\–Ê’£—Í
 real   , intent(in)    :: muw						! …‚Ì”S«ŒW”
 real   , intent(in)    :: SLDLim					! SLD‚Ìè‡’l
 logical, intent(out)   :: fImpi					! Õ“Ë”»’è
 real   , intent(out)   :: up2, vp2, wp2				! ‰t“H’µ‚Ë•Ô‚è‘¬“x
 real   , intent(out)   :: dp2						! Õ“ËŒã‚Ì‰t“HŒa
 real   , intent(out)   :: mr2						! Õ“ËŒã‚Ì‰t“H¿—Ê”ä
 integer, intent(inout) :: nSpl						! ƒXƒvƒ‰ƒbƒVƒ…‚Ì‰t“H”
 integer, intent(inout) :: nBou						! ƒoƒEƒ“ƒh‚Ì‰t“H”
 integer, intent(inout) :: n2Imp					! 2‰ñÕ“Ë‚µ‚½‰t“H”
 real   , intent(out)   :: Ohw, Rew
 real   , intent(out)   :: ImpMass
 logical, intent(inout)   :: fSplash, fBounce, fImpi2
 ! ‹ÇŠ•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: Ax, Ay, Az, Bx, By, Bz						! •Ç–ÊˆÊ’uv
 real :: Nx, Ny, Nz, Ni, Hx, Hy, Hz, Hi					! •Ç–Ê–@üv‚Æ‚’¼v
 real :: dl								! ‰t“H‚Æ•Ç–Ê‚Ì‹——£
 real :: Ux, Uy, Uz, UU							! ‰t“H‘¬“xv (ŒvZÀ•W)
 real :: Udotp								! ‰t“H‘¬“xv‚Æ•Ç–Ê–@ü’PˆÊv‚Ì“àÏ
 real :: Uh1, Un1, Uh2, Un2						! ‰t“H‘¬“xv (•Ç–Ê’¼sÀ•W)
 real :: alp1, bet1							! ‰t“HÕ“ËŠp
 real :: alp2								! ‰t“H’µ‚Ë•Ô‚èŠp
 real :: KK, KL, KR							! ƒXƒvƒ‰ƒbƒVƒ…ƒpƒ‰ƒ[ƒ^
! real :: Rew								! ƒŒƒCƒmƒ‹ƒY”
 !real :: Ohw								! ƒI[ƒlƒ]ƒ‹ƒQ”
 ! ˆ—ŠJn ********************************************************************************************
 ! •Ç–ÊÕ“Ë”»’è ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! •Ç–Ê–@ü•ûŒü’PˆÊƒxƒNƒgƒ‹ (ŠOÏ‚©‚ç“±o) -------------------------------------------------------------
 Ax = x2 - x1
 Ay = y2 - y1
 Az = z2 - z1
 Bx = x3 - x1
 By = y3 - y1
 Bz = z3 - z1
 Nx = Ay * Bz - Az * By
 Ny = Az * Bx - Ax * Bz
 Nz = Ax * By - Ay * Bx
 Ni = 1.0 / max(zero, sqrt(Nx**2 + Ny**2 + Nz**2))
 Nx = Nx * Ni
 Ny = Ny * Ni
 Nz = Nz * Ni
 ! ‰t“H‚ÆÕ“Ë–Ê‚Ì‹——£ (“àÏ‚©‚ç“±o) -------------------------------------------------------------------
 dl = (xp - x1) * Nx + (yp - y1) * Ny + (zp - z1) * Nz
 ! ‰t“H‚ÆÕ“Ë–Ê‚Æ‚Ì‹——£‚ª‰t“HŒaˆÈ‰º‚Å‚ ‚ê‚ÎÕ“Ë‚Æ”»’è --------------------------------------------------
 if(dl <= 0.5 * dp1) then
   fImpi = .true.
    if(fSplash .or. fBounce)then
     fImpi2 = .true.
     n2Imp = n2Imp + 1
    else
     fImpi2 = .false.
    endif
  else
   fImpi = .false.
   fImpi2 = .false.
   up2 = up1; vp2 = vp1; wp2 = wp1; dp2 = dp1; mr2 = mr1
   return
 endif
 ! Õ“ËŠp‚ÆÕ“Ë‘¬“x ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! Õ“Ë‰t“H‚Ì‘¬“xƒxƒNƒgƒ‹ ------------------------------------------------------------------------------
 Ux = up1
 Uy = vp1
 Uz = wp1
 UU = sqrt(Ux**2 + Uy**2 + Uz**2)
 ! Õ“ËŠp (•Ç–Ê–@üƒxƒNƒgƒ‹‚Æ‰t“H‘¬“xƒxƒNƒgƒ‹‚Ì“àÏ‚©‚ç“±o) -------------------------------------------
 Udotp = Ux * Nx + Uy * Ny + Uz * Nz
 bet1  = min(0.5 * pi, max(0.0, acos(-1.0 * Udotp / max(UU, zero) ) ) )
 alp1  = 0.5 * pi - bet1
 ! Õ“Ë‘¬“x‚Ì•Ç–Ê…•½¬•ª‚Æ•Ç–Ê‚’¼¬•ª (•Ç–Ê’¼sÀ•WŒn) -----------------------------------------------
 Uh1 = UU * cos(alp1)
 Un1 = UU * sin(alp1)
 Un1 = -1.0 * Un1
 ! ƒXƒvƒ‰ƒbƒVƒ…ƒpƒ‰ƒ[ƒ^ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! Ohnesorge” -----------------------------------------------------------------------------------------
 Ohw = muw / sqrt(Rhow * Sigw * dp1)
 ! Reynolds” ------------------------------------------------------------------------------------------
! Rew = Rhow * UU * dp1 / muw
 Rew = Rhow * abs(Un1) * dp1 / muw					! ‚¢‚»ƒR[ƒh‚Í‚±‚Á‚¿
 ! Splash•Ï” ------------------------------------------------------------------------------------------
 KK = Ohw * Rew**1.25
 KL = 0.859 * sqrt(KK) * (Rhow / LWC)**0.125 / max( zero, sin(alp1) )**1.25 
! KR = 8.72 * exp(-0.0281 * KK)
 ! ƒXƒvƒ‰ƒbƒVƒ…EƒoƒEƒ“ƒh”»’è ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 if(KL > 200.0) then
  KR = 8.72 * exp(-0.0281 * KK)
 ! ‘S¿—ÊÕ“Ë ------------------------------------------------------------------------------------------
   if(KR <= 0.05) then	
    up2 = 0.0; vp2 = 0.0; wp2 = 0.0
    dp2 = 0.0; mr2 = 0.0
    ImpMass = Rhow * 4.0 / 3.0 * pi * (0.5 * dp1)**3.0
    return
 ! ƒXƒvƒ‰ƒbƒVƒ… ----------------------------------------------------------------------------------------
   else if(KR <= 1.0) then
    fSplash = .true.
    ! ‰t“H”‚ÌƒJƒEƒ“ƒ^[
    nSpl = nSpl + 1
    ! Õ“ËŒã‚Ì‰t“HŒa
    dp2 = KR * dp1
    ! Õ“ËŒã‚Ì‰t“H‘¬“x¬•ª (•Ç–Ê’¼sÀ•WŒn)
!    Uh2 = Uh1 * (1.075 - 0.0025 * alp1)
!    Un2 = Un1 * (0.300 - 0.0020 * alp1)
    Uh2 = Uh1 * (1.075 - 0.0025 * alp1 * 180.0 / pi)			! ‚¢‚»ƒR[ƒh‚Í‚±‚Á‚¿
    Un2 = Un1 * (0.300 - 0.0020 * alp1 * 180.0 / pi)
    ! Õ“ËŒã‚Ì¿—Ê”ä (”ò‚ñ‚Å‚¢‚­•ª)
!    mr2 = mr1 * ( 1.0 - 0.7 * ( 1.0 - sin(alp1) ) * ( 1.0 - exp( -0.0092026 * (KL - 200.0) ) ) )
    mr2 = mr1 * 0.7 * ( 1.0 - sin(alp1) ) * ( 1.0 - exp( -0.0092026 * (KL - 200.0) ) )
    ImpMass   = Rhow * 4.0 / 3.0 * pi * (0.5 * dp1)**3.0 * (1.0 - mr2)
!    write(*, '(a, e16.8e3)')' * ImpMass = ', ImpMass
    if(mr2 >= mr1) then
      write(*, '(a)') '!!!!! Error : Mass rate of splash droplet !!!!!'
      write(*, '(a,e16.8e3)') '* mr1 = ', mr1
      write(*, '(a,e16.8e3)') '* mr2 = ', mr2
    endif
 ! ƒoƒEƒ“ƒh --------------------------------------------------------------------------------------------
   else if(KR > 1.0) then
    fBounce = .true.
    ! ‰t“H”‚ÌƒJƒEƒ“ƒ^[
    nBou = nBou + 1
    ! Õ“ËŒã‚Ì‰t“HŒa
    dp2 = dp1
    ! Õ“ËŒã‚Ì‰t“H‘¬“x¬•ª (•Ç–Ê’¼sÀ•WŒn)
    Uh2 = Uh1
    Un2 = Un1
    ! Õ“ËŒã‚Ì¿—Ê”ä
    mr2 = mr1 * 1.0
    ! •Ç–ÊÕ“Ë‚Ìƒtƒ‰ƒO
    fImpi = .false.
   endif
 ! ‘S¿—ÊÕ“Ë ------------------------------------------------------------------------------------------
 else
  up2 = 0.0; vp2 = 0.0; wp2 = 0.0
  dp2 = 0.0; mr2 = 0.0
  ImpMass = Rhow * 4.0 / 3.0 * pi * (0.5 * dp1)**3.0
 endif
! ! ƒXƒvƒ‰ƒbƒVƒ…EƒoƒEƒ“ƒh”»’è ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! if(KL <= 200.0 .or. KR <= 0.05 .or. dp1 <= SLDLim) then
!   ! ‘S¿—Ê•Ç–Ê•t’… ------------------------------------------------------------------------------------
!   up2 = 0.0; vp2 = 0.0; wp2 = 0.0
!   dp2 = 0.0; mr2 = 0.0
!   ImpMass = Rhow * 4.0 / 3.0 * pi * (0.5 * dp1)**3.0
!!   write(*, '(a, e16.8e3)')' * ImpMass = ', ImpMass
!   return
!  else if(KR < 1.0) then
!   ! ƒXƒvƒ‰ƒbƒVƒ… --------------------------------------------------------------------------------------
!   ! ‰t“H”‚ÌƒJƒEƒ“ƒ^[
!   nSpl = nSpl + 1
!   ! Õ“ËŒã‚Ì‰t“HŒa
!   dp2 = KR * dp1
!   ! Õ“ËŒã‚Ì‰t“H‘¬“x¬•ª (•Ç–Ê’¼sÀ•WŒn)
!!   Uh2 = Uh1 * (1.075 - 0.0025 * alp1)
!!   Un2 = Un1 * (0.300 - 0.0020 * alp1)
!   Uh2 = Uh1 * (1.075 - 0.0025 * alp1 * 180.0 / pi)			! ‚¢‚»ƒR[ƒh‚Í‚±‚Á‚¿
!   Un2 = Un1 * (0.300 - 0.0020 * alp1 * 180.0 / pi)
!   ! Õ“ËŒã‚Ì¿—Ê”ä (”ò‚ñ‚Å‚¢‚­•ª)
!!   mr2 = mr1 * ( 1.0 - 0.7 * ( 1.0 - sin(alp1) ) * ( 1.0 - exp( -0.0092026 * (KL - 200.0) ) ) )
!   mr2 = mr1 * 0.7 * ( 1.0 - sin(alp1) ) * ( 1.0 - exp( -0.0092026 * (KL - 200.0) ) )
!   ImpMass = Rhow * 4.0 / 3.0 * pi * (0.5 * dp1)**3.0 * (1.0 - mr2)
!!   write(*, '(a, e16.8e3)')' * ImpMass = ', ImpMass
!   if(mr2 >= mr1) then
!     write(*, '(a)') '!!!!! Error : Mass rate of splash droplet !!!!!'
!     write(*, '(a,e16.8e3)') '* mr1 = ', mr1
!     write(*, '(a,e16.8e3)') '* mr2 = ', mr2
!   endif
!  else
!   ! ƒoƒEƒ“ƒh ------------------------------------------------------------------------------------------
!   ! ‰t“H”‚ÌƒJƒEƒ“ƒ^[
!   nBou = nBou + 1
!   ! Õ“ËŒã‚Ì‰t“HŒa
!   dp2 = dp1
!   ! Õ“ËŒã‚Ì‰t“H‘¬“x¬•ª (•Ç–Ê’¼sÀ•WŒn)
!   Uh2 = Uh1
!   Un2 = Un1
!   ! Õ“ËŒã‚Ì¿—Ê”ä
!   mr2 = mr1 * 1.0
!   ! •Ç–ÊÕ“Ë‚Ìƒtƒ‰ƒO
!   fImpi = .false.
! endif
 ! ƒXƒvƒ‰ƒbƒVƒ…EƒoƒEƒ“ƒh (ŒvZÀ•WŒn) +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! •Ç–Ê…•½•ûŒü’PˆÊƒxƒNƒgƒ‹ ----------------------------------------------------------------------------
 Hx = Ux - Udotp * Nx
 Hy = Uy - Udotp * Ny
 Hz = Uz - Udotp * Nz
 Hi = 1.0 / max( zero, sqrt(Hx**2 + Hy**2 + Hz**2) )
 Hx = Hx * Hi
 Hy = Hy * Hi
 Hz = Hz * Hi
 ! ’µ‚Ë•Ô‚èŒã‚Ì‰t“H‘¬“x --------------------------------------------------------------------------------
 Un2  = -1.0 * Un2
 alp2 = atan(Un2 / Uh2)
 up2  = Uh2 * Hx + Un2 * Nx
 vp2  = Uh2 * Hy + Un2 * Ny
 wp2  = Uh2 * Hz + Un2 * Nz
 ! ˆ—I—¹ ********************************************************************************************
 return
end subroutine SplashLEWICE3D
!**************************************************************************************************
! ƒXƒvƒ‰ƒbƒVƒ…ƒ‚ƒfƒ‹ (‚‘¬—Ìˆæ‚ÅŒvZ‰Â”\H)
! Droplet interaction with shear-driven liquid films: analysis of deposition and secondary droplet characteristics
! W.Samenfink , International Journal of Heat and Fluid Flow 20 (1999) 462-469
!**************************************************************************************************
!Samefink Model ***********************************************************************************
subroutine SplashSamenfink( &
&             xp, yp, zp, up1, vp1, wp1, dp1, mr1, x1, y1, z1, x2, y2, z2, x3, y3, z3, &
&             LWC, Rhow, Sigw, muw, SLDlim, Chord, &
&             fImpi, up2, vp2, wp2, dp2, mr2, nSpl, nBou )
!•Ï”éŒ¾******************************************************************************************
implicit none
 real, parameter :: pi   = 3.1415926535897932
 real, parameter :: zero = 1.0e-20
!ˆø”•Ï”++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
real   , intent(in)    :: Chord						! —ƒŒ·’·
real   , intent(in)    :: xp, yp, zp					! ‰t“HÀ•W
real   , intent(in)    :: up1, vp1, wp1					! ‰t“HÕ“Ë‘¬“x
real   , intent(in)    :: dp1						! Õ“Ë‘O‚Ì‰t“HŒa
real   , intent(in)    :: mr1						! Õ“Ë‘O‚Ì‰t“H¿—Ê”ä
real   , intent(in)    :: x1, y1, z1					! •Ç–ÊÀ•W1
real   , intent(in)    :: x2, y2, z2					! •Ç–ÊÀ•W2
real   , intent(in)    :: x3, y3, z3					! •Ç–ÊÀ•W3
real   , intent(in)    :: LWC						! ‰t“H…•ªŠÜ—L—¦
real   , intent(in)    :: Rhow						! …‚Ì–§“x
real   , intent(in)    :: Sigw						! …‚Ì•\–Ê’£—Í
real   , intent(in)    :: muw						! …‚Ì”S«ŒW”
real   , intent(in)    :: SLDLim					! SLD‚Ìè‡’l
logical, intent(out)   :: fImpi						! Õ“Ë”»’è
real   , intent(out)   :: up2, vp2, wp2					! ‰t“H’µ‚Ë•Ô‚è‘¬“x
real   , intent(out)   :: dp2						! Õ“ËŒã‚Ì‰t“HŒa
real   , intent(out)   :: mr2						! Õ“ËŒã‚Ì‰t“H¿—Ê”ä
integer, intent(inout) :: nSpl						! ƒXƒvƒ‰ƒbƒVƒ…‚Ì‰t“H”
integer, intent(inout) :: nBou						! ƒoƒEƒ“ƒh‚Ì‰t“H”
! ‹ÇŠ•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
real :: Ax, Ay, Az, Bx, By, Bz						! •Ç–ÊˆÊ’uv
real :: Nx, Ny, Nz, Ni, Hx, Hy, Hz, Hi					! •Ç–Ê–@üv‚Æ‚’¼v
real :: dl								! ‰t“H‚Æ•Ç–Ê‚Ì‹——£
real :: Ux, Uy, Uz, UU							! ‰t“H‘¬“xv (ŒvZÀ•W)
real :: Udotp								! ‰t“H‘¬“xv‚Æ•Ç–Ê–@ü’PˆÊv‚Ì“àÏ
real :: Uh1, Un1, Uh2, Un2						! ‰t“H‘¬“xv (•Ç–Ê’¼sÀ•W)
real :: alp1, bet1							! ‰t“HÕ“ËŠp
real :: Thetas								! ‰t“H’µ‚Ë•Ô‚èŠp
real :: S, La, KR							! ƒXƒvƒ‰ƒbƒVƒ…ƒpƒ‰ƒ[ƒ^
real :: Rew								! ƒŒƒCƒmƒ‹ƒY”
real :: Ohw								! ƒI[ƒlƒ]ƒ‹ƒQ”
real :: Wele								! ‘O‰‚Å‚ÌƒEƒF[ƒo[”
real :: Delta								! …–ŒŒú‚³
real :: Dle								! ‘O‰‚Ì’¼Œa
real :: Vs								! ƒXƒvƒ‰ƒbƒVƒ…Œã‚Ì‘¬“x
! ‹ÇŠ’è” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
real ,parameter :: Rho0 = 1.10						! ‘O‰‹È—¦”¼Œa”ä
! ˆ—ŠJn ****************************************************************************************
! •Ç–ÊÕ“Ë”»’è ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! •Ç–Ê–@ü•ûŒü’PˆÊƒxƒNƒgƒ‹ (ŠOÏ‚©‚ç“±o) ---------------------------------------------------------
Ax = x2 - x1
Ay = y2 - y1
Az = z2 - z1
Bx = x3 - x1
By = y3 - y1
Bz = z3 - z1
Nx = Ay * Bz - Az * By
Ny = Az * Bx - Ax * Bz
Nz = Ax * By - Ay * Bx
Ni = 1.0 / max(zero, sqrt(Nx**2 + Ny**2 + Nz**2))
Nx = Nx * Ni
Ny = Ny * Ni
Nz = Nz * Ni
! ‰t“H‚ÆÕ“Ë–Ê‚Ì‹——£ (“àÏ‚©‚ç“±o) ---------------------------------------------------------------
dl = (xp - x1) * Nx + (yp - y1) * Ny + (zp - z1) * Nz
! ‰t“H‚ÆÕ“Ë–Ê‚Æ‚Ì‹——£‚ª‰t“HŒaˆÈ‰º‚Å‚ ‚ê‚ÎÕ“Ë‚Æ”»’è ----------------------------------------------
if(dl <= 0.5 * dp1) then
  fImpi = .true.
 else
  fImpi = .false.
  up2 = up1; vp2 = vp1; wp2 = wp1; dp2 = dp1; mr2 = mr1
  return
endif
! Õ“ËŠp‚ÆÕ“Ë‘¬“x ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! Õ“Ë‰t“H‚Ì‘¬“xƒxƒNƒgƒ‹ --------------------------------------------------------------------------
Ux = up1
Uy = vp1
Uz = wp1
UU = sqrt(Ux**2 + Uy**2 + Uz**2)
! Õ“ËŠp (•Ç–Ê–@üƒxƒNƒgƒ‹‚Æ‰t“H‘¬“xƒxƒNƒgƒ‹‚Ì“àÏ‚©‚ç“±o) ---------------------------------------
Udotp = Ux * Nx + Uy * Ny + Uz * Nz
bet1  = min(0.5 * pi, max(0.0, acos(-1.0 * Udotp / max(UU, zero) ) ) )
alp1  = 0.5 * pi - bet1
! Õ“Ë‘¬“x‚Ì•Ç–Ê…•½¬•ª‚Æ•Ç–Ê‚’¼¬•ª (•Ç–Ê’¼sÀ•WŒn) -------------------------------------------
Uh1 = UU * cos(alp1)
Un1 = UU * sin(alp1)
Un1 = -1.0 * Un1
! ƒXƒvƒ‰ƒbƒVƒ…ƒpƒ‰ƒ[ƒ^ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! Ohnesorge” -------------------------------------------------------------------------------------
Ohw = muw / sqrt(Rhow * Sigw * dp1)
! Reynolds” --------------------------------------------------------------------------------------
! Rew = Rhow * UU * dp1 / muw
Rew = Rhow * abs(Un1) * dp1 / muw					! ‚¢‚»ƒR[ƒh‚Í‚±‚Á‚¿
! ‘O‰‚Ì’¼Œa ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Dle = 2.0 * Rho0 * (0.12 * Chord) * 0.12**2				! —ƒŒ^Šwp2 ƒÏ0‚Ì®‚ğ•ÏŒ`
! Weber” -----------------------------------------------------------------------------------------
Wele = Rhow * Dle * UU / Sigw
! …–ŒŒú‚³ ----------------------------------------------------------------------------------------
Delta = 3.76 * (Dle / dp1)**1.25 * (LWC / Rhow)**0.5 * Wele**(-0.125)
! Splash•Ï” --------------------------------------------------------------------------------------
La = 1.0 / Ohw**2.0
S  = Rew / ( 24.0 * La**0.419)
KR = 1.0 - 0.03454 * S**0.175 * alp1**0.1239 * La**0.265
! ƒXƒvƒ‰ƒbƒVƒ…EƒoƒEƒ“ƒh”»’è ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
if(S <= 1.0 .or. S >= 5.0 .or. dp1 <= SLDLim) then
  ! ‘S¿—Ê•Ç–Ê•t’… --------------------------------------------------------------------------------
  up2 = 0.0; vp2 = 0.0; wp2 = 0.0
  dp2 = 0.0; mr2 = 0.0
  return
 else if(KR < 1.0) then
! ƒXƒvƒ‰ƒbƒVƒ… ------------------------------------------------------------------------------------
! ‰t“H”‚ÌƒJƒEƒ“ƒ^[
  nSpl = nSpl + 1
! Õ“ËŒã‚Ì‰t“HŒa
  dp2 = KR * dp1
!ƒXƒvƒ‰ƒbƒVƒ…Šp“x
  Thetas = 2.154 * S**1.0946 * alp1**0.03389 * Delta**(-0.1589)
!Õ“ËŒã‚Ì‘¬“x
  Vs = 0.08214 * S**(-0.3384) * alp1**0.2938 * Delta**(-0.03113) * La**0.01157 * UU
! Õ“ËŒã‚Ì‰t“H‘¬“x¬•ª (•Ç–Ê’¼sÀ•WŒn)
  Uh2 = Vs * cos(pi * Thetas / 180.0)
  Un1 = Vs * sin(pi * Thetas / 180.0)
! Õ“ËŒã‚Ì¿—Ê”ä
  mr2 = mr1 * 0.0866 * (S - 1)**0.3188 * alp1**0.1223 * Delta**(-0.9585)
   if(mr2 >= mr1) then
     write(*, '(a)') '!!!!! Error : Mass rate of splash droplet !!!!!'
     write(*, '(a,e16.8e3)') '* mr1 = ', mr1
     write(*, '(a,e16.8e3)') '* mr2 = ', mr2
   endif
  else
! ƒoƒEƒ“ƒh ----------------------------------------------------------------------------------------
! ‰t“H”‚ÌƒJƒEƒ“ƒ^[
   nBou = nBou + 1
! Õ“ËŒã‚Ì‰t“HŒa
   dp2 = dp1
! Õ“ËŒã‚Ì‰t“H‘¬“x¬•ª (•Ç–Ê’¼sÀ•WŒn)
   Uh2 = Uh1
   Un2 = Un1
! Õ“ËŒã‚Ì¿—Ê”ä
   mr2 = mr1 * 1.0
! •Ç–ÊÕ“Ë‚Ìƒtƒ‰ƒO
   fImpi = .false.
endif
! ƒXƒvƒ‰ƒbƒVƒ…EƒoƒEƒ“ƒh (ŒvZÀ•WŒn) +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! •Ç–Ê…•½•ûŒü’PˆÊƒxƒNƒgƒ‹ ------------------------------------------------------------------------
Hx = Ux - Udotp * Nx
Hy = Uy - Udotp * Ny
Hz = Uz - Udotp * Nz
Hi = 1.0 / max( zero, sqrt(Hx**2 + Hy**2 + Hz**2) )
Hx = Hx * Hi
Hy = Hy * Hi
Hz = Hz * Hi
! ’µ‚Ë•Ô‚èŒã‚Ì‰t“H‘¬“x ----------------------------------------------------------------------------
Un2  = -1.0 * Un2
! alp2 = atan(Un2 / Uh2)
up2  = Uh2 * Hx + Un2 * Nx
vp2  = Uh2 * Hy + Un2 * Ny
wp2  = Uh2 * Hz + Un2 * Nz
! ˆ—I—¹ ****************************************************************************************
return
end subroutine SplashSamenfink
!*******************************************************************************************************
!******** MicroAVS ƒtƒ@ƒCƒ‹o—Í									********
!*******************************************************************************************************
subroutine MakeMAVSFileDroplet3D( &
&            strdir, strname, ext, lRef, aRef, iteration, x, y, z, u, v, w )
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 ! ˆø”•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strdir*(*), strname*(*), ext*4
 real,      intent(in) :: lRef, aRef
 integer,   intent(in) :: iteration
 real,      intent(in) :: x(1:iteration), y(1:iteration), z(1:iteration)
 real,      intent(in) :: u(1:iteration), v(1:iteration), w(1:iteration)
 ! ‹ÇŠ•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: n
 ! ˆ—ŠJn ********************************************************************************************
 open(1, file = trim(strdir) // trim(strname) // ext, form = 'formatted', status = 'replace')
  ! ƒwƒbƒ_o—Í -----------------------------------------------------------------------------------------
  write(1, '(a)')     '# AVS field file'
  write(1, '(a)')     'ndim = 1'
  write(1, '(a, i6)') 'dim1 = ', iteration
  write(1, '(a)')     'nspace = 3'
  write(1, '(a)')     'veclen = 1'
  write(1, '(a)')     'data = float'
  write(1, '(a)')     'field = irregular'
  write(1, '(a)')     'label = vabs'
  ! ƒf[ƒ^ƒtƒ@ƒCƒ‹İ’è ---------------------------------------------------------------------------------
  write(1, '(3a)') 'variable 1 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 3 stride = 4 close = 1'
  write(1, '(3a)') 'coord    1 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 0 stride = 4 close = 1'
  write(1, '(3a)') 'coord    2 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 1 stride = 4 close = 1'
  write(1, '(3a)') 'coord    3 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 2 stride = 4 close = 1'
  write(1, '(a)') 'eot'
  write(1, '(a)') ''
  ! ƒf[ƒ^o—Í -----------------------------------------------------------------------------------------
  do n = 1, iteration
   write(1, '(e16.8e3, 3(1x, e16.8e3))') x(n) * lRef, y(n) * lRef, z(n) * lRef, &
   &                                     sqrt( u(n)**2 + v(n)**2 + w(n)**2 ) * aRef
  enddo
 close(1)
 ! ˆ—I—¹ ********************************************************************************************
 return
end subroutine MakeMAVSFileDroplet3D
!*******************************************************************************************************
!******** MicroAVS ƒtƒ@ƒCƒ‹o—Í									********
!*******************************************************************************************************
subroutine MakeMAVSFileDropletTemperature3D( &
&            strdir, strname, ext, lRef, aRef, iteration, x, y, z, t )
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 ! ˆø”•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strdir*(*), strname*(*), ext*4
 integer,   intent(in) :: iteration
 real   ,   intent(in) :: lRef, aRef
 real   ,   intent(in) :: x(1:iteration), y(1:iteration), z(1:iteration)
 real   ,   intent(in) :: t(1:iteration)
 ! ‹ÇŠ•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: n
 ! ˆ—ŠJn ********************************************************************************************
 open(1, file = trim(strdir) // trim(strname) // ext, form = 'formatted', status = 'replace')
  ! ƒwƒbƒ_o—Í -----------------------------------------------------------------------------------------
  write(1, '(a)')     '# AVS field file'
  write(1, '(a)')     'ndim = 1'
  write(1, '(a, i6)') 'dim1 = ', iteration
  write(1, '(a)')     'nspace = 3'
  write(1, '(a)')     'veclen = 1'
  write(1, '(a)')     'data = float'
  write(1, '(a)')     'field = irregular'
  write(1, '(a)')     'label = vabs'
  ! ƒf[ƒ^ƒtƒ@ƒCƒ‹İ’è ---------------------------------------------------------------------------------
  write(1, '(3a)') 'variable 1 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 3 stride = 4 close = 1'
  write(1, '(3a)') 'coord    1 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 0 stride = 4 close = 1'
  write(1, '(3a)') 'coord    2 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 1 stride = 4 close = 1'
  write(1, '(3a)') 'coord    3 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 2 stride = 4 close = 1'
  write(1, '(a)') 'eot'
  write(1, '(a)') ''
  ! ƒf[ƒ^o—Í -----------------------------------------------------------------------------------------
  do n = 1, iteration
   write(1, '(e16.8e3, 3(1x, e16.8e3))') x(n) * lRef, y(n) * lRef, z(n) * lRef, &
   &                                     t(n) * aRef**2
  enddo
 close(1)
 ! ˆ—I—¹ ********************************************************************************************
 return
end subroutine MakeMAVSFileDropletTemperature3D
!*******************************************************************************************************
!******** MicroAVS ƒtƒ@ƒCƒ‹o—Í (SLD)								********
!*******************************************************************************************************
subroutine MakeMAVSFileSLD3D( &
&            strdir, strname, ext, lRef, aRef, iteration, x, y, z, m )
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 ! ˆø”•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strdir*(*), strname*(*), ext*4
 real,      intent(in) :: lRef, aRef
 integer,   intent(in) :: iteration
 real   ,   intent(in) :: x(1:iteration), y(1:iteration), z(1:iteration)
 real,      intent(in) :: m(1:iteration)
 ! ‹ÇŠ•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: n
 ! ˆ—ŠJn ********************************************************************************************
 open(1, file = trim(strdir) // trim(strname) // ext, form = 'formatted', status = 'replace')
  ! ƒwƒbƒ_o—Í -----------------------------------------------------------------------------------------
  write(1, '(a)')     '# AVS field file'
  write(1, '(a)')     'ndim = 1'
  write(1, '(a, i6)') 'dim1 = ', iteration
  write(1, '(a)')     'nspace = 3'
  write(1, '(a)')     'veclen = 1'
  write(1, '(a)')     'data = float'
  write(1, '(a)')     'field = irregular'
  write(1, '(a)')     'label = vabs'
  ! ƒf[ƒ^ƒtƒ@ƒCƒ‹İ’è ---------------------------------------------------------------------------------
  write(1, '(3a)') 'variable 1 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 3 stride = 4 close = 1'
  write(1, '(3a)') 'coord    1 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 0 stride = 4 close = 1'
  write(1, '(3a)') 'coord    2 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 1 stride = 4 close = 1'
  write(1, '(3a)') 'coord    3 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 2 stride = 4 close = 1'
  write(1, '(a)') 'eot'
  write(1, '(a)') ''
  ! ƒf[ƒ^o—Í -----------------------------------------------------------------------------------------
  do n = 1, iteration
   write(1, '(e16.8e3, 4(1x, e16.8e3))') x(n) * lRef, y(n) * lRef, z(n) * lRef, &
   &                                     m(n)
  enddo
 close(1)
 ! ˆ—I—¹ ********************************************************************************************
 return
end subroutine MakeMAVSFileSLD3D
!*******************************************************************************************************
!******** MicroAVS ƒtƒ@ƒCƒ‹o—Í	(We”)								********
!*******************************************************************************************************
subroutine MakeMAVSFileDropletWe3D( &
&            strdir, strname, ext, iteration, lRef, x, y, z, We )
 ! •Ï”éŒ¾ ********************************************************************************************
 implicit none
 ! ˆø”•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strdir*(*), strname*(*), ext*4
 integer,   intent(in) :: iteration
 real   ,   intent(in) :: lRef
 real   ,   intent(in) :: x(1:iteration), y(1:iteration), z(1:iteration)
 real   ,   intent(in) :: We(1:iteration)
 ! ‹ÇŠ•Ï” ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: n
 ! ˆ—ŠJn ********************************************************************************************
 open(1, file = trim(strdir) // trim(strname) // ext, form = 'formatted', status = 'replace')
  ! ƒwƒbƒ_o—Í -----------------------------------------------------------------------------------------
  write(1, '(a)')     '# AVS field file'
  write(1, '(a)')     'ndim = 1'
  write(1, '(a, i6)') 'dim1 = ', iteration
  write(1, '(a)')     'nspace = 3'
  write(1, '(a)')     'veclen = 1'
  write(1, '(a)')     'data = float'
  write(1, '(a)')     'field = irregular'
  write(1, '(a)')     'label = vabs'
  ! ƒf[ƒ^ƒtƒ@ƒCƒ‹İ’è ---------------------------------------------------------------------------------
  write(1, '(3a)') 'variable 1 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 3 stride = 4 close = 1'
  write(1, '(3a)') 'coord    1 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 0 stride = 4 close = 1'
  write(1, '(3a)') 'coord    2 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 1 stride = 4 close = 1'
  write(1, '(3a)') 'coord    3 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 2 stride = 4 close = 1'
  write(1, '(a)') 'eot'
  write(1, '(a)') ''
  ! ƒf[ƒ^o—Í -----------------------------------------------------------------------------------------
  do n = 1, iteration
   write(1, '(e16.8e3, 3(1x, e16.8e3))') x(n) * lRef, y(n) * lRef, z(n) * lRef, &
   &                                     We(n)
  enddo
 close(1)
 ! ˆ—I—¹ ********************************************************************************************
 return
end subroutine MakeMAVSFileDropletWe3D
! ’è‹`I—¹ *********************************************************************************************
end module Package_Droplet
