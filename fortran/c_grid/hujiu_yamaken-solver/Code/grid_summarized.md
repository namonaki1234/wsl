# folder "grid"

## file "Droplet_Trajectory_NACA.f90"

```fortran
!*******************************************************************************************************
!*******************************************************************************************************
!******** 液滴軌道計算プログラム								********
!******** (NACA翼，三次元圧縮性乱流場，重合格子法，液滴径分布なし)				********
!********					      2013.06.18  PROGRAMMED BY RYOSUKE HAYASHI ********
!********					      2013.07.18     UPDATED BY RYOSUKE HAYASHI ********
!********					      2014.04.15     UPDATED BY RYOSUKE HAYASHI ********
!******** 液滴変形モデル			      2014.12.08     UPDATED BY MIKI	SHIMURA	********
!********					      2015.04.29     UPDATED BY MIKI	SHIMURA ********
!********					      2015.05.04     UPDATED BY MIKI	SHIMURA	********
!******** 二次液滴の衝突判定入り		      2015.07.27     UPDATED BY MIKI    SHIMURA ********
!*******************************************************************************************************
!*******************************************************************************************************
program DropletTrajectory_NACA
 ! モジュール宣言 **************************************************************************************
 use Package_NACA
 use Package_FileIO
 use Package_Droplet
 use mt95
 use Package_Grid
 use Package_Flow
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 共有定数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer, parameter :: mini     =   me !1					! 液滴初期ブロック
 integer, parameter :: CalNum   =   3					! 1 : 衝突　2 : 可視化　3 : 両方
 integer, parameter :: nDrpView = 500					! 可視化液滴数
 real   , parameter :: SplLim   = 40.0e-6				! スプラッシュ判定
 ! 共有変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 logical, pointer :: fOver(:, :, :)					! 重合格子部のフラグ
 integer :: DrpNum							! 液滴ファイル番号
 real    :: xmin, ymin, ymax, zmin, zmax				! 液滴投入範囲
 real    :: uini, vini, wini						! 液滴初期速度
 real    :: xp, yp, zp                              			! 液滴位置 (物理空間)
 real    :: up, vp, wp                         				! 液滴速度 (物理空間)
 real    :: xip, etp, zep                           			! 液滴位置 (計算空間)
 real    :: uxp, vep, wzp                           			! 液滴速度 (計算空間)
 real    :: ypini							! 液滴初期位置 (物理空間)
 real    :: dp								! 液滴直径
 real    :: fx, fy, fz                              			! 液滴に働く力
 real    :: Ohw, Rew
 real    :: Cd								! 抗力係数
 real    :: AsRatio							! 液滴のアスペクト比
 real    :: ImpMass							! 液滴の衝突質量
 real    :: Time0							! 時間 (時間ごとの様子を見たい時)
 integer :: Nlost							! 液滴ロスト数
 logical :: fSearch							! 液滴探索成功フラグ
 logical :: fSplash							! 液滴スプラッシュフラグ
 logical :: fBounce							! 液滴バウンドフラグ
 logical :: fImpi1							! 1回目の液滴衝突フラグ
 logical :: fImpi2							! 2回目の液滴衝突フラグ
 logical :: fBreakup							! 液滴分裂フラグ
 ! 処理開始 ********************************************************************************************
 ! 検証実験ケース選択 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 write(*, '(a)'  ) "<< Exp. Case Selection >>"
 call SelectExpCase
 ! 初期設定 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 write(*, '(/,a)') "<< Initial Condition Set >>"
 call InitialSetting
 ! 液滴軌道計算初期条件 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 write(*, '(/,a)') "<< Inlet Droplet Set >>"
 call InitialDropletCondition
 ! 衝突面積計算 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 write(*, '(/,a)') "<< Impingemenr Area Set >>"
 call CalImpingementArea
 ! 液滴軌道計算 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 write(*, '(/,a)') "<< Droplet Trajectory calculation Computation >>"
 call CalDropletTrajectory
 ! メモリ解放 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 write(*, '(/,a)') "<< Memory Deallocation >>"
 call Deallocating
 ! 内部手続き ******************************************************************************************
 stop
contains
!*******************************************************************************************************
!******** 検証実験ケース選択 									********
!*******************************************************************************************************
subroutine SelectExpCase
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character :: fname * 20
 ! 処理開始 ********************************************************************************************
 ! 計算条件ファイル入力
 call Input_CalSetting( trim(ND_CalSetFile) // strtxt )
 ! ディレクトリ設定
 if( IceStep == 0 ) then
   GrdInDir    = bckdir // 'grid/clean/'
   OSGDir      = bckdir // 'overset/clean/'
   FlwIniDir   = bckdir // 'flow/initial/clean/'
   FlwCalInDir = bckdir // 'flow/cal/clean/'
   DrpImpDir   = bckdir // 'droplet/impingement/clean/'
   DrpTraDir   = bckdir // 'droplet/trajectory/clean/'
  else
   GrdInDir    = bckdir // 'grid/icing/'
   OSGDir      = bckdir // 'overset/icing/'
   FlwIniDir   = bckdir // 'flow/initial//icing/'
   FlwCalInDir = bckdir // 'flow/cal/icing/'
   DrpImpDir   = bckdir // 'droplet/impingement/icing/'
   DrpTraDir   = bckdir // 'droplet/trajectory/icing/'
 endif
 write(*, '(a,i2)') '* Ice step      = ', IceStep
 write(*, '(a,i2)') '* Ice step max. = ', IceStepMax
 write(*, '(a,e16.8e3)') '* Ts    = ', TsExp * aRef**2
 write(*, '(a,e16.8e3)') '* Ps    = ', PsExp * (rhoRef * aRef**2)
 write(*, '(a,e16.8e3)') '* V     = ', VelExp * aRef
 write(*, '(a,e16.8e3)') '* LWC   = ', LWC * RhoRef
 write(*, '(a,e16.8e3)') '* MVD   = ', MVD * LRef
 write(*, '(a,e16.8e3)') '* Rho   = ', Rhod * RhoRef
 write(*, '(a,e16.8e3)') '* Chord = ', Chord * LRef
 write(*, '(a,e16.8e3)') '* AOA   = ', AOA * 180.0 / pi
 ! 処理終了 ********************************************************************************************
 return
end subroutine SelectExpCase
!*******************************************************************************************************
!******** 初期設定										********
!*******************************************************************************************************
subroutine InitialSetting
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer   :: i, j, k, m
 integer   :: jp
 character :: fname * 30
 ! 処理開始 ********************************************************************************************
 ! 構造体メモリ確保 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! allocate( Flw(ms:me), OSG(ms:me), Drp(1:nDrpFile), Ice(ms:me) )
 allocate( Flw(ms:me), Drp(1:nDrpFile), Ice(ms:me) )
 ! ブロック名設定 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 call Set_BlockName
 ! 格子解像度 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! do m = ms, me
 m = me
  call Input_Resolution3D( &
  &      trim(GrdInDir) // trim(BlkName(m)) // trim(RslFile), strtxt, &
  &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke )
! enddo
 ! メモリ確保 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! do m = ms, me
 m = me
  allocate( Flw(m)%x   (Flw(m)%is: Flw(m)%ie, Flw(m)%js: Flw(m)%je, Flw(m)%ks: Flw(m)%ke), &
  &         Flw(m)%y   (Flw(m)%is: Flw(m)%ie, Flw(m)%js: Flw(m)%je, Flw(m)%ks: Flw(m)%ke), &
  &         Flw(m)%z   (Flw(m)%is: Flw(m)%ie, Flw(m)%js: Flw(m)%je, Flw(m)%ks: Flw(m)%ke), &
  &         Flw(m)%rho (Flw(m)%is: Flw(m)%ie, Flw(m)%js: Flw(m)%je, Flw(m)%ks: Flw(m)%ke), &
  &         Flw(m)%u   (Flw(m)%is: Flw(m)%ie, Flw(m)%js: Flw(m)%je, Flw(m)%ks: Flw(m)%ke), &
  &         Flw(m)%v   (Flw(m)%is: Flw(m)%ie, Flw(m)%js: Flw(m)%je, Flw(m)%ks: Flw(m)%ke), &
  &         Flw(m)%w   (Flw(m)%is: Flw(m)%ie, Flw(m)%js: Flw(m)%je, Flw(m)%ks: Flw(m)%ke), &
  &         Flw(m)%p   (Flw(m)%is: Flw(m)%ie, Flw(m)%js: Flw(m)%je, Flw(m)%ks: Flw(m)%ke), &
  &         Flw(m)%t   (Flw(m)%is: Flw(m)%ie, Flw(m)%js: Flw(m)%je, Flw(m)%ks: Flw(m)%ke), &
  &         Flw(m)%mu  (Flw(m)%is: Flw(m)%ie, Flw(m)%js: Flw(m)%je, Flw(m)%ks: Flw(m)%ke), &
  &         Flw(m)%kin (Flw(m)%is: Flw(m)%ie, Flw(m)%js: Flw(m)%je, Flw(m)%ks: Flw(m)%ke), &
  &         Flw(m)%eps (Flw(m)%is: Flw(m)%ie, Flw(m)%js: Flw(m)%je, Flw(m)%ks: Flw(m)%ke), &
  &         Flw(m)%xix (Flw(m)%is: Flw(m)%ie, Flw(m)%js: Flw(m)%je, Flw(m)%ks: Flw(m)%ke), &
  &         Flw(m)%xiy (Flw(m)%is: Flw(m)%ie, Flw(m)%js: Flw(m)%je, Flw(m)%ks: Flw(m)%ke), &
  &         Flw(m)%xiz (Flw(m)%is: Flw(m)%ie, Flw(m)%js: Flw(m)%je, Flw(m)%ks: Flw(m)%ke), &
  &         Flw(m)%etx (Flw(m)%is: Flw(m)%ie, Flw(m)%js: Flw(m)%je, Flw(m)%ks: Flw(m)%ke), &
  &         Flw(m)%ety (Flw(m)%is: Flw(m)%ie, Flw(m)%js: Flw(m)%je, Flw(m)%ks: Flw(m)%ke), &
  &         Flw(m)%etz (Flw(m)%is: Flw(m)%ie, Flw(m)%js: Flw(m)%je, Flw(m)%ks: Flw(m)%ke), &
  &         Flw(m)%zex (Flw(m)%is: Flw(m)%ie, Flw(m)%js: Flw(m)%je, Flw(m)%ks: Flw(m)%ke), &
  &         Flw(m)%zey (Flw(m)%is: Flw(m)%ie, Flw(m)%js: Flw(m)%je, Flw(m)%ks: Flw(m)%ke), &
  &         Flw(m)%zez (Flw(m)%is: Flw(m)%ie, Flw(m)%js: Flw(m)%je, Flw(m)%ks: Flw(m)%ke), &
  &         Flw(m)%jac (Flw(m)%is: Flw(m)%ie, Flw(m)%js: Flw(m)%je, Flw(m)%ks: Flw(m)%ke), &
  &         Flw(m)%qh  (Flw(m)%is: Flw(m)%ie, Flw(m)%js: Flw(m)%je, Flw(m)%ks: Flw(m)%ke, ls: le) )
! enddo
 ! 格子座標 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! do m = ms, me
 m = me
  call Input_Grid3D( &
  &      trim(FlwIniDir) // trim(BlkName(m)) // trim(ND_GrdFile), strbin, &
  &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, &
  &      Flw(m)%x, Flw(m)%y, Flw(m)%z )
! enddo
 ! C 型格子分割点 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! m = 1
 m = me
 call Input_CtypeGridPoint( &
 &      trim(GrdInDir) // trim(BlkName(m)) // trim(CtypePointFile) // strtxt, &
 &      Flw(m)%i1, Flw(m)%i2, Flw(m)%i3 )
 ! メトリックス ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! do m = ms, me
 m = me
  call Input_Metrics3D( &
  &      trim(FlwIniDir) // trim(BlkName(m)) // trim(ND_MetFile), strbin, &
  &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, &
  &      Flw(m)%jac, &
  &      Flw(m)%xix, Flw(m)%xiy, Flw(m)%xiz, &
  &      Flw(m)%etx, Flw(m)%ety, Flw(m)%etz, &
  &      Flw(m)%zex, Flw(m)%zey, Flw(m)%zez )
! enddo
 ! 流束関数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! do m = ms, me
 m = me
  call Input_Flux3D( &
  &      trim(FlwCalInDir) // trim(BlkName(m)) // trim(ND_FlxFile), strbin, &
  &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, &
  &      ls, le, Flw(m)%qh )
!  call Input_Flux3D( &
!  &      trim(FlwCalInDir) // trim(fname) // trim(BlkName(m)) // trim(ND_FlxFile), strbin, &
!  &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, &
!  &      ls, le, Flw(m)%qh )
! enddo
 ! 物理量 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! do m = ms, me
 m = me
  call SetPhysics3DKEM( &
  &      Rg, gamma, &
  &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, ls, le, &
  &      Flw(m)%qh, Flw(m)%jac, &
  &      Flw(m)%rho, Flw(m)%u, Flw(m)%v, Flw(m)%w, Flw(m)%p, Flw(m)%t, Flw(m)%kin, Flw(m)%eps )
  call ViscosityCoefficient3D( &
  &      muSth, TsSth, s1, &
  &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, &
  &      Flw(m)%t, &
  &      Flw(m)%mu )
  Flw(m)%w(:,:,:) = 0.0
! enddo
! ! 重合格子補間係数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! do m = ms, me
!  ! 補間探索範囲 ---------------------------------------------------------------------------------------
!  call Input_Resolution3D( &
!  &      trim(OSGDir) // trim(BlkName(m)) // trim(OverAreaFile), strtxt, &
!  &      OSG(m)%is, OSG(m)%ie, OSG(m)%js, OSG(m)%je, OSG(m)%ks, OSG(m)%ke )
!  ! メモリ確保 -----------------------------------------------------------------------------------------
!  allocate( OSG(m)%ip   (OSG(m)%is: OSG(m)%ie, OSG(m)%js: OSG(m)%je, OSG(m)%ks: OSG(m)%ke), &
!  &         OSG(m)%jp   (OSG(m)%is: OSG(m)%ie, OSG(m)%js: OSG(m)%je, OSG(m)%ks: OSG(m)%ke), &
!  &         OSG(m)%kp   (OSG(m)%is: OSG(m)%ie, OSG(m)%js: OSG(m)%je, OSG(m)%ks: OSG(m)%ke), &
!  &         OSG(m)%fOver(OSG(m)%is: OSG(m)%ie, OSG(m)%js: OSG(m)%je, OSG(m)%ks: OSG(m)%ke), &
!  &         OSG(m)%term1(OSG(m)%is: OSG(m)%ie, OSG(m)%js: OSG(m)%je, OSG(m)%ks: OSG(m)%ke), &
!  &         OSG(m)%term2(OSG(m)%is: OSG(m)%ie, OSG(m)%js: OSG(m)%je, OSG(m)%ks: OSG(m)%ke), &
!  &         OSG(m)%term3(OSG(m)%is: OSG(m)%ie, OSG(m)%js: OSG(m)%je, OSG(m)%ks: OSG(m)%ke), &
!  &         OSG(m)%term4(OSG(m)%is: OSG(m)%ie, OSG(m)%js: OSG(m)%je, OSG(m)%ks: OSG(m)%ke), &
!  &         OSG(m)%term5(OSG(m)%is: OSG(m)%ie, OSG(m)%js: OSG(m)%je, OSG(m)%ks: OSG(m)%ke), &
!  &         OSG(m)%term6(OSG(m)%is: OSG(m)%ie, OSG(m)%js: OSG(m)%je, OSG(m)%ks: OSG(m)%ke), &
!  &         OSG(m)%term7(OSG(m)%is: OSG(m)%ie, OSG(m)%js: OSG(m)%je, OSG(m)%ks: OSG(m)%ke), &
!  &         OSG(m)%term8(OSG(m)%is: OSG(m)%ie, OSG(m)%js: OSG(m)%je, OSG(m)%ks: OSG(m)%ke) )
!  ! 補間係数 -------------------------------------------------------------------------------------------
!  call Input_OversetCoe3D( &
!  &      trim(OSGDir) // trim(BlkName(m)) // trim(OverCoeFile), strbin, &
!  &      OSG(m)%is, OSG(m)%ie, OSG(m)%js, OSG(m)%je, OSG(m)%ks, OSG(m)%ke, &
!  &      OSG(m)%fOver, OSG(m)%ip, OSG(m)%jp, OSG(m)%kp, &
!  &      OSG(m)%term1, OSG(m)%term2, OSG(m)%term3, OSG(m)%term4, &
!  &      OSG(m)%term5, OSG(m)%term6, OSG(m)%term7, OSG(m)%term8 )
! enddo
! ! 重合格子部のフラグ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! m = 1
! allocate( fOver(Flw(m)%is: Flw(m)%ie, Flw(m)%js: Flw(m)%je, Flw(m)%ks: Flw(m)%ke) )
! fOver(:,:,:) = .false.
! do k = OSG(m)%ks, OSG(m)%ke
! do j = OSG(m)%js, OSG(m)%je
! do i = OSG(m)%is, OSG(m)%ie
!  if( OSG(m)%fOver(i,j,k) == 0 ) cycle
!  fOver(i,j,k) = .true.
! enddo
! enddo
! enddo
! ! メモリ解放 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! do m = ms, me
!  deallocate( Flw(m)%p, Flw(m)%t, Flw(m)%kin, Flw(m)%eps, Flw(m)%jac, Flw(m)%qh )
!  deallocate( OSG(m)%fOver, OSG(m)%ip   , OSG(m)%jp   , OSG(m)%kp   , &
!  &           OSG(m)%term1, OSG(m)%term2, OSG(m)%term3, OSG(m)%term4, &
!  &           OSG(m)%term5, OSG(m)%term6, OSG(m)%term7, OSG(m)%term8 )
! enddo
 ! 液滴軌道 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 do m = 1, nDrpFile
  allocate( Drp(m)%m(1:nCalMax), &
  &         Drp(m)%x(1:nCalMax), Drp(m)%y(1:nCalMax), Drp(m)%z(1:nCalMax), &
  &         Drp(m)%u(1:nCalMax), Drp(m)%v(1:nCalMax), Drp(m)%w(1:nCalMax), &
  &         Drp(m)%mr(1:nCalMax), Drp(m)%Cd(1:nCalMax), Drp(m)%AsRatio(1:nCalMax)  )
  Drp(m)%m(:) = 1
  Drp(m)%u(:) = 0.0; Drp(m)%v(:) = 0.0; Drp(m)%w(:) = 0.0
  Drp(m)%mr(:) = 1.0; Drp(m)%Cd(:) = 0.0; Drp(m)%AsRatio(:) = 0.0
 enddo
 ! 着氷計算領域 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! do m = ms, me
 m = me
  call Input_Resolution1D( &
  &      trim(GrdInDir) // trim(BlkName(m)) // trim(IceRslFile), strtxt, &
  &      Ice(m)%is, Ice(m)%ie )
! enddo
 ! 衝突セル ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! do m = ms, me
 m = me
  ! メモリ確保
  allocate( Flw(m)%nimp(Ice(m)%is: Ice(m)%ie, Flw(m)%ks: Flw(m)%ke), &
  &         Flw(m)%uimp(Ice(m)%is: Ice(m)%ie, Flw(m)%ks: Flw(m)%ke), &
  &         Flw(m)%vimp(Ice(m)%is: Ice(m)%ie, Flw(m)%ks: Flw(m)%ke), &
  &         Flw(m)%wimp(Ice(m)%is: Ice(m)%ie, Flw(m)%ks: Flw(m)%ke), &
  &         Flw(m)%simp(Ice(m)%is: Ice(m)%ie, Flw(m)%ks: Flw(m)%ke), &
  &         Flw(m)%CE  (Ice(m)%is: Ice(m)%ie, Flw(m)%ks: Flw(m)%ke), &
  &         Flw(m)%ImpMass(Ice(m)%is: Ice(m)%ie, Flw(m)%ks: Flw(m)%ke) )
  Flw(m)%nimp(:,:) = 0
  Flw(m)%uimp(:,:) = 0.0; Flw(m)%vimp(:,:) = 0.0; Flw(m)%wimp(:,:) = 0.0; Flw(m)%simp(:,:) = 0
  Flw(m)%ImpMass(:,:) =0.0
! enddo
 ! 液滴計算途中解 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 if( nDrop > nDrpOutputCount .and. CalNum /= 2 ) then
   write(fname, '(a,i8.8,a)') 'Drop', nDrop, '_'
!   do m = ms, me
 m = me
    call Input_Impingement3D( &
    &      trim(DrpImpDir) // trim(BlkName(m)) // trim(ND_DrpImpiDataFile), strbin, &
    &      Ice(m)%is, Ice(m)%ie, Flw(m)%ks, Flw(m)%ke, &
    &      Flw(m)%nimp, Flw(m)%uimp, Flw(m)%vimp, Flw(m)%wimp )
!    call Input_Impingement3D( &
!    &      trim(DrpImpDir) // trim(fname) // trim(BlkName(m)) // trim(ND_DrpImpiDataFile), strbin, &
!    &      Ice(m)%is, Ice(m)%ie, Flw(m)%ks, Flw(m)%ke, &
!    &      Flw(m)%nimp, Flw(m)%uimp, Flw(m)%vimp, Flw(m)%wimp )
    nStart = nDrop
!   enddo
  else
   nStart = 1
 endif
 ! 処理終了 ********************************************************************************************
 return
end subroutine InitialSetting
!*******************************************************************************************************
!******** 液滴軌道計算の初期条件								********
!*******************************************************************************************************
subroutine InitialDropletCondition
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 局所定数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real   , parameter :: rxMin = -7.0
 real   , parameter :: ryMin = -0.9!-0.2 !-0.9 !4deg用　!-0.1 0deg用
 real   , parameter :: ryMax = +0.2!+0.2 !-0.3 !4deg用　!+0.1 0deg用
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: m
 integer :: i
 integer :: ip, jp, kp
 integer :: imin, imax
 real    :: dis
 ! 処理開始 ********************************************************************************************
 ! 液滴投入ブロック ------------------------------------------------------------------------------------
 m = mini
 ip = Flw(m)%i2; jp = Flw(m)%js; kp = int(0.5 * Flw(m)%ke)
 ! 液滴投入範囲 ----------------------------------------------------------------------------------------
 ! x 方向
 xmin = Flw(m)%x(ip,jp,kp) + rxMin * chord
 ! y 方向
 ymin = minval( Flw(m)%y(Flw(m)%i1:Flw(m)%i3,jp,kp) ) + ryMin * chord
 ymax = maxval( Flw(m)%y(Flw(m)%i1:Flw(m)%i3,jp,kp) ) + ryMax * chord
 write(*,'(a,e16.8e3)')'* ymin = ',ymin
 write(*,'(a,e16.8e3)')'* ymax = ',ymax
 ! z 方向
! zmin = Flw(m)%z(ip, jp, Flw(m)%ks + 1)
! zmax = Flw(m)%z(ip, jp, Flw(m)%ke - 1)
!Mainグリッドはz方向に4分割,Subグリッドは5分割なので,Mainに合わせる
 zmin = Flw(m)%z(ip, jp, Flw(m)%ks) + (Flw(m)%z(ip, jp, Flw(m)%ke) - Flw(m)%z(ip, jp, Flw(m)%ks)) / 3.0
 zmax = Flw(m)%z(ip, jp, Flw(m)%ke) - (Flw(m)%z(ip, jp, Flw(m)%ke) - Flw(m)%z(ip, jp, Flw(m)%ks)) / 3.0
 ! 液滴投入速度 ----------------------------------------------------------------------------------------
 uini = VelExp * cos(AOA)
 vini = VelExp * sin(AOA)
 wini = 0.0
 DrpInVel = sqrt(uini**2 + vini**2 + wini**2)
 ! 液滴投入面積 ----------------------------------------------------------------------------------------
 DrpInArea = (ymax - ymin) * (zmax - zmin)
 ! ファイル出力 ----------------------------------------------------------------------------------------
 if(nDrop == 0) then
   call Output_DropInCondition( &
   &      trim(DrpImpDir) // trim(DrpInConditionFile), strtxt, &
   &      DrpInArea * lRef**2,  DrpInVel * aRef )
 endif
 ! 処理終了 ********************************************************************************************
 return
end subroutine InitialDropletCondition
!*******************************************************************************************************
!******** 液滴軌道計算										********
!*******************************************************************************************************
subroutine CalDropletTrajectory
 ! 変数宣言 ********************************************************************************************
 implicit none
 character :: fname * 50
 ! 処理開始 ********************************************************************************************
 ! ログファイル設定 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 open(9, file = trim(DrpImpDir) // 'Log.txt')
 write(9, '(a)')         '+++ Numerical Condition +++'
 write(9, '(a,i2)')      '* Exp. case        = ', ExpCaseNum
 write(9, '(a,e10.4e1)') '* Cn               = ', Cnd
 write(9, '(a,i9)')      '* Droplet Count    = ', nDrpIn
 write(9, '(a,i9)')      '* Max. Calculation = ', nCalMax
 write(*, '(a)')          '+++ Numerical Condition +++'
 write(*, '(a,i2)')       '* Exp. case        = ', ExpCaseNum
 write(*, '(a,e10.4e1)')  '* Cn               = ', Cnd
 write(*, '(a,i9)')       '* Droplet Count    = ', nDrpIn
 write(*, '(a,i9)')       '* Max. Calculation = ', nCalMax
 ! 初期値 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 DrpNum = 0
 Nlost  = 0
 if(CalNum == 2) then
   nDrpIn       = nDrpView
   nDrpFile     = nDrpView
   nOutputCount = nDrpView
 endif
 call genrand_init( nStart )
 ! 液滴投入ループ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 do nDrop = nStart, nDrpIn
  ! 液滴ファイル番号
  DrpNum = mod(DrpNum, nDrpFile) + 1
  ! 液滴軌道計算
  call DropletTimeStep
  ! 計算途中解出力
  if( mod(nDrop, nDrpOutputCount) == 0.0 ) then
    select case(CalNum)
     case(1)
      call CalCollectionEfficiency
     case(2)
      call OutputViewFile
     case(3)
      call CalCollectionEfficiency
      call OutputViewFile
    end select
  endif
!!!  if(fSplash .or. fBounce) then
!!!    call ViewSLDPhenomena( DrpNum )
!!!  endif
  ! 計算ログ出力
  if( mod(nDrop, nOutputLog) == 0.0 .or. &
  &   nDrop == 1 .or. CalNum == 2 ) then
!  open(15,file='alp1.txt')
!  write(15,'(e16.8e3,2(5X,e16.8e3))') Ohw, Rew
    write(9, '(/, a)')    '+++ Computation Progress +++'
    write(9, '(a, i11)')  '* Droplet Number      = ', nDrop
!    write(9, '(a, i11)')  '* Impingement on Main = ', nint( sum(Flw(1)%nimp(:,:)) )
    write(9, '(a, i11)')  '* Impingement on Sub1 = ', nint( sum(Flw(2)%nimp(:,Flw(2)%ks+1)) )
    write(9, '(a, i11)')  '* Impingement on Sub2 = ', nint( sum(Flw(2)%nimp(:,Flw(2)%ks+2)) )
    write(9, '(a, i11)')  '* Impingement on Sub3 = ', nint( sum(Flw(2)%nimp(:,Flw(2)%ke-1)) )
    write(9, '(a, i11)')  '* Missing Number      = ', Nlost
    write(9, '(a, i11)')  '* Splash Number       = ', nDrpSpl
    write(9, '(a, i11)')  '* Bounce Number       = ', nDrpBou
    write(9, '(a, i11)')  '* 2 impinge Number    = ', nDrp2Imp
    write(9, '(a, i11)')  '* Breakup Number      = ', nDrpBrk
    write(*, '(/, a)')    '+++ Computation Progress +++'
    write(*, '(a, i11)')  '* Droplet Number      = ', nDrop
!    write(*, '(a, i11)')  '* Impingement on Main = ', nint( sum(Flw(1)%nimp(:,:)) )
    write(*, '(a, i11)')  '* Impingement on Sub1 = ', nint( sum(Flw(2)%nimp(:,Flw(2)%ks+1)) )
    write(*, '(a, i11)')  '* Impingement on Sub2 = ', nint( sum(Flw(2)%nimp(:,Flw(2)%ks+2)) )
    write(*, '(a, i11)')  '* Impingement on Sub3 = ', nint( sum(Flw(2)%nimp(:,Flw(2)%ke-1)) )
    write(*, '(a, i11)')  '* Missing Number      = ', Nlost
    write(*, '(a, i11)')  '* Splash Number       = ', nDrpSpl
    write(*, '(a, i11)')  '* Bounce Number       = ', nDrpBou
    write(*, '(a, i11)')  '* 2 impinge Number    = ', nDrp2Imp
    write(*, '(a, i11)')  '* Breakup Number      = ', nDrpBrk
  endif
 enddo
 call OutputViewFile
 close(9)
! close(15)
 ! 処理終了 ********************************************************************************************
 return
end subroutine CalDropletTrajectory
!*******************************************************************************************************
!******** 液滴軌道の時間進行									********
!*******************************************************************************************************
subroutine DropletTimeStep
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 局所定数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer, parameter :: nRetry = 100					! 液滴探索最大再試行回数
 integer, parameter :: mRetry = 10					! 液滴補間最大再試行回数
 integer, parameter :: SR     = 2					! 液滴探索範囲
 real   , parameter :: MGN    = 1.0e-3					! 補間経緯数許容誤差
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: n, m
 integer :: ip, jp, kp, mp
 integer :: ip0, jp0, kp0
 real(8) :: rr
 real    :: xp0, yp0, zp0, up0, vp0, wp0
 real    :: dt
 real    :: mr
 logical :: fMove, fImpi, fExit
 character :: fname * 20
 ! 処理開始 ********************************************************************************************
 ! 液滴初期位置及び速度 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 mp   = mini
 xp   = xmin
 up   = uini; vp = vini; wp = wini
 dp   = MVD
 mr   = 1.0
 fSplash = .false.
 fBounce = .false.
 fImpi1 = .false.
 fImpi2 = .false.
 fBreakup = .false.
 do n = 1, nRetry
  select case(CalNum)
   case(2)
    ! y 方向
    yp = ymin + (ymax - ymin) * real(nDrop - 1) / real(nDrpView - 1)
    ypini = yp
    ! z 方向
    zp = 0.5 *  (zmax + zmin)
   case default
    ! y 方向 (乱数)
    call genrand_real1(rr)
    yp = ymin + (ymax - ymin) * real(rr)
    ypini = yp
    ! z 方向 (乱数)
    call genrand_real1(rr)
    zp = zmin + (zmax - zmin) * real(rr)
  end select
  ! 初期位置探索
  do m = 1, mRetry
   call SearchDroplet( &
   &      mp, &
   &      Flw(mp)%is, Flw(mp)%ie - 1, &
   &      Flw(mp)%js, Flw(mp)%je - 1, &
   &      Flw(mp)%ks, Flw(mp)%ke - 1, &
   &      MGN * real(m - 1), ip, jp, kp )
   if(fSearch) exit
  enddo
  if(fSearch) exit
 enddo
 if(.not. fSearch) then
   write(9, '(a)') '!!!!! Error : Droplet initial position !!!!!'
   write(9, '(a, i11)') '* Droplet number   = ', nDrop
   write(9, '(a, 4(i4, a))') '* Cell index (', mp, ',', ip, ',', jp, ',', kp, ')'
   write(*, '(a)') '!!!!! Error : Droplet initial position !!!!!'
   write(*, '(a, i11)') '* Droplet number   = ', nDrop
   write(*, '(a, 4(i4, a))') '* Cell index (', mp, ',', ip, ',', jp, ',', kp, ')'
   return
 endif
 ! 液滴のアスペクト比の出力ファイル ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 write(fname, '(a, 2(i2.2,a))') 'IceStep', IceStep, 'of', IceStepMax, '_'
 open(12, file = trim(DrpImpDir) // trim(fname) // 'AspectRatio.txt')
 Time0 = 0.0
 ! 液滴の時間進行 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 do nCount = 1, nCalMax
  ! 時間刻み -------------------------------------------------------------------------------------------
  call dt3D( uxp, vep, wzp, Cnd, dt )
  if(CalNum == 2) then
   write(12,'(e16.8e3,3x,e16.8e3)')Time0,AsRatio
  Time0 = Time0 + dt
  endif
  ! 液滴位置探索 ---------------------------------------------------------------------------------------
  ip0 = ip; jp0 = jp; kp0 = kp
  do n = 1, nRetry
   xp0 = xp; yp0 = yp; zp0 = zp
   up0 = up; vp0 = vp; wp0 = wp
   ! 時間進行
   call TimeEuler3D( &
   &      dt, fx, fy, fz, xp0, yp0, zp0, up0, vp0, wp0, &
   &      xp, yp, zp, up, vp, wp )
   ! 液滴探索
   do m = 1, mRetry
    call SearchDroplet( &
    &      mp, &
    &      max(Flw(mp)%is, ip0 - SR), min(Flw(mp)%ie - 1, ip0 + SR), &
    &      max(Flw(mp)%js, jp0 - SR), min(Flw(mp)%je - 1, jp0 + SR), &
    &      max(Flw(mp)%ks, kp0 - SR), min(Flw(mp)%ke - 1, kp0 + SR), &
    &      MGN * real(m - 1), ip, jp, kp )
    if(fSearch) exit
   enddo
   if(fSearch) then
     exit
    else
     call BoundaryBladeSurface( ip0, jp0, kp0, Flw(mp)%js, mp, fImpi, up, vp, wp, mr )
     if(fImpi) return
   endif
  enddo
  if(.not. fSearch) then
    write(9, '(a)') '!!!!! Error : Droplet search !!!!!'
    write(9, '(a, i6)')  '* Iteration number = ', nCount
    write(9, '(a, i11)') '* Droplet number   = ', nDrop
    write(9, '(a, 4(i4, a))') '* Cell index (', mp, ',', ip0, ',', jp0, ',', kp0, ')'
    write(*, '(a)') '!!!!! Error : Droplet search !!!!!'
    write(*, '(a, i6)')  '* Iteration number = ', nCount
    write(*, '(a, i11)') '* Droplet number   = ', nDrop
    write(*, '(a, 4(i4, a))') '* Cell index (', mp, ',', ip0, ',', jp0, ',', kp0, ')'
    Nlost = Nlost + 1
    return								! ロスト．次の液滴へ
  endif
  ! 境界条件 -------------------------------------------------------------------------------------------
  fMove = .false.; fImpi = .false.; fExit = .false.
  select case(mp)
   ! Main Grid
   case(1)
!    ! 流出境界
!    if(.not. fMove) call BoundaryOutlet( ip, jp, mp, fExit )
!    if(fExit) return
!    ! Sub Grid 境界
!    if(.not. fMove) call BoundaryMGtoSG( ip, jp, kp, mp, fMove )
!    ! C 型格子ブランチ・カット
!    if(.not. fMove) call BoundaryCtypeBranchCut( ip, jp, mp, fMove )
!    ! 翼表面
!    if(.not. fMove) call BoundaryBladeSurface( ip, jp, kp, Flw(mp)%js, mp, fImpi, up, vp, wp, mr )
!    if(fImpi) return
!    ! 周期境界
!    if(.not. fMove) call BoundaryPeriodic( ip, jp, kp, mp, fMove )
    write(*,*) 'error:boundary condition in droplet trajectory'
    stop
   ! Sub Grid
   case(2)
!    ! Main Grid 境界
!    if(.not. fMove) call BoundarySGtoMG( ip, jp, kp, mp, fMove )
    ! 流出境界
    if(.not. fMove) call BoundaryOutlet( ip, jp, mp, fExit )
    if(fExit) return
    ! C 型格子ブランチ・カット
    if(.not. fMove) call BoundaryCtypeBranchCut( ip, jp, mp, fMove )
    ! 翼表面
    if(.not. fMove) call BoundaryBladeSurface( ip, jp, kp, Flw(mp)%js, mp, fImpi, up, vp, wp, mr )
    if(fImpi) return
    ! 周期境界
    if(.not. fMove) call BoundaryPeriodic( ip, jp, kp, mp, fMove )
   case default
    write(*, '(a)') '!!!!! Error : Block index !!!!!'
    stop
  end select
  ! 格子移動後の液滴位置探索 ---------------------------------------------------------------------------
  if(fMove) then
    do n = 1, nRetry
     ! 液滴位置探索
     do m = 1, mRetry
      call SearchDroplet( &
      &      mp, &
      &      Flw(mp)%is, Flw(mp)%ie - 1, &
      &      Flw(mp)%js, Flw(mp)%je - 1, &
      &      Flw(mp)%ks, Flw(mp)%ke - 1, &
      &      MGN * real(m - 1), ip, jp, kp )
      if(fSearch) exit
     enddo
     if(fSearch) exit
     ! 時間進行 (探索失敗時)
     xp0 = xp; yp0 = yp; zp0 = zp
     up0 = up; vp0 = vp; wp0 = wp
     call TimeEuler3D( &
     &      0.1 * dt, fx, fy, fz, xp0, yp0, zp0, up0, vp0, wp0, &
     &      xp, yp, zp, up, vp, wp )
     ! 格子を突き抜けた場合の処理
     call BoundaryBladeSurface( ip, jp, kp, Flw(mp)%js, mp, fImpi, up, vp, wp, mr )
     if(fImpi) return
    enddo
    if(.not. fSearch) then
      write(9, '(a)') '!!!!! Error : Droplet search !!!!!'
      write(9, '(a, i6)')  '* Iteration number = ', nCount
      write(9, '(a, i11)') '* Droplet number   = ', nDrop
      write(9, '(a, 4(i4, a))') '* Cell index (', mp, ',', ip0, ',', jp0, ',', kp0, ')'
      write(*, '(a)') '!!!!! Error : Droplet search !!!!!'
      write(*, '(a, i6)')  '* Iteration number = ', nCount
      write(*, '(a, i11)') '* Droplet number   = ', nDrop
      write(*, '(a, 4(i4, a))') '* Cell index (', mp, ',', ip0, ',', jp0, ',', kp0, ')'
      Nlost = Nlost + 1
      return								! ロスト．次の液滴へ
    endif
  endif
  ! 液滴軌道データログ ---------------------------------------------------------------------------------
  Drp(DrpNum)%step       = nCount
  Drp(DrpNum)%m (nCount) = mp
  Drp(DrpNum)%x (nCount) = xp
  Drp(DrpNum)%y (nCount) = yp
  Drp(DrpNum)%z (nCount) = zp
  Drp(DrpNum)%u (nCount) = up
  Drp(DrpNum)%v (nCount) = vp
  Drp(DrpNum)%w (nCount) = wp
  Drp(DrpNum)%mr(nCount) = mr
  Drp(DrpNum)%Cd(nCount) = Cd
  Drp(DrpNum)%AsRatio(nCount) = AsRatio
 enddo
 close(12)
 ! 処理終了 ********************************************************************************************
 return
end subroutine DropletTimeStep
!*******************************************************************************************************
!******** 液滴探索										********
!*******************************************************************************************************
subroutine SearchDroplet( &
&            mp, isp, iep, jsp, jep, ksp, kep, MGN, ip, jp, kp )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer, intent(in)  :: mp						! 補間点探索ブロック
 integer, intent(in)  :: isp, iep, jsp, jep, ksp, kep			! 補間点探索範囲
 real   , intent(in)  :: MGN						! 補間係数許容誤差
 integer, intent(out) :: ip, jp, kp					! 補間点格子番号
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i1, i2, i3, i4, i5, i6, i7, i8, &
 &          j1, j2, j3, j4, j5, j6, j7, j8, &
 &          k1, k2, k3, k4, k5, k6, k7, k8				! 補間点
 real    :: alp, bet, gam						! 補間係数
 integer :: fInter							! 補間パターン
 real    :: term1, term2, term3, term4, term5, term6, term7, term8	! 補間係数
 real    :: rhof, uf, vf, wf, muf                                       ! 周囲流体の物理量
 real    :: fdx, fdy, fdz						! 液滴に働く抗力
 real    :: fgx, fgy, fgz						! 液滴に働く重力
 real    :: gx, gy, gz							! 重力係数
 real    :: xixp, xiyp, xizp, etxp, etyp, etzp, zexp, zeyp, zezp
 real    :: dp1, dp2
 ! 処理開始 ********************************************************************************************
 ! 探索開始 (物理空間) +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 fInter = 0
 do kp = ksp, kep
 do jp = jsp, jep
 do ip = isp, iep
  ! ワイド・サーチ -------------------------------------------------------------------------------------
  i1 = ip    ; j1 = jp    ; k1 = kp    ; i2 = ip + 1; j2 = jp    ; k2 = kp
  i3 = ip    ; j3 = jp + 1; k3 = kp    ; i4 = ip + 1; j4 = jp + 1; k4 = kp
  i5 = ip    ; j5 = jp    ; k5 = kp + 1; i6 = ip + 1; j6 = jp    ; k6 = kp + 1
  i7 = ip    ; j7 = jp + 1; k7 = kp + 1; i8 = ip + 1; j8 = jp + 1; k8 = kp + 1
  call WideSearch3D8Point( &
  &      xp, yp, zp, &
  &      Flw(mp)%x(i1,j1,k1), Flw(mp)%y(i1,j1,k1), Flw(mp)%z(i1,j1,k1), &
  &      Flw(mp)%x(i2,j2,k2), Flw(mp)%y(i2,j2,k2), Flw(mp)%z(i2,j2,k2), &
  &      Flw(mp)%x(i3,j3,k3), Flw(mp)%y(i3,j3,k3), Flw(mp)%z(i3,j3,k3), &
  &      Flw(mp)%x(i4,j4,k4), Flw(mp)%y(i4,j4,k4), Flw(mp)%z(i4,j4,k4), &
  &      Flw(mp)%x(i5,j5,k5), Flw(mp)%y(i5,j5,k5), Flw(mp)%z(i5,j5,k5), &
  &      Flw(mp)%x(i6,j6,k6), Flw(mp)%y(i6,j6,k6), Flw(mp)%z(i6,j6,k6), &
  &      Flw(mp)%x(i7,j7,k7), Flw(mp)%y(i7,j7,k7), Flw(mp)%z(i7,j7,k7), &
  &      Flw(mp)%x(i8,j8,k8), Flw(mp)%y(i8,j8,k8), Flw(mp)%z(i8,j8,k8), &
  &      MGN, fSearch )
  if(.not. fSearch) then
   cycle
  endif
  ! 三重線形補間 ---------------------------------------------------------------------------------------
  alp = 0.5; bet = 0.5; gam = 0.5
  call Interpolation3D8Point( &
  &      xp, yp, zp, &
  &      Flw(mp)%x(i1,j1,k1), Flw(mp)%y(i1,j1,k1), Flw(mp)%z(i1,j1,k1), &
  &      Flw(mp)%x(i2,j2,k2), Flw(mp)%y(i2,j2,k2), Flw(mp)%z(i2,j2,k2), &
  &      Flw(mp)%x(i3,j3,k3), Flw(mp)%y(i3,j3,k3), Flw(mp)%z(i3,j3,k3), &
  &      Flw(mp)%x(i4,j4,k4), Flw(mp)%y(i4,j4,k4), Flw(mp)%z(i4,j4,k4), &
  &      Flw(mp)%x(i5,j5,k5), Flw(mp)%y(i5,j5,k5), Flw(mp)%z(i5,j5,k5), &
  &      Flw(mp)%x(i6,j6,k6), Flw(mp)%y(i6,j6,k6), Flw(mp)%z(i6,j6,k6), &
  &      Flw(mp)%x(i7,j7,k7), Flw(mp)%y(i7,j7,k7), Flw(mp)%z(i7,j7,k7), &
  &      Flw(mp)%x(i8,j8,k8), Flw(mp)%y(i8,j8,k8), Flw(mp)%z(i8,j8,k8), &
  &  	 MGN, alp, bet, gam, fSearch )
  if(fSearch) then
    fInter = 1
    exit
  endif
  ! 三次元線形補間 -------------------------------------------------------------------------------------
  ! Pattern-1
  i1 = ip    ; j1 = jp    ; k1 = kp    ; i2 = ip    ; j2 = jp    ; k2 = kp + 1
  i3 = ip + 1; j3 = jp    ; k3 = kp + 1; i4 = ip    ; j4 = jp + 1; k4 = kp + 1
  alp = 0.5; bet = 0.5; gam = 0.5
  call Interpolation3D4Point( &
  &      xp, yp, zp, &
  &      Flw(mp)%x(i1,j1,k1), Flw(mp)%y(i1,j1,k1), Flw(mp)%z(i1,j1,k1), &
  &      Flw(mp)%x(i2,j2,k2), Flw(mp)%y(i2,j2,k2), Flw(mp)%z(i2,j2,k2), &
  &      Flw(mp)%x(i3,j3,k3), Flw(mp)%y(i3,j3,k3), Flw(mp)%z(i3,j3,k3), &
  &      Flw(mp)%x(i4,j4,k4), Flw(mp)%y(i4,j4,k4), Flw(mp)%z(i4,j4,k4), &
  &	 MGN, alp, bet, gam, fSearch )
  if(fSearch) then
    fInter = 2
    exit
  endif
  ! Pattern-2
  i1 = ip    ; j1 = jp    ; k1 = kp    ; i2 = ip    ; j2 = jp + 1; k2 = kp
  i3 = ip + 1; j3 = jp + 1; k3 = kp    ; i4 = ip    ; j4 = jp + 1; k4 = kp + 1
  alp = 0.5; bet = 0.5; gam = 0.5
  call Interpolation3D4Point( &
  &      xp, yp, zp, &
  &      Flw(mp)%x(i1,j1,k1), Flw(mp)%y(i1,j1,k1), Flw(mp)%z(i1,j1,k1), &
  &      Flw(mp)%x(i2,j2,k2), Flw(mp)%y(i2,j2,k2), Flw(mp)%z(i2,j2,k2), &
  &      Flw(mp)%x(i3,j3,k3), Flw(mp)%y(i3,j3,k3), Flw(mp)%z(i3,j3,k3), &
  &      Flw(mp)%x(i4,j4,k4), Flw(mp)%y(i4,j4,k4), Flw(mp)%z(i4,j4,k4), &
  &	 MGN, alp, bet, gam, fSearch )
  if(fSearch) then
    fInter = 3
    exit
  endif
  ! Pattern-3
  i1 = ip    ; j1 = jp    ; k1 = kp    ; i2 = ip + 1; j2 = jp + 1; k2 = kp
  i3 = ip + 1; j3 = jp    ; k3 = kp + 1; i4 = ip    ; j4 = jp + 1; k4 = kp + 1
  alp = 0.5; bet = 0.5; gam = 0.5
  call Interpolation3D4Point( &
  &      xp, yp, zp, &
  &      Flw(mp)%x(i1,j1,k1), Flw(mp)%y(i1,j1,k1), Flw(mp)%z(i1,j1,k1), &
  &      Flw(mp)%x(i2,j2,k2), Flw(mp)%y(i2,j2,k2), Flw(mp)%z(i2,j2,k2), &
  &      Flw(mp)%x(i3,j3,k3), Flw(mp)%y(i3,j3,k3), Flw(mp)%z(i3,j3,k3), &
  &      Flw(mp)%x(i4,j4,k4), Flw(mp)%y(i4,j4,k4), Flw(mp)%z(i4,j4,k4), &
  &	 MGN, alp, bet, gam, fSearch )
  if(fSearch) then
    fInter = 4
    exit
  endif
  ! Pattern-4
  i1 = ip    ; j1 = jp    ; k1 = kp    ; i2 = ip + 1; j2 = jp    ; k2 = kp
  i3 = ip + 1; j3 = jp + 1; k3 = kp    ; i4 = ip + 1; j4 = jp    ; k4 = kp + 1
  alp = 0.5; bet = 0.5; gam = 0.5
  call Interpolation3D4Point( &
  &      xp, yp, zp, &
  &      Flw(mp)%x(i1,j1,k1), Flw(mp)%y(i1,j1,k1), Flw(mp)%z(i1,j1,k1), &
  &      Flw(mp)%x(i2,j2,k2), Flw(mp)%y(i2,j2,k2), Flw(mp)%z(i2,j2,k2), &
  &      Flw(mp)%x(i3,j3,k3), Flw(mp)%y(i3,j3,k3), Flw(mp)%z(i3,j3,k3), &
  &      Flw(mp)%x(i4,j4,k4), Flw(mp)%y(i4,j4,k4), Flw(mp)%z(i4,j4,k4), &
  &	 MGN, alp, bet, gam, fSearch )
  if(fSearch) then
    fInter = 5
    exit
  endif
  ! Pattern-5
  i1 = ip + 1; j1 = jp + 1; k1 = kp    ; i2 = ip + 1; j2 = jp    ; k2 = kp + 1
  i3 = ip    ; j3 = jp + 1; k3 = kp + 1; i4 = ip + 1; j4 = jp + 1; k4 = kp + 1
  alp = 0.5; bet = 0.5; gam = 0.5
  call Interpolation3D4Point( &
  &      xp, yp, zp, &
  &      Flw(mp)%x(i1,j1,k1), Flw(mp)%y(i1,j1,k1), Flw(mp)%z(i1,j1,k1), &
  &      Flw(mp)%x(i2,j2,k2), Flw(mp)%y(i2,j2,k2), Flw(mp)%z(i2,j2,k2), &
  &      Flw(mp)%x(i3,j3,k3), Flw(mp)%y(i3,j3,k3), Flw(mp)%z(i3,j3,k3), &
  &      Flw(mp)%x(i4,j4,k4), Flw(mp)%y(i4,j4,k4), Flw(mp)%z(i4,j4,k4), &
  &	 MGN, alp, bet, gam, fSearch )
  if(fSearch) then
    fInter = 6
    exit
  endif
 enddo
 if(fInter /= 0) exit
 enddo
 if(fInter /= 0) exit
 enddo
 ! 補間係数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 select case(fInter)
  case(0)
   return
  case(1)
   term1 = (1.0 - alp) * (1.0 - bet) * (1.0 - gam)
   term2 =        alp  * (1.0 - bet) * (1.0 - gam)
   term3 = (1.0 - alp) *        bet  * (1.0 - gam)
   term4 =        alp  *        bet  * (1.0 - gam)
   term5 = (1.0 - alp) * (1.0 - bet) *        gam
   term6 =        alp  * (1.0 - bet) *        gam
   term7 = (1.0 - alp) *        bet  *        gam
   term8 =        alp  *        bet  *        gam
  case(2:6)
   term1 = 1.0
   term2 = alp
   term3 = bet
   term4 = gam
  case default
   write(*, '(a)') '!!!!! Error : fInter number !!!!!'
   stop
 end select
 ! 周囲流体の情報を補間 (計算空間) +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 select case(fInter)
  case(1)
   xixp = term1 * Flw(mp)%xix(i1,j1,k1) + term2 * Flw(mp)%xix(i2,j2,k2) &
   &    + term3 * Flw(mp)%xix(i3,j3,k3) + term4 * Flw(mp)%xix(i4,j4,k4) &
   &    + term5 * Flw(mp)%xix(i5,j5,k5) + term6 * Flw(mp)%xix(i6,j6,k6) &
   &    + term7 * Flw(mp)%xix(i7,j7,k7) + term8 * Flw(mp)%xix(i8,j8,k8)
   xiyp = term1 * Flw(mp)%xiy(i1,j1,k1) + term2 * Flw(mp)%xiy(i2,j2,k2) &
   &    + term3 * Flw(mp)%xiy(i3,j3,k3) + term4 * Flw(mp)%xiy(i4,j4,k4) &
   &    + term5 * Flw(mp)%xiy(i5,j5,k5) + term6 * Flw(mp)%xiy(i6,j6,k6) &
   &    + term7 * Flw(mp)%xiy(i7,j7,k7) + term8 * Flw(mp)%xiy(i8,j8,k8)
   xizp = term1 * Flw(mp)%xiz(i1,j1,k1) + term2 * Flw(mp)%xiz(i2,j2,k2) &
   &    + term3 * Flw(mp)%xiz(i3,j3,k3) + term4 * Flw(mp)%xiz(i4,j4,k4) &
   &    + term5 * Flw(mp)%xiz(i5,j5,k5) + term6 * Flw(mp)%xiz(i6,j6,k6) &
   &    + term7 * Flw(mp)%xiz(i7,j7,k7) + term8 * Flw(mp)%xiz(i8,j8,k8)
   etxp = term1 * Flw(mp)%etx(i1,j1,k1) + term2 * Flw(mp)%etx(i2,j2,k2) &
   &    + term3 * Flw(mp)%etx(i3,j3,k3) + term4 * Flw(mp)%etx(i4,j4,k4) &
   &    + term5 * Flw(mp)%etx(i5,j5,k5) + term6 * Flw(mp)%etx(i6,j6,k6) &
   &    + term7 * Flw(mp)%etx(i7,j7,k7) + term8 * Flw(mp)%etx(i8,j8,k8)
   etyp = term1 * Flw(mp)%ety(i1,j1,k1) + term2 * Flw(mp)%ety(i2,j2,k2) &
   &    + term3 * Flw(mp)%ety(i3,j3,k3) + term4 * Flw(mp)%ety(i4,j4,k4) &
   &    + term5 * Flw(mp)%ety(i5,j5,k5) + term6 * Flw(mp)%ety(i6,j6,k6) &
   &    + term7 * Flw(mp)%ety(i7,j7,k7) + term8 * Flw(mp)%ety(i8,j8,k8)
   etzp = term1 * Flw(mp)%etz(i1,j1,k1) + term2 * Flw(mp)%etz(i2,j2,k2) &
   &    + term3 * Flw(mp)%etz(i3,j3,k3) + term4 * Flw(mp)%etz(i4,j4,k4) &
   &    + term5 * Flw(mp)%etz(i5,j5,k5) + term6 * Flw(mp)%etz(i6,j6,k6) &
   &    + term7 * Flw(mp)%etz(i7,j7,k7) + term8 * Flw(mp)%etz(i8,j8,k8)
   zexp = term1 * Flw(mp)%zex(i1,j1,k1) + term2 * Flw(mp)%zex(i2,j2,k2) &
   &    + term3 * Flw(mp)%zex(i3,j3,k3) + term4 * Flw(mp)%zex(i4,j4,k4) &
   &    + term5 * Flw(mp)%zex(i5,j5,k5) + term6 * Flw(mp)%zex(i6,j6,k6) &
   &    + term7 * Flw(mp)%zex(i7,j7,k7) + term8 * Flw(mp)%zex(i8,j8,k8)
   zeyp = term1 * Flw(mp)%zey(i1,j1,k1) + term2 * Flw(mp)%zey(i2,j2,k2) &
   &    + term3 * Flw(mp)%zey(i3,j3,k3) + term4 * Flw(mp)%zey(i4,j4,k4) &
   &    + term5 * Flw(mp)%zey(i5,j5,k5) + term6 * Flw(mp)%zey(i6,j6,k6) &
   &    + term7 * Flw(mp)%zey(i7,j7,k7) + term8 * Flw(mp)%zey(i8,j8,k8)
   zezp = term1 * Flw(mp)%zez(i1,j1,k1) + term2 * Flw(mp)%zez(i2,j2,k2) &
   &    + term3 * Flw(mp)%zez(i3,j3,k3) + term4 * Flw(mp)%zez(i4,j4,k4) &
   &    + term5 * Flw(mp)%zez(i5,j5,k5) + term6 * Flw(mp)%zez(i6,j6,k6) &
   &    + term7 * Flw(mp)%zez(i7,j7,k7) + term8 * Flw(mp)%zez(i8,j8,k8)
   rhof = term1 * Flw(mp)%rho(i1,j1,k1) + term2 * Flw(mp)%rho(i2,j2,k2) &
   &    + term3 * Flw(mp)%rho(i3,j3,k3) + term4 * Flw(mp)%rho(i4,j4,k4) &
   &    + term5 * Flw(mp)%rho(i5,j5,k5) + term6 * Flw(mp)%rho(i6,j6,k6) &
   &    + term7 * Flw(mp)%rho(i7,j7,k7) + term8 * Flw(mp)%rho(i8,j8,k8)
   uf   = term1 * Flw(mp)%u  (i1,j1,k1) + term2 * Flw(mp)%u  (i2,j2,k2) &
   &    + term3 * Flw(mp)%u  (i3,j3,k3) + term4 * Flw(mp)%u  (i4,j4,k4) &
   &    + term5 * Flw(mp)%u  (i5,j5,k5) + term6 * Flw(mp)%u  (i6,j6,k6) &
   &    + term7 * Flw(mp)%u  (i7,j7,k7) + term8 * Flw(mp)%u  (i8,j8,k8)
   vf   = term1 * Flw(mp)%v  (i1,j1,k1) + term2 * Flw(mp)%v  (i2,j2,k2) &
   &    + term3 * Flw(mp)%v  (i3,j3,k3) + term4 * Flw(mp)%v  (i4,j4,k4) &
   &    + term5 * Flw(mp)%v  (i5,j5,k5) + term6 * Flw(mp)%v  (i6,j6,k6) &
   &    + term7 * Flw(mp)%v  (i7,j7,k7) + term8 * Flw(mp)%v  (i8,j8,k8)
   wf   = term1 * Flw(mp)%w  (i1,j1,k1) + term2 * Flw(mp)%w  (i2,j2,k2) &
   &    + term3 * Flw(mp)%w  (i3,j3,k3) + term4 * Flw(mp)%w  (i4,j4,k4) &
   &    + term5 * Flw(mp)%w  (i5,j5,k5) + term6 * Flw(mp)%w  (i6,j6,k6) &
   &    + term7 * Flw(mp)%w  (i7,j7,k7) + term8 * Flw(mp)%w  (i8,j8,k8)
   muf  = term1 * Flw(mp)%mu (i1,j1,k1) + term2 * Flw(mp)%mu (i2,j2,k2) &
   &    + term3 * Flw(mp)%mu (i3,j3,k3) + term4 * Flw(mp)%mu (i4,j4,k4) &
   &    + term5 * Flw(mp)%mu (i5,j5,k5) + term6 * Flw(mp)%mu (i6,j6,k6) &
   &    + term7 * Flw(mp)%mu (i7,j7,k7) + term8 * Flw(mp)%mu (i8,j8,k8)
  case(2:6)
   xixp = term1 * Flw(mp)%xix(i1,j1,k1) + term2 * (Flw(mp)%xix(i2,j2,k2) - Flw(mp)%xix(i1,j1,k1)) &
   &                                    + term3 * (Flw(mp)%xix(i3,j3,k3) - Flw(mp)%xix(i1,j1,k1)) &
   &                                    + term4 * (Flw(mp)%xix(i4,j4,k4) - Flw(mp)%xix(i1,j1,k1))
   xiyp = term1 * Flw(mp)%xiy(i1,j1,k1) + term2 * (Flw(mp)%xiy(i2,j2,k2) - Flw(mp)%xiy(i1,j1,k1)) &
   &                                    + term3 * (Flw(mp)%xiy(i3,j3,k3) - Flw(mp)%xiy(i1,j1,k1)) &
   &                                    + term4 * (Flw(mp)%xiy(i4,j4,k4) - Flw(mp)%xiy(i1,j1,k1))
   xizp = term1 * Flw(mp)%xiz(i1,j1,k1) + term2 * (Flw(mp)%xiz(i2,j2,k2) - Flw(mp)%xiz(i1,j1,k1)) &
   &                                    + term3 * (Flw(mp)%xiz(i3,j3,k3) - Flw(mp)%xiz(i1,j1,k1)) &
   &                                    + term4 * (Flw(mp)%xiz(i4,j4,k4) - Flw(mp)%xiz(i1,j1,k1))
   etxp = term1 * Flw(mp)%etx(i1,j1,k1) + term2 * (Flw(mp)%etx(i2,j2,k2) - Flw(mp)%etx(i1,j1,k1)) &
   &                                    + term3 * (Flw(mp)%etx(i3,j3,k3) - Flw(mp)%etx(i1,j1,k1)) &
   &                                    + term4 * (Flw(mp)%etx(i4,j4,k4) - Flw(mp)%etx(i1,j1,k1))
   etyp = term1 * Flw(mp)%ety(i1,j1,k1) + term2 * (Flw(mp)%ety(i2,j2,k2) - Flw(mp)%ety(i1,j1,k1)) &
   &                                    + term3 * (Flw(mp)%ety(i3,j3,k3) - Flw(mp)%ety(i1,j1,k1)) &
   &                                    + term4 * (Flw(mp)%ety(i4,j4,k4) - Flw(mp)%ety(i1,j1,k1))
   etzp = term1 * Flw(mp)%etz(i1,j1,k1) + term2 * (Flw(mp)%etz(i2,j2,k2) - Flw(mp)%etz(i1,j1,k1)) &
   &                                    + term3 * (Flw(mp)%etz(i3,j3,k3) - Flw(mp)%etz(i1,j1,k1)) &
   &                                    + term4 * (Flw(mp)%etz(i4,j4,k4) - Flw(mp)%etz(i1,j1,k1))
   zexp = term1 * Flw(mp)%zex(i1,j1,k1) + term2 * (Flw(mp)%zex(i2,j2,k2) - Flw(mp)%zex(i1,j1,k1)) &
   &                                    + term3 * (Flw(mp)%zex(i3,j3,k3) - Flw(mp)%zex(i1,j1,k1)) &
   &                                    + term4 * (Flw(mp)%zex(i4,j4,k4) - Flw(mp)%zex(i1,j1,k1))
   zeyp = term1 * Flw(mp)%zey(i1,j1,k1) + term2 * (Flw(mp)%zey(i2,j2,k2) - Flw(mp)%zey(i1,j1,k1)) &
   &                                    + term3 * (Flw(mp)%zey(i3,j3,k3) - Flw(mp)%zey(i1,j1,k1)) &
   &                                    + term4 * (Flw(mp)%zey(i4,j4,k4) - Flw(mp)%zey(i1,j1,k1))
   zezp = term1 * Flw(mp)%zez(i1,j1,k1) + term2 * (Flw(mp)%zez(i2,j2,k2) - Flw(mp)%zez(i1,j1,k1)) &
   &                                    + term3 * (Flw(mp)%zez(i3,j3,k3) - Flw(mp)%zez(i1,j1,k1)) &
   &                                    + term4 * (Flw(mp)%zez(i4,j4,k4) - Flw(mp)%zez(i1,j1,k1))
   rhof = term1 * Flw(mp)%rho(i1,j1,k1) + term2 * (Flw(mp)%rho(i2,j2,k2) - Flw(mp)%rho(i1,j1,k1)) &
   &                                    + term3 * (Flw(mp)%rho(i3,j3,k3) - Flw(mp)%rho(i1,j1,k1)) &
   &                                    + term4 * (Flw(mp)%rho(i4,j4,k4) - Flw(mp)%rho(i1,j1,k1))
   uf   = term1 * Flw(mp)%u  (i1,j1,k1) + term2 * (Flw(mp)%u  (i2,j2,k2) - Flw(mp)%u  (i1,j1,k1)) &
   &                                    + term3 * (Flw(mp)%u  (i3,j3,k3) - Flw(mp)%u  (i1,j1,k1)) &
   &                                    + term4 * (Flw(mp)%u  (i4,j4,k4) - Flw(mp)%u  (i1,j1,k1))
   vf   = term1 * Flw(mp)%v  (i1,j1,k1) + term2 * (Flw(mp)%v  (i2,j2,k2) - Flw(mp)%v  (i1,j1,k1)) &
   &                                    + term3 * (Flw(mp)%v  (i3,j3,k3) - Flw(mp)%v  (i1,j1,k1)) &
   &                                    + term4 * (Flw(mp)%v  (i4,j4,k4) - Flw(mp)%v  (i1,j1,k1))
   wf   = term1 * Flw(mp)%w  (i1,j1,k1) + term2 * (Flw(mp)%w  (i2,j2,k2) - Flw(mp)%w  (i1,j1,k1)) &
   &                                    + term3 * (Flw(mp)%w  (i3,j3,k3) - Flw(mp)%w  (i1,j1,k1)) &
   &                                    + term4 * (Flw(mp)%w  (i4,j4,k4) - Flw(mp)%w  (i1,j1,k1))
   muf  = term1 * Flw(mp)%mu (i1,j1,k1) + term2 * (Flw(mp)%mu (i2,j2,k2) - Flw(mp)%mu (i1,j1,k1)) &
   &                                    + term3 * (Flw(mp)%mu (i3,j3,k3) - Flw(mp)%mu (i1,j1,k1)) &
   &                                    + term4 * (Flw(mp)%mu (i4,j4,k4) - Flw(mp)%mu (i1,j1,k1))
  case default
   write(*, '(a)') '!!!!! Error : fInter number !!!!!'
   stop
 end select
 ! 液滴速度 (計算空間) +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 call Velocity3D( &
 &      xixp, xiyp, xizp, etxp, etyp, etzp, zexp, zeyp, zezp, up, vp, wp, &
 &      uxp, vep, wzp )
! ! 液滴のアスペクト比 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! call CalAspectRatio( &
! &       dp, rhod, up, vp, wp, rhof, uf, vf, wf, mud, sigd, muf, &
! &       AsRatio)
 ! 液滴の分裂 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 dp1 = dp
 call DropletBreakup( &
  &      dp1, Rhod, up, vp, wp, Rhof, uf, vf, wf, mud, sigd, fBreakup, nDrpBrk, &
  &      dp2 )
 dp = dp2
 ! 液滴に働く抗力 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 select case(DragNum)
 case(1)
  call Drag3D( &
  &      dp, Rhod, up, vp, wp, Rhof, uf, vf, wf, muf, &
  &      fdx, fdy, fdz, Cd )
 case(2)
  call DragGennaro( &
  &      dp, Rhod, up, vp, wp, Rhof, uf, vf, wf, muf, &
  &      fdx, fdy, fdz, Cd )
 case(3)
  call WiegandDrag( &
  &      dp, Rhod, up, vp, wp, Rhof, uf, vf, wf, muf, sigd, &
  &      fdx, fdy, fdz, Cd )
 case(4)
  call WebernumberDrag( &
  &      dp, Rhod, up, vp, wp, Rhof, uf, vf, wf, muf, sigd, &
  &      fdx, fdy, fdz, Cd )
end select
 ! 液滴に働く重力と浮力 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 gx = +0.0
 gy = -0.0
 gz = 0.0
 gx = gx / (aRef**2 / lRef)
 gy = gy / (aRef**2 / lRef)
 gz = gz / (aRef**2 / lRef)
 call GravityBuoyancy3D( &
 &      Rhod, Rhof, gx, gy, gz, &
 &      fgx, fgy, fgz )
 ! 合力 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 fx = fdx + fgx; fy = fdy + fgy; fz = fdz + fgz
 ! 処理終了 ********************************************************************************************
 return
end subroutine SearchDroplet
!*******************************************************************************************************
!******** Main Grid から Sub Grid への移動							********
!*******************************************************************************************************
subroutine BoundaryMGtoSG( ip, jp, kp, mp, fMove )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer, intent(in)    :: ip, jp, kp
 integer, intent(inout) :: mp
 logical, intent(out)   :: fMove
 ! 処理開始 ********************************************************************************************
 ! 例外処理 --------------------------------------------------------------------------------------------
 if( ip == Flw(mp)%ie .or. jp == Flw(mp)%je .or. kp == Flw(mp)%ke ) then
  fMove = .false.
  return
 endif
 ! ブロック移動判定 ------------------------------------------------------------------------------------
 if( fOver(ip  , jp  , kp) .and. fOver(ip+1, jp  , kp) .and. &
 &   fOver(ip  , jp+1, kp) .and. fOver(ip+1, jp+1, kp) ) then
   fMove = .true.
   mp    = 2
  else
   fMove = .false.
   mp    = 1
 endif
 ! 処理終了 ********************************************************************************************
 return
end subroutine BoundaryMGtoSG
!*******************************************************************************************************
!******** Sub Grid から Main Grid への移動							********
!*******************************************************************************************************
subroutine BoundarySGtoMG( ip, jp, kp, mp, fMove )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer, intent(in)    :: ip, jp, kp
 integer, intent(inout) :: mp
 logical, intent(out)   :: fMove
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 logical :: isOut, ieOut, jeOut
 ! 処理開始 ********************************************************************************************
 isOut = ip <  Flw(mp)%is + 1 .and. uxp < 0.0
 ieOut = ip >= Flw(mp)%ie - 1 .and. uxp > 0.0
 jeOut = jp >= Flw(mp)%je - 1 .and. vep > 0.0
 if( isOut .or. ieOut .or. jeOut ) then
   fMove = .true.
   mp    = 1
  else
   fMove = .false.
   mp    = 2
 endif
 ! 処理終了 ********************************************************************************************
 return
end subroutine BoundarySGtoMG
!*******************************************************************************************************
!******** 翼表面の衝突判定									********
!*******************************************************************************************************
subroutine BoundaryBladeSurface( ip, jp, kp, j0, mp, fImpi, up, vp, wp, mr )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer, intent(in)    :: ip, jp, kp
 integer, intent(in)    :: j0
 integer, intent(in)    :: mp
 logical, intent(out)   :: fImpi
 real   , intent(inout) :: up, vp, wp, mr
 ! 局所定数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer, parameter :: jMin   = 20
 integer, parameter :: nRetry = 100
 real   , parameter :: MGN    = 0.01
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real    :: x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4
 real    :: alp, bet, gam
 integer :: n
 integer :: i1, i2, i3, i4, j1, j2, j3, j4, k1, k2, k3, k4
 logical :: fDivi
 real    :: wgh1, wgh2, wgh3, wgh4, wgh5, wgh6, wgh7, wgh8
 real    :: r1, r2, r3, r4
 real    :: u1, v1, w1, d1, m1, n1, u2, v2, w2, d2, m2, n2
 real    :: SLDLim
 integer,parameter	:: swi_splash_bound = 0 !0:全量付着,1:スプラッシュ・バウンドモデル(wright)
 ! 処理開始 ********************************************************************************************
 ! 例外処理 --------------------------------------------------------------------------------------------
 if( ip == Flw(mp)%ie .or. jp == Flw(mp)%je .or. kp == Flw(mp)%ke ) then
   fImpi = .false.
   return
 endif
 if( (mp == 1) .and. (ip < Flw(mp)%i1 .or. ip >= Flw(mp)%i3) ) then
   fImpi = .false.
   return
 endif
 if( jp > jMin ) then
   fImpi = .false.
   return
 endif
 ! 衝突判定 --------------------------------------------------------------------------------------------
 ! 周囲点のインデックス
 i1 = ip; k1 = kp; i2 = ip; k2 = kp + 1; i3 = ip + 1; k3 = kp
 ! 周囲 3点の座標
 x1 = Flw(mp)%x(i1,j0,k1); y1 = Flw(mp)%y(i1,j0,k1); z1 = Flw(mp)%z(i1,j0,k1)
 x2 = Flw(mp)%x(i2,j0,k2); y2 = Flw(mp)%y(i2,j0,k2); z2 = Flw(mp)%z(i2,j0,k2)
 x3 = Flw(mp)%x(i3,j0,k3); y3 = Flw(mp)%y(i3,j0,k3); z3 = Flw(mp)%z(i3,j0,k3)
 ! 衝突前の物理量
 u1 = up; v1 = vp; w1 = wp; d1 = dp; m1 = mr
 n1 = nDrpSpl + nDrpBou
 SLDLim = SplLim / lRef
 ! 衝突判定
 select case(swi_splash_bound)
  case(0)
   call ImpingementJudge3D( &
   &      xp, yp, zp, x1, y1, z1, x2, y2, z2, x3, y3, z3, MVD, &
   &      fImpi, Rhod, ImpMass )
   u2 = 0.0; v2 = 0.0; w2 = 0.0
   d2 = 0.0; m2 = 0.0; m2 = 0.0
  case(1)
   call SplashLEWICE3D( &
   &      xp, yp, zp, u1, v1, w1, d1, m1, x1, y1, z1, x2, y2, z2, x3, y3, z3, &
   &      LWC, Rhod, Sigd, mud, SLDLim, &
   &      fImpi, u2, v2, w2, d2, m2, nDrpSpl, nDrpBou, nDrp2Imp, ImpMass, Ohw, Rew, fSplash, fBounce, fImpi2 )
  ! call SplashSamenfink( &
  ! &      xp, yp, zp, u1, v1, w1, d1, m1, x1, y1, z1, x2, y2, z2, x3, y3, z3, &
  ! &      LWC, Rhod, Sigd, mud, SLDLim, Chord, &
  ! &      fImpi, u2, v2, w2, d2, m2, nDrpSpl, nDrpBou )
   ! 衝突後の物理量
   up = u2; vp = v2; wp = w2; dp = d2; mr = m2
   n2 = nDrpSpl + nDrpBou
   ! スプラッシュ・バウンドのログ
   if(n1 < n2 ) then
     if(d1 > d2 )then
  !     write(*, '(a)') '----- Splash -----'
  !     write(*, '(a, i11)') '* Droplet number   = ', nDrop
  !     write(*, '(a, 4(i4, a))') '* Cell index (', mp, ',', ip, ',', jp, ',', kp, ')'
  !     write(9, '(a)') '----- Splash -----'
  !     write(9, '(a, i11)') '* Droplet number   = ', nDrop
  !     write(9, '(a, 4(i4, a))') '* Cell index (', mp, ',', ip, ',', jp, ',', kp, ')'
  !     fSplash = .true.
      else
  !     write(*, '(a)') '----- Bounce -----'
  !     write(*, '(a, i11)') '* Droplet number   = ', nDrop
  !     write(*, '(a, 4(i4, a))') '* Cell index (', mp, ',', ip, ',', jp, ',', kp, ')'
  !     write(9, '(a)') '----- Bounce -----'
  !     write(9, '(a, i11)') '* Droplet number   = ', nDrop
  !     write(9, '(a, 4(i4, a))') '* Cell index (', mp, ',', ip, ',', jp, ',', kp, ')'
  !     fBounce = .true.
     endif
    else
     if(fImpi) then
  !     write(*, '(a)') '----- Impingement -----'
  !     write(*, '(a, i11)') '* Droplet number   = ', nDrop
  !     write(*, '(a, 4(i4, a))') '* Cell index (', mp, ',', ip, ',', jp, ',', kp, ')'
  !     write(9, '(a)') '----- Impingement -----'
  !     write(9, '(a, i11)') '* Droplet number   = ', nDrop
  !     write(9, '(a, 4(i4, a))') '* Cell index (', mp, ',', ip, ',', jp, ',', kp, ')'
     endif
   endif
 end select
 if(.not. fImpi) return
 ! 衝突量の分配 ----------------------------------------------------------------------------------------
 ! 周囲 4点と液滴の距離
 i1 = ip; k1 = kp; i2 = ip; k2 = kp + 1; i3 = ip + 1; k3 = kp; i4 = ip + 1; k4 = kp + 1
 x1 = Flw(mp)%x(i1,j0,k1); y1 = Flw(mp)%y(i1,j0,k1); z1 = Flw(mp)%z(i1,j0,k1)
 x2 = Flw(mp)%x(i2,j0,k2); y2 = Flw(mp)%y(i2,j0,k2); z2 = Flw(mp)%z(i2,j0,k2)
 x3 = Flw(mp)%x(i3,j0,k3); y3 = Flw(mp)%y(i3,j0,k3); z3 = Flw(mp)%z(i3,j0,k3)
 x4 = Flw(mp)%x(i4,j0,k4); y4 = Flw(mp)%y(i4,j0,k4); z4 = Flw(mp)%z(i4,j0,k4)
 r1 = sqrt( (x1 - xp)**2 + (y1 - yp)**2 + (z1 - zp)**2 )
 r2 = sqrt( (x2 - xp)**2 + (y2 - yp)**2 + (z2 - zp)**2 )
 r3 = sqrt( (x3 - xp)**2 + (y3 - yp)**2 + (z3 - zp)**2 )
 r4 = sqrt( (x4 - xp)**2 + (y4 - yp)**2 + (z4 - zp)**2 )
 ! 重み関数
 if( r1 == 0.0 ) then
   wgh1 = 1.0; wgh2 = 0.0; wgh3 = 0.0; wgh4 = 0.0
  else if( r2 == 0.0 ) then 
   wgh1 = 0.0; wgh2 = 1.0; wgh3 = 0.0; wgh4 = 0.0
  else if( r3 == 0.0 ) then 
   wgh1 = 0.0; wgh2 = 0.0; wgh3 = 1.0; wgh4 = 0.0
  else if( r4 == 0.0 ) then 
   wgh1 = 0.0; wgh2 = 0.0; wgh3 = 0.0; wgh4 = 1.0
  else
   alp  = (r2 * r3 * r4 + r1 * r3 * r4 + r1 * r2 * r4 + r1 * r2 * r3) / (r1 * r2 * r3 * r4)
   wgh1 = 1.0 / (r1 * alp)
   wgh2 = 1.0 / (r2 * alp)
   wgh3 = 1.0 / (r3 * alp)
   wgh4 = 1.0 / (r4 * alp)
 endif
 ! 衝突個数
 Flw(mp)%nimp(i1,k1) = Flw(mp)%nimp(i1,k1) + (m1 - m2) * wgh1
 Flw(mp)%uimp(i1,k1) = Flw(mp)%uimp(i1,k1) + u1        * wgh1
 Flw(mp)%vimp(i1,k1) = Flw(mp)%vimp(i1,k1) + v1        * wgh1
 Flw(mp)%wimp(i1,k1) = Flw(mp)%wimp(i1,k1) + w1        * wgh1
 Flw(mp)%nimp(i2,k2) = Flw(mp)%nimp(i2,k2) + (m1 - m2) * wgh2
 Flw(mp)%uimp(i2,k2) = Flw(mp)%uimp(i2,k2) + u1        * wgh2
 Flw(mp)%vimp(i2,k2) = Flw(mp)%vimp(i2,k2) + v1        * wgh2
 Flw(mp)%wimp(i2,k2) = Flw(mp)%wimp(i2,k2) + w1        * wgh2
 Flw(mp)%nimp(i3,k3) = Flw(mp)%nimp(i3,k3) + (m1 - m2) * wgh3
 Flw(mp)%uimp(i3,k3) = Flw(mp)%uimp(i3,k3) + u1        * wgh3
 Flw(mp)%vimp(i3,k3) = Flw(mp)%vimp(i3,k3) + v1        * wgh3
 Flw(mp)%wimp(i3,k3) = Flw(mp)%wimp(i3,k3) + w1        * wgh3
 Flw(mp)%nimp(i4,k4) = Flw(mp)%nimp(i4,k4) + (m1 - m2) * wgh4
 Flw(mp)%uimp(i4,k4) = Flw(mp)%uimp(i4,k4) + u1        * wgh4
 Flw(mp)%vimp(i4,k4) = Flw(mp)%vimp(i4,k4) + v1        * wgh4
 Flw(mp)%wimp(i4,k4) = Flw(mp)%wimp(i4,k4) + w1        * wgh4
 ! 衝突量
 Flw(mp)%ImpMass(i1,k1) = Flw(mp)%ImpMass(i1,k1) + ImpMass * wgh1
 Flw(mp)%ImpMass(i2,k2) = Flw(mp)%ImpMass(i2,k2) + ImpMass * wgh2
 Flw(mp)%ImpMass(i3,k3) = Flw(mp)%ImpMass(i3,k3) + ImpMass * wgh3
 Flw(mp)%ImpMass(i4,k4) = Flw(mp)%ImpMass(i4,k4) + ImpMass * wgh4
 ! スプラッシュの場合は計算続行
 if(n1 < n2 ) fImpi = .false.
 ! 2回めの衝突の場合 ***********************************************************************************
 if(fImpi2)then
  write(*,'(a)')               '***** droplet impinges twice *****'
  write(*,'(a, i11)')          '* Droplet Number =', nDrop
  write(*,'(a, e16.8e3)')      '* Initial yp     =', ypini
  write(*,'(a, 2(i4, a))')     '* ( ip, jp )     = ( ', ip, ', ', jp, ' )'
  write(*,'(a, 2(e16.8e3, a))')'* ( xp, yp )     = ( ', xp, ', ', yp, ' )'
 endif
 ! 処理終了 ********************************************************************************************
 return
end subroutine BoundaryBladeSurface
!*******************************************************************************************************
!******** C 型格子ブランチ・カット								********
!*******************************************************************************************************
subroutine BoundaryCtypeBranchCut( ip, jp, mp, fMove )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer, intent(in)  :: ip, jp
 integer, intent(in)  :: mp
 logical, intent(out) :: fMove
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 logical :: jsOut
 ! 処理開始 ********************************************************************************************
 ! 例外処理 --------------------------------------------------------------------------------------------
 if( ip >= Flw(mp)%i1 .and. ip < Flw(mp)%i3 ) return
 ! ブロック移動判定 ------------------------------------------------------------------------------------
 jsOut = jp < Flw(mp)%js + 1 .and. vep < 0.0
 if(jsOut) then
   xp    = xp + up / abs(vep) * 2.0
   yp    = yp + vp / abs(vep) * 2.0
   zp    = zp + wp / abs(vep) * 2.0
   fMove = .true.
  else
   fMove = .false.
 endif
 ! 処理終了 ********************************************************************************************
 return
end subroutine BoundaryCtypeBranchCut
!*******************************************************************************************************
!******** 周期境界										********
!*******************************************************************************************************
subroutine BoundaryPeriodic( ip, jp, kp, mp, fMove )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer, intent(in)  :: ip, jp, kp
 integer, intent(in)  :: mp
 logical, intent(out) :: fMove
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real    :: dz
 logical :: ksOut, keOut
 ! 処理開始 ********************************************************************************************
 ksOut = kp <  Flw(mp)%ks + 1 .and. wzp < 0.0
 keOut = kp >= Flw(mp)%ke - 1 .and. wzp > 0.0
 dz    = maxval( Flw(mp)%z(ip,jp,:Flw(mp)%ke-1) )  - minval( Flw(mp)%z(ip,jp,:) )
 if(ksOut) then
   zp = zp + dz
   fMove = .true.
   return
 endif
 if(keOut) then
   zp = zp - dz
   fMove = .true.
   return
 endif
 fMove = .false.
 ! 処理終了 ********************************************************************************************
 return
end subroutine BoundaryPeriodic
!*******************************************************************************************************
!******** 流出境界										********
!*******************************************************************************************************
subroutine BoundaryOutlet( ip, jp, mp, fExit )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer, intent(in)  :: ip, jp
 integer, intent(in)  :: mp
 logical, intent(out) :: fExit
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: j0
 integer :: ibs, ibe
 logical :: TEOut, isOut, ieOut, jeOut
 ! 処理開始 ********************************************************************************************
 ! ξ方向 ----------------------------------------------------------------------------------------------
! j0 = Flw(1)%js
 j0 = Flw(2)%js
 ! T.E. 通過
! ibs = Flw(1)%i1 + 1; ibe = Flw(1)%i3 - 1
! TEOut = xp > maxval( Flw(1)%x(ibs:ibe, j0, :) )
 ibs = Flw(2)%i1 + 1; ibe = Flw(2)%i3 - 1
 TEOut = xp > maxval( Flw(2)%x(ibs:ibe, j0, :) )
 ! 計算領域
 isOut = ip <  Flw(mp)%is + 1 .and. uxp < 0.0
 ieOut = ip >= Flw(mp)%ie - 1 .and. uxp > 0.0
 ! 流出判定
 if( TEOut .or. isOut .or. ieOut ) then
   fExit = .true.
   return
  else
   fExit = .false.
 endif
 ! η方向 ----------------------------------------------------------------------------------------------
 jeOut = jp >= Flw(mp)%je - 1 .and. vep > 0.0
 ! 流出判定
 if( jeOut ) then
   fExit = .true.
   return
  else
   fExit = .false.
 endif
 ! 処理終了 ********************************************************************************************
 return
end subroutine BoundaryOutlet
!*******************************************************************************************************
!******** 衝突面積計算										********
!*******************************************************************************************************
subroutine CalImpingementArea
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: m
 integer :: j0
 ! 処理開始 ********************************************************************************************
! do m = ms, me
 m = me
  j0 = Flw(m)%js
  ! 衝突面積
  call ImpingementArea3D( &
  &      Ice(m)%is, Ice(m)%ie, Flw(m)%ks, Flw(m)%ke, &
  &      Flw(m)%x(Ice(m)%is:Ice(m)%ie, j0, :), &
  &      Flw(m)%y(Ice(m)%is:Ice(m)%ie, j0, :), &
  &      Flw(m)%z(Ice(m)%is:Ice(m)%ie, j0, :), &
  &      Flw(m)%simp )
  ! ファイル出力
  if( nDrop == 0 ) then
    call Output_ArrayReal2D( &
    &      trim(DrpImpDir) // trim(BlkName(m)) // trim(DrpImpiAreaFile), strbin, &
    &      Ice(m)%is, Ice(m)%ie, Flw(m)%ks, Flw(m)%ke, Flw(m)%simp * lRef**2 )
  endif
! enddo
 ! 処理終了 ********************************************************************************************
 return
end subroutine CalImpingementArea
!*******************************************************************************************************
!******** 収集効率計算										********
!*******************************************************************************************************
subroutine CalCollectionEfficiency
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real   , pointer :: ui(:, :), vi(:, :), wi(:, :)
 integer   :: m
 integer   :: j0
 character :: fname * 20
 ! 処理開始 ********************************************************************************************
 write(fname, '(a, 2(i2.2,a))') 'IceStep', IceStep, 'of', IceStepMax, '_'
 ! 計算ログ出力 ----------------------------------------------------------------------------------------
 call Output_CalSetting( trim(ND_CalSetFile) // strtxt )
 ! 衝突速度及び収集効率 --------------------------------------------------------------------------------
! do m = ms, me
 m = me
  ! 初期設定
  allocate( ui(Ice(m)%is:Ice(m)%ie, Flw(m)%ks:Flw(m)%ke), &
  &         vi(Ice(m)%is:Ice(m)%ie, Flw(m)%ks:Flw(m)%ke), &
  &         wi(Ice(m)%is:Ice(m)%ie, Flw(m)%ks:Flw(m)%ke) )
  ui(:, :) = Flw(m)%uimp(:, :)
  vi(:, :) = Flw(m)%vimp(:, :)
  wi(:, :) = Flw(m)%wimp(:, :)
  ! 衝突速度
  call ImpingementVelocity3D( &
  &      Ice(m)%is, Ice(m)%ie, Flw(m)%ks, Flw(m)%ke, Flw(m)%nimp, &
  &      ui, vi, wi )
  ! 収集効率
  call CollectionEfficiency3D( &
  &      Ice(m)%is, Ice(m)%ie, Flw(m)%ks, Flw(m)%ke, &
  &      nDrop, MVD, LWC, Rhod, DrpInArea, DrpInVel, &
  &      Flw(m)%nimp, Flw(m)%simp, Flw(m)%ImpMass, Flw(m)%CE )
  ! ファイル出力
  call Output_Impingement3D( &
  &      trim(DrpImpDir) // trim(BlkName(m)) // trim(ND_DrpImpiDataFile), strbin, &
  &      Ice(m)%is, Ice(m)%ie, Flw(m)%ks, Flw(m)%ke, &
  &      Flw(m)%nimp, Flw(m)%uimp, Flw(m)%vimp, Flw(m)%wimp )
  call Output_CollectionEfficiency3D( &
  &      trim(DrpimpDir) // trim(BlkName(m)) // trim(CollectionFile), strbin, &
  &      Ice(m)%is, Ice(m)%ie, Flw(m)%ks, Flw(m)%ke, &
  &      Flw(m)%CE * aRef / lRef**3, ui * aRef, vi * aRef, wi * aRef )
  call Output_Impingement3D( &
  &      trim(DrpImpDir) // trim(fname) // trim(BlkName(m)) // trim(ND_DrpImpiDataFile), strbin, &
  &      Ice(m)%is, Ice(m)%ie, Flw(m)%ks, Flw(m)%ke, &
  &      Flw(m)%nimp, Flw(m)%uimp, Flw(m)%vimp, Flw(m)%wimp )
  call Output_CollectionEfficiency3D( &
  &      trim(DrpimpDir) // trim(fname) // trim(BlkName(m)) // trim(CollectionFile), strbin, &
  &      Ice(m)%is, Ice(m)%ie, Flw(m)%ks, Flw(m)%ke, &
  &      Flw(m)%CE * aRef / lRef**3, ui * aRef, vi * aRef, wi * aRef )
  ! メモリ解法
  deallocate( ui, vi, wi )
! enddo
 ! 処理終了 ********************************************************************************************
 return
end subroutine CalCollectionEfficiency
!*******************************************************************************************************
!******** 液滴軌道可視化ファイル出力								********
!*******************************************************************************************************
subroutine OutputViewFile
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer   :: n
 character :: fname * 20
 ! 処理開始 ********************************************************************************************
! do n = 1, nDrpFile
!  write(fname, '(a,i5.5,a)') 'Drop', n, '_'
!  call MakeMAVSFileDroplet3D( &
!  &      trim(DrpTraDir), trim(fname) // trim(DrpTrajectoryFile), strfld, &
!  &      lRef, aRef, Drp(n)%step, &
!  &      Drp(n)%x(1:Drp(n)%step), Drp(n)%y(1:Drp(n)%step), Drp(n)%z(1:Drp(n)%step), &
!  &      Drp(n)%u(1:Drp(n)%step), Drp(n)%v(1:Drp(n)%step), Drp(n)%w(1:Drp(n)%step) )
! enddo
 do n = 1, nDrpFile
  write(fname, '(a,i5.5,a)') 'Drop', n, '_'
   call MakeMAVSFileDropletWe3D( &
  &      trim(DrpTradir), trim(fname) // trim(DrpTrajectoryFile), strfld, &
  &      Drp(n)%step, lRef, Drp(n)%x(1:Drp(n)%step), Drp(n)%y(1:Drp(n)%step), Drp(n)%z(1:Drp(n)%step), &
  &      Drp(n)%cd(1:Drp(n)%step) )
 enddo
 ! 処理終了 ********************************************************************************************
 return
end subroutine OutputViewFile
!*******************************************************************************************************
!******** SLD現象の可視化ファイル								********
!*******************************************************************************************************
subroutine ViewSLDPhenomena(n)
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer  , intent(in) :: n
 character :: fname * 20
 ! 処理開始 ********************************************************************************************
 if(fSplash .and. fBounce) then
!   write(fname, '(a,i5.5,a)') 'SLD', nDrpSpl + nDrpBou, '_'
!   call MakeMAVSFileSLD3D( &
!   &      trim(DrpTraDir), trim(fname) // trim(DrpTrajectoryFile), strfld, &
!   &      lRef, aRef, Drp(n)%step, &
!   &      Drp(n)%x(1:Drp(n)%step), Drp(n)%y(1:Drp(n)%step), Drp(n)%z(1:Drp(n)%step), &
!   &      Drp(n)%mr(1:Drp(n)%step) )
  else if(fSplash) then
   write(fname, '(a,i5.5,a)') 'Splash', nDrpSpl, '_'
   call MakeMAVSFileSLD3D( &
   &      trim(DrpTraDir), trim(fname) // trim(DrpTrajectoryFile), strfld, &
   &      lRef, aRef, Drp(n)%step, &
   &      Drp(n)%x(1:Drp(n)%step), Drp(n)%y(1:Drp(n)%step), Drp(n)%z(1:Drp(n)%step), &
   &      Drp(n)%mr(1:Drp(n)%step) )
  else
!   write(fname, '(a,i5.5,a)') 'Bounce', nDrpBou, '_'
!   call MakeMAVSFileDroplet3D( &
!   &      trim(DrpTraDir), trim(fname) // trim(DrpTrajectoryFile), strfld, &
!   &      lRef, aRef, Drp(n)%step, &
!   &      Drp(n)%x(1:Drp(n)%step), Drp(n)%y(1:Drp(n)%step), Drp(n)%z(1:Drp(n)%step), &
!   &      Drp(n)%u(1:Drp(n)%step), Drp(n)%v(1:Drp(n)%step), Drp(n)%w(1:Drp(n)%step) )
 endif
 ! 処理終了 ********************************************************************************************
 return
end subroutine ViewSLDPhenomena
!*******************************************************************************************************
!******** メモリ解放										********
!*******************************************************************************************************
subroutine Deallocating
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: m
 ! 処理開始 ********************************************************************************************
! do m = ms, me
 m = me
  deallocate( Flw(m)%x, Flw(m)%y, Flw(m)%z, &
  &           Flw(m)%rho, Flw(m)%u, Flw(m)%v, Flw(m)%w, Flw(m)%mu, &
  &           Flw(m)%xix, Flw(m)%xiy, Flw(m)%xiz, &
  &           Flw(m)%etx, Flw(m)%ety, Flw(m)%etz, &
  &           Flw(m)%zex, Flw(m)%zey, Flw(m)%zez, &
  &           Flw(m)%nimp, Flw(m)%uimp, Flw(m)%vimp, Flw(m)%wimp, Flw(m)%CE )
  deallocate( Drp(m)%m, Drp(m)%x, Drp(m)%y, Drp(m)%z, Drp(m)%u, Drp(m)%v, Drp(m)%w, &
  &           Drp(m)%mr, Drp(m)%Cd, Drp(m)%AsRatio )
! enddo
 ! 処理終了 ********************************************************************************************
 return
end subroutine Deallocating
! 定義終了 *********************************************************************************************
end program DropletTrajectory_NACA
```

## file "Flow_Field_NACA.f90"

```fortran
!*******************************************************************************************************
!*******************************************************************************************************
!******** 流れ場計算プログラム                                                                        ********
!******** (NACA翼，三次元圧縮性乱流場，重合格子法，高レイノルズ数型 k-eモデル)                          ********
!********                                              2012.02.02  PROGRAMMED BY RYOSUKE HAYASHI ********
!********                                              2013.07.18     UPDATED BY RYOSUKE HAYASHI ********
!********                                              2014.04.15     UPDATED BY RYOSUKE HAYASHI ********
!*******************************************************************************************************
!*******************************************************************************************************
program FlowField_NACA
   ! モジュール宣言 **************************************************************************************
   use Package_NACA
   use Package_FileIO
   use Package_Flow
   use Package_Icing
   ! 変数宣言 ********************************************************************************************
   implicit none
   ! ファイル名設定 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   character, parameter :: ResidualFile*8 = 'Residual'
   ! 処理開始 ********************************************************************************************
   ! 検証実験ケース選択 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   write (*, '(a)') "<< Exp. Case Selecation >>"
   call SelectExpCase
   ! 初期設定 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   write (*, '(/,a)') "<< Initial Setting >>"
   call InitialSetting
   ! 流れ場計算 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   write (*, '(/,a)') "<< Flow Field Computation >>"
   call CalFlowField
   ! メモリ解法 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   write (*, '(/,a)') "<< Computation Finallized >>"
   call Deallocating
   ! 内部手続き ******************************************************************************************
   stop
contains
!*******************************************************************************************************
!******** 検証実験ケース選択                                                                         ********
!*******************************************************************************************************
   subroutine SelectExpCase
      ! 変数宣言 ********************************************************************************************
      implicit none
      character :: fname*20
      ! 処理開始 ********************************************************************************************
      ! 計算条件ファイル入力
      call Input_CalSetting(trim(ND_CalSetFile)//strtxt)
      ! ディレクトリ設定
      if (IceStep == 0) then
         GrdInDir = bckdir//'grid//clean//'
         OSGDir = bckdir//'overset//clean//'
         FlwIniDir = bckdir//'flow//initial//clean//'
         FlwCalInDir = bckdir//'flow//cal//clean//'
         FlwCalOutDir = bckdir//'flow//cal//clean//'
      else
         GrdInDir = bckdir//'grid//icing//'
         OSGDir = bckdir//'overset//icing//'
         FlwIniDir = bckdir//'flow//initial//icing//'
         FlwCalInDir = bckdir//'flow//cal//icing//'
         FlwCalOutDir = bckdir//'flow//cal//icing//'
         IceCalInDir = bckdir//'icing//cal//'
      end if
      write (*, '(a)') '+++ Icing Step +++'
      write (*, '(a,i2)') '* Ice step      = ', IceStep
      write (*, '(a,i2)') '* Ice step max. = ', IceStepMax
      write (*, '(/,a)') '+++ Exp. Condition +++'
      write (*, '(a,e16.8e3)') '* Ts    = ', TsExp*aRef**2
      write (*, '(a,e16.8e3)') '* Ps    = ', PsExp*(rhoRef*aRef**2)
      write (*, '(a,e16.8e3)') '* V     = ', VelExp*aRef
      write (*, '(a,e16.8e3)') '* LWC   = ', LWC*RhoRef
      write (*, '(a,e16.8e3)') '* MVD   = ', MVD*LRef
      write (*, '(a,e16.8e3)') '* Rho   = ', Rhod*RhoRef
      write (*, '(a,e16.8e3)') '* Chord = ', Chord*LRef
      write (*, '(a,e16.8e3)') '* AOA   = ', AOA*180.0/pi
      ! 処理終了 ********************************************************************************************
      return
   end subroutine SelectExpCase
!*******************************************************************************************************
!******** 初期設定                                                                                ********
!*******************************************************************************************************
   subroutine InitialSetting
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 局所定数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer, parameter :: nSmooth = 100
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer   :: m, n
      integer        :: j
      character :: fname*30
      ! 処理開始 ********************************************************************************************
      ! 構造体メモリ確保 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! allocate( Flw(ms:me), OSG(ms:me) )
      allocate (Flw(ms:me))
      ! ブロック名設定 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      call Set_BlockName
      ! 格子解像度 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! do m = ms, me
      m = me
      call Input_Resolution3D( &
      &      trim(GrdInDir)//trim(BlkName(m))//trim(RslFile), strtxt, &
      &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke)
! enddo
      ! メモリ確保 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! do m = ms, me
      m = me
      allocate (Flw(m)%x(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke), &
      &         Flw(m)%y(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke), &
      &         Flw(m)%z(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke), &
      &         Flw(m)%rho(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke), &
      &         Flw(m)%u(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke), &
      &         Flw(m)%v(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke), &
      &         Flw(m)%w(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke), &
      &         Flw(m)%p(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke), &
      &         Flw(m)%t(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke), &
      &         Flw(m)%mu(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke), &
      &         Flw(m)%kin(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke), &
      &         Flw(m)%eps(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke), &
      &         Flw(m)%mut(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke), &
      &         Flw(m)%xix(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke), &
      &         Flw(m)%xiy(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke), &
      &         Flw(m)%xiz(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke), &
      &         Flw(m)%etx(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke), &
      &         Flw(m)%ety(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke), &
      &         Flw(m)%etz(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke), &
      &         Flw(m)%zex(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke), &
      &         Flw(m)%zey(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke), &
      &         Flw(m)%zez(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke), &
      &         Flw(m)%jac(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke), &
      &         Flw(m)%qh(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke, ls:le), &
      &         Flw(m)%qh0(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke, ls:le), &
      &         Flw(m)%dqh(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke, ls:le), &
      &         Flw(m)%dqh0(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke, ls:le), &
      &         Flw(m)%dqc(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke, ls:le), &
      &         Flw(m)%dqd(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke, ls:le), &
      &         Flw(m)%dqp(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke, ls:le), &
      &         Flw(m)%dqr(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke, ls:le), &
      &         Flw(m)%dt(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke), &
      &         Flw(m)%Res(ls:le))
! enddo
      ! 格子座標 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! do m = ms, me
      m = me
      call Input_Grid3D( &
      &      trim(FlwIniDir)//trim(BlkName(m))//trim(ND_GrdFile), strbin, &
      &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, &
      &      Flw(m)%x, Flw(m)%y, Flw(m)%z)
! enddo
      ! メトリックス ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! do m = ms, me
      m = me
      call Input_Metrics3D( &
      &      trim(FlwIniDir)//trim(BlkName(m))//trim(ND_MetFile), strbin, &
      &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, &
      &      Flw(m)%jac, &
      &      Flw(m)%xix, Flw(m)%xiy, Flw(m)%xiz, &
      &      Flw(m)%etx, Flw(m)%ety, Flw(m)%etz, &
      &      Flw(m)%zex, Flw(m)%zey, Flw(m)%zez)
! enddo
      ! 流束関数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      nStart = nCount; time = 0.0
      if (nCount == 0) then
!   do m = ms, me
         m = me
         call Input_Flux3D( &
         &      trim(FlwIniDir)//trim(BlkName(m))//trim(ND_IniFlxFile), strbin, &
         &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, &
         &      ls, le, Flw(m)%qh)
!   enddo
      else
!   do m = ms, me
         m = me
         call Input_Flux3D( &
         &      trim(FlwCalInDir)//trim(BlkName(m))//trim(ND_FlxFile), strbin, &
         &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, &
         &      ls, le, Flw(m)%qh)
!   enddo
      end if
      ! 物理量 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! do m = ms, me
      m = me
      call SetPhysics3DKEM( &
      &      Rg, gamma, &
      &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, ls, le, &
      &      Flw(m)%qh, Flw(m)%jac, &
      &      Flw(m)%rho, Flw(m)%u, Flw(m)%v, Flw(m)%w, Flw(m)%p, Flw(m)%t, Flw(m)%kin, Flw(m)%eps)
! enddo
      ! C 型格子分割点 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! do m = ms, me
      m = me
      call Input_CtypeGridPoint( &
      &      trim(GrdInDir)//trim(BlkName(m))//trim(CtypePointFile)//strtxt, &
      &      Flw(m)%i1, Flw(m)%i2, Flw(m)%i3)
! end do
      ! 重合格子補間係数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! do m = ms, me
!  ! 補間探索範囲 ---------------------------------------------------------------------------------------
!  call Input_Resolution3D( &
!  &      trim(OSGDir) // trim(BlkName(m)) // trim(OverAreaFile), strtxt, &
!  &      OSG(m)%is, OSG(m)%ie, OSG(m)%js, OSG(m)%je, OSG(m)%ks, OSG(m)%ke )
!  ! メモリ確保 -----------------------------------------------------------------------------------------
!  allocate( OSG(m)%ip   ( OSG(m)%is: OSG(m)%ie, OSG(m)%js: OSG(m)%je, OSG(m)%ks: OSG(m)%ke ), &
!  &         OSG(m)%jp   ( OSG(m)%is: OSG(m)%ie, OSG(m)%js: OSG(m)%je, OSG(m)%ks: OSG(m)%ke ), &
!  &         OSG(m)%kp   ( OSG(m)%is: OSG(m)%ie, OSG(m)%js: OSG(m)%je, OSG(m)%ks: OSG(m)%ke ), &
!  &         OSG(m)%fOver( OSG(m)%is: OSG(m)%ie, OSG(m)%js: OSG(m)%je, OSG(m)%ks: OSG(m)%ke ), &
!  &         OSG(m)%term1( OSG(m)%is: OSG(m)%ie, OSG(m)%js: OSG(m)%je, OSG(m)%ks: OSG(m)%ke ), &
!  &         OSG(m)%term2( OSG(m)%is: OSG(m)%ie, OSG(m)%js: OSG(m)%je, OSG(m)%ks: OSG(m)%ke ), &
!  &         OSG(m)%term3( OSG(m)%is: OSG(m)%ie, OSG(m)%js: OSG(m)%je, OSG(m)%ks: OSG(m)%ke ), &
!  &         OSG(m)%term4( OSG(m)%is: OSG(m)%ie, OSG(m)%js: OSG(m)%je, OSG(m)%ks: OSG(m)%ke ), &
!  &         OSG(m)%term5( OSG(m)%is: OSG(m)%ie, OSG(m)%js: OSG(m)%je, OSG(m)%ks: OSG(m)%ke ), &
!  &         OSG(m)%term6( OSG(m)%is: OSG(m)%ie, OSG(m)%js: OSG(m)%je, OSG(m)%ks: OSG(m)%ke ), &
!  &         OSG(m)%term7( OSG(m)%is: OSG(m)%ie, OSG(m)%js: OSG(m)%je, OSG(m)%ks: OSG(m)%ke ), &
!  &         OSG(m)%term8( OSG(m)%is: OSG(m)%ie, OSG(m)%js: OSG(m)%je, OSG(m)%ks: OSG(m)%ke ) )
!  ! 補間係数 -------------------------------------------------------------------------------------------
!  call Input_OversetCoe3D( &
!  &      trim(OSGDir) // trim(BlkName(m)) // trim(OverCoeFile), strbin, &
!  &      OSG(m)%is, OSG(m)%ie, OSG(m)%js, OSG(m)%je, OSG(m)%ks, OSG(m)%ke, &
!  &      OSG(m)%fOver, OSG(m)%ip, OSG(m)%jp, OSG(m)%kp, &
!  &      OSG(m)%term1, OSG(m)%term2, OSG(m)%term3, OSG(m)%term4, &
!  &      OSG(m)%term5, OSG(m)%term6, OSG(m)%term7, OSG(m)%term8 )
! enddo
      ! 計算除去点 (氷の中の点) +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! m = 1
! allocate( IceIn( Flw(m)%is: Flw(m)%ie, Flw(m)%js: Flw(m)%je, Flw(m)%ks: Flw(m)%ke ) )
! if( IceStep == 0 ) then
!   IceIn(:, :, :) = 0
!  else
!   call Input_ArrayInt3D( &
!   &      trim(OSGDir) // trim(BlkName(m)) // trim(IceInPointFile), strbin, &
!   &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, &
!   &      IceIn )
!   IceIn(:, :, :) = 0
! endif
      ! スムージング ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      if (IceStep /= 0) then
         do n = 1, nSmooth
!   do m = ms, me
            m = me
            call SmoothingFlux3D( &
            &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, ls, le, &
            &      Flw(m)%jac, Flw(m)%qh)
!   enddo
!   call InterpolationOversetGrid
         end do
      end if
      ! 粗さのフラグ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! m = 1
      m = me
      allocate (Flw(m)%fRough(Flw(m)%is:Flw(m)%ie, Flw(m)%ks:Flw(m)%ke))
      Flw(m)%fRough(:, :) = 0
      m = 2
      allocate (Flw(m)%fRough(Flw(m)%is:Flw(m)%ie, Flw(m)%ks:Flw(m)%ke), &
      &         Flw(m)%RH(Flw(m)%is:Flw(m)%ie, Flw(m)%ks:Flw(m)%ke))
      if (IceStep > 0) then
         call Input_ArrayInt2D( &
         &      trim(IceCalInDir)//trim(BlkName(m))//trim(RoughFlagFile), strdat, &
         &      Flw(m)%is, Flw(m)%ie, Flw(m)%ks, Flw(m)%ke, &
         &      Flw(m)%fRough)
      else
         Flw(m)%fRough(:, :) = 0
      end if
      ! 処理終了 ********************************************************************************************
      return
   end subroutine InitialSetting
!*******************************************************************************************************
!******** 流れ場計算                                                                                 ********
!*******************************************************************************************************
   subroutine CalFlowField
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 局所定数 ********************************************************************************************
      real, parameter :: dtMax = 1.0e0
      real, parameter :: dtMin = 1.0e-20
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer :: m, nn
      integer        :: i
      integer :: nCompCount
      real    :: dt, dtTmp
      real    :: RK(1:nRunge)
      logical :: fOutputCount, fOutputLog
      integer   :: fnum = 0
      character :: num*4
      character :: fstep*2
      character :: fdir*100
      character :: fn*100
      ! 処理開始 ********************************************************************************************
      write (*, '(a)') '+++ Computational loop start +++'
      ! 初期設定 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! 収束判定ファイル出力 --------------------------------------------------------------------------------
      open (20, file=trim(FlwCalOutDir)//trim(BlkName(1))//trim(ResidualFile)//strtxt)
      open (21, file=trim(FlwCalOutDir)//trim(BlkName(2))//trim(ResidualFile)//strtxt)
      ! 流れ場計算ループ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      if (IceStep == 0) then
         nCompCount = nCalMax !* 2.0
      else
         nCompCount = nCalMax
      end if
      do nCount = nStart, nCompCount
         ! 時間刻み幅 -----------------------------------------------------------------------------------------
!  do m = ms, me
         m = me
         ! 局所時間刻み
         call CalLocalDt3D( &
         &      cn, Rg, gamma, &
         &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, &
         &      Flw(m)%xix, Flw(m)%xiy, Flw(m)%xiz, &
         &      Flw(m)%etx, Flw(m)%ety, Flw(m)%etz, &
         &      Flw(m)%zex, Flw(m)%zey, Flw(m)%zez, &
         &      Flw(m)%rho, Flw(m)%u, Flw(m)%v, Flw(m)%w, Flw(m)%t, Flw(m)%mu, &
         &      Flw(m)%dt)
!  enddo
         ! 非定常計算 -----------------------------------------------------------------------------------------
         if (.not. fSteady) then
            dt = dtMax
!    do m = ms, me
            m = me
            dt = min(minval(Flw(m)%dt(:, :, :)), dt)
!    enddo
!    do m = ms, me
            Flw(m)%dt(:, :, :) = dt
!    enddo
         end if
         ! 過去の流束を保存 -----------------------------------------------------------------------------------
!  do m = ms, me
         m = me
         call SaveFlux3DKEM( &
         &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, ls, le, &
         &      Flw(m)%qh, Flw(m)%dqh, Flw(m)%qh0, Flw(m)%dqh0)
!  enddo
         ! 内部反復 -------------------------------------------------------------------------------------------
         do nn = 1, nRunge
!   do m = ms, me
            m = me
            ! 粘性係数
            call ViscosityCoefficient3D( &
            &      muSth, TsSth, s1, &
            &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, &
            &      Flw(m)%t, &
            &      Flw(m)%mu)
            ! 対流項
            call Convection3D( &
            &      nTVD, eTVD, Rg, gamma, &
            &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, ls, le, &
            &      Flw(m)%xix, Flw(m)%xiy, Flw(m)%xiz, &
            &      Flw(m)%etx, Flw(m)%ety, Flw(m)%etz, &
            &      Flw(m)%zex, Flw(m)%zey, Flw(m)%zez, &
            &      Flw(m)%jac, Flw(m)%qh, &
            &      Flw(m)%u, Flw(m)%v, Flw(m)%w, Flw(m)%p, Flw(m)%t, &
            &      Flw(m)%dqc)
            ! 拡散項 & 生産項
            select case (TurbNum)
               ! 層流
            case (0)
               call Viscosity3D( &
               &      Rg, gamma, Pr, &
               &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, ls, le, &
               &      Flw(m)%xix, Flw(m)%xiy, Flw(m)%xiz, &
               &      Flw(m)%etx, Flw(m)%ety, Flw(m)%etz, &
               &      Flw(m)%zex, Flw(m)%zey, Flw(m)%zez, &
               &      Flw(m)%jac, Flw(m)%qh, &
               &      Flw(m)%u, Flw(m)%v, Flw(m)%w, Flw(m)%t, Flw(m)%mu, &
               &      Flw(m)%dqd &
               &          )
               Flw(m)%dqp(:, :, :, :) = 0.0
               ! Launder-Spalding
            case (1)
               call Turbulence3DEvmStd( &
               &             LmtPro, Rg, gamma, Pr, Prt, &
               &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, ls, le, &
               &      Flw(m)%xix, Flw(m)%xiy, Flw(m)%xiz, &
               &      Flw(m)%etx, Flw(m)%ety, Flw(m)%etz, &
               &      Flw(m)%zex, Flw(m)%zey, Flw(m)%zez, &
               &      Flw(m)%jac, Flw(m)%qh, &
               &      Flw(m)%u, Flw(m)%v, Flw(m)%w, Flw(m)%t, Flw(m)%kin, Flw(m)%eps, Flw(m)%mu, &
               &      Flw(m)%mut, Flw(m)%dqd, Flw(m)%dqp)
               ! Kato-Launder
            case (2)
               call Turbulence3DEvmStdKL( &
               &             LmtPro, Rg, gamma, Pr, Prt, &
               &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, ls, le, &
               &      Flw(m)%xix, Flw(m)%xiy, Flw(m)%xiz, &
               &      Flw(m)%etx, Flw(m)%ety, Flw(m)%etz, &
               &      Flw(m)%zex, Flw(m)%zey, Flw(m)%zez, &
               &      Flw(m)%jac, Flw(m)%qh, &
               &      Flw(m)%u, Flw(m)%v, Flw(m)%w, Flw(m)%t, Flw(m)%kin, Flw(m)%eps, Flw(m)%mu, &
               &      Flw(m)%mut, Flw(m)%dqd, Flw(m)%dqp)
               ! Launder-Sharma
            case (3)
               call Turbulence3DEvmLS( &
               &             LmtPro, Rg, gamma, Pr, Prt, &
               &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, ls, le, &
               &      Flw(m)%xix, Flw(m)%xiy, Flw(m)%xiz, &
               &      Flw(m)%etx, Flw(m)%ety, Flw(m)%etz, &
               &      Flw(m)%zex, Flw(m)%zey, Flw(m)%zez, &
               &      Flw(m)%jac, &
               &      Flw(m)%rho, Flw(m)%u, Flw(m)%v, Flw(m)%w, Flw(m)%t, Flw(m)%kin, Flw(m)%eps, Flw(m)%mu, &
               &      Flw(m)%mut, Flw(m)%dqd, Flw(m)%dqp)
               ! AKN k-e
            case (4)
               call Turbulence3DEvmAKN( &
               &             LmtPro, Rg, gamma, Pr, Prt, &
               &      Flw(m)%is, Flw(m)%ie, Flw(m)%i1, Flw(m)%i3, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, ls, le, &
               &      Flw(m)%x, Flw(m)%y, Flw(m)%z, &
               &      Flw(m)%xix, Flw(m)%xiy, Flw(m)%xiz, &
               &      Flw(m)%etx, Flw(m)%ety, Flw(m)%etz, &
               &      Flw(m)%zex, Flw(m)%zey, Flw(m)%zez, &
               &      Flw(m)%jac, &
               &      Flw(m)%rho, Flw(m)%u, Flw(m)%v, Flw(m)%w, Flw(m)%t, Flw(m)%kin, Flw(m)%eps, Flw(m)%mu, &
               &      Flw(m)%mut, Flw(m)%dqd, Flw(m)%dqp)
            case default; write (*, '(a)') '!!!!! Error : TurbNum !!!!!'
            end select
            ! 外力項
            Flw(m)%dqr(:, :, :, :) = 0.0
            ! 各項の和
            call SumDQH3D( &
            &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, ls, le, &
            &      Flw(m)%dqc, Flw(m)%dqd, Flw(m)%dqp, Flw(m)%dqr, &
            &      Flw(m)%dqh)
            ! 未来の流束
            if (fTime) then
               call RungeKutta3D( &
               &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, ls, le, &
               &      nn, nRunge, Flw(m)%dt, &
               &      Flw(m)%dqh, Flw(m)%qh0, Flw(m)%qh)
            else
               call LUADI3D( &
               &      0.5, rg, gamma, &
               &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, ls, le, &
               &      Flw(m)%xix, Flw(m)%xiy, Flw(m)%xiz, &
               &      Flw(m)%etx, Flw(m)%ety, Flw(m)%etz, &
               &      Flw(m)%zex, Flw(m)%zey, Flw(m)%zez, &
               &      Flw(m)%jac, &
               &      Flw(m)%rho, Flw(m)%u, Flw(m)%v, Flw(m)%w, Flw(m)%t, Flw(m)%mu + Flw(m)%mut, &
               &      Flw(m)%dt, &
               &      Flw(m)%dqh0, Flw(m)%dqh, Flw(m)%qh0, Flw(m)%qh)
            end if
            ! 乱流量のリミッター
            if (LmtAve /= 0.0) then
               call Limiter3DKEM( &
               &      LmtAve, &
               &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, ls, le, &
               &      Flw(m)%jac, &
               &      Flw(m)%qh)
            end if
!   enddo
            ! 境界条件
            call BoundaryCondition
!   ! 重合格子の補間
!   call InterpolationOversetGrid
            ! 物理量
!   do m = ms, me
            call SetPhysics3DKEM( &
            &      Rg, gamma, &
            &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, ls, le, &
            &      Flw(m)%qh, Flw(m)%jac, &
            &      Flw(m)%rho, Flw(m)%u, Flw(m)%v, Flw(m)%w, Flw(m)%p, Flw(m)%t, Flw(m)%kin, Flw(m)%eps)
!   enddo
         end do
         ! 経過時間 -------------------------------------------------------------------------------------------
         if (.not. fSteady) then
            time = time + dt
         end if
         ! ファイル出力 ---------------------------------------------------------------------------------------
         fOutputCount = mod(nCount, nOutputCount) .eq. 0.0 .or. nCount == nCompCount
         fOutputLog = mod(nCount, nOutputLog) .eq. 0.0 .or. nCount == nCompCount
         if (fOutputLog .or. fOutputCount) then
            if (nCount == nStart) then
               write (*, '(a)') '+++ Numerical Condition +++'
               write (*, '(a,e10.4e1)') '* Cn                  = ', Cn
               write (*, '(a,i2)') '* TVD Order           = ', nTVD
               write (*, '(a,e10.4e1)') '* TVD Entropy         = ', eTVD
               write (*, '(a,e10.4e1)') '* Limitter k-e Ave    = ', LmtAve
               write (*, '(a,e10.4e1)') '* Limitter k-e Pro    = ', LmtPro
               write (*, '(a,i7)') '* Computational Count = ', nCompCount
            end if
            if (fOutputLog) then
               call CalResidual
            end if
            if (fOutputCount) call OutputFileCount
            write (*, '(a)') '+++ Calculation progress +++'
            write (*, '(a,i6,a)') '* Calculation Count = ', nCount
            if (fSteady) then
!      write(*, '(a,e16.8e3)') '* Main Min. dt = ', minval(Flw(1)%dt(:,:,:))
!      write(*, '(a,e16.8e3)') '* Main Max. dt = ', maxval(Flw(1)%dt(:,:,:))
               write (*, '(a,e16.8e3)') '* Sub  Min. dt = ', minval(Flw(2)%dt(:, :, :))
               write (*, '(a,e16.8e3)') '* Sub  Max. dt = ', maxval(Flw(2)%dt(:, :, :))
            else
               write (*, '(a,e16.8e3)') '* Calculation time  = ', time
               write (*, '(a,e16.8e3)') '* Calculation dt    = ', dt
            end if

            fnum = fnum + 1
            write (num, '(I4.4)') fnum
            write (fstep, '(I2.2)') IceStep
!   do m = ms, me
            m = me
            write (*, *) 'Output File : ', trim(BlkName(m))//'Flow'//trim(num)
            if (IceStep .eq. 0) then
               fdir = bckdir//'flow//view//clean//overtime//'
            else
               fdir = bckdir//'flow//view//icing//overtime//'
            end if

!    !ParaViewファイル出力
!    fn = trim(BlkName(m)) // 'Flow' // trim(fstep) // '_' // trim(num)
!    call OutputPara_bin( &
!       &      trim(fdir), trim(fn), &
!       &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, &
!       &      rhoRef, aRef, lRef, &
!       &      Flw(m)%rho, Flw(m)%u, Flw(m)%v, Flw(m)%w, Flw(m)%p, Flw(m)%t, Flw(m)%mu, &
!       &      Flw(m)%kin, Flw(m)%eps, Flw(m)%mut, &
!       &      Flw(m)%x, Flw(m)%y, Flw(m)%z )

            if (m .eq. me) then
               call calyplus(m)
            end if
!   end do

         end if
      end do
      close (20); close (21); close (22)
      ! 処理終了 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      return
   end subroutine CalFlowField
!*******************************************************************************************************
!******** 境界条件                                                                                 ********
!*******************************************************************************************************
   subroutine BoundaryCondition
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 局所定数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer :: i, j, k, l, m
      ! 処理開始 ********************************************************************************************
      ! Main Grid, Sub Grid++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! do m = ms,me
      m = me
      ! 流入境界 --------------------------------------------------------------------------------------------
      call BoundaryInlet( &
      &      m, Flw(m)%is + 1, Flw(m)%ie - 1, Flw(m)%ks + 1, Flw(m)%ke - 1, &
      &      Flw(m)%je - 0, Flw(m)%je - 1)
      ! C 型格子ブランチ・カット ----------------------------------------------------------------------------
      call BoundaryCtypeBranch( &
      &      m, Flw(m)%is + 1, Flw(m)%i1 - 1, Flw(m)%ks + 1, Flw(m)%ke - 1, &
      &      Flw(m)%js + 0, Flw(m)%js + 1, &
      &      Flw(m)%ie)
! call BoundaryCtypeBranch( &
! &      m, Flw(m)%i3 + 1, Flw(m)%ie - 1, Flw(m)%ks + 1, Flw(m)%ke - 1, &
! &      Flw(m)%js + 0, Flw(m)%js + 1, &
! &      Flw(m)%ie )
      ! 翼壁面 ----------------------------------------------------------------------------------------------
      call BoundaryBladeSurface( &
      &      m, Flw(m)%i1 + 0, Flw(m)%i3 - 0, Flw(m)%ks + 1, Flw(m)%ke - 1, &
      &      Flw(m)%js + 0, Flw(m)%js + 1, Flw(m)%js + 2, TurbNum)
      ! 流出境界 --------------------------------------------------------------------------------------------
      call BoundaryOutlet( &
      &      m, Flw(m)%js + 0, Flw(m)%je - 0, Flw(m)%ks + 1, Flw(m)%ke - 1, &
      &      Flw(m)%is + 0, Flw(m)%is + 1)
      call BoundaryOutlet( &
      &      m, Flw(m)%js + 0, Flw(m)%je - 0, Flw(m)%ks + 1, Flw(m)%ke - 1, &
      &      Flw(m)%ie - 0, Flw(m)%ie - 1)
      ! 氷の中の点 ------------------------------------------------------------------------------------------
! call BoundaryIceIn( &
! &      1, 2, Flw(1)%i1, Flw(1)%i3, Flw(1)%js, Flw(1)%je, Flw(1)%ks + 1, Flw(1)%ke - 1, &
! &      Flw(2)%i1, Flw(2)%i2, Flw(2)%js, int(0.5 * Flw(2)%ke) )
      ! 周期境界 --------------------------------------------------------------------------------------------
      call BoundaryPeriodic( &
      &      m, Flw(m)%is + 0, Flw(m)%ie - 0, Flw(m)%js + 0, Flw(m)%je - 0, &
      &      Flw(m)%ks + 0, Flw(m)%ke - 1)
      call BoundaryPeriodic( &
      &      m, Flw(m)%is + 0, Flw(m)%ie - 0, Flw(m)%js + 0, Flw(m)%je - 0, &
      &      Flw(m)%ke - 0, Flw(m)%ks + 1)
! end do
      ! 処理終了 ********************************************************************************************
      return
   end subroutine BoundaryCondition
!*******************************************************************************************************
!******** 流入境界                                                                                ********
!******** ⅰ．密度外挿，その他固定　                        ⅱ．角度・全温・全圧固定，マッハ数外挿        ********
!******** ⅲ．角度・体積流量・全温固定，密度外挿                                                  ********
!*******************************************************************************************************
   subroutine BoundaryInlet( &
   &            m, is, ie, ks, ke, j0, j1)
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer, intent(in) :: m
      integer, intent(in) :: is, ie, ks, ke
      integer, intent(in) :: j0, j1
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer :: i, k, l
      real    :: u, v, w, p, t
      real    :: Tt_Ts, Ts, Ps, mac, vel, rho, kin, eps
      ! 処理開始 ********************************************************************************************
      select case (BCNum)
      case (1)
         do k = ks, ke
         do i = is, ie
            ! 密度外挿
            rho = Flw(m)%qh(i, j1, k, 1)*Flw(m)%jac(i, j1, k)
            ! その他固定
            vel = VelIn
            u = vel*cos(AOA)
            v = vel*sin(AOA)
            w = 0.0
            t = TsExp/aRef**2
            kin = 0.5*3.0*(0.01*vel)**2
            eps = rho*kin**2/(Flw(m)%mu(i, j0, k)*Ret)
            ! 流束関数
            Flw(m)%qh(i, j0, k, 1) = rho/Flw(m)%jac(i, j0, k)
            Flw(m)%qh(i, j0, k, 2) = u*Flw(m)%qh(i, j0, k, 1)
            Flw(m)%qh(i, j0, k, 3) = v*Flw(m)%qh(i, j0, k, 1)
            Flw(m)%qh(i, j0, k, 4) = w*Flw(m)%qh(i, j0, k, 1)
            Flw(m)%qh(i, j0, k, 5) = (Rg*t/(gamma - 1.0) + 0.5*vel**2 + kin)*Flw(m)%qh(i, j0, k, 1)
            Flw(m)%qh(i, j0, k, 6) = kin*Flw(m)%qh(i, j0, k, 1)
            Flw(m)%qh(i, j0, k, 7) = eps*Flw(m)%qh(i, j0, k, 1)
         end do
         end do
      case (2)
         do k = ks, ke
         do i = is, ie
            ! 外挿する速度からマッハ数導出
            u = Flw(m)%qh(i, j1, k, 2)/Flw(m)%qh(i, j1, k, 1)
            v = Flw(m)%qh(i, j1, k, 3)/Flw(m)%qh(i, j1, k, 1)
            w = Flw(m)%qh(i, j1, k, 4)/Flw(m)%qh(i, j1, k, 1)
            p = (Flw(m)%qh(i, j1, k, 5) - Flw(m)%qh(i, j1, k, 6) &
            &     - 0.5*(Flw(m)%qh(i, j1, k, 2)**2 &
            &             + Flw(m)%qh(i, j1, k, 3)**2 &
            &             + Flw(m)%qh(i, j1, k, 4)**2)/Flw(m)%qh(i, j1, k, 1) &
            &   )*(gamma - 1.0)*Flw(m)%jac(i, j1, k)
            t = p/(Flw(m)%qh(i, j1, k, 1)*Flw(m)%jac(i, j1, k)*Rg)
            mac = sqrt(u**2 + v**2 + w**2)/sqrt(gamma*Rg*t)
            ! 外挿するマッハ数と固定する全温・全圧から静温・静圧導出
            Tt_Ts = 1.0 + 0.5*(gamma - 1.0)*mac**2
            Ts = TtIn/Tt_Ts
            Ps = PtIn/Tt_Ts**(gamma/(gamma - 1.0))
            ! その他導出
            rho = Ps/(Rg*Ts)
            vel = mac*sqrt(gamma*Rg*Ts)
            u = vel*cos(AOA)
            v = vel*sin(AOA)
            w = 0.0
            kin = 0.5*3.0*(0.01*vel)**2
            eps = rho*kin**2/(Flw(m)%mu(i, j0, k)*Ret)
            ! 流束関数
            Flw(m)%qh(i, j0, k, 1) = rho/Flw(m)%jac(i, j0, k)
            Flw(m)%qh(i, j0, k, 2) = u*Flw(m)%qh(i, j0, k, 1)
            Flw(m)%qh(i, j0, k, 3) = v*Flw(m)%qh(i, j0, k, 1)
            Flw(m)%qh(i, j0, k, 4) = w*Flw(m)%qh(i, j0, k, 1)
            Flw(m)%qh(i, j0, k, 5) = (Rg*Ts/(gamma - 1.0) + 0.5*vel**2 + kin)*Flw(m)%qh(i, j0, k, 1)
            Flw(m)%qh(i, j0, k, 6) = kin*Flw(m)%qh(i, j0, k, 1)
            Flw(m)%qh(i, j0, k, 7) = eps*Flw(m)%qh(i, j0, k, 1)
         end do
         end do
      case (3)
         do k = ks, ke
         do i = is, ie
            ! 密度外挿
            rho = Flw(m)%qh(i, j1, k, 1)*Flw(m)%jac(i, j1, k)
            ! 体積流量固定
            vel = VelIn
            ! 全温固定
            Ts = TtIn - (gamma - 1.0)/(2.0*gamma*Rg)*vel**2
            Ps = rho*Rg*Ts
            ! 速度から乱流量導出
            kin = 0.5*3.0*(0.01*vel)**2
            eps = rho*kin**2/(Flw(m)%mu(i, j0, k)*Ret)
            ! 流束関数
            Flw(m)%qh(i, j0, k, 1) = rho/Flw(m)%jac(i, j0, k)
            Flw(m)%qh(i, j0, k, 2) = vel*cos(AOA)*Flw(m)%qh(i, j0, k, 1)
            Flw(m)%qh(i, j0, k, 3) = vel*sin(AOA)*Flw(m)%qh(i, j0, k, 1)
            Flw(m)%qh(i, j0, k, 4) = 0.0
            Flw(m)%qh(i, j0, k, 5) = (Rg*Ts/(gamma - 1.0) + 0.5*vel**2 + kin)*Flw(m)%qh(i, j0, k, 1)
            Flw(m)%qh(i, j0, k, 6) = kin*Flw(m)%qh(i, j0, k, 1)
            Flw(m)%qh(i, j0, k, 7) = eps*Flw(m)%qh(i, j0, k, 1)
         end do
         end do
      case default
         write (*, '(a)') '!!!! Error : Inlet boundary condition pattern !!!!'
      end select
      ! 処理終了 ********************************************************************************************
      return
   end subroutine BoundaryInlet
!*******************************************************************************************************
!******** 流出境界                                                                                ********
!*******************************************************************************************************
   subroutine BoundaryOutlet( &
   &            m, js, je, ks, ke, i0, i1)
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer, intent(in) :: m
      integer, intent(in) :: js, je, ks, ke
      integer, intent(in) :: i0, i1
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer :: j, k, l
      real    :: Ts, Ps
      ! 処理開始 ********************************************************************************************
      do k = ks, ke
      do j = js, je
         Ps = (Flw(m)%qh(i1, j, k, 5) - Flw(m)%qh(i1, j, k, 6) &
         &      - 0.5*(Flw(m)%qh(i1, j, k, 2)**2 &
         &              + Flw(m)%qh(i1, j, k, 3)**2 &
         &              + Flw(m)%qh(i1, j, k, 4)**2)/Flw(m)%qh(i1, j, k, 1) &
         &    )*(gamma - 1.0)*Flw(m)%jac(i1, j, k)
         Ts = Ps/(Flw(m)%qh(i1, j, k, 1)*Flw(m)%jac(i1, j, k)*Rg)
         do l = ls + 1, le
            Flw(m)%qh(i0, j, k, l) = Flw(m)%qh(i1, j, k, l)/Flw(m)%qh(i1, j, k, 1)
         end do
         Flw(m)%qh(i0, j, k, 1) = PsOut/(Rg*Ts*Flw(m)%jac(i0, j, k))
         do l = ls + 1, le
            Flw(m)%qh(i0, j, k, l) = Flw(m)%qh(i0, j, k, l)*Flw(m)%qh(i0, j, k, 1)
         end do
      end do
      end do
      ! 処理終了 ********************************************************************************************
      return
   end subroutine BoundaryOutlet
!*******************************************************************************************************
!******** C 型格子ブランチ・カット境界 (平均値外挿)                                                   ********
!*******************************************************************************************************
   subroutine BoundaryCtypeBranch( &
   &            m, is, ie, ks, ke, j0, j1, imax)
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer, intent(in) :: m
      integer, intent(in) :: is, ie, ks, ke
      integer, intent(in) :: j0, j1
      integer, intent(in) :: imax
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer :: i, k, l
      real    :: qAve
      ! 処理開始 ********************************************************************************************
      do l = ls, le
      do k = ks, ke
      do i = is, ie
         qAve = 0.5*(Flw(m)%qh(i, j1, k, l)*Flw(m)%jac(i, j1, k) &
         &            + Flw(m)%qh(imax - i, j1, k, l)*Flw(m)%jac(imax - i, j1, k))
         Flw(m)%qh(i, j0, k, l) = qAve/Flw(m)%jac(i, j0, k)
         Flw(m)%qh(imax - i, j0, k, l) = qAve/Flw(m)%jac(imax - i, j0, k)
      end do
      end do
      end do
      ! 処理終了 ********************************************************************************************
      return
   end subroutine BoundaryCtypeBranch
!*******************************************************************************************************
!******** 翼壁面境界                                                                                ********
!*******************************************************************************************************
   subroutine BoundaryBladeSurface( &
   &            m, is, ie, ks, ke, j0, j1, j2, TurbNum)
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer, intent(in) :: m
      integer, intent(in) :: is, ie, ks, ke
      integer, intent(in) :: j0, j1, j2
      integer, intent(in) :: TurbNum !低Re数型乱流モデル用
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer :: i, k
      ! 処理開始 ********************************************************************************************
      do k = ks, ke
      do i = is, ie
         if (TurbNum .eq. 4) then
            call WallNoSlipLRe(m, i, j0, k, i, j1, k)
         else
            if (fSlip) then
               if (Flw(m)%qh(i, j1, k, 1) <= 0.0 .or. Flw(m)%qh(i, j2, k, 1) <= 0.0) cycle
               call WallSlipWF(m, i, j0, k, i, j1, k, i, j2, k)
            else
               if (Flw(m)%qh(i, j1, k, 1) <= 0.0) cycle
               call WallNoSlipWF(m, i, j0, k, i, j1, k)
            end if
         end if
      end do
      end do
      ! 処理終了 ********************************************************************************************
      return
   end subroutine BoundaryBladeSurface
!*******************************************************************************************************
!******** 壁境界 (滑りなし, 断熱, 壁関数)                                                        ********
!*******************************************************************************************************
   subroutine WallNoslipWF( &
   &            m, i0, j0, k0, i1, j1, k1)
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer, intent(in) :: m
      integer, intent(in) :: i0, j0, k0
      integer, intent(in) :: i1, j1, k1
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      real :: dx, dy, dz
      real :: uc, vc, wc
      real :: yp, up, nup, kp, epsp, utau, dudy1, dudy2
      ! 処理開始 ********************************************************************************************
      ! 壁関数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! 壁近傍の分布 ----------------------------------------------------------------------------------------
      dx = Flw(m)%x(i1, j1, k1) - Flw(m)%x(i0, j0, k0)
      dy = Flw(m)%y(i1, j1, k1) - Flw(m)%y(i0, j0, k0)
      dz = Flw(m)%z(i1, j1, k1) - Flw(m)%z(i0, j0, k0)
      uc = Flw(m)%qh(i1, j1, k1, 2)/Flw(m)%qh(i1, j1, k1, 1)
      vc = Flw(m)%qh(i1, j1, k1, 3)/Flw(m)%qh(i1, j1, k1, 1)
      wc = Flw(m)%qh(i1, j1, k1, 4)/Flw(m)%qh(i1, j1, k1, 1)
      ! 壁関数 ----------------------------------------------------------------------------------------------
      yp = sqrt(dx**2 + dy**2 + dz**2)
      up = sqrt(uc**2 + vc**2 + wc**2)
      up = max(zero, up)
      nup = Flw(m)%mu(i1, j1, k1)/(Flw(m)%qh(i1, j1, k1, 1)*Flw(m)%jac(i1, j1, k1))
      kp = Flw(m)%kin(i1, j1, k1)
      epsp = Flw(m)%eps(i1, j1, k1)
      nup = max(zero, nup)
      kp = max(zero, kp)
      epsp = max(zero, epsp)
      select case (Flw(m)%fRough(i0, k0))
      case (0)
         call WallFunctionKEM2S( &
         &      yp, up, nup, utau, dudy1, dudy2, kp, epsp)
      case (1)
         call WallFunctionKEM2R( &
         &      Flw(m)%RH(i0, k0), yp, up, nup, utau, dudy1, dudy2, kp, epsp)
      case default
         write (*, '(a)') '!!!!! Error : fRough number !!!!!'
      end select
      ! 速度 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! 壁面 ------------------------------------------------------------------------------------------------
      uc = 0.0
      vc = 0.0
      wc = 0.0
      ! 流束関数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! 壁面から一点目 --------------------------------------------------------------------------------------
      ! kp, epsp
      Flw(m)%qh(i1, j1, k1, 5) = Flw(m)%qh(i1, j1, k1, 5) - Flw(m)%qh(i1, j1, k1, 6)
      Flw(m)%qh(i1, j1, k1, 6) = Flw(m)%qh(i1, j1, k1, 1)*kp
      Flw(m)%qh(i1, j1, k1, 7) = Flw(m)%qh(i1, j1, k1, 1)*epsp
      Flw(m)%qh(i1, j1, k1, 5) = Flw(m)%qh(i1, j1, k1, 5) + Flw(m)%qh(i1, j1, k1, 6)
      ! 壁面 ------------------------------------------------------------------------------------------------
      ! 全て外挿
      Flw(m)%qh(i0, j0, k0, 1) = Flw(m)%qh(i1, j1, k1, 1)*Flw(m)%jac(i1, j1, k1)/Flw(m)%jac(i0, j0, k0)
      Flw(m)%qh(i0, j0, k0, 2) = uc*Flw(m)%qh(i0, j0, k0, 1)
      Flw(m)%qh(i0, j0, k0, 3) = vc*Flw(m)%qh(i0, j0, k0, 1)
      Flw(m)%qh(i0, j0, k0, 4) = wc*Flw(m)%qh(i0, j0, k0, 1)
      Flw(m)%qh(i0, j0, k0, 5) = Flw(m)%jac(i1, j1, k1)/Flw(m)%jac(i0, j0, k0) &
      &                     *(Flw(m)%qh(i1, j1, k1, 5) &
      &                       - 0.5*(Flw(m)%qh(i1, j1, k1, 2)**2 &
      &                               + Flw(m)%qh(i1, j1, k1, 3)**2 &
      &                               + Flw(m)%qh(i1, j1, k1, 4)**2)/Flw(m)%qh(i1, j1, k1, 1)) &
      &                     + 0.5*(Flw(m)%qh(i0, j0, k0, 2)**2 &
      &                             + Flw(m)%qh(i0, j0, k0, 3)**2 &
      &                             + Flw(m)%qh(i0, j0, k0, 4)**2)/Flw(m)%qh(i0, j0, k0, 1)
      Flw(m)%qh(i0, j0, k0, 6) = Flw(m)%qh(i1, j1, k1, 6)*Flw(m)%jac(i1, j1, k1)/Flw(m)%jac(i0, j0, k0)
      Flw(m)%qh(i0, j0, k0, 7) = Flw(m)%qh(i1, j1, k1, 7)*Flw(m)%jac(i1, j1, k1)/Flw(m)%jac(i0, j0, k0)
      ! 処理終了 ********************************************************************************************
      return
   end subroutine WallNoSlipWF
!*******************************************************************************************************
!******** 壁境界 (滑りあり, 断熱, 壁関数)                                                        ********
!*******************************************************************************************************
   subroutine WallSlipWF( &
   &            m, i0, j0, k0, i1, j1, k1, i2, j2, k2)
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer, intent(in) :: m
      integer, intent(in) :: i0, j0, k0
      integer, intent(in) :: i1, j1, k1
      integer, intent(in) :: i2, j2, k2
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      real :: dx2, dy2, dz2
      real :: uc2, vc2, wc2
      real :: uc1, vc1, wc1
      real :: uc0, vc0, wc0
      real :: yp, up, nup, kp, epsp, utau, dudy1, dudy2
      ! 処理開始 ********************************************************************************************
      ! 壁関数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! 壁近傍の分布 ----------------------------------------------------------------------------------------
      dx2 = Flw(m)%x(i2, j2, k2) - Flw(m)%x(i0, j0, k0)
      dy2 = Flw(m)%y(i2, j2, k2) - Flw(m)%y(i0, j0, k0)
      dz2 = Flw(m)%z(i2, j2, k2) - Flw(m)%z(i0, j0, k0)
      uc2 = Flw(m)%qh(i2, j2, k2, 2)/Flw(m)%qh(i2, j2, k2, 1)
      vc2 = Flw(m)%qh(i2, j2, k2, 3)/Flw(m)%qh(i2, j2, k2, 1)
      wc2 = Flw(m)%qh(i2, j2, k2, 4)/Flw(m)%qh(i2, j2, k2, 1)
      ! 壁関数 ----------------------------------------------------------------------------------------------
      yp = sqrt(dx2**2 + dy2**2 + dz2**2)
      up = sqrt(uc2**2 + vc2**2 + wc2**2)
      nup = Flw(m)%mu(i2, j2, k2)/(Flw(m)%qh(i2, j2, k2, 1)*Flw(m)%jac(i2, j2, k2))
      kp = Flw(m)%kin(i2, j2, k2)
      epsp = Flw(m)%eps(i2, j2, k2)
      up = max(zero, up)
      nup = max(zero, nup)
      kp = max(zero, kp)
      epsp = max(zero, epsp)
      select case (Flw(m)%fRough(i0, k0))
      case (0)
         call WallFunctionKEM2S( &
         &      yp, up, nup, utau, dudy1, dudy2, kp, epsp)
      case (1)
         call WallFunctionKEM2R( &
         &      Flw(m)%RH(i0, k0), yp, up, nup, utau, dudy1, dudy2, kp, epsp)
      case default
         write (*, '(a)') '!!!!! Error : fRough number !!!!!'
      end select
      ! 速度 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! 壁面から一点目 --------------------------------------------------------------------------------------
      uc1 = Flw(m)%qh(i1, j1, k1, 2)/Flw(m)%qh(i1, j1, k1, 1)
      vc1 = Flw(m)%qh(i1, j1, k1, 3)/Flw(m)%qh(i1, j1, k1, 1)
      wc1 = Flw(m)%qh(i1, j1, k1, 4)/Flw(m)%qh(i1, j1, k1, 1)
      yp = sqrt((Flw(m)%x(i2, j2, k2) - Flw(m)%x(i1, j1, k1))**2 &
      &         + (Flw(m)%y(i2, j2, k2) - Flw(m)%y(i1, j1, k1))**2 &
      &         + (Flw(m)%z(i2, j2, k2) - Flw(m)%z(i1, j1, k1))**2)
      up = max(zero, up - dudy1*yp)/max(zero, sqrt(uc1**2 + vc1**2 + wc1**2))
      uc1 = uc1*up
      vc1 = vc1*up
      wc1 = wc1*up
      ! 壁面 ------------------------------------------------------------------------------------------------
      uc0 = 0.0
      vc0 = 0.0
      wc0 = 0.0
      ! 流束関数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! 壁面から二点目 --------------------------------------------------------------------------------------
      ! kp, epsp 外挿
      Flw(m)%qh(i2, j2, k2, 5) = Flw(m)%qh(i2, j2, k2, 5) - Flw(m)%qh(i2, j2, k2, 6)
      Flw(m)%qh(i2, j2, k2, 6) = Flw(m)%qh(i2, j2, k2, 1)*kp
      Flw(m)%qh(i2, j2, k2, 7) = Flw(m)%qh(i2, j2, k2, 1)*epsp
      Flw(m)%qh(i2, j2, k2, 5) = Flw(m)%qh(i2, j2, k2, 5) + Flw(m)%qh(i2, j2, k2, 6)
      ! 壁面から一点目 --------------------------------------------------------------------------------------
      ! up, vp, wp, kp, epsp 外挿
      Flw(m)%qh(i1, j1, k1, 5) = Flw(m)%qh(i1, j1, k1, 5) &
      &                    - 0.5*(Flw(m)%qh(i1, j1, k1, 2)**2 &
      &                            + Flw(m)%qh(i1, j1, k1, 3)**2 &
      &                            + Flw(m)%qh(i1, j1, k1, 4)**2)/Flw(m)%qh(i1, j1, k1, 1) &
      &                    - Flw(m)%qh(i1, j1, k1, 6)
      Flw(m)%qh(i1, j1, k1, 2) = uc1*Flw(m)%qh(i1, j1, k1, 1)
      Flw(m)%qh(i1, j1, k1, 3) = vc1*Flw(m)%qh(i1, j1, k1, 1)
      Flw(m)%qh(i1, j1, k1, 4) = wc1*Flw(m)%qh(i1, j1, k1, 1)
      Flw(m)%qh(i1, j1, k1, 6) = kp*Flw(m)%qh(i1, j1, k1, 1)
      Flw(m)%qh(i1, j1, k1, 7) = epsp*Flw(m)%qh(i1, j1, k1, 1)
      Flw(m)%qh(i1, j1, k1, 5) = Flw(m)%qh(i1, j1, k1, 5) &
      &                    + 0.5*(Flw(m)%qh(i1, j1, k1, 2)**2 &
      &                            + Flw(m)%qh(i1, j1, k1, 3)**2 &
      &                            + Flw(m)%qh(i1, j1, k1, 4)**2)/Flw(m)%qh(i1, j1, k1, 1) &
      &                    + Flw(m)%qh(i1, j1, k1, 6)
      ! 壁面 ------------------------------------------------------------------------------------------------
      ! 全て外挿
      Flw(m)%qh(i0, j0, k0, 1) = Flw(m)%qh(i1, j1, k1, 1)*Flw(m)%jac(i1, j1, k1)/Flw(m)%jac(i0, j0, k0)
      Flw(m)%qh(i0, j0, k0, 2) = uc0*Flw(m)%qh(i0, j0, k0, 1)
      Flw(m)%qh(i0, j0, k0, 3) = vc0*Flw(m)%qh(i0, j0, k0, 1)
      Flw(m)%qh(i0, j0, k0, 4) = wc0*Flw(m)%qh(i0, j0, k0, 1)
      Flw(m)%qh(i0, j0, k0, 5) = Flw(m)%jac(i1, j1, k1)/Flw(m)%jac(i0, j0, k0) &
      &                     *(Flw(m)%qh(i1, j1, k1, 5) &
      &                       - 0.5*(Flw(m)%qh(i1, j1, k1, 2)**2 &
      &                               + Flw(m)%qh(i1, j1, k1, 3)**2 &
      &                               + Flw(m)%qh(i1, j1, k1, 4)**2)/Flw(m)%qh(i1, j1, k1, 1)) &
      &                     + 0.5*(Flw(m)%qh(i0, j0, k0, 2)**2 &
      &                             + Flw(m)%qh(i0, j0, k0, 3)**2 &
      &                             + Flw(m)%qh(i0, j0, k0, 4)**2)/Flw(m)%qh(i0, j0, k0, 1)
      Flw(m)%qh(i0, j0, k0, 6) = Flw(m)%qh(i1, j1, k1, 6)*Flw(m)%jac(i1, j1, k1)/Flw(m)%jac(i0, j0, k0)
      Flw(m)%qh(i0, j0, k0, 7) = Flw(m)%qh(i1, j1, k1, 7)*Flw(m)%jac(i1, j1, k1)/Flw(m)%jac(i0, j0, k0)
      ! 処理終了 ********************************************************************************************
      return
   end subroutine WallslipWF
!*******************************************************************************************************
!******** 壁境界 (滑りなし, 断熱, 低レイノルズ数型AKNモデル)                                          ********
!*******************************************************************************************************
   subroutine WallNoslipLRe( &
   &            m, i0, j0, k0, i1, j1, k1)
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer, intent(in) :: m
      integer, intent(in) :: i0, j0, k0
      integer, intent(in) :: i1, j1, k1
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      real :: dx, dy, dz, yp
      double precision :: epsp
      real :: uc, vc, wc
      ! 処理開始 ********************************************************************************************
      ! 速度 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! 壁面 ------------------------------------------------------------------------------------------------
      uc = 0.0
      vc = 0.0
      wc = 0.0
      ! 流束関数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! 壁面から一点目 --------------------------------------------------------------------------------------
      dx = Flw(m)%x(i1, j1, k1) - Flw(m)%x(i0, j0, k0)
      dy = Flw(m)%y(i1, j1, k1) - Flw(m)%y(i0, j0, k0)
      dz = Flw(m)%z(i1, j1, k1) - Flw(m)%z(i0, j0, k0)
      yp = sqrt(dx**2 + dy**2 + dz**2)
      epsp = 2.0d0*dble(Flw(m)%mu(i1, j1, k1)*Flw(m)%kin(i1, j1, k1))/ &
      &      ((dble(Flw(m)%qh(i1, j1, k1, 1))*dble(Flw(m)%jac(i1, j1, k1)))*dble(yp)**2.0)
!write(*,*) i1,j1,k1,epsp,Flw(m)%kin(i1,j1,k1),Flw(m)%qh(i1,j1,k1,1),Flw(m)%jac(i1,j1,k1)
      if (epsp .ne. epsp) then
         write (*, *) 'eps_p is diverged'
         write (*, *) i1, j1, Flw(m)%mu(i1, j1, k1), Flw(m)%qh(i1, j1, k1, 6), Flw(m)%jac(i1, j1, k1), &
         &          Flw(m)%qh(i1, j1, k1, 1), Flw(m)%jac(i1, j1, k1), yp
         stop
      end if
      ! epsp
      Flw(m)%qh(i1, j1, k1, 7) = real(dble(Flw(m)%qh(i1, j1, k1, 1))*epsp)
      ! 壁面 ------------------------------------------------------------------------------------------------
      ! 全て外挿
      Flw(m)%qh(i0, j0, k0, 1) = Flw(m)%qh(i1, j1, k1, 1)*Flw(m)%jac(i1, j1, k1)/Flw(m)%jac(i0, j0, k0)
      Flw(m)%qh(i0, j0, k0, 2) = uc*Flw(m)%qh(i0, j0, k0, 1)
      Flw(m)%qh(i0, j0, k0, 3) = vc*Flw(m)%qh(i0, j0, k0, 1)
      Flw(m)%qh(i0, j0, k0, 4) = wc*Flw(m)%qh(i0, j0, k0, 1)
      Flw(m)%qh(i0, j0, k0, 5) = Flw(m)%jac(i1, j1, k1)/Flw(m)%jac(i0, j0, k0) &
      &                     *(Flw(m)%qh(i1, j1, k1, 5) &
      &                       - 0.5*(Flw(m)%qh(i1, j1, k1, 2)**2 &
      &                               + Flw(m)%qh(i1, j1, k1, 3)**2 &
      &                               + Flw(m)%qh(i1, j1, k1, 4)**2)/Flw(m)%qh(i1, j1, k1, 1)) &
      &                     + 0.5*(Flw(m)%qh(i0, j0, k0, 2)**2 &
      &                             + Flw(m)%qh(i0, j0, k0, 3)**2 &
      &                             + Flw(m)%qh(i0, j0, k0, 4)**2)/Flw(m)%qh(i0, j0, k0, 1)
      Flw(m)%qh(i0, j0, k0, 6) = 0.0
      Flw(m)%qh(i0, j0, k0, 7) = Flw(m)%qh(i1, j1, k1, 7)*Flw(m)%jac(i1, j1, k1)/Flw(m)%jac(i0, j0, k0)
      ! 処理終了 ********************************************************************************************
      return
   end subroutine WallNoSlipLRe
!*******************************************************************************************************
!******** 氷の中の点の処理 (氷層の平均値を外挿)                                                         *******
!*******************************************************************************************************
   subroutine BoundaryIceIn( &
   &            m1, m2, is, ie, js, je, ks, ke, i1, i2, j0, k0)
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer, intent(in) :: m1, m2
      integer, intent(in) :: is, ie, js, je, ks, ke
      integer, intent(in) :: i1, i2, j0, k0
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      real, pointer :: qAve(:)
      integer :: i, j, k, l
      ! 処理開始 ********************************************************************************************
      ! メモリ確保 ------------------------------------------------------------------------------------------
      allocate (qAve(ls:le))
      ! 氷層の平均値 ----------------------------------------------------------------------------------------
      do l = ls, le
         qAve(l) = sum(Flw(m2)%qh(i1:i2, j0, k0, l)*Flw(m2)%jac(i1:i2, j0, k0)) &
         &       /real(i2 - i1 + 1)
      end do
      ! 平均値を外挿 ----------------------------------------------------------------------------------------
      do k = ks, ke
      do j = js, je
      do i = is, ie
         if (IceIn(i, j, k) == 0) cycle
         do l = ls, le
            Flw(m1)%qh(i, j, k, l) = qAve(l)/Flw(m1)%jac(i, j, k)
         end do
      end do
      end do
      end do
      ! メモリ解放 ------------------------------------------------------------------------------------------
      deallocate (qAve)
      ! 処理終了 ********************************************************************************************
      return
   end subroutine BoundaryIceIn
!*******************************************************************************************************
!******** 周期境界                                                                                  *******
!*******************************************************************************************************
   subroutine BoundaryPeriodic( &
   &            m, is, ie, js, je, k0, k1)
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer, intent(in) :: m
      integer, intent(in) :: is, ie, js, je
      integer, intent(in) :: k0, k1
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer :: i, j, l
      ! 処理開始 ********************************************************************************************
      do l = ls, le
      do j = js, je
      do i = is, ie
         Flw(m)%qh(i, j, k0, l) = Flw(m)%qh(i, j, k1, l)*Flw(m)%jac(i, j, k1)/Flw(m)%jac(i, j, k0)
      end do
      end do
      end do
      ! 処理終了 ********************************************************************************************
      return
   end subroutine BoundaryPeriodic
!*******************************************************************************************************
!******** 重合格子の補間                                                                        ********
!*******************************************************************************************************
   subroutine InterpolationOversetGrid
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer :: i, j, k, l, m, n
      integer :: i0, j0, k0, &
      &          i1, j1, k1, i2, j2, k2, i3, j3, k3, i4, j4, k4, &
      &          i5, j5, k5, i6, j6, k6, i7, j7, k7, i8, j8, k8
      ! 処理開始 ********************************************************************************************
      do m = ms, me
         select case (m)
         case (1); n = 2
         case (2); n = 1
         end select
!$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(i, j, k, l, i0, j0, k0, &
!$OMP&  i1, j1, k1, i2, j2, k2, i3, j3, k3, i4, j4, k4, &
!$OMP&  i5, j5, k5, i6, j6, k6, i7, j7, k7, i8, j8, k8)
         do k0 = OSG(m)%ks, OSG(m)%ke
         do j0 = OSG(m)%js, OSG(m)%je
         do i0 = OSG(m)%is, OSG(m)%ie
            i = OSG(m)%ip(i0, j0, k0); j = OSG(m)%jp(i0, j0, k0); k = OSG(m)%kp(i0, j0, k0)
            select case (OSG(m)%fOver(i0, j0, k0))
               ! 補間しない点 -------------------------------------------------------------------------------------
            case (0)
               cycle
               ! 三重線形補間点 -----------------------------------------------------------------------------------
            case (1)
               i1 = i; j1 = j; k1 = k; i2 = i + 1; j2 = j; k2 = k
               i3 = i; j3 = j + 1; k3 = k; i4 = i + 1; j4 = j + 1; k4 = k
               i5 = i; j5 = j; k5 = k + 1; i6 = i + 1; j6 = j; k6 = k + 1
               i7 = i; j7 = j + 1; k7 = k + 1; i8 = i + 1; j8 = j + 1; k8 = k + 1
               do l = ls, le
                  Flw(m)%qh(i0, j0, k0, l) = (OSG(m)%term1(i0, j0, k0)*Flw(n)%qh(i1, j1, k1, l)*Flw(n)%jac(i1, j1, k1) &
                  &                       + OSG(m)%term2(i0, j0, k0)*Flw(n)%qh(i2, j2, k2, l)*Flw(n)%jac(i2, j2, k2) &
                  &                       + OSG(m)%term3(i0, j0, k0)*Flw(n)%qh(i3, j3, k3, l)*Flw(n)%jac(i3, j3, k3) &
                  &                       + OSG(m)%term4(i0, j0, k0)*Flw(n)%qh(i4, j4, k4, l)*Flw(n)%jac(i4, j4, k4) &
                  &                       + OSG(m)%term5(i0, j0, k0)*Flw(n)%qh(i5, j5, k5, l)*Flw(n)%jac(i5, j5, k5) &
                  &                       + OSG(m)%term6(i0, j0, k0)*Flw(n)%qh(i6, j6, k6, l)*Flw(n)%jac(i6, j6, k6) &
                  &                       + OSG(m)%term7(i0, j0, k0)*Flw(n)%qh(i7, j7, k7, l)*Flw(n)%jac(i7, j7, k7) &
                  &                       + OSG(m)%term8(i0, j0, k0)*Flw(n)%qh(i8, j8, k8, l)*Flw(n)%jac(i8, j8, k8) &
                  &                         )/Flw(m)%jac(i0, j0, k0)
               end do
               ! 三次元線形補間点 ---------------------------------------------------------------------------------
            case (2)
               i1 = i; j1 = j; k1 = k; i2 = i; j2 = j; k2 = k + 1
               i3 = i + 1; j3 = j; k3 = k + 1; i4 = i; j4 = j + 1; k4 = k + 1
               do l = ls, le
                  Flw(m)%qh(i0, j0, k0, l) = (OSG(m)%term1(i0, j0, k0)*Flw(n)%qh(i1, j1, k1, l)*Flw(n)%jac(i1, j1, k1) &
                  &                       + OSG(m)%term2(i0, j0, k0) &
                  &                         *(Flw(n)%qh(i2, j2, k2, l)*Flw(n)%jac(i2, j2, k2) &
                  &                           - Flw(n)%qh(i1, j1, k1, l)*Flw(n)%jac(i1, j1, k1)) &
                  &                       + OSG(m)%term3(i0, j0, k0) &
                  &                         *(Flw(n)%qh(i3, j3, k3, l)*Flw(n)%jac(i3, j3, k3) &
                  &                           - Flw(n)%qh(i1, j1, k1, l)*Flw(n)%jac(i1, j1, k1)) &
                  &                       + OSG(m)%term4(i0, j0, k0) &
                  &                         *(Flw(n)%qh(i4, j4, k4, l)*Flw(n)%jac(i4, j4, k4) &
                  &                           - Flw(n)%qh(i1, j1, k1, l)*Flw(n)%jac(i1, j1, k1)) &
                  &                         )/Flw(m)%jac(i0, j0, k0)
               end do
            case (3)
               i1 = i; j1 = j; k1 = k; i2 = i; j2 = j + 1; k2 = k
               i3 = i + 1; j3 = j + 1; k3 = k; i4 = i; j4 = j + 1; k4 = k + 1
               do l = ls, le
                  Flw(m)%qh(i0, j0, k0, l) = (OSG(m)%term1(i0, j0, k0)*Flw(n)%qh(i1, j1, k1, l)*Flw(n)%jac(i1, j1, k1) &
                  &                       + OSG(m)%term2(i0, j0, k0) &
                  &                         *(Flw(n)%qh(i2, j2, k2, l)*Flw(n)%jac(i2, j2, k2) &
                  &                           - Flw(n)%qh(i1, j1, k1, l)*Flw(n)%jac(i1, j1, k1)) &
                  &                       + OSG(m)%term3(i0, j0, k0) &
                  &                         *(Flw(n)%qh(i3, j3, k3, l)*Flw(n)%jac(i3, j3, k3) &
                  &                           - Flw(n)%qh(i1, j1, k1, l)*Flw(n)%jac(i1, j1, k1)) &
                  &                       + OSG(m)%term4(i0, j0, k0) &
                  &                         *(Flw(n)%qh(i4, j4, k4, l)*Flw(n)%jac(i4, j4, k4) &
                  &                           - Flw(n)%qh(i1, j1, k1, l)*Flw(n)%jac(i1, j1, k1)) &
                  &                         )/Flw(m)%jac(i0, j0, k0)
               end do
            case (4)
               i1 = i; j1 = j; k1 = k; i2 = i + 1; j2 = j + 1; k2 = k
               i3 = i + 1; j3 = j; k3 = k + 1; i4 = i; j4 = j + 1; k4 = k + 1
               do l = ls, le
                  Flw(m)%qh(i0, j0, k0, l) = (OSG(m)%term1(i0, j0, k0)*Flw(n)%qh(i1, j1, k1, l)*Flw(n)%jac(i1, j1, k1) &
                  &                       + OSG(m)%term2(i0, j0, k0) &
                  &                         *(Flw(n)%qh(i2, j2, k2, l)*Flw(n)%jac(i2, j2, k2) &
                  &                           - Flw(n)%qh(i1, j1, k1, l)*Flw(n)%jac(i1, j1, k1)) &
                  &                       + OSG(m)%term3(i0, j0, k0) &
                  &                         *(Flw(n)%qh(i3, j3, k3, l)*Flw(n)%jac(i3, j3, k3) &
                  &                           - Flw(n)%qh(i1, j1, k1, l)*Flw(n)%jac(i1, j1, k1)) &
                  &                       + OSG(m)%term4(i0, j0, k0) &
                  &                         *(Flw(n)%qh(i4, j4, k4, l)*Flw(n)%jac(i4, j4, k4) &
                  &                           - Flw(n)%qh(i1, j1, k1, l)*Flw(n)%jac(i1, j1, k1)) &
                  &                         )/Flw(m)%jac(i0, j0, k0)
               end do
            case (5)
               i1 = i; j1 = j; k1 = k; i2 = i + 1; j2 = j; k2 = k
               i3 = i + 1; j3 = j + 1; k3 = k; i4 = i + 1; j4 = j; k4 = k + 1
               do l = ls, le
                  Flw(m)%qh(i0, j0, k0, l) = (OSG(m)%term1(i0, j0, k0)*Flw(n)%qh(i1, j1, k1, l)*Flw(n)%jac(i1, j1, k1) &
                  &                       + OSG(m)%term2(i0, j0, k0) &
                  &                         *(Flw(n)%qh(i2, j2, k2, l)*Flw(n)%jac(i2, j2, k2) &
                  &                           - Flw(n)%qh(i1, j1, k1, l)*Flw(n)%jac(i1, j1, k1)) &
                  &                       + OSG(m)%term3(i0, j0, k0) &
                  &                         *(Flw(n)%qh(i3, j3, k3, l)*Flw(n)%jac(i3, j3, k3) &
                  &                           - Flw(n)%qh(i1, j1, k1, l)*Flw(n)%jac(i1, j1, k1)) &
                  &                       + OSG(m)%term4(i0, j0, k0) &
                  &                         *(Flw(n)%qh(i4, j4, k4, l)*Flw(n)%jac(i4, j4, k4) &
                  &                           - Flw(n)%qh(i1, j1, k1, l)*Flw(n)%jac(i1, j1, k1)) &
                  &                         )/Flw(m)%jac(i0, j0, k0)
               end do
            case (6)
               i1 = i + 1; j1 = j + 1; k1 = k; i2 = i + 1; j2 = j; k2 = k + 1
               i3 = i; j3 = j + 1; k3 = k + 1; i4 = i + 1; j4 = j + 1; k4 = k + 1
               do l = ls, le
                  Flw(m)%qh(i0, j0, k0, l) = (OSG(m)%term1(i0, j0, k0)*Flw(n)%qh(i1, j1, k1, l)*Flw(n)%jac(i1, j1, k1) &
                  &                       + OSG(m)%term2(i0, j0, k0) &
                  &                         *(Flw(n)%qh(i2, j2, k2, l)*Flw(n)%jac(i2, j2, k2) &
                  &                           - Flw(n)%qh(i1, j1, k1, l)*Flw(n)%jac(i1, j1, k1)) &
                  &                       + OSG(m)%term3(i0, j0, k0) &
                  &                         *(Flw(n)%qh(i3, j3, k3, l)*Flw(n)%jac(i3, j3, k3) &
                  &                           - Flw(n)%qh(i1, j1, k1, l)*Flw(n)%jac(i1, j1, k1)) &
                  &                       + OSG(m)%term4(i0, j0, k0) &
                  &                         *(Flw(n)%qh(i4, j4, k4, l)*Flw(n)%jac(i4, j4, k4) &
                  &                           - Flw(n)%qh(i1, j1, k1, l)*Flw(n)%jac(i1, j1, k1)) &
                  &                         )/Flw(m)%jac(i0, j0, k0)
               end do
            end select
         end do
         end do
         end do
         !$OMP END PARALLEL DO
      end do
      ! 処理終了 ********************************************************************************************
      return
   end subroutine InterpolationOversetGrid
!*******************************************************************************************************
!******** 残差計算                                                                                 ********
!*******************************************************************************************************
   subroutine CalResidual
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      real, pointer :: res0(:, :, :, :)
      integer :: l, m
      ! 処理開始 ********************************************************************************************
! do m = ms, me
      m = me
      ! メモリ確保 -----------------------------------------------------------------------------------------
      allocate (res0(Flw(m)%is:Flw(m)%ie, Flw(m)%js:Flw(m)%je, Flw(m)%ks:Flw(m)%ke, ls:le))
      ! 残差計算 -------------------------------------------------------------------------------------------
      call CalResidual3D( &
      &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, &
      &     ls, le, Flw(m)%dt, Flw(m)%qh0, Flw(m)%qh, &
      &     res0)
      ! 最大値算出 -----------------------------------------------------------------------------------------
      do l = ls, le
         Flw(m)%Res(l) = maxval(res0(:, :, :, l))
      end do
      ! メモリ解放 -----------------------------------------------------------------------------------------
      deallocate (res0)
! enddo
      ! ファイル出力 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! write(20, '(i6, 7e16.8e3)') nCount, Flw(1)%Res(ls:le)
      write (21, '(i6, 7e16.8e3)') nCount, Flw(2)%Res(ls:le)
      ! 処理終了 ********************************************************************************************
      return
   end subroutine CalResidual
!*******************************************************************************************************
!******** 流れ場ファイル出力 (計算回数毎)                                                         ********
!*******************************************************************************************************
   subroutine OutputFileCount
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      character :: fname*30
      integer   :: m
      ! 処理開始 ********************************************************************************************
      ! 計算条件 --------------------------------------------------------------------------------------------
      call OUtput_CalSetting(trim(ND_CalSetFile)//strtxt)
      ! 流束関数 --------------------------------------------------------------------------------------------
      write (fname, '(a, 2(i2.2,a))') 'IceStep', IceStep, 'of', IceStepMax, '_'
! do m = ms, me
      m = me
      call Output_Flux3D( &
      &      trim(FlwCalOutDir)//trim(BlkName(m))//trim(ND_FlxFile), strbin, &
      &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, &
      &      ls, le, Flw(m)%qh)
      call Output_Flux3D( &
      &      trim(FlwCalOutDir)//trim(fname)//trim(BlkName(m))//trim(ND_FlxFile), strbin, &
      &      Flw(m)%is, Flw(m)%ie, Flw(m)%js, Flw(m)%je, Flw(m)%ks, Flw(m)%ke, &
      &      ls, le, Flw(m)%qh)
! enddo
      ! 処理終了 ********************************************************************************************
      return
   end subroutine OutputFileCount
!*******************************************************************************************************
!******** メモリ解放                                                                                 ********
!*******************************************************************************************************
   subroutine Deallocating
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer :: m
      ! 処理開始 ********************************************************************************************
! do m = ms, me
      m = me
      deallocate (Flw(m)%x, Flw(m)%y, Flw(m)%z, &
      &           Flw(m)%rho, Flw(m)%u, Flw(m)%v, Flw(m)%w, &
      &           Flw(m)%p, Flw(m)%t, Flw(m)%mu, &
      &           Flw(m)%kin, Flw(m)%eps, Flw(m)%mut, &
      &           Flw(m)%xix, Flw(m)%xiy, Flw(m)%xiz, &
      &           Flw(m)%etx, Flw(m)%ety, Flw(m)%etz, &
      &           Flw(m)%zex, Flw(m)%zey, Flw(m)%zez, &
      &           Flw(m)%jac, Flw(m)%qh, Flw(m)%qh0, &
      &           Flw(m)%dqc, Flw(m)%dqd, Flw(m)%dqp, Flw(m)%dqr, &
      &           Flw(m)%dqh, Flw(m)%dqh0, &
      &           Flw(m)%dt, Flw(m)%Res)
!  deallocate( OSG(m)%ip, OSG(m)%jp, OSG(m)%kp, &
!  &           OSG(m)%term1, OSG(m)%term2, OSG(m)%term3, OSG(m)%term4, &
!  &           OSG(m)%term5, OSG(m)%term6, OSG(m)%term7, OSG(m)%term8, &
!  &           OSG(m)%fOver )
! enddo
      ! 処理終了 ********************************************************************************************
      return
   end subroutine Deallocating
!*******************************************************************************************************
!******** y+計算                                                                                 ********
!*******************************************************************************************************
   subroutine calyplus(m)
      implicit none
      !mainroutine_variable
      integer, intent(in)        :: m
      !subroutine_variable
      integer                :: i, j, k
      real, allocatable        :: utau(:)
      real, allocatable        :: yplus(:)
      real                        :: yp, up
      real                        :: ypmax, ypmin

      !array_allocation
      allocate (utau(Flw(m)%is:Flw(m)%ie))
      allocate (yplus(Flw(m)%i1:Flw(m)%i3))

      do i = Flw(m)%i1, Flw(m)%i3
         yp = sqrt((Flw(m)%x(i, Flw(m)%js + 1, Flw(m)%ks) - Flw(m)%x(i, Flw(m)%js, Flw(m)%ks))**2.0 + &
              &    (Flw(m)%y(i, Flw(m)%js + 1, Flw(m)%ks) - Flw(m)%y(i, Flw(m)%js, Flw(m)%ks))**2.0)
         up = sqrt(Flw(m)%u(i, Flw(m)%js + 1, Flw(m)%ks)**2.0 + Flw(m)%v(i, Flw(m)%js + 1, Flw(m)%ks)**2.0)
         yplus(i) = sqrt(Flw(m)%rho(i, Flw(m)%js, Flw(m)%ks)/ &
         &              (Flw(m)%mut(i, Flw(m)%js, Flw(m)%ks) + Flw(m)%mu(i, Flw(m)%js, Flw(m)%ks))* &
         &              yp*up)
      end do
      ypmax = maxval(yplus)
      ypmin = minval(yplus)

      write (*, *) 'Range of yplus:', ypmin, 'to', ypmax

      deallocate (utau)
      deallocate (yplus)
   end subroutine calyplus

!*******************************************************************************************************
!******** ParaViewファイル出力                                                                        ********
!*******************************************************************************************************
   subroutine OutputPara_bin( &
   &      strdir, strname, is, ie, js, je, ks, ke, &
   &      rhoRef, aRef, lRef, rho, u, v, w, Ps, Ts, mu, &
   &      kin, eps, mut, &
   &      x, y, z)
      implicit none
      !mainroutine_variable
      character, intent(in)  :: strdir*(*), strname*(*)
      integer, intent(in)  :: is, ie, js, je, ks, ke
      real, intent(in)  :: rhoRef, aRef, lRef
      real, intent(in)  :: rho(is:ie, js:je, ks:ke), &
      &                         u(is:ie, js:je, ks:ke), v(is:ie, js:je, ks:ke), w(is:ie, js:je, ks:ke), &
      &                         Ps(is:ie, js:je, ks:ke), Ts(is:ie, js:je, ks:ke), mu(is:ie, js:je, ks:ke), &
      &                         kin(is:ie, js:je, ks:ke), eps(is:ie, js:je, ks:ke), &
      &                         mut(is:ie, js:je, ks:ke)
      real, intent(in)  :: x(is:ie, js:je, ks:ke), y(is:ie, js:je, ks:ke), z(is:ie, js:je, ks:ke)
      !subroutine_variable
      character(len=4), parameter                :: strvtk = '.vtk'
      character(len=1), parameter                :: newline = char(10)
      character(len=200)        :: strnum
      integer                :: i, j, k, n
      integer                :: ni, nj, nk
      integer                :: npoint

      npoint = (ie - is)*(je - js)*(ke - ks)

open(unit       = 1, &
     file       = trim(strdir)//trim(strname)//trim(strvtk), &
     form       = 'unformatted', &
     access     = 'stream', &          ! ← ここを stream に
     convert    = 'big_endian', &      ! GNU拡張（OK）。気になるなら -fconvert で全体指定でも可
     action     = 'write')
      write (1) '# vtk DataFile Version 3.0'//newline
      write (1) 'vtk output'//newline
      write (1) 'BINARY'//newline
      write (1) 'DATASET UNSTRUCTURED_GRID'//newline
      write (strnum, *) npoint*8
      write (1) 'POINTS'//trim(strnum)//' float'//newline
      do n = 0, npoint - 1
         ni = mod(mod(n, (ie - is)*(je - js)), (ie - is))
         nj = int(mod(n, (ie - is)*(je - js))/(ie - is))
         nk = int(n/((ie - is)*(je - js)))
         write (1) x(ni, nj, nk)*lRef, y(ni, nj, nk)*lRef, z(ni, nj, nk)*lRef
         write (1) x(ni + 1, nj, nk)*lRef, y(ni + 1, nj, nk)*lRef, z(ni + 1, nj, nk)*lRef
         write (1) x(ni + 1, nj + 1, nk)*lRef, y(ni + 1, nj + 1, nk)*lRef, z(ni + 1, nj + 1, nk)*lRef
         write (1) x(ni, nj + 1, nk)*lRef, y(ni, nj + 1, nk)*lRef, z(ni, nj + 1, nk)*lRef
         write (1) x(ni, nj, nk + 1)*lRef, y(ni, nj, nk + 1)*lRef, z(ni, nj, nk + 1)*lRef
         write (1) x(ni + 1, nj, nk + 1)*lRef, y(ni + 1, nj, nk + 1)*lRef, z(ni + 1, nj, nk + 1)*lRef
         write (1) x(ni + 1, nj + 1, nk + 1)*lRef, y(ni + 1, nj + 1, nk + 1)*lRef, z(ni + 1, nj + 1, nk + 1)*lRef
         write (1) x(ni, nj + 1, nk + 1)*lRef, y(ni, nj + 1, nk + 1)*lRef, z(ni, nj + 1, nk + 1)*lRef
      end do
      write (1) newline
      write (strnum, *) npoint, npoint*9
      write (1) 'CELLS'//trim(strnum)//newline
      do n = 0, npoint - 1
         write (1) 8, n*8 + 0, n*8 + 1, n*8 + 2, n*8 + 3, n*8 + 4, n*8 + 5, n*8 + 6, n*8 + 7
      end do
      write (1) newline
      write (strnum, *) npoint
      write (1) 'CELL_TYPES'//trim(strnum)//newline
      do n = 0, npoint - 1
         write (1) 12
      end do
      write (1) newline
      write (strnum, *) npoint*8
      write (1) 'POINT_DATA'//trim(strnum)//newline
      write (1) 'VECTORS velocity float'//newline
      do n = 0, npoint - 1
         ni = mod(mod(n, (ie - is)*(je - js)), (ie - is))
         nj = int(mod(n, (ie - is)*(je - js))/(ie - is))
         nk = int(n/((ie - is)*(je - js)))
         write (1) u(ni, nj, nk)*aRef, v(ni, nj, nk)*aRef, w(ni, nj, nk)*aRef
         write (1) u(ni + 1, nj, nk)*aRef, v(ni + 1, nj, nk)*aRef, w(ni + 1, nj, nk)*aRef
         write (1) u(ni + 1, nj + 1, nk)*aRef, v(ni + 1, nj + 1, nk)*aRef, w(ni + 1, nj + 1, nk)*aRef
         write (1) u(ni, nj + 1, nk)*aRef, v(ni, nj + 1, nk)*aRef, w(ni, nj + 1, nk)*aRef
         write (1) u(ni, nj, nk + 1)*aRef, v(ni, nj, nk + 1)*aRef, w(ni, nj, nk + 1)*aRef
         write (1) u(ni + 1, nj, nk + 1)*aRef, v(ni + 1, nj, nk + 1)*aRef, w(ni + 1, nj, nk + 1)*aRef
         write (1) u(ni + 1, nj + 1, nk + 1)*aRef, v(ni + 1, nj + 1, nk + 1)*aRef, w(ni + 1, nj + 1, nk + 1)*aRef
         write (1) u(ni, nj + 1, nk + 1)*aRef, v(ni, nj + 1, nk + 1)*aRef, w(ni, nj + 1, nk + 1)*aRef
      end do
      write (1) newline
      write (1) 'SCALARS rho float'//newline
      write (1) 'LOOKUP_TABLE default'//newline
      do n = 0, npoint - 1
         ni = mod(mod(n, (ie - is)*(je - js)), (ie - is))
         nj = int(mod(n, (ie - is)*(je - js))/(ie - is))
         nk = int(n/((ie - is)*(je - js)))
         write (1) rho(ni, nj, nk)*rhoRef
         write (1) rho(ni + 1, nj, nk)*rhoRef
         write (1) rho(ni + 1, nj + 1, nk)*rhoRef
         write (1) rho(ni, nj + 1, nk)*rhoRef
         write (1) rho(ni, nj, nk + 1)*rhoRef
         write (1) rho(ni + 1, nj, nk + 1)*rhoRef
         write (1) rho(ni + 1, nj + 1, nk + 1)*rhoRef
         write (1) rho(ni, nj + 1, nk + 1)*rhoRef
      end do
      write (1) newline
      write (1) 'SCALARS Ps float'//newline
      write (1) 'LOOKUP_TABLE default'//newline
      do n = 0, npoint - 1
         ni = mod(mod(n, (ie - is)*(je - js)), (ie - is))
         nj = int(mod(n, (ie - is)*(je - js))/(ie - is))
         nk = int(n/((ie - is)*(je - js)))
         write (1) Ps(ni, nj, nk)*rhoRef*aRef**2.0
         write (1) Ps(ni + 1, nj, nk)*rhoRef*aRef**2.0
         write (1) Ps(ni + 1, nj + 1, nk)*rhoRef*aRef**2.0
         write (1) Ps(ni, nj + 1, nk)*rhoRef*aRef**2.0
         write (1) Ps(ni, nj, nk + 1)*rhoRef*aRef**2.0
         write (1) Ps(ni + 1, nj, nk + 1)*rhoRef*aRef**2.0
         write (1) Ps(ni + 1, nj + 1, nk + 1)*rhoRef*aRef**2.0
         write (1) Ps(ni, nj + 1, nk + 1)*rhoRef*aRef**2.0
      end do
      write (1) newline
      write (1) 'SCALARS Ts float'//newline
      write (1) 'LOOKUP_TABLE default'//newline
      do n = 0, npoint - 1
         ni = mod(mod(n, (ie - is)*(je - js)), (ie - is))
         nj = int(mod(n, (ie - is)*(je - js))/(ie - is))
         nk = int(n/((ie - is)*(je - js)))
         write (1) Ts(ni, nj, nk)*aRef**2.0
         write (1) Ts(ni + 1, nj, nk)*aRef**2.0
         write (1) Ts(ni + 1, nj + 1, nk)*aRef**2.0
         write (1) Ts(ni, nj + 1, nk)*aRef**2.0
         write (1) Ts(ni, nj, nk + 1)*aRef**2.0
         write (1) Ts(ni + 1, nj, nk + 1)*aRef**2.0
         write (1) Ts(ni + 1, nj + 1, nk + 1)*aRef**2.0
         write (1) Ts(ni, nj + 1, nk + 1)*aRef**2.0
      end do
      write (1) newline
      write (1) 'SCALARS mu float'//newline
      write (1) 'LOOKUP_TABLE default'//newline
      do n = 0, npoint - 1
         ni = mod(mod(n, (ie - is)*(je - js)), (ie - is))
         nj = int(mod(n, (ie - is)*(je - js))/(ie - is))
         nk = int(n/((ie - is)*(je - js)))
         write (1) mu(ni, nj, nk)*rhoRef*aRef*lRef
         write (1) mu(ni + 1, nj, nk)*rhoRef*aRef*lRef
         write (1) mu(ni + 1, nj + 1, nk)*rhoRef*aRef*lRef
         write (1) mu(ni, nj + 1, nk)*rhoRef*aRef*lRef
         write (1) mu(ni, nj, nk + 1)*rhoRef*aRef*lRef
         write (1) mu(ni + 1, nj, nk + 1)*rhoRef*aRef*lRef
         write (1) mu(ni + 1, nj + 1, nk + 1)*rhoRef*aRef*lRef
         write (1) mu(ni, nj + 1, nk + 1)*rhoRef*aRef*lRef
      end do
      write (1) newline
      write (1) 'SCALARS k float'//newline
      write (1) 'LOOKUP_TABLE default'//newline
      do n = 0, npoint - 1
         ni = mod(mod(n, (ie - is)*(je - js)), (ie - is))
         nj = int(mod(n, (ie - is)*(je - js))/(ie - is))
         nk = int(n/((ie - is)*(je - js)))
         write (1) kin(ni, nj, nk)*aRef**2.0
         write (1) kin(ni + 1, nj, nk)*aRef**2.0
         write (1) kin(ni + 1, nj + 1, nk)*aRef**2.0
         write (1) kin(ni, nj + 1, nk)*aRef**2.0
         write (1) kin(ni, nj, nk + 1)*aRef**2.0
         write (1) kin(ni + 1, nj, nk + 1)*aRef**2.0
         write (1) kin(ni + 1, nj + 1, nk + 1)*aRef**2.0
         write (1) kin(ni, nj + 1, nk + 1)*aRef**2.0
      end do
      write (1) newline
      write (1) 'SCALARS eps float'//newline
      write (1) 'LOOKUP_TABLE default'//newline
      do n = 0, npoint - 1
         ni = mod(mod(n, (ie - is)*(je - js)), (ie - is))
         nj = int(mod(n, (ie - is)*(je - js))/(ie - is))
         nk = int(n/((ie - is)*(je - js)))
         write (1) eps(ni, nj, nk)*aRef**3.0/lRef
         write (1) eps(ni + 1, nj, nk)*aRef**3.0/lRef
         write (1) eps(ni + 1, nj + 1, nk)*aRef**3.0/lRef
         write (1) eps(ni, nj + 1, nk)*aRef**3.0/lRef
         write (1) eps(ni, nj, nk + 1)*aRef**3.0/lRef
         write (1) eps(ni + 1, nj, nk + 1)*aRef**3.0/lRef
         write (1) eps(ni + 1, nj + 1, nk + 1)*aRef**3.0/lRef
         write (1) eps(ni, nj + 1, nk + 1)*aRef**3.0/lRef
      end do
      write (1) newline
      write (1) 'SCALARS mut float'//newline
      write (1) 'LOOKUP_TABLE default'//newline
      do n = 0, npoint - 1
         ni = mod(mod(n, (ie - is)*(je - js)), (ie - is))
         nj = int(mod(n, (ie - is)*(je - js))/(ie - is))
         nk = int(n/((ie - is)*(je - js)))
         write (1) mut(ni, nj, nk)*rhoRef*aRef*lRef
         write (1) mut(ni + 1, nj, nk)*rhoRef*aRef*lRef
         write (1) mut(ni + 1, nj + 1, nk)*rhoRef*aRef*lRef
         write (1) mut(ni, nj + 1, nk)*rhoRef*aRef*lRef
         write (1) mut(ni, nj, nk + 1)*rhoRef*aRef*lRef
         write (1) mut(ni + 1, nj, nk + 1)*rhoRef*aRef*lRef
         write (1) mut(ni + 1, nj + 1, nk + 1)*rhoRef*aRef*lRef
         write (1) mut(ni, nj + 1, nk + 1)*rhoRef*aRef*lRef
      end do
      close (1)

   end subroutine OutputPara_bin
! 定義終了 *********************************************************************************************
end program FlowField_NACA
```

## file "Grid_Generation_NACA.f90"

```fortran
!*******************************************************************************************************
!*******************************************************************************************************
!******** 格子生成プログラム                                                                        ********
!******** (NACA0012翼，三次元，C-type，重合格子法)                                                ********
!********                                         　　　2014.04.10  PROGRAMMED BY RYOSUKE HAYASHI ********
!********                                              2014.04.15     UPDATED BY RYOSUKE HAYASHI ********
!*******************************************************************************************************
!*******************************************************************************************************
program GridGeneration_NACA
   ! モジュール宣言 **************************************************************************************
   use Package_NACA
   use Package_FileIO
   use Package_Equation
   use Package_Grid
   ! 変数宣言 ********************************************************************************************
   implicit none
   ! ファイル名設定 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   character, parameter :: ViewGrdFile*8 = 'ViewGrid'
   ! 共有定数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   integer, parameter :: NACA1 = 0                                        ! NACA 翼の反り比
   integer, parameter :: NACA2 = 0                                        ! NACA 翼の最大反り位置
   integer, parameter :: NACA34 = 12                                        ! NACA 翼の最大翼厚
   real, parameter :: a0 = 0.2969                                        ! 翼厚分布式の定数
   real, parameter :: a1 = -0.1260                                        ! 翼厚分布式の定数
   real, parameter :: a2 = -0.3516                                        ! 翼厚分布式の定数
   real, parameter :: a3 = 0.2843                                        ! 翼厚分布式の定数
   real, parameter :: a4 = -0.1015                                        ! 翼厚分布式の定数
   ! 共有変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   real   :: thick, ytmax, ycmax, xc
   ! 処理開始 ********************************************************************************************
   ! 検証実験ケース選択 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   write (*, '(a)') "<< Computational Condition >>"
   call SelectExpCase
   ! 初期設定 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   write (*, '(a)') '<< Initial Setting >>'
   call InitialSetting
! ! Main Grid +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! call MainGrid
! write(*, '(a)') '+++++ Main grid complete. +++++'
   ! Sub Grid +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   call SubGrid
   write (*, '(a)') '+++++ Sub grid complete. +++++'
   ! 内部手続き ******************************************************************************************
   stop
contains
!*******************************************************************************************************
!******** 検証実験ケース選択                                                                         ********
!*******************************************************************************************************
   subroutine SelectExpCase
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      character :: fname*20
      ! 処理開始 ********************************************************************************************
      ! 実験条件 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! 実験ケース入力
      write (*, '(a)') '* Select Exp. Case...'
      read (*, *) ExpCaseNum
      write (fname, '(i2.2)') ExpCaseNum
      ! 実験条件入力
      call Input_ExpCondition( &
      &      trim(ExpConditionFile)//trim(fname)//strtxt)
      ! 着氷モデル選択 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      write (*, '(a)') '* Select Icing Model...'
      read (*, *) ThermoNum
      write (fname, '(i2.2)') ThermoNum
      ! ディレクトリ設定 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      write (fname, '(a)') 'clean/'
      GrdOutDir = bckdir//'grid/'//trim(fname)
      ! 計算条件 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! 計算条件設定
      nCount = 0; nDrop = 0; IceStep = 0; IceStepMax = 5
      IceTime = 0.0; dti = 1.0e-3
      Cn = 1.0; nRunge = 4; nCalMax = 20000; nOutputLog = 1000; nOutputCount = 50000
      nTVD = 2; eTVD = 0.1; LmtPro = 0.1; LmtAve = 100.0
      TurbNum = 4; fSteady = .true.; fTime = .false.
      BCNum = 2; fSlip = .false.
      RoughNum = 1; RunbackNum = 1; DropShedNum = 0; IceShedNum = 0; DragNum = 1
      Cnd = 0.03
      nDrpIn = 1000000; nDrpCalMax = 100000; nDrpFile = 100; nDrpOutputLog = 100000; nDrpOutputCount = 50000
      Rg = 287.1; gamma = 1.4; Pr = 0.72; Prt = 0.90; Ret = 500.0; Cmu = 0.09
      muSth = 1.82e-5; TsSth = 273.15; s1 = 117.0
      ! 計算条件ファイル出力
      call Output_CalSetting(trim(ND_CalSetFile)//strtxt)
      ! 処理終了 ********************************************************************************************
      return
   end subroutine SelectExpCase
!*******************************************************************************************************
!********* 初期設定                                                                                ********
!*******************************************************************************************************
   subroutine InitialSetting
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 処理開始 ********************************************************************************************
      ! ブロック名設定 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      call Set_BlockName
      ! 構造体メモリ確保 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      allocate (Grd(ms:me))
      ! 翼形状 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ycmax = chord*real(NACA1)*1.0e-2
      xc = chord*real(NACA2)*1.0e-1
      thick = chord*real(NACA34)*1.0e-2
      ytmax = 0.5*thick
      ! 処理終了 ********************************************************************************************
      return
   end subroutine InitialSetting
!*******************************************************************************************************
!********* Main Grid 生成                                                                        ********
!*******************************************************************************************************
   subroutine MainGrid
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer :: m
      real    :: dom1, dom2, dom3
      ! 処理開始 ********************************************************************************************
      ! ブロック番号 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      m = 1
      ! 解像度 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      Grd(m)%is = 0
      Grd(m)%i1 = 192 + Grd(m)%is
      Grd(m)%i2 = 256 + Grd(m)%i1
      Grd(m)%i3 = 256 + Grd(m)%i2
      Grd(m)%ie = 192 + Grd(m)%i3
      Grd(m)%js = 0
      Grd(m)%je = 256
      Grd(m)%ks = 0
      Grd(m)%ke = 3
      ! 計算領域 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      dom1 = 10.0*chord                                                        ! 後縁から流出境界まで
      dom2 = 10.0*chord                                                        ! 後縁から外部境界まで
      dom3 = 10.0*chord                                                        ! 最大翼厚位置から流入境界まで
      ! メモリ確保 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      allocate (Grd(m)%x(Grd(m)%is:Grd(m)%ie, Grd(m)%js:Grd(m)%je, Grd(m)%ks:Grd(m)%ke), &
      &         Grd(m)%y(Grd(m)%is:Grd(m)%ie, Grd(m)%js:Grd(m)%je, Grd(m)%ks:Grd(m)%ke), &
      &         Grd(m)%z(Grd(m)%is:Grd(m)%ie, Grd(m)%js:Grd(m)%je, Grd(m)%ks:Grd(m)%ke), &
      &         Grd(m)%f(Grd(m)%is:Grd(m)%ie, Grd(m)%js:Grd(m)%je, Grd(m)%ks:Grd(m)%ke))
      ! 格子生成 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      write (*, '(a)') '+++++ C-typr grid generation start. +++++'
      call CtypeGridBlade( &
      &      Grd(m)%is, Grd(m)%ie, Grd(m)%js, Grd(m)%je, Grd(m)%ks, Grd(m)%ke, &
      &      Grd(m)%i1, Grd(m)%i2, Grd(m)%i3, dom1, dom2, dom3, &
      &      Grd(m)%x, Grd(m)%y, Grd(m)%z)
      ! 翼のフラグ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      call ViewBlade( &
      &      m, Grd(m)%is, Grd(m)%ie, Grd(m)%js, Grd(m)%je, Grd(m)%ks, Grd(m)%ke, &
      &      Grd(m)%i1, Grd(m)%i3, Grd(m)%js, Grd(m)%f)
      ! ファイル出力 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      call Output_Resolution3D( &
      &      trim(GrdOutDir)//trim(BlkName(m))//trim(RslFile), strtxt, &
      &      Grd(m)%is, Grd(m)%ie, Grd(m)%js, Grd(m)%je, Grd(m)%ks, Grd(m)%ke)
      call Output_Resolution1D( &
      &      trim(GrdOutDir)//trim(BlkName(m))//trim(IceRslFile), strtxt, &
      &      Grd(m)%i1, Grd(m)%i3)
      call Output_CtypeGridPoint( &
      &      trim(GrdOutDir)//trim(BlkName(m))//trim(CtypePointFile)//strtxt, &
      &      Grd(m)%i1, Grd(m)%i2, Grd(m)%i3)
      call Output_Grid3D( &
      &      trim(GrdOutDir)//trim(BlkName(m))//trim(GrdFile), strbin, &
      &      Grd(m)%is, Grd(m)%ie, Grd(m)%js, Grd(m)%je, Grd(m)%ks, Grd(m)%ke, &
      &      Grd(m)%x, Grd(m)%y, Grd(m)%z)
      ! 可視化 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      call MakeMAVSFile3D( &
      &      trim(GrdOutDir), trim(BlkName(m))//trim(ViewGrdFile), strbin, &
      &      Grd(m)%is, Grd(m)%ie, Grd(m)%js, Grd(m)%je, Grd(m)%ks, Grd(m)%ke, &
      &      Grd(m)%f, Grd(m)%x, Grd(m)%y, Grd(m)%z)
      call OutputPara_bin( &
       &      trim(GrdOutDir), trim(BlkName(m))//trim(ViewGrdFile), &
       &      Grd(m)%is, Grd(m)%ie, Grd(m)%js, Grd(m)%je, Grd(m)%ks, Grd(m)%ke, &
       &      Grd(m)%x, Grd(m)%y, Grd(m)%z)
      ! 処理終了 ********************************************************************************************
      return
   end subroutine MainGrid
!*******************************************************************************************************
!********* Sub Grid 生成                                                                        ********
!*******************************************************************************************************
   subroutine SubGrid
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer :: m
      real    :: dom1, dom2, dom3
      ! 処理開始 ********************************************************************************************
      ! ブロック番号 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      m = me
      ! 解像度 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      Grd(m)%is = 0
      Grd(m)%i1 = 192 + Grd(m)%is
      Grd(m)%i2 = 256 + Grd(m)%i1
      Grd(m)%i3 = 256 + Grd(m)%i2
      Grd(m)%ie = 192 + Grd(m)%i3
      Grd(m)%js = 0
      Grd(m)%je = 256
      Grd(m)%ks = 0
      Grd(m)%ke = 4
      ! 計算領域 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      dom1 = 10.0*chord                                                        ! 後縁から流出境界まで
      dom2 = 10.0*chord                                                        ! 後縁から外部境界まで
      dom3 = 10.0*chord                                                        ! 最大翼厚位置から流入境界まで
      ! メモリ確保 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      allocate (Grd(m)%x(Grd(m)%is:Grd(m)%ie, Grd(m)%js:Grd(m)%je, Grd(m)%ks:Grd(m)%ke), &
      &         Grd(m)%y(Grd(m)%is:Grd(m)%ie, Grd(m)%js:Grd(m)%je, Grd(m)%ks:Grd(m)%ke), &
      &         Grd(m)%z(Grd(m)%is:Grd(m)%ie, Grd(m)%js:Grd(m)%je, Grd(m)%ks:Grd(m)%ke), &
      &         Grd(m)%f(Grd(m)%is:Grd(m)%ie, Grd(m)%js:Grd(m)%je, Grd(m)%ks:Grd(m)%ke))
      ! 格子生成 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      write (*, '(a)') '+++++ C-typr grid generation start. +++++'
      call CtypeGridBlade( &
      &      Grd(m)%is, Grd(m)%ie, Grd(m)%js, Grd(m)%je, Grd(m)%ks, Grd(m)%ke, &
      &      Grd(m)%i1, Grd(m)%i2, Grd(m)%i3, dom1, dom2, dom3, &
      &      Grd(m)%x, Grd(m)%y, Grd(m)%z)
      ! 翼のフラグ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      call ViewBlade( &
      &      m, Grd(m)%is, Grd(m)%ie, Grd(m)%js, Grd(m)%je, Grd(m)%ks, Grd(m)%ke, &
      &      Grd(m)%i1, Grd(m)%i3, Grd(m)%js, Grd(m)%f)
      ! ファイル出力 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      call Output_Resolution3D( &
      &      trim(GrdOutDir)//trim(BlkName(m))//trim(RslFile), strtxt, &
      &      Grd(m)%is, Grd(m)%ie, Grd(m)%js, Grd(m)%je, Grd(m)%ks, Grd(m)%ke)
      call Output_Resolution1D( &
      &      trim(GrdOutDir)//trim(BlkName(m))//trim(IceRslFile), strtxt, &
      &      Grd(m)%i1, Grd(m)%i3)
      call Output_CtypeGridPoint( &
      &      trim(GrdOutDir)//trim(BlkName(m))//trim(CtypePointFile)//strtxt, &
      &      Grd(m)%i1, Grd(m)%i2, Grd(m)%i3)
      call Output_Grid3D( &
      &      trim(GrdOutDir)//trim(BlkName(m))//trim(GrdFile), strbin, &
      &      Grd(m)%is, Grd(m)%ie, Grd(m)%js, Grd(m)%je, Grd(m)%ks, Grd(m)%ke, &
      &      Grd(m)%x, Grd(m)%y, Grd(m)%z)
      ! 可視化 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      call MakeMAVSFile3D( &
      &      trim(GrdOutDir), trim(BlkName(m))//trim(ViewGrdFile), strbin, &
      &      Grd(m)%is, Grd(m)%ie, Grd(m)%js, Grd(m)%je, Grd(m)%ks, Grd(m)%ke, &
      &      Grd(m)%f, Grd(m)%x, Grd(m)%y, Grd(m)%z)
      call OutputPara_bin( &
       &      trim(GrdOutDir), trim(BlkName(m))//trim(ViewGrdFile), &
       &      Grd(m)%is, Grd(m)%ie, Grd(m)%js, Grd(m)%je, Grd(m)%ks, Grd(m)%ke, &
       &      Grd(m)%x, Grd(m)%y, Grd(m)%z)
      ! 処理終了 ********************************************************************************************
      return
   end subroutine SubGrid
!*******************************************************************************************************
!********* 翼周りの格子 (C-type)                                                                ********
!*******************************************************************************************************
   subroutine CtypeGridBlade( &
   &            is, ie, js, je, ks, ke, i1, i2, i3, dom1, dom2, dom3, x, y, z)
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer, intent(in)  :: is, ie, js, je, ks, ke
      integer, intent(in)  :: i1, i2, i3
      real, intent(in)  :: dom1, dom2, dom3
      real, intent(out) :: x(is:ie, js:je, ks:ke), &
      &                       y(is:ie, js:je, ks:ke), &
      &                       z(is:ie, js:je, ks:ke)
      ! 局所定数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      real, parameter :: rs1 = 1.0*1.0e-1                                ! 領域ⅰ起点格子幅
      real, parameter :: re1 = 4.79512133220952*1.0e-1                        ! 領域ⅰ終点格子幅
      real, parameter :: rs2 = 6.0*1.0e-0                                ! 領域ⅱ起点格子幅
      real, parameter :: re2 = 5.0*1.0e-2                               ! 領域ⅱ終点格子幅
      real, parameter :: rs3 = 5.0*1.0e-2                                ! 領域ⅲ起点格子幅
      real, parameter :: re3 = 6.0*1.0e-0                               ! 領域ⅲ終点格子幅
      real, parameter :: rs4 = 4.79512133220952*1.0e-1                        ! 領域ⅳ起点格子幅
      real, parameter :: re4 = 1.0*1.0e-1                               ! 領域ⅳ終点格子幅
      real, parameter :: rs5 = 3.28649582292613*1.0e-3                        ! 内部境界格子幅
      real, parameter :: re5 = 1.0*1.0e+2                                ! 外部境界格子幅
      real, parameter :: tb1 = 2.6579*1.0e-1                                ! 内部境界直交性のパラメータ
      real, parameter :: tb2 = 7.0*1.0e0                                ! 外部境界直交性のパラメータ
      real, parameter :: mgn = 3.0                                        ! 楕円-双曲型重み関数の許容誤差
      real, parameter :: rsd = 1.0e-5                                        ! 楕円-双曲型最大計算回数
      ! 処理開始 ********************************************************************************************
      ! 内部境界 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      call CtypeInternalBoundary( &
      &      is, i1, i2, i3, ie, dom1, rs1, re1, rs2, re2, rs3, re3, rs4, re4, x(:, js, ks), y(:, js, ks))
      ! 外部境界 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      call CtypeExternalBoundary( &
      &      is, i1, i2, i3, ie, js, je, dom2, dom3, x(:, :, ks), y(:, :, ks))
! ! 側部境界 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! call CtypeSideBoundary( &
! &      is, ie, js, je, x(:, :, ks), y(:, :, ks) )
! ! Transfinite 補間 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! call TransfiniteInterpolation( &
! &      is, ie, js, je, x(:, :, ks), y(:, :, ks) )
! ! 楕円-双曲型偏微分法 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! call CtypeGenerationEHPDE( &
! &      is, i1, i2, i3, ie, js, je, rs5, re5, mgn, rsd, x(:, :, ks), y(:, :, ks) )
      ! 二境界法 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      call GenerationTwoBoundary( &
      &      is, ie, js, je, rs5, re5, tb1, tb2, x(:, :, ks), y(:, :, ks))
      ! 三次元化 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      call ThreeDimensionalized( &
      &      is, ie, js, je, ks, ke, span, x, y, z)
      ! 処理終了 ********************************************************************************************
      return
   end subroutine CtypeGridBlade
!*******************************************************************************************************
!******** 内部境界 (C-type)                                                                        ********
!*******************************************************************************************************
   subroutine CtypeInternalBoundary( &
   &            is, i1, i2, i3, ie, dom, rs1, re1, rs2, re2, rs3, re3, rs4, re4, x, y)
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer, intent(in)  :: is, i1, i2, i3, ie
      real, intent(in)  :: dom
      real, intent(in)  :: rs1, re1, rs2, re2, rs3, re3, rs4, re4
      real, intent(out) :: x(is:ie), y(is:ie)
      ! 局所定数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer, parameter :: nmax = 10000
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      real, pointer :: xu(:), xl(:), yu(:), yl(:)
      real, pointer :: tu(:), tl(:), lu(:), ll(:)
      real, pointer :: x2(:), y2(:)
      real, pointer :: tb(:)
      real, pointer :: sy(:)
      integer :: n, i
      integer :: n1, n2, n3, n4, n5
      integer :: si
      real    :: xx, yy, yt, yc, theta
      real    :: rr
      ! 処理開始 ********************************************************************************************
      ! メモリ確保 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      allocate (xu(0:nmax), yu(0:nmax), xl(0:nmax), yl(0:nmax))
      allocate (tu(i2:i3), tl(i1:i2), lu(0:nmax), ll(0:nmax))
      allocate (x2(i1:i2), y2(i1:i2))
      allocate (tb(is:i1))
      ! 翼周り ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! 翼形状 ----------------------------------------------------------------------------------------------
      do n = 1, nmax - 1
         ! コード方向位置
         xx = chord*real(n)/real(nmax)
         ! 翼厚分布
         yt = 5.0*thick*(a0*(xx/chord)**0.5 + a1*(xx/chord)**1 + a2*(xx/chord)**2 &
         &                  + a3*(xx/chord)**3 + a4*(xx/chord)**4)
         ! 翼反り分布
         if (xc == 0.0) then
            yc = 0.0
         else
            if (xx < xc) then
               yc = ycmax*chord**2/xc**2*(2.0*xc*xx/chord**2 - xx**2/chord**2)
            else
               yc = ycmax*chord**2/(chord - xc)**2 &
                   &  *(1.0 - 2.0*xc/chord + 2.0*xc*xx/chord**2 - xx**2/chord**2)
            end if
         end if
         ! 翼座標
         theta = atan(yc/xx)
         xu(n) = xx - yt*sin(theta)
         yu(n) = yc + yt*cos(theta)
         xl(n) = xx + yt*sin(theta)
         yl(n) = yc - yt*cos(theta)
      end do
      xu(0) = 0.0; xu(nmax) = chord
      yu(0) = 0.0; yu(nmax) = 0.0
      xl(0) = 0.0; xl(nmax) = chord
      yl(0) = 0.0; yl(nmax) = 0.0
      ! 格子幅調整 ------------------------------------------------------------------------------------------
      ! 媒介変数
      call VinokurInterpolation(rs3/real(i3 - i2 + 1), re3/real(i3 - i2 + 1), i3 - i2 + 1, tu)
      call VinokurInterpolation(re2/real(i2 - i1 + 1), rs2/real(i2 - i1 + 1), i2 - i1 + 1, tl)
      ! 前縁からの距離
      lu(0) = 0.0; ll(0) = 0.0
      do n = 1, nmax
         lu(n) = sqrt((xu(n) - xu(n - 1))**2 + (yu(n) - yu(n - 1))**2) + lu(n - 1)
         ll(n) = sqrt((xl(n) - xl(n - 1))**2 + (yl(n) - yl(n - 1))**2) + ll(n - 1)
      end do
      ! 無次元化
      do n = 0, nmax
         lu(n) = lu(n)/lu(nmax)
         ll(n) = ll(n)/ll(nmax)
      end do
      ! ラグランジュ補間で探索 (上面)
      do i = i2 + 1, i3 - 1
         do n = 0, nmax - 1
            if (lu(n) <= tu(i) .and. tu(i) < lu(n + 1)) then
               select case (n)
               case default
                  n1 = n - 2; n2 = n - 1; n3 = n; n4 = n + 1; n5 = n + 2
                  call LagrangeInterpolation(5, lu(n1:n5), xu(n1:n5), tu(i), x(i))
                  call LagrangeInterpolation(5, lu(n1:n5), yu(n1:n5), tu(i), y(i))
               case (0)
                  n1 = n; n2 = n + 1; n3 = n + 2
                  call LagrangeInterpolation(3, lu(n1:n3), xu(n1:n3), tu(i), x(i))
                  call LagrangeInterpolation(3, lu(n1:n3), yu(n1:n3), tu(i), y(i))
               case (1)
                  n1 = n - 1; n2 = n; n3 = n + 1; n4 = n + 2
                  call LagrangeInterpolation(4, lu(n1:n4), xu(n1:n4), tu(i), x(i))
                  call LagrangeInterpolation(4, lu(n1:n4), yu(n1:n4), tu(i), y(i))
               case (nmax - 1)
                  n1 = n - 2; n2 = n - 1; n3 = n; n4 = n + 1
                  call LagrangeInterpolation(4, lu(n1:n4), xu(n1:n4), tu(i), x(i))
                  call LagrangeInterpolation(4, lu(n1:n4), yu(n1:n4), tu(i), y(i))
               end select
               exit
            end if
         end do
      end do
      x(i2) = xu(0); x(i3) = xu(nmax)
      y(i2) = yu(0); y(i3) = yu(nmax)
      ! ラグランジュ補間で探索 (下面)
      do i = i1 + 1, i2 - 1
         do n = 0, nmax - 1
            if (ll(n) <= tl(i) .and. tl(i) < ll(n + 1)) then
               select case (n)
               case default
                  n1 = n - 2; n2 = n - 1; n3 = n; n4 = n + 1; n5 = n + 2
                  call LagrangeInterpolation(5, ll(n1:n5), xl(n1:n5), tl(i), x(i))
                  call LagrangeInterpolation(5, ll(n1:n5), yl(n1:n5), tl(i), y(i))
               case (0)
                  n1 = n; n2 = n + 1; n3 = n + 2
                  call LagrangeInterpolation(3, ll(n1:n3), xl(n1:n3), tl(i), x(i))
                  call LagrangeInterpolation(3, ll(n1:n3), yl(n1:n3), tl(i), y(i))
               case (1)
                  n1 = n - 1; n2 = n; n3 = n + 1; n4 = n + 2
                  call LagrangeInterpolation(4, ll(n1:n4), xl(n1:n4), tl(i), x(i))
                  call LagrangeInterpolation(4, ll(n1:n4), yl(n1:n4), tl(i), y(i))
               case (nmax - 1)
                  n1 = n - 2; n2 = n - 1; n3 = n; n4 = n + 1
                  call LagrangeInterpolation(4, ll(n1:n4), xl(n1:n4), tl(i), x(i))
                  call LagrangeInterpolation(4, ll(n1:n4), yl(n1:n4), tl(i), y(i))
               end select
               exit
            end if
         end do
      end do
      x(i1) = xl(0); x(i2) = xl(nmax)
      y(i1) = yl(0); y(i2) = yl(nmax)
      ! 格子番号整理
      do i = i1, i2
         x2(i) = x(i1 + i2 - i)
         y2(i) = y(i1 + i2 - i)
      end do
      do i = i1, i2
         x(i) = x2(i)
         y(i) = y2(i)
      end do
      ! 後縁をスムージング ----------------------------------------------------------------------------------
      allocate (sy(is:ie))
      si = 3
      do n = 1, 5
         do i = i1 + 1, i1 + si
            sy(i) = (y(i - 1) + y(i) + y(i + 1))/3.0
         end do
         do i = i1 + 1, i1 + si
            y(i) = sy(i)
         end do
         do i = i3 - si, i3 - 1
            sy(i) = (y(i - 1) + y(i) + y(i + 1))/3.0
         end do
         do i = i3 - si, i3 - 1
            y(i) = sy(i)
         end do
      end do
      deallocate (sy)
      ! C 型格子ブランチ・カット ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      call GeometricInterpolationInv(re1/real(i1 - is + 1), i1 - is + 1, tb, rr)
      do i = is, i1 - 1
         x(i) = dom - (dom - x(i1))*tb(i)
         y(i) = y(i1)
      end do
      do i = i3, ie
         x(i) = x(ie - i)
         y(i) = y(ie - i)
      end do
      ! メモリ解放 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      deallocate (xu, yu, tu, lu, xl, yl, tl, ll, x2, y2, tb)
      ! 処理終了 ********************************************************************************************
      return
   end subroutine CtypeInternalBoundary
!*******************************************************************************************************
!******** 外部境界 (C-type)                                                                        ********
!*******************************************************************************************************
   subroutine CtypeExternalBoundary( &
   &            is, i1, i2, i3, ie, js, je, dom1, dom2, x, y)
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer, intent(in)    :: is, i1, i2, i3, ie, js, je
      real, intent(in)    :: dom1, dom2
      real, intent(inout) :: x(is:ie, js:je), y(is:ie, js:je)
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer :: i
      integer :: ic
      real    :: a1, a2, a3, b1, b2, b3, c1, c2, c3
      ! 処理開始 ********************************************************************************************
      ! C 型の湾曲部 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      do i = i1 + 1, i3 - 1
         ! 翼周り方向ベクトル
         a1 = 0.5*(-x(i - 1, js) + x(i + 1, js))
         a2 = 0.5*(-y(i - 1, js) + y(i + 1, js))
         a3 = 0.0
         ! スパン方向ベクトル
         b1 = 0.0
         b2 = 0.0
         b3 = -1.0
         ! 法線方向ベクトル
         c1 = a2*b3 - a3*b2
         c2 = a3*b1 - a1*b3
         c3 = a1*b2 - a2*b1
         ! 翼周り部外部領域
         x(i, je) = c1/sqrt(c1**2 + c2**2 + c3**2)*dom1 + x(i, js)
         y(i, je) = c2/sqrt(c1**2 + c2**2 + c3**2)*dom1 + y(i, js)
      end do
      ! C 型の直線部 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! x 方向 ----------------------------------------------------------------------------------------------
      ! 下面
      do i = i1 + 1, i2
         if (x(i, je) < x(i1, js)) exit
      end do
      ic = i - 1
      do i = is, ic
         x(i, je) = x(ic, je) + (x(is, js) - x(ic, je))*real(ic - i)/real(ic)
      end do
      ! 上面
      do i = i2, i3 - 1
         if (x(i, je) > x(i1, js)) exit
      end do
      ic = i
      do i = ic, ie
         x(i, je) = x(ic, je) + (x(is, js) - x(ic, je))*real(i - ic)/real(ie - ic)
      end do
      ! y 方向 ----------------------------------------------------------------------------------------------
      ! 下面
      do i = i1 + 1, i2
         if (y(i, je) == minval(y(i1 + 1:i2, je))) exit
      end do
      ic = i
      do i = is, ic - 1
         y(i, je) = minval(y(ic:i2, je))
      end do
      ! 上面
      do i = i2, i3 - 1
         if (y(i, je) == maxval(y(i2:i3 - 1, je))) exit
      end do
      ic = i
      do i = ic + 1, ie
         y(i, je) = maxval(y(i2:ic, je))
      end do
      ! 処理終了 ********************************************************************************************
      return
   end subroutine CtypeExternalBoundary
!*******************************************************************************************************
!******** 側部境界 (C-type)                                                                        ********
!*******************************************************************************************************
   subroutine CtypeSideBoundary( &
   &            is, ie, js, je, x, y)
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer, intent(in)    :: is, ie, js, je
      real, intent(inout) :: x(is:ie, js:je), y(is:ie, js:je)
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer :: j
      ! 処理開始 ********************************************************************************************
      do j = js + 1, je - 1
         x(is, j) = x(is, js)
         x(ie, j) = x(ie, js)
         y(is, j) = (y(is, je) - y(is, js))*real(j)/real(je) + y(is, js)
         y(ie, j) = (y(ie, je) - y(ie, js))*real(j)/real(je) + y(ie, js)
      end do
      ! 処理開始 ********************************************************************************************
      return
   end subroutine CtypeSideBoundary
!*******************************************************************************************************
!******** 楕円-双曲型偏微分方程式法に基づく格子生成                                                ********
!*******************************************************************************************************
   subroutine CtypeGenerationEHPDE( &
   &            is, i1, i2, i3, ie, js, je, rs, re, margin, resi, x, y)
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer, intent(in)    :: is, i1, i2, i3, ie, js, je
      real, intent(in)    :: rs, re
      real, intent(in)    :: margin                                        ! 楕円-双曲型重み関数許容誤差
      real, intent(in)    :: resi                                                ! 計算ループ収束判定値
      real, intent(inout) :: x(is:ie, js:je), y(is:ie, js:je)
      ! 局所定数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      real, parameter :: omg = 1.0                                        ! 緩和係数
      integer, parameter :: nmax = 100000                                        ! 最大計算回数
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      real, pointer :: Cs(:, :)
      real, pointer :: cv1m(:, :), cv1p(:, :), cv2m(:, :), cv2p(:, :)
      real, pointer :: dx1m(:, :), dx1p(:, :), dy1m(:, :), dy1p(:, :)
      real, pointer :: dx2m(:, :), dx2p(:, :), dy2m(:, :), dy2p(:, :)
      integer :: i, j, n
      real    :: dmax
      real    :: a1, a2, a3, b1, b2, b3, c1, c2, c3, hjs1, hjs2, hje1, hje2
      ! 処理開始 ********************************************************************************************
      ! メモリ確保 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      allocate (cs(is:ie, js:je), &
      &         cv1m(is:ie, js:je), cv1p(is:ie, js:je), cv2m(is:ie, js:je), cv2p(is:ie, js:je), &
      &         dx1m(is:ie, js:je), dx1p(is:ie, js:je), dy1m(is:ie, js:je), dy1p(is:ie, js:je), &
      &         dx2m(is:ie, js:je), dx2p(is:ie, js:je), dy2m(is:ie, js:je), dy2p(is:ie, js:je))
      ! パラメータ設定 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! 双曲型重み関数 --------------------------------------------------------------------------------------
      do j = js + 1, je - 1
      do i = is + 1, ie - 1
         ! i - 方向
         if (i < i1) then
            cv1m(i, j) = 1.0
         else if (i <= i3) then
            cv1m(i, j) = real(j)/real(je)*real(i3 - i)/real(i3 - i1)
         else
            cv1m(i, j) = 0.0
         end if
         ! i + 方向
         if (i3 < i) then
            cv1p(i, j) = 1.0
         else if (i1 <= i) then
            cv1p(i, j) = real(j)/real(je)*real(i - i1)/real(i3 - i1)
         else
            cv1p(i, j) = 0.0
         end if
         ! j - 方向
         cv2m(i, j) = (real(je - j)/real(je))**2
         ! j + 方向
         if (i2 < i) then
            cv2p(i, j) = (real(ie - i)/real(ie))**2
         else if (i == i2) then
            cv2p(i, j) = 0.0
         else
            cv2p(i, j) = (real(i)/real(ie))**2
         end if
!  cv2p(i,j) = (real(j-js) / real(je))**1 * 0.3
      end do
      end do
      ! 楕円型重み関数 --------------------------------------------------------------------------------------
      do j = js + 1, je - 1
      do i = is + 1, ie - 1
         ! 内部境界法線ベクトル
         a1 = 0.5*(-x(i - 1, js) + x(i + 1, js))
         a2 = 0.5*(-y(i - 1, js) + y(i + 1, js))
         a3 = 0.0
         b1 = 0.0
         b2 = 0.0
         b3 = -1.0
         c1 = a2*b3 - a3*b2
         c2 = a3*b1 - a1*b3
         hjs1 = c1/sqrt(c1**2 + c2**2)
         hjs2 = c2/sqrt(c1**2 + c2**2)
         ! 外部境界法線ベクトル
         a1 = 0.5*(-x(i - 1, je) + x(i + 1, je))
         a2 = 0.5*(-y(i - 1, je) + y(i + 1, je))
         a3 = 0.0
         b1 = 0.0
         b2 = 0.0
         b3 = -1.0
         c1 = a2*b3 - a3*b2
         c2 = a3*b1 - a1*b3
         hje1 = c1/sqrt(c1**2 + c2**2)
         hje2 = c2/sqrt(c1**2 + c2**2)
         ! i - 方向
         if (i < i1) then
            dx1m(i, j) = x(i, je) - x(i - 1, je)
            dy1m(i, j) = y(i, je) - y(i - 1, je)
         else if (i <= i3) then
            dx1m(i, j) = (-x(i - 1, js) + x(i, js))*real(je - j)/real(je) &
            &         + (-x(i - 1, je) + x(i, je))*(real(j - js)/real(je))**2
            dy1m(i, j) = (-y(i - 1, js) + y(i, js))*real(je - j)/real(je) &
            &         + (-y(i - 1, je) + y(i, je))*(real(j - js)/real(je))**2
         else
            dx1m(i, j) = 0.0
            dy1m(i, j) = 0.0
         end if
         ! i + 方向
         if (i3 < i) then
            dx1p(i, j) = x(i + 1, je) - x(i, je)
            dy1p(i, j) = y(i + 1, je) - y(i, je)
         else if (i1 <= i) then
            dx1p(i, j) = (-x(i, js) + x(i + 1, js))*real(je - j)/real(je) &
            &         + (-x(i, je) + x(i + 1, je))*(real(j - js)/real(je))**2
            dy1p(i, j) = (-y(i, js) + y(i + 1, js))*real(je - j)/real(je) &
            &         + (-y(i, je) + y(i + 1, je))*(real(j - js)/real(je))**2
         else
            dx1p(i, j) = 0.0
            dy1p(i, j) = 0.0
         end if
         ! j - 方向
         dx2m(i, j) = hjs1*rs
         dy2m(i, j) = hjs2*rs
         ! j + 方向
         dx2p(i, j) = hje1*re
         dy2p(i, j) = hje2*re
      end do
      end do
      ! 楕円-双曲型重み関数 ---------------------------------------------------------------------------------
      do j = js + 1, je - 1
      do i = is + 1, ie - 1
         Cs(i, j) = 1.0 - max(cv1m(i, j), cv1p(i, j), cv2m(i, j), cv2p(i, j)) + margin
      end do
      end do
      ! 格子生成計算ループ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      do n = 1, nmax
         ! ソルバー部 -----------------------------------------------------------------------------------------
         call GridEHPDE2D( &
         &      omg, is, ie, js, je, &
         &      cs, cv1m, cv1p, cv2m, cv2p, dx1m, dy1m, dx1p, dy1p, dx2m, dy2m, dx2p, dy2p, &
         &      x, y, dmax)
         if (mod(n, 1000) == 0.0) write (*, "(a,i5,e16.8e3)") "* Elliptic-Hyperbolic calculation...", n, dmax
         if (dmax < resi) exit
         ! 境界条件 -------------------------------------------------------------------------------------------
         do j = js + 1, je - 1
            y(is, j) = y(is + 1, j)
            y(ie, j) = y(ie - 1, j)
         end do
      end do
      if (dmax > resi) then
         write (*, '(a)') "!!!!! Elliptic-Hyperbolic calculation error !!!!!"
         stop
      end if
      ! 処理終了 ********************************************************************************************
      return
   end subroutine CtypeGenerationEHPDE
!*******************************************************************************************************
!********* 翼前縁付近の着氷計算用の格子 (H-type)                                                ********
!*******************************************************************************************************
   subroutine HtypeGridIceLE( &
   &            is, ie, js, je, ks, ke, dom1, dom2, x, y, z)
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer, intent(in)  :: is, ie, js, je, ks, ke
      real, intent(in)  :: dom1, dom2
      real, intent(out) :: x(is:ie, js:je, ks:ke), &
      &                       y(is:ie, js:je, ks:ke), &
      &                       z(is:ie, js:je, ks:ke)
      ! 局所定数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      real, parameter :: rs1 = 7.0*1.0e-2                                ! 前縁付近格子幅
      real, parameter :: re1 = 2.0*1.0e-0                                ! 着氷限界位置付近格子幅
      real, parameter :: rs2 = 5.0*1.0e-1                                ! 翼表面境界格子幅
      real, parameter :: re2 = 7.0*1.0e-2                                ! 翼遠方境界格子幅
      real, parameter :: tb1 = 1.0*1.0e-1                                ! 内部境界直交性のパラメータ
      real, parameter :: tb2 = 2.0*1.0e-1                                ! 外部境界直交性のパラメータ
      ! 処理開始 ********************************************************************************************
      ! 内部境界 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      call HtypeInternalBoundary( &
      &      is, ie, dom1, rs1, re1, x(:, js, ks), y(:, js, ks))
      ! 外部境界 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      call HtypeExternalBoundary( &
      &      is, ie, js, je, dom2, x(:, :, ks), y(:, :, ks))
! ! 側部境界 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! call HtypeSideBoundary( &
! &      is, ie, js, je, rs2, re2, x(:, :, ks), y(:, :, ks) )
! ! Transfinite 補間 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! call TransfiniteInterpolation( &
! &      is, ie, js, je, x(:, :, ks), y(:, :, ks) )
      ! 二境界法 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      call GenerationTwoBoundary( &
      &      is, ie, js, je, rs2, re2, tb1, tb2, x(:, :, ks), y(:, :, ks))
      ! 三次元化 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      call ThreeDimensionalized( &
      &      is, ie, js, je, ks, ke, span, x, y, z)
      ! 処理終了 ********************************************************************************************
      return
   end subroutine HtypeGridIceLE
!*******************************************************************************************************
!******** 内部境界 (H-type)                                                                        ********
!*******************************************************************************************************
   subroutine HtypeInternalBoundary( &
   &            is, ie, dom, rs, re, x, y)
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer, intent(in)  :: is, ie
      real, intent(in)  :: dom
      real, intent(in)  :: rs, re
      real, intent(out) :: x(is:ie), y(is:ie)
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      real, pointer :: xu(:), xl(:), yu(:), yl(:)
      real, pointer :: tu(:), tl(:), lu(:), ll(:)
      real, pointer :: x0(:), y0(:)
      real, pointer :: sy(:)
      integer :: n, i
      integer :: n1, n2, n3, n4, n5
      integer :: si
      integer :: i1
      integer :: nmax
      real    :: xx, yy, yt, yc, theta
      real    :: rr
      ! 処理開始 ********************************************************************************************
      ! 前縁格子番号 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      i1 = int(0.5*ie)
      ! メモリ確保 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      nmax = 10000
      allocate (xu(0:nmax), yu(0:nmax), xl(0:nmax), yl(0:nmax))
      allocate (tu(i1:ie), tl(is:i1), lu(0:nmax), ll(0:nmax))
      allocate (x0(is:i1), y0(is:i1))
      ! 翼周り ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! 翼形状 ----------------------------------------------------------------------------------------------
      do n = 1, nmax - 1
         ! コード方向位置
         xx = chord*real(n)/real(nmax)
         ! 翼厚分布
         yt = 5.0*thick*(a0*(xx/chord)**0.5 + a1*(xx/chord)**1 + a2*(xx/chord)**2 &
         &                  + a3*(xx/chord)**3 + a4*(xx/chord)**4)
         ! 翼反り分布
         if (xc == 0.0) then
            yc = 0.0
         else
            if (xx < xc) then
               yc = ycmax*chord**2/xc**2*(2.0*xc*xx/chord**2 - xx**2/chord**2)
            else
               yc = ycmax*chord**2/(chord - xc)**2 &
                   &  *(1.0 - 2.0*xc/chord + 2.0*xc*xx/chord**2 - xx**2/chord**2)
            end if
         end if
         ! 翼座標
         theta = atan(yc/xx)
         xu(n) = xx - yt*sin(theta)
         yu(n) = yc + yt*cos(theta)
         xl(n) = xx + yt*sin(theta)
         yl(n) = yc - yt*cos(theta)
      end do
      xu(0) = 0.0; xu(nmax) = chord
      yu(0) = 0.0; yu(nmax) = 0.0
      xl(0) = 0.0; xl(nmax) = chord
      yl(0) = 0.0; yl(nmax) = 0.0
      ! 計算領域 --------------------------------------------------------------------------------------------
      do n = 0, nmax
         if (xu(n) - xu(0) > dom) exit
      end do
      nmax = n
      ! 格子幅調整 ------------------------------------------------------------------------------------------
      ! 媒介変数
      call VinokurInterpolation(rs/real(ie - i1 + 1), re/real(ie - i1 + 1), ie - i1 + 1, tu)
      call VinokurInterpolation(rs/real(i1 - is + 1), re/real(i1 - is + 1), i1 - is + 1, tl)
      ! 前縁からの距離
      lu(0) = 0.0; ll(0) = 0.0
      do n = 1, nmax
         lu(n) = sqrt((xu(n) - xu(n - 1))**2 + (yu(n) - yu(n - 1))**2) + lu(n - 1)
         ll(n) = sqrt((xl(n) - xl(n - 1))**2 + (yl(n) - yl(n - 1))**2) + ll(n - 1)
      end do
      ! 無次元化
      do n = 0, nmax
         lu(n) = lu(n)/lu(nmax)
         ll(n) = ll(n)/ll(nmax)
      end do
      ! ラグランジュ補間で探索 (上面)
      do i = i1 + 1, ie - 1
         do n = 0, nmax - 1
            if (lu(n) <= tu(i) .and. tu(i) < lu(n + 1)) then
               if (n <= 0) then
                  n1 = n; n2 = n + 1; n3 = n + 2
                  call LagrangeInterpolation(3, lu(n1:n3), xu(n1:n3), tu(i), x(i))
                  call LagrangeInterpolation(3, lu(n1:n3), yu(n1:n3), tu(i), y(i))
               else if (n <= 1) then
                  n1 = n - 1; n2 = n; n3 = n + 1; n4 = n + 2
                  call LagrangeInterpolation(4, lu(n1:n4), xu(n1:n4), tu(i), x(i))
                  call LagrangeInterpolation(4, lu(n1:n4), yu(n1:n4), tu(i), y(i))
               else if (n < nmax - 1) then
                  n1 = n - 2; n2 = n - 1; n3 = n; n4 = n + 1; n5 = n + 2
                  call LagrangeInterpolation(5, lu(n1:n5), xu(n1:n5), tu(i), x(i))
                  call LagrangeInterpolation(5, lu(n1:n5), yu(n1:n5), tu(i), y(i))
               else
                  n1 = n - 2; n2 = n - 1; n3 = n; n4 = n + 1
                  call LagrangeInterpolation(4, lu(n1:n4), xu(n1:n4), tu(i), x(i))
                  call LagrangeInterpolation(4, lu(n1:n4), yu(n1:n4), tu(i), y(i))
               end if
               exit
            end if
         end do
      end do
      x(i1) = xu(0); x(ie) = xu(nmax)
      y(i1) = yu(0); y(ie) = yu(nmax)
      ! ラグランジュ補間で探索 (下面)
      do i = is + 1, i1 - 1
         do n = 0, nmax - 1
            if (ll(n) <= tl(i) .and. tl(i) < ll(n + 1)) then
               if (n <= 0) then
                  n1 = n; n2 = n + 1; n3 = n + 2
                  call LagrangeInterpolation(3, ll(n1:n3), xl(n1:n3), tl(i), x(i))
                  call LagrangeInterpolation(3, ll(n1:n3), yl(n1:n3), tl(i), y(i))
               else if (n <= 1) then
                  n1 = n - 1; n2 = n; n3 = n + 1; n4 = n + 2
                  call LagrangeInterpolation(4, ll(n1:n4), xl(n1:n4), tl(i), x(i))
                  call LagrangeInterpolation(4, ll(n1:n4), yl(n1:n4), tl(i), y(i))
               else if (n < nmax - 1) then
                  n1 = n - 2; n2 = n - 1; n3 = n; n4 = n + 1; n5 = n + 2
                  call LagrangeInterpolation(5, ll(n1:n5), xl(n1:n5), tl(i), x(i))
                  call LagrangeInterpolation(5, ll(n1:n5), yl(n1:n5), tl(i), y(i))
               else
                  n1 = n - 2; n2 = n - 1; n3 = n; n4 = n + 1
                  call LagrangeInterpolation(4, ll(n1:n4), xl(n1:n4), tl(i), x(i))
                  call LagrangeInterpolation(4, ll(n1:n4), yl(n1:n4), tl(i), y(i))
               end if
               exit
            end if
         end do
      end do
      x(is) = xu(0); x(i1) = xl(nmax)
      y(is) = yu(0); y(i1) = yl(nmax)
      ! 格子番号整理
      do i = is, i1
         x0(i) = x(is + i1 - i)
         y0(i) = y(is + i1 - i)
      end do
      do i = is, i1
         x(i) = x0(i)
         y(i) = y0(i)
      end do
      ! 処理終了 ********************************************************************************************
      return
   end subroutine HtypeInternalBoundary
!*******************************************************************************************************
!******** 外部境界 (H-type)                                                                        ********
!*******************************************************************************************************
   subroutine HtypeExternalBoundary( &
   &            is, ie, js, je, dom, x, y)
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer, intent(in)    :: is, ie, js, je
      real, intent(in)    :: dom
      real, intent(inout) :: x(is:ie, js:je), y(is:ie, js:je)
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer :: i
      integer :: ic
      real    :: a1, a2, a3, b1, b2, b3, c1, c2, c3
      ! 処理開始 ********************************************************************************************
      do i = is, ie
         ! 翼周り方向ベクトル
         if (i == is) then
            a1 = -x(i, js) + x(i + 1, js)
            a2 = -y(i, js) + y(i + 1, js)
         else if (i == ie) then
            a1 = -x(i - 1, js) + x(i, js)
            a2 = -y(i - 1, js) + y(i, js)
         else
            a1 = 0.5*(-x(i - 1, js) + x(i + 1, js))
            a2 = 0.5*(-y(i - 1, js) + y(i + 1, js))
         end if
         a3 = 0.0
         ! スパン方向ベクトル
         b1 = 0.0
         b2 = 0.0
         b3 = -1.0
         ! 法線方向ベクトル
         c1 = a2*b3 - a3*b2
         c2 = a3*b1 - a1*b3
         c3 = a1*b2 - a2*b1
         ! 翼周り部外部領域
         x(i, je) = c1/sqrt(c1**2 + c2**2 + c3**2)*dom + x(i, js)
         y(i, je) = c2/sqrt(c1**2 + c2**2 + c3**2)*dom + y(i, js)
      end do
      ! 処理終了 ********************************************************************************************
      return
   end subroutine HtypeExternalBoundary
!*******************************************************************************************************
!******** 側部境界 (H-type)                                                                        ********
!*******************************************************************************************************
   subroutine HtypeSideBoundary( &
   &            is, ie, js, je, rs, re, x, y)
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer, intent(in)    :: is, ie, js, je
      real, intent(in)    :: rs, re
      real, intent(inout) :: x(is:ie, js:je), y(is:ie, js:je)
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      real, pointer :: t(:)
      integer :: j
      real    :: rr
      ! 処理開始 ********************************************************************************************
      allocate (t(js:je))
      call GeometricInterpolation(rs/real(je - js + 1), je - js + 1, t, rr)
      do j = js + 1, je - 1
!  x(is,j) = x(is,js)
!  x(ie,j) = x(ie,js)
         x(is, j) = (x(is, je) - x(is, js))*t(j) + x(is, js)
         x(ie, j) = (x(ie, je) - x(ie, js))*t(j) + x(ie, js)
         y(is, j) = (y(is, je) - y(is, js))*t(j) + y(is, js)
         y(ie, j) = (y(ie, je) - y(ie, js))*t(j) + y(ie, js)
      end do
      deallocate (t)
      ! 処理開始 ********************************************************************************************
      return
   end subroutine HtypeSideBoundary
!*******************************************************************************************************
!******** Transfinite 補間                                                                        ********
!*******************************************************************************************************
   subroutine TransfiniteInterpolation( &
   &            is, ie, js, je, x, y)
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer, intent(in)    :: is, ie, js, je
      real, intent(inout) :: x(is:ie, js:je), y(is:ie, js:je)
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      real, pointer :: alp1(:), alp2(:), bet1(:), bet2(:)
      integer :: i, j
      ! 処理開始 ********************************************************************************************
      ! メモリ確保 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      allocate (alp1(is:ie), alp2(is:ie), bet1(js:je), bet2(js:je))
      ! Transfinite 補間 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! 媒介変数
      do i = is, ie
         alp1(i) = real(ie - i)/real(ie)
         alp2(i) = 1.0 - alp1(i)
      end do
      do j = js, je
         bet1(j) = real(je - j)/real(je)
         bet2(j) = 1.0 - bet1(j)
      end do
      ! 補間
      call Transfinite2D(is, ie, js, je, alp1, alp2, bet1, bet2, x)
      call Transfinite2D(is, ie, js, je, alp1, alp2, bet1, bet2, y)
      ! メモリ解放 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      deallocate (alp1, alp2, bet1, bet2)
      ! 処理終了 ********************************************************************************************
      return
   end subroutine TransfiniteInterpolation
!*******************************************************************************************************
!******** 二境界法に基づく格子生成                                                                ********
!*******************************************************************************************************
   subroutine GenerationTwoBoundary( &
   &            is, ie, js, je, rs, re, t1, t2, x, y)
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer, intent(in)    :: is, ie, js, je
      real, intent(in)    :: rs, re, t1, t2
      real, intent(inout) :: x(is:ie, js:je), y(is:ie, js:je)
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      real, pointer :: etabar(:)
      real    :: rr
      ! 処理開始 ********************************************************************************************
      ! メモリ確保
      allocate (etabar(js:je))
      ! 媒介変数
      call GeometricInterpolation(rs/real(je - js + 1), je - js + 1, etabar, rr)
      ! 二境界法
      call TwoBoundaryMethod2D( &
      &      is, ie, js, je, t1, t2, etabar, x, y)
      ! メモリ解放
      deallocate (etabar)
      ! 処理終了 ********************************************************************************************
      return
   end subroutine GenerationTwoBoundary
!*******************************************************************************************************
!******** 三次元化 (スパン方向変化なし)                                                                ********
!*******************************************************************************************************
   subroutine ThreeDimensionalized( &
   &            is, ie, js, je, ks, ke, dom, x, y, z)
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer, intent(in)    :: is, ie, js, je, ks, ke
      real, intent(in)    :: dom
      real, intent(inout) :: x(is:ie, js:je, ks:ke), y(is:ie, js:je, ks:ke)
      real, intent(out)   :: z(is:ie, js:je, ks:ke)
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer :: i, j, k
      ! 処理開始 ********************************************************************************************
      do k = ks, ke
      do j = js, je
      do i = is, ie
         x(i, j, k) = x(i, j, ks)
         y(i, j, k) = y(i, j, ks)
         z(i, j, k) = -0.5*dom + dom*real(k)/real(ke)
      end do
      end do
      end do
      ! 処理終了 ********************************************************************************************
      return
   end subroutine ThreeDimensionalized
!*******************************************************************************************************
!******** 翼のフラグ                                                                                ********
!*******************************************************************************************************
   subroutine ViewBlade( &
   &            m, is, ie, js, je, ks, ke, ibs, ibe, j0, f)
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer, intent(in)  :: m
      integer, intent(in)  :: is, ie, js, je, ks, ke
      integer, intent(in)  :: ibs, ibe, j0
      integer, intent(out) :: f(is:ie, js:je, ks:ke)
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer :: i, j, k
      ! 処理開始 ********************************************************************************************
      do k = ks, ke
      do j = js, je
      do i = is, ie
         if (ibs <= i .and. i <= ibe .and. j == j0) then
            f(i, j, k) = 1
         else
            f(i, j, k) = 0
!    f(i,j,k) = m
         end if
      end do
      end do
      end do
      ! 処理終了 ********************************************************************************************
   end subroutine ViewBlade
!*******************************************************************************************************
!******** MicroAVSファイル作成（三次元）                                                          ********
!*******************************************************************************************************
   subroutine MakeMAVSFile3D( &
   &            strdir, strname, ext, is, ie, js, je, ks, ke, f, x, y, z)
      ! 変数宣言 ********************************************************************************************
      implicit none
      ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      character, intent(in)  :: strdir*(*), strname*(*), ext*4
      integer, intent(in)  :: is, ie, js, je, ks, ke
      integer, intent(in)  :: f(is:ie, js:je, ks:ke)
      real, intent(in)  :: x(is:ie, js:je, ks:ke), y(is:ie, js:je, ks:ke), z(is:ie, js:je, ks:ke)
      ! 局所定数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      character, parameter :: strbin*4 = '.bin'
      character, parameter :: strfld*4 = '.fld'
      integer, parameter :: ndim = 3
      integer, parameter :: nspace = 3
      integer, parameter :: veclen = 1
      ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      integer   :: nrkind, nskip
      real      :: r
      integer   :: i, j, k, n
      ! 処理開始 ********************************************************************************************
      ! ヘッダファイル出力 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      open (1, file=trim(strdir)//trim(strname)//trim(strfld), form='formatted')
      write (1, '(a)') '# AVS field file'
      write (1, '(a,i1)') 'ndim   = ', ndim
      write (1, '(a,i4)') 'dim1   = ', ie - is + 1
      write (1, '(a,i4)') 'dim2   = ', je - js + 1
      write (1, '(a,i4)') 'dim3   = ', ke - ks + 1
      write (1, '(a)') 'label  = flag'
      write (1, '(a,i1)') 'nspace = ', nspace
      write (1, '(a,i2)') 'veclen = ', veclen
      write (1, '(a)') 'data   = float'
      write (1, '(a)') 'field  = irregular'
      select case (ext)
         ! Binary ----------------------------------------------------------------------------------------------
      case (strbin)
         nrkind = kind(r)
         nskip = nrkind*(ie - is + 1)*(je - js + 1)*(ke - ks + 1) + 8
         do n = 1, veclen
            write (1, '((a,i2), (x,2a), (x,a), (x,a,i11), 2(x,a,i1))') &
            & 'variable ', n, &
            & 'file = ', trim(strname)//ext, &
            & 'filetype = binary', &
            & 'skip = ', 4 + nskip*(n - 1), &
            & 'stride = ', 1, &
            & 'close = ', 1
         end do
         do n = 1, nspace
            write (1, '((a,i1), (x,2a), (x,a), (x,a,i11), 2(x,a,i1))') &
            & 'coord ', n, &
            & 'file = ', trim(strname)//ext, &
            & 'filetype = binary', &
            & 'skip = ', 4 + nskip*(veclen + n - 1), &
            & 'stride = ', 1, &
            & 'close = ', 1
         end do
         ! Aschii ----------------------------------------------------------------------------------------------
      case default
         do n = 1, veclen
            write (1, '((a,i2), (1x,2a), (1x,a), (1x,a,i1), 2(1x,a,i2), (1x,a,i1))') &
            & 'variable ', n, &
            & 'file = ', trim(strname)//ext, &
            & 'filetype = ascii', &
            & 'skip = ', 0, &
            & 'offset = ', n - 1, &
            & 'stride = ', veclen + nspace, &
            & 'close = ', 1
         end do
         do n = 1, nspace
            write (1, '((a,i1), (1x,2a), (1x,a), (1x,a,i1), 2(1x,a,i2), (1x,a,i1))') &
            & 'coord ', n, &
            & 'file = ', trim(strname)//ext, &
            & 'filetype = ascii', &
            & 'skip = ', 0, &
            & 'offset = ', veclen + n - 1, &
            & 'stride = ', veclen + nspace, &
            & 'close = ', 1
         end do
      end select
      close (1)
      ! データファイル出力 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      select case (ext)
         ! Binary ----------------------------------------------------------------------------------------------
      case (strbin)
         open (1, file=trim(strdir)//trim(strname)//ext, form='unformatted', status='replace')
         write (1) real(f); write (1) x; write (1) y; write (1) z
         close (1)
         close (1)
         ! Aschii ----------------------------------------------------------------------------------------------
      case default
         open (1, file=trim(strdir)//trim(strname)//ext, form='formatted', status='replace')
         do k = ks, ke
         do j = js, je
         do i = is, ie
            write (1, '(e16.8e3, 3(x,e16.8e3))') real(f(i, j, k)), x(i, j, k), y(i, j, k), z(i, j, k)
         end do
         end do
         end do
         close (1)
      end select
      ! 処理終了 ********************************************************************************************
      return
   end subroutine MakeMAVSFile3D
!*******************************************************************************************************
!******** vtkファイル出力サブルーチン                                                                 ********
!*******************************************************************************************************
   subroutine OutputPara_bin( &
   &      strdir, strname, is, ie, js, je, ks, ke, &
   &      x, y, z)
      implicit none
      !mainroutine_variable
      character, intent(in)  :: strdir*(*), strname*(*)
      integer, intent(in)  :: is, ie, js, je, ks, ke
      real, intent(in)  :: x(is:ie, js:je, ks:ke), y(is:ie, js:je, ks:ke), z(is:ie, js:je, ks:ke)
      !subroutine_variable
      character(len=4), parameter                :: strvtk = '.vtk'
      character(len=1), parameter                :: newline = char(10)
      character(len=200)        :: strnum
      integer                :: i, j, k, n
      integer                :: ni, nj, nk
      integer                :: npoint

      npoint = (ie - is)*(je - js)*(ke - ks)
      open (unit=1, &
            file=trim(strdir)//trim(strname)//trim(strvtk), &
            form='unformatted', &
            access='stream', &          ! ← ここを stream に
            convert='big_endian', &      ! GNU拡張（OK）。気になるなら -fconvert で全体指定でも可
            action='write')
      write (1) '# vtk DataFile Version 3.0'//newline
      write (1) 'vtk output'//newline
      write (1) 'BINARY'//newline
      write (1) 'DATASET UNSTRUCTURED_GRID'//newline
      write (strnum, *) npoint*8
      write (1) 'POINTS'//trim(strnum)//' float'//newline
      do n = 0, npoint - 1
         ni = mod(mod(n, (ie - is)*(je - js)), (ie - is))
         nj = int(mod(n, (ie - is)*(je - js))/(ie - is))
         nk = int(n/((ie - is)*(je - js)))
         write (1) x(ni, nj, nk), y(ni, nj, nk), z(ni, nj, nk)
         write (1) x(ni + 1, nj, nk), y(ni + 1, nj, nk), z(ni + 1, nj, nk)
         write (1) x(ni + 1, nj + 1, nk), y(ni + 1, nj + 1, nk), z(ni + 1, nj + 1, nk)
         write (1) x(ni, nj + 1, nk), y(ni, nj + 1, nk), z(ni, nj + 1, nk)
         write (1) x(ni, nj, nk + 1), y(ni, nj, nk + 1), z(ni, nj, nk + 1)
         write (1) x(ni + 1, nj, nk + 1), y(ni + 1, nj, nk + 1), z(ni + 1, nj, nk + 1)
         write (1) x(ni + 1, nj + 1, nk + 1), y(ni + 1, nj + 1, nk + 1), z(ni + 1, nj + 1, nk + 1)
         write (1) x(ni, nj + 1, nk + 1), y(ni, nj + 1, nk + 1), z(ni, nj + 1, nk + 1)
      end do
      write (1) newline
      write (strnum, *) npoint, npoint*9
      write (1) 'CELLS'//trim(strnum)//newline
      do n = 0, npoint - 1
         write (1) 8, n*8 + 0, n*8 + 1, n*8 + 2, n*8 + 3, n*8 + 4, n*8 + 5, n*8 + 6, n*8 + 7
      end do
      write (1) newline
      write (strnum, *) npoint
      write (1) 'CELL_TYPES'//trim(strnum)//newline
      do n = 0, npoint - 1
         write (1) 12
      end do
      write (1) newline
      write (strnum, *) npoint*8
      write (1) 'POINT_DATA'//trim(strnum)//newline
      write (1) 'SCALARS n float'//newline
      write (1) 'LOOKUP_TABLE default'//newline
      do n = 0, npoint - 1
         write (1) real(n*8 + 0)
         write (1) real(n*8 + 1)
         write (1) real(n*8 + 2)
         write (1) real(n*8 + 3)
         write (1) real(n*8 + 4)
         write (1) real(n*8 + 5)
         write (1) real(n*8 + 6)
         write (1) real(n*8 + 7)
      end do
      close (1)

   end subroutine OutputPara_bin
! 定義終了 *********************************************************************************************
end program GridGeneration_NACA
```

## file "Mod_Package_Droplet.f90"

```fortran
!*******************************************************************************************************
!*******************************************************************************************************
!******** パッケージ型モジュール                                    				********
!******** 液滴軌道計算用サブルーチン群                              				********
!********  				              2013.05.15  PROGRAMMED BY RYOSKUE HAYASHI	********
!********					      2013.06.18     UPDATED BY RYOSKUE HAYASHI	********
!********					      2013.06.24     UPDATED BY RYOSKUE HAYASHI	********
!********					      2013.07.21     UPDATED BY RYOSKUE HAYASHI	********
!********					      2014.04.15     UPDATED BY RYOSKUE HAYASHI	********
!********					      2014.12.08     UPDATED BY MIKI	SHIMURA	********
!********					      2015.04.29     UPDATED BY MIKI	SHIMURA	********
!********					      2015.05.04     UPDATED BY MIKI	SHIMURA	********
!******** 球の抗力係数を統一									********
!******** Schiller and Naumman			      2015.05.11     UPDATED BY MIKI    SHIMURA ********
!******** 											********
!******** 収集効率を衝突量から計算                    2015.05.27     UPDATED BY MIKI    SHIMURA ********
!*******************************************************************************************************
!*******************************************************************************************************
!*******************************************************************************************************
module Package_Droplet
 ! 変数宣言 ********************************************************************************************
 implicit none
 private
 ! サブルーチン宣言 ************************************************************************************
 ! 共有サブルーチン ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 public :: DropletBreakup        , CalAspectRatio
 public :: Drag2D                , Drag3D           
 public :: WiegandDrag           , WebernumberDrag
 public :: DragGennaro           , VargasFeoDrag
 public :: GravityBuoyancy2D     , GravityBuoyancy3D
 public :: Rotation2D            , Rotation3D       
 public :: TimeEuler2D           , TimeEuler3D      
 public :: TimeEulerTemperature2D, TimeEulerTemperature3D
 public :: Velocity2D            , Velocity3D       
 public :: dt2D       	         , dt3D          
 public :: ImpingementJudge3D
 public :: ImpingementArea3D
 public :: ImpingementVelocity3D
 public :: ImpingementTemperature3D
 public :: CollectionEfficiency3D
 public :: SplashLEWICE3D        , SplashSamenfink
 public :: MakeMAVSFileDroplet3D
 public :: MakeMAVSFileDropletTemperature3D
 public :: MakeMAVSFileDropletWe3D
 public :: MakeMAVSFileSLD3D
 ! 共有定数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real, parameter :: pi   = 3.1415926535897932
 real, parameter :: zero = 1.0e-20
 ! 内部手続き ******************************************************************************************
contains
!*******************************************************************************************************
!******** 液滴分裂モデル									********
!******** LEWICEに使ってるモデル？								********
!*******************************************************************************************************
subroutine DropletBreakup( &
&            dp1, rhop, up, vp, wp, rhof, uf, vf, wf, mup, sigp, fBreakup, nBrk, &
&            dp2 )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! 液滴のパラメータ ------------------------------------------------------------------------------------
 real, intent(in)  :: dp1
 real, intent(in)  :: up, vp, wp
 real, intent(in)  :: rhop, mup, sigp
 ! 流体のパラメータ ------------------------------------------------------------------------------------
 real, intent(in)  :: uf, vf, wf
 real, intent(in)  :: rhof
 ! 液滴分裂のフラグと液滴数 ----------------------------------------------------------------------------
 logical, intent(out) :: fBreakup
 integer, intent(inout) :: nBrk
 ! 分裂後の液滴径 --------------------------------------------------------------------------------------
 real, intent(out) :: dp2
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: Vel, We, Rep
 ! 処理開始 ********************************************************************************************
 Vel = sqrt((uf - up)**2 + (vf - vp)**2 + (wf - wp)**2)
 ! ウェーバー数 ----------------------------------------------------------------------------------------
 We = rhof * Vel**2 * dp1 / sigp
 ! 液滴のレイノルズ数 ----------------------------------------------------------------------------------
 Rep = rhop * Vel * dp1 / mup
 ! 分裂後の液滴径 --------------------------------------------------------------------------------------
 if(We > 13.0)then
  fBreakup = .true.
  dp2 = 6.2 * (rhop / rhof)**0.25 * Rep**(-0.5) * dp1
  nBrk = nBrk + 1
 else
  fBreakup = .false.
  dp2 = dp1
 endif
 ! 処理終了 ********************************************************************************************
 return
end subroutine DropletBreakup
!*******************************************************************************************************
!******** 液滴の変形のアスペクト比の計算							********
!******** Quasi-steady deformation and drag of uncontaminated liquid drops			********
!******** B.T.Helenbrook, C.F.Edward (2002)							********
!*******************************************************************************************************
subroutine CalAspectRatio( &
&            dp, rhop, up, vp, wp, rhof, uf, vf, wf, mup, sigp, muf, &
&            AsRatio )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! 液滴のパラメータ ------------------------------------------------------------------------------------
 real, intent(in)  :: dp
 real, intent(in)  :: up, vp, wp
 real, intent(in)  :: rhop, mup, sigp
 ! 流体のパラメータ ------------------------------------------------------------------------------------
 real, intent(in)  :: uf, vf, wf
 real, intent(in)  :: rhof, muf
 ! アスペクト比 ----------------------------------------------------------------------------------------
 real, intent(out) :: AsRatio
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: Vel, We, Oh
 ! 処理開始 ********************************************************************************************
 Vel = sqrt((uf - up)**2 + (vf - vp)**2 + (wf - wp)**2)
 ! ウェーバー数 ----------------------------------------------------------------------------------------
 We = rhof * Vel**2 * dp / sigp
 ! オーネゾルゲ数 --------------------------------------------------------------------------------------
 Oh = mup / sqrt(rhop * sigp * dp)
 ! アスペクト比 ----------------------------------------------------------------------------------------
 AsRatio = 1.0 - 0.11 * We**0.82 + 0.013 * sqrt(rhop / rhof) * muf / mup * Oh**0.55 * We**1.1
 ! 処理終了 ********************************************************************************************
 return
end subroutine CalAspectRatio
!*******************************************************************************************************
!******** 定常抗力 (二次元)    		                               				********
!*******************************************************************************************************
subroutine Drag2D( &
&            dp, rhop, up, vp, rhof, uf, vf, muf, &
&            fx, fy, Cd )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! 液滴のパラメータ ------------------------------------------------------------------------------------
 real, intent(in)  :: dp                      				! 直径
 real, intent(in)  :: rhop                    				! 密度
 real, intent(in)  :: up, vp                  				! 速度
 ! 流体のパラメータ ------------------------------------------------------------------------------------
 real, intent(in)  :: rhof                 				! 密度
 real, intent(in)  :: uf, vf                  				! 速度
 real, intent(in)  :: muf                  				! 粘性係数
 ! 定常抗力 --------------------------------------------------------------------------------------------
 real, intent(out) :: fx, fy, Cd
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: vel, Rep, f
 ! 処理開始 ********************************************************************************************
 ! 液滴レイノルズ数 ------------------------------------------------------------------------------------
 vel = sqrt((uf - up)**2 + (vf - vp)**2)
 Rep = vel * dp * rhof / max(zero, muf)
 Rep = min(1000.0, max(0.01, Rep))
 ! 抵抗係数 --------------------------------------------------------------------------------------------
 cd = 24.0 / Rep * (1.0 + 0.15 * Rep**0.687)
 ! 単位質量の液滴に働く抗力 ----------------------------------------------------------------------------
 f  = 3.0 * cd * rhof / (4.0 * rhop * dp)
 fx = f * vel * (uf - up)
 fy = f * vel * (vf - vp)
 ! 処理終了 ********************************************************************************************
 return
end subroutine Drag2D
!*******************************************************************************************************
!******** 定常抗力 (三次元) 	                				                ********
!*******************************************************************************************************
subroutine Drag3D( &
&            dp, rhop, up, vp, wp, rhof, uf, vf, wf, muf, &
&            fx, fy, fz, Cd )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! 液滴のパラメータ ------------------------------------------------------------------------------------
 real, intent(in)  :: dp                      				! 直径
 real, intent(in)  :: rhop                    				! 密度
 real, intent(in)  :: up, vp, wp              				! 速度
 ! 流体のパラメータ ------------------------------------------------------------------------------------
! real, intent(in)  :: ReRef       				        ! 代表レイノルズ数
 real, intent(in)  :: rhof        				        ! 密度
 real, intent(in)  :: uf, vf, wf  				        ! 速度
 real, intent(in)  :: muf         				        ! 粘性係数
 ! 定常抗力 --------------------------------------------------------------------------------------------
 real, intent(out) :: fx, fy, fz, Cd
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: vel, Rep, f
 ! 処理開始 ********************************************************************************************
 ! 液滴レイノルズ数 ------------------------------------------------------------------------------------
 vel = sqrt((uf - up)**2 + (vf - vp)**2 + (wf - wp)**2)
 Rep = vel * dp * rhof / max(zero, muf)
 Rep = min(1000.0, max(0.01, Rep))
 ! 抵抗係数 --------------------------------------------------------------------------------------------
 cd = 24.0 / Rep * (1.0 + 0.15 * Rep**0.687)
 ! 単位質量の液滴に働く抗力 ----------------------------------------------------------------------------
 f  = 3.0 * cd * rhof / (4.0 * rhop * dp)
 fx = f * vel * (uf - up)
 fy = f * vel * (vf - vp)
 fz = f * vel * (wf - wp)
 ! 処理終了 ********************************************************************************************
 return
end subroutine Drag3D
! 抗力 *************************************************************************************************
! De Gennaro (2009) , Mingione (2012) 
subroutine DragGennaro( &
&            dp, rhop, up, vp, wp, rhof, uf, vf, wf, muf, &
&            fx, fy, fz, Cd )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! 液滴のパラメータ ------------------------------------------------------------------------------------
 real, intent(in)  :: dp                      				! 直径
 real, intent(in)  :: rhop                    				! 密度
 real, intent(in)  :: up, vp, wp              				! 速度
 ! 流体のパラメータ ------------------------------------------------------------------------------------
! real, intent(in)  :: ReRef       				        ! 代表レイノルズ数
 real, intent(in)  :: rhof        				        ! 密度
 real, intent(in)  :: uf, vf, wf  				        ! 速度
 real, intent(in)  :: muf         				        ! 粘性係数
 ! 定常抗力 --------------------------------------------------------------------------------------------
 real, intent(out) :: fx, fy, fz, Cd
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: vel, Rep, f
 ! 処理開始 ********************************************************************************************
 ! 液滴レイノルズ数 ------------------------------------------------------------------------------------
 vel = sqrt((uf - up)**2 + (vf - vp)**2 + (wf - wp)**2)
 Rep = vel * dp * rhof / max(zero, muf)
 Rep = min(1000.0, max(0.01, Rep))
 ! 抵抗係数 --------------------------------------------------------------------------------------------
 if( Rep <= 345.0 ) then
  cd = 24.0 / Rep * (1.0 + 0.15 * Rep**0.687)
 else if( (345.0 < Rep) .and. (Rep <= 385.0) ) then 
  cd = 24.0 / Rep * (-0.00355 * Rep + 3.760)
 else if( (385.0 < Rep) .and. (Rep <= 442.0) ) then 
  cd = 24.0 / Rep * (-0.00517 * Rep + 4.782)
 else if( (442.0 < Rep) .and. (Rep <= 475.0) ) then 
  cd = 24.0 / Rep * (-0.00255 * Rep + 3.425)
 else if( (475.0 < Rep) .and. (Rep <= 518.0) ) then 
  cd = 24.0 / Rep * ( 0.0318  * Rep - 12.903)
 else if( (518.0 < Rep) .and. (Rep <= 630.0) ) then 
  cd = 24.0 / Rep * ( 0.00333 * Rep - 0.313)
 else if( (630.0 < Rep) .and. (Rep <= 720.0) ) then 
  cd = 24.0 / Rep * (-0.00325 * Rep + 2.221)
 else if(720.0 < Rep)then
  cd = 24.0 / Rep * (1.0 + 0.15 * Rep**0.687)
 endif
 ! 単位質量の液滴に働く抗力 ----------------------------------------------------------------------------
 f  = 3.0 * cd * rhof / (4.0 * rhop * dp)
 fx = f * vel * (uf - up)
 fy = f * vel * (vf - vp)
 fz = f * vel * (wf - wp)
 ! 処理終了 ********************************************************************************************
 return
end subroutine DragGennaro
! 抗力 *************************************************************************************************
! Wiegand (1987)
! Schmehl "Tropfendeformation und Nachzerfall bei der technischen Gemischaufbereitung" 2003
! ******************************************************************************************************
subroutine WiegandDrag( &
&            dp, rhop, up, vp, wp, rhof, uf, vf, wf, muf, sigp, &
&            fx, fy, fz, Cd )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! 液滴のパラメータ ------------------------------------------------------------------------------------
 real, intent(in)  :: dp                      				! 直径
 real, intent(in)  :: rhop                    				! 密度
 real, intent(in)  :: up, vp, wp              				! 速度
 ! 流体のパラメータ ------------------------------------------------------------------------------------
! real, intent(in)  :: ReRef       				        ! 代表レイノルズ数
 real, intent(in)  :: rhof        				        ! 密度
 real, intent(in)  :: uf, vf, wf  				        ! 速度
 real, intent(in)  :: muf         				        ! 粘性係数
 ! 定常抗力 --------------------------------------------------------------------------------------------
 real, intent(out) :: fx, fy, fz, Cd
 real, intent(in)  :: sigp
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: vel, Rep, f, We, cdin, cddef
 ! 処理開始 ********************************************************************************************
 ! 液滴レイノルズ数 ------------------------------------------------------------------------------------
 vel = sqrt((uf - up)**2 + (vf - vp)**2 + (wf - wp)**2)
 Rep = vel * dp * rhof / max(zero, muf)
 Rep = min(1000.0, max(0.01, Rep))
 ! Weber Number ----------------------------------------------------------------------------------------
 We = rhof * vel**2 * dp / sigp
 ! 抵抗係数 --------------------------------------------------------------------------------------------
 !if(Rep <= 1000.0) then
 cdin = 24.0 / Rep * (1.0 + 0.15 * Rep**0.687)
 !else if (1000.0 < Rep) then
 !cdin = 0.424
 !endif
 cddef = We * ( 0.2319 - 0.1579 * log(Rep) + 0.0471 * (log(Rep))**2 - 0.0042 * (log(Rep))**3)
 cd = cdin + cddef
 ! 単位質量の液滴に働く抗力 ----------------------------------------------------------------------------
 f  = 3.0 * cd * rhof / (4.0 * rhop * dp)
 fx = f * vel * (uf - up)
 fy = f * vel * (vf - vp)
 fz = f * vel * (wf - wp)
 ! 処理終了 ********************************************************************************************
 return
end subroutine WiegandDrag
! 抗力 *************************************************************************************************
! Shpere と Disk の比 (ウェーバー数)
! ******************************************************************************************************
subroutine WebernumberDrag( &
&            dp, rhop, up, vp, wp, rhof, uf, vf, wf, muf, sigd, &
&            fx, fy, fz, Cd )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! 液滴のパラメータ ------------------------------------------------------------------------------------
 real, intent(in)  :: dp                      				! 直径
 real, intent(in)  :: rhop                    				! 密度
 real, intent(in)  :: up, vp, wp              				! 速度
 real, intent(in)  :: Sigd						! 表面張力
 ! 流体のパラメータ ------------------------------------------------------------------------------------
! real, intent(in)  :: ReRef       				        ! 代表レイノルズ数
 real, intent(in)  :: rhof        				        ! 密度
 real, intent(in)  :: uf, vf, wf  				        ! 速度
 real, intent(in)  :: muf         				        ! 粘性係数
 ! 定常抗力 --------------------------------------------------------------------------------------------
 real, intent(out) :: fx, fy, fz, Cd
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: vel, Rep, f
 real :: We, Cdsph, Cddisk, e
 ! 処理開始 ********************************************************************************************
 ! 液滴レイノルズ数 ------------------------------------------------------------------------------------
 vel = sqrt((uf - up)**2 + (vf - vp)**2 + (wf - wp)**2)
 Rep = vel * dp * rhof / max(zero, muf)
 Rep = min(1000.0, max(0.01, Rep))
 ! Weber Number ----------------------------------------------------------------------------------------
 We = rhof * vel**2 * dp / sigd
 ! parameter e -----------------------------------------------------------------------------------------
 e = 1.0 - ( 1.0 / (1.0 + 0.007 * We**0.5)**6.0 )
 ! 抵抗係数 --------------------------------------------------------------------------------------------
 Cdsph  = 24.0 / Rep * (1.0 + 0.15 * Rep**0.687)
 Cddisk = 1.1 + 64.0 / (pi * Rep)
 Cd = (1.0 - e) * Cdsph + e * Cddisk
 ! 単位質量の液滴に働く抗力 ----------------------------------------------------------------------------
 f  = 3.0 * cd * rhof / (4.0 * rhop * dp)
 fx = f * vel * (uf - up)
 fy = f * vel * (vf - vp)
 fz = f * vel * (wf - wp)
 ! 処理終了 ********************************************************************************************
 return
end subroutine WebernumberDrag
!*******************************************************************************************************
! Drag
! Varcas and Fro NASA/TM-2011-216946
!*******************************************************************************************************
subroutine VargasFeoDrag( &
&            dp, rhop, up, vp, wp, dv, rhof, uf, vf, wf, muf, dt, &
&            fx, fy, fz )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! 液滴のパラメータ ------------------------------------------------------------------------------------
 real, intent(in)  :: dp                      				! 直径
 real, intent(in)  :: rhop                    				! 密度
 real, intent(in)  :: up, vp, wp  				        ! 速度
 real, intent(in)  :: dv		              			! 速度差
 real, intent(in)  :: dt						! 時間刻み
 ! 流体のパラメータ ------------------------------------------------------------------------------------
! real, intent(in)  :: ReRef       				        ! 代表レイノルズ数
 real, intent(in)  :: rhof        				        ! 密度
 real, intent(in)  :: uf, vf, wf  				        ! 速度
 real, intent(in)  :: muf         				        ! 粘性係数
 ! 定常抗力 --------------------------------------------------------------------------------------------
 real, intent(out) :: fx, fy, fz
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: vel, cd, f
 ! 処理開始 ********************************************************************************************
 vel = sqrt((uf - up)**2 + (vf - vp)**2 + (wf - wp)**2)
 ! 抵抗係数 --------------------------------------------------------------------------------------------
 cd = 4.0 / 3.0 * rhof / rhop * dp / vel**2 * dv / dt
 ! 単位質量の液滴に働く抗力 ----------------------------------------------------------------------------
 f  = 3.0 * cd * rhof / (4.0 * rhop * dp)
 fx = f * vel * (uf - up)
 fy = f * vel * (vf - vp)
 fz = f * vel * (wf - wp)
 ! 処理終了 ********************************************************************************************
 return
end subroutine VargasFeoDrag
!*******************************************************************************************************
!******** 重力と浮力 (二次元)    					                        ********
!*******************************************************************************************************
subroutine GravityBuoyancy2D( &
&            rhop, rhof, gx, gy, &
&            fx, fy )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real, intent(in)  :: rhop                   				! 液滴密度
 real, intent(in)  :: rhof                   				! 流体密度
 real, intent(in)  :: gx, gy                 				! 重力加速度
 real, intent(out) :: fx, fy                 				! 重力と浮力の合力
 ! 処理開始 ********************************************************************************************
 ! 単位質量の液滴に働く重力と浮力 ----------------------------------------------------------------------
 fx = (1.0 - rhof / rhop) * gx
 fy = (1.0 - rhof / rhop) * gy
 ! 処理終了 ********************************************************************************************
 return
end subroutine GravityBuoyancy2D
!*******************************************************************************************************
!******** 重力と浮力 (三次元)  					                                ********
!*******************************************************************************************************
subroutine GravityBuoyancy3D( &
&            rhop, rhof, gx, gy, gz, &
&            fx, fy, fz )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real, intent(in)  :: rhop      					! 液滴密度
 real, intent(in)  :: rhof      				        ! 流体密度
 real, intent(in)  :: gx, gy, gz				        ! 重力加速度
 real, intent(out) :: fx, fy, fz				        ! 重力と浮力の合力
 ! 処理開始 ********************************************************************************************
 ! 単位質量の液滴に働く重力と浮力 ----------------------------------------------------------------------
 fx = (1.0 - rhof / rhop) * gx
 fy = (1.0 - rhof / rhop) * gy
 fz = (1.0 - rhof / rhop) * gz
 ! 処理終了 ********************************************************************************************
 return
end subroutine GravityBuoyancy3D
!*******************************************************************************************************
!******** 回転座標系の慣性力 (二次元)   							********
!*******************************************************************************************************
subroutine Rotation2D( &
&            OmegaZ, xp, yp, up, vp, &
&            fx, fy )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real, intent(in)  :: OmegaZ 				                ! 座標系の角速度
 real, intent(in)  :: xp, yp 				                ! 液滴の座標
 real, intent(in)  :: up, vp 				                ! 液滴の速度
 real, intent(out) :: fx, fy 				                ! 慣性力
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: CoriolisX, CoriolisY
 real :: CentrifugalX, CentrifugalY
 ! 処理開始 ********************************************************************************************
 CoriolisX    = - 2.0 * OmegaZ * vp
 CoriolisY    =   2.0 * OmegaZ * up
 CentrifugalX = - OmegaZ**2 * xp
 CentrifugalY = - OmegaZ**2 * yp
 fx = - CoriolisX - CentrifugalX
 fy = - CoriolisY - CentrifugalY
 ! 処理終了 ********************************************************************************************
 return
end subroutine Rotation2D
!*******************************************************************************************************
!******** 回転座標系の慣性力 (三次元) 	                         				********
!*******************************************************************************************************
subroutine Rotation3D( &
&            OmegaX, OmegaY, OmegaZ, xp, yp, zp, up, vp, wp, &
&            fx, fy, fz )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real, intent(in)  :: OmegaX, OmegaY, OmegaZ  				! 座標系の角速度
 real, intent(in)  :: xp, yp, zp              				! 液滴の座標
 real, intent(in)  :: up, vp, wp              				! 液滴の速度
 real, intent(out) :: fx, fy, fz              				! 慣性力
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: CoriolisX, CoriolisY, coriolisz
 real :: CentrifugalX, CentrifugalY, centrifugalz
 ! 処理開始 ********************************************************************************************
 CoriolisX    = 2.0 * (OmegaY * wp - OmegaZ * vp)
 CoriolisY    = 2.0 * (OmegaZ * up - OmegaX * wp)
 Coriolisz    = 2.0 * (OmegaX * vp - OmegaY * up)
 CentrifugalX = OmegaY * (OmegaX * yp - OmegaY * xp) &
 &            - OmegaZ * (OmegaZ * xp - OmegaX * zp)
 CentrifugalY = OmegaZ * (OmegaY * zp - OmegaZ * yp) &
 &            - OmegaX * (OmegaX * yp - OmegaY * xp)
 Centrifugalz = OmegaX * (OmegaZ * xp - OmegaX * zp) &
 &            - OmegaY * (OmegaY * zp - OmegaZ * yp)
 fx = - CoriolisX - CentrifugalX
 fy = - CoriolisY - CentrifugalY
 fz = - Coriolisz - Centrifugalz
 ! 処理終了 ********************************************************************************************
 return
end subroutine Rotation3D
!********************************************************************************************************
!******** 液滴軌道計算時間進行 (二次元，Euler 陽解法) 	  				         ********
!********************************************************************************************************
subroutine TimeEuler2D( &
&            dtp, fx0, fy0, xp0, yp0, up0, vp0, &
&            xp1, yp1, up1, vp1)
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! 時間刻み --------------------------------------------------------------------------------------------
 real, intent(in)  :: dtp
 ! 前ステップの液滴変数 --------------------------------------------------------------------------------
 real, intent(in)  :: fx0, fy0      					! 液滴に働く力
 real, intent(in)  :: xp0, yp0      					! 液滴位置
 real, intent(in)  :: up0, vp0      					! 液滴速度
 ! 時間進行後の液滴変数 --------------------------------------------------------------------------------
 real, intent(out) :: xp1, yp1          				! 液滴位置
 real, intent(out) :: up1, vp1          				! 液滴速度
 ! 処理開始 ********************************************************************************************
 xp1 = xp0 + up0 * dtp
 yp1 = yp0 + vp0 * dtp
 up1 = up0 + fx0 * dtp
 vp1 = vp0 + fy0 * dtp
 ! 処理終了 ********************************************************************************************
 return
end subroutine TimeEuler2D
!*******************************************************************************************************
!******** 液滴軌道計算時間進行 (三次元，Euler 陽解法) 					        ********
!*******************************************************************************************************
subroutine TimeEuler3D( &
&            dtp, fx0, fy0, fz0, xp0, yp0, zp0, up0, vp0, wp0, &
&            xp1, yp1, zp1, up1, vp1, wp1 )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! 時間刻み --------------------------------------------------------------------------------------------
 real, intent(in)  :: dtp
 ! 前ステップの液滴変数 --------------------------------------------------------------------------------
 real, intent(in)  :: fx0, fy0, fz0     				! 液滴に働く力
 real, intent(in)  :: xp0, yp0, zp0     				! 液滴位置
 real, intent(in)  :: up0, vp0, wp0     				! 液滴速度
 ! 時間進行後の液滴変数 --------------------------------------------------------------------------------
 real, intent(out) :: xp1, yp1, zp1     				! 液滴位置
 real, intent(out) :: up1, vp1, wp1     				! 液滴速度
 ! 処理開始 ********************************************************************************************
 xp1 = xp0 + up0 * dtp
 yp1 = yp0 + vp0 * dtp
 zp1 = zp0 + wp0 * dtp
 up1 = up0 + fx0 * dtp
 vp1 = vp0 + fy0 * dtp
 wp1 = wp0 + fz0 * dtp
 ! 処理終了 ********************************************************************************************
 return
end subroutine TimeEuler3D
!********************************************************************************************************
!******** 液滴軌道計算時間進行 (二次元，Euler 陽解法，温度変化)				         ********
!********************************************************************************************************
subroutine TimeEulerTemperature2D( &
&            dtp, rhop, dp, Cpw, kw, Prt, &
&            rhof, uf, vf, muf, tf, fx0, fy0, xp0, yp0, up0, vp0, tp0, &
&            xp1, yp1, up1, vp1, tp1)
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real, intent(in)  :: dtp						! 時間刻み
 real, intent(in)  :: rhop						! 液滴密度
 real, intent(in)  :: Cpw						! 液滴の定圧比熱
 real, intent(in)  :: kw						! 液滴の熱伝導率
 real, intent(in)  :: Prt						! プラントル数
 real, intent(in)  :: dp						! 液滴直径
 real, intent(in)  :: rhof, uf, vf, muf, tf				! 周囲流体の情報
 real, intent(in)  :: fx0, fy0      					! 液滴に働く力
 real, intent(in)  :: xp0, yp0      					! 液滴位置
 real, intent(in)  :: up0, vp0      					! 液滴速度
 real, intent(in)  :: tp0	      					! 液滴温度
 real, intent(out) :: xp1, yp1          				! 液滴位置
 real, intent(out) :: up1, vp1          				! 液滴速度
 real, intent(out) :: tp1	          				! 液滴温度
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: vel, Nup, Rep, mp
 ! 処理開始 ********************************************************************************************
 ! 液滴位置 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 xp1 = xp0 + up0 * dtp
 yp1 = yp0 + vp0 * dtp
 ! 液滴速度 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 up1 = up0 + fx0 * dtp
 vp1 = vp0 + fy0 * dtp
 ! 液滴温度 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! 液滴レイノルズ数
 vel = sqrt((uf - up0)**2 + (vf - vp0)**2)
 Rep = vel * dp * rhof / max(zero, muf)
 Rep = min(1000.0, max(0.01, Rep))
 ! 液滴ヌッセルト数
 Nup = 2.0 + 0.6 * Rep**(1.0/2.0) * Prt**(1.0/3.0)
 ! 液滴質量
 mp  = rhop * pi * (0.5 * dp)**2
 ! 液滴温度
 tp1 = tp0 + dtp / (mp * Cpw) * (pi * dp * kw * (tf - tp0) * Nup)
 ! 処理終了 ********************************************************************************************
 return
end subroutine TimeEulerTemperature2D
!********************************************************************************************************
!******** 液滴軌道計算時間進行 (三次元，Euler 陽解法，温度変化)				         ********
!********************************************************************************************************
subroutine TimeEulerTemperature3D( &
&            dtp, rhop, dp, Cpw, kw, Prt, &
&            rhof, uf, vf, wf, muf, tf, fx0, fy0, fz0, xp0, yp0, zp0, up0, vp0, wp0, tp0, &
&            xp1, yp1, zp1, up1, vp1, wp1, tp1)
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real, intent(in)  :: dtp						! 時間刻み
 real, intent(in)  :: rhop						! 液滴密度
 real, intent(in)  :: Cpw						! 液滴の定圧比熱
 real, intent(in)  :: kw						! 液滴の熱伝導率
 real, intent(in)  :: Prt						! プラントル数
 real, intent(in)  :: dp						! 液滴直径
 real, intent(in)  :: rhof, uf, vf, wf, muf, tf				! 周囲流体の情報
 real, intent(in)  :: fx0, fy0, fz0    					! 液滴に働く力
 real, intent(in)  :: xp0, yp0, zp0    					! 液滴位置
 real, intent(in)  :: up0, vp0, wp0    					! 液滴速度
 real, intent(in)  :: tp0	      					! 液滴温度
 real, intent(out) :: xp1, yp1, zp1          				! 液滴位置
 real, intent(out) :: up1, vp1, wp1          				! 液滴速度
 real, intent(out) :: tp1	          				! 液滴温度
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: vel, Nup, Rep, mp
 ! 処理開始 ********************************************************************************************
 ! 液滴位置 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 xp1 = xp0 + up0 * dtp
 yp1 = yp0 + vp0 * dtp
 zp1 = zp0 + wp0 * dtp
 ! 液滴速度 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 up1 = up0 + fx0 * dtp
 vp1 = vp0 + fy0 * dtp
 wp1 = wp0 + fz0 * dtp
 ! 液滴温度 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! 液滴レイノルズ数
 vel = sqrt((uf - up0)**2 + (vf - vp0)**2 + (wf - wp0)**2)
 Rep = vel * dp * rhof / max(zero, muf)
 Rep = min(1000.0, max(0.01, Rep))
 ! 液滴ヌッセルト数
 Nup = 2.0 + 0.6 * Rep**(1.0/2.0) * Prt**(1.0/3.0)
 ! 液滴質量
 mp  = rhop * 4.0 / 3.0 * pi * (0.5 * dp)**3
 ! 液滴温度
 tp1 = tp0 + dtp / (mp * Cpw) * (pi * dp * kw * (tf - tp0) * Nup)
 ! 処理終了 ********************************************************************************************
 return
end subroutine TimeEulerTemperature3D
!*******************************************************************************************************
!******** 液滴速度 (二次元，計算空間 : 反変速度)        				　      ********
!*******************************************************************************************************
subroutine Velocity2D( &
&            xix, xiy, etx, ety, up, vp, &
&            uxp, vep )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! 座標変換パラメータ ----------------------------------------------------------------------------------
 real, intent(in)  :: xix, xiy, etx, ety
 ! 液滴速度 --------------------------------------------------------------------------------------------
 real, intent(in)  :: up, vp               				! 液滴速度 (物理座標系)
 real, intent(out) :: uxp, vep             				! 液滴速度 (計算座標系)
 ! 処理開始 ********************************************************************************************
 uxp = xix * up + xiy * vp
 vep = etx * up + ety * vp
 ! 処理終了 ********************************************************************************************
 return
end subroutine Velocity2D
!*******************************************************************************************************
!******** 液滴速度 (三次元，計算空間 : 反変速度)                   				********
!*******************************************************************************************************
subroutine Velocity3D( &
&            xix, xiy, xiz, etx, ety, etz, zex, zey, zez, up, vp, wp, &
&            uxp, vep, wzp )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! 座標変換パラメータ ----------------------------------------------------------------------------------
 real, intent(in)  :: xix, xiy, xiz, etx, ety, etz, zex, zey, zez
 ! 液滴速度 --------------------------------------------------------------------------------------------
 real, intent(in)  :: up, vp, wp       					! 液滴速度 (物理座標系)
 real, intent(out) :: uxp, vep, wzp    					! 液滴速度 (計算座標系)
 ! 処理開始 ********************************************************************************************
 uxp = xix * up + xiy * vp + xiz * wp
 vep = etx * up + ety * vp + etz * wp
 wzp = zex * up + zey * vp + zez * wp
 ! 処理終了 ********************************************************************************************
 return
end subroutine Velocity3D
!*******************************************************************************************************
!******** 液滴起動計算時間刻み (二次元)        				                        ********
!*******************************************************************************************************
subroutine dt2D( &
&            uxp, vep, cnp, dtp )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 局所定数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real, parameter :: almin = 1.0e-08
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real, intent(in)  :: uxp, vep        					! 液滴速度 (計算座標系)
 real, intent(in)  :: cnp             					! 液滴のクーラン数
 real, intent(out) :: dtp             					! 時間刻み
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: alxi, alet, almax
 ! 処理開始 ********************************************************************************************
 alxi  = abs(uxp)
 alet  = abs(vep)
 almax = max(alxi, alet, almin)
 dtp   = cnp / almax
 ! 処理終了 ********************************************************************************************
 return
end subroutine dt2D
!*******************************************************************************************************
!******** 液滴起動計算時間刻み (三次元)                                				********
!*******************************************************************************************************
subroutine dt3D( &
&            uxp, vep, wzp, cnp, dtp )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 局所定数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real, parameter :: almin = 1.0e-08
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real, intent(in)  :: uxp, vep, wzp   					! 液滴速度 (計算座標系)
 real, intent(in)  :: cnp             					! 液滴のクーラン数
 real, intent(out) :: dtp             					! 時間刻み
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: alxi, alet, alze, almax
 ! 処理開始 ********************************************************************************************
 alxi  = abs(uxp)
 alet  = abs(vep)
 alze  = abs(wzp)
 almax = max(alxi, alet, alze, almin)
 dtp   = cnp / almax
 ! 処理終了 ********************************************************************************************
 return
end subroutine dt3D
!*******************************************************************************************************
!******** 壁面衝突判定 (三次元)                                        				********
!********　※ 法線ベクトルの向きに注意								********
!*******************************************************************************************************
subroutine ImpingementJudge3D( &
&            xp, yp, zp, x1, y1, z1, x2, y2, z2, x3, y3, z3, dp, &
&            fImp, Rhow, ImpMass )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real   , intent(in)  :: x1, y1, z1
 real   , intent(in)  :: x2, y2, z2
 real   , intent(in)  :: x3, y3, z3
 real   , intent(in)  :: xp, yp, zp
 real   , intent(in)  :: dp
 logical, intent(out) :: fImp
 real   , intent(in)  :: Rhow
 real   , intent(out) :: ImpMass
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: ax, ay, az, bx, by, bz, cx, cy, cz
 real :: nx, ny, nz, ni							! 壁面法線ベクトル
 real :: dl                   						! 衝突面までの距離
 ! 処理開始 ********************************************************************************************
 ! 衝突面の単位法線ベクトル (外積から導出) -------------------------------------------------------------
 ax = x2 - x1
 ay = y2 - y1
 az = z2 - z1
 bx = x3 - x1
 by = y3 - y1
 bz = z3 - z1
 nx = ay * bz - az * by
 ny = az * bx - ax * bz
 nz = ax * by - ay * bx
 ni = 1.0 / max(zero, sqrt(nx**2 + ny**2 + nz**2))
 nx = nx * ni
 ny = ny * ni
 nz = nz * ni
 ! 液滴と衝突面の距離 (内積から導出) -------------------------------------------------------------------
 dl = (xp - x1) * nx + (yp - y1) * ny + (zp - z1) * nz
 ! 液滴と衝突面との距離が液滴径以下であれば衝突と判定 --------------------------------------------------
 if(dl <= 0.5 * dp) then
   fImp = .true.
   ImpMass = Rhow * 4.0 / 3.0 * pi * (0.5 * dp)**3.0
  else
   fImp = .false.
 endif
 ! 処理終了 ********************************************************************************************
 return
end subroutine ImpingementJudge3D
!*******************************************************************************************************
!******** 壁面衝突速度 (三次元)	                                        			********
!******** ※ 液滴径分布無視                                         				********
!*******************************************************************************************************
subroutine ImpingementVelocity3D( &
&            is, ie, ks, ke, nimp, uimp, vimp, wimp )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer, intent(in)    :: is, ie, ks, ke				! 格子数
 real   , intent(in)    :: nimp(is:ie, ks:ke)				! 液滴衝突数
 real   , intent(inout) :: uimp(is:ie, ks:ke), &
 &			   vimp(is:ie, ks:ke), &
 &			   wimp(is:ie, ks:ke)				! 衝突速度
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i, k
 ! 処理開始 ********************************************************************************************
 do k = ks, ke
 do i = is, ie
  if( nimp(i,k) == 0.0 ) cycle
  uimp(i,k) = uimp(i,k) / nimp(i,k)
  vimp(i,k) = vimp(i,k) / nimp(i,k)
  wimp(i,k) = wimp(i,k) / nimp(i,k)
 enddo
 enddo
 ! 処理終了 ********************************************************************************************
 return
end subroutine ImpingementVelocity3D
!*******************************************************************************************************
!******** 壁面衝突速度 (三次元)	                                        			********
!******** ※ 液滴径分布無視                                         				********
!*******************************************************************************************************
subroutine ImpingementTemperature3D( &
&            is, ie, ks, ke, nimp, timp )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer, intent(in)    :: is, ie, ks, ke				! 格子数
 real   , intent(in)    :: nimp(is:ie, ks:ke)				! 液滴衝突数
 real   , intent(inout) :: timp(is:ie, ks:ke)				! 衝突温度
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i, k
 ! 処理開始 ********************************************************************************************
 do k = ks, ke
 do i = is, ie
  if( nimp(i,k) == 0.0 ) cycle
  timp(i,k) = timp(i,k) / nimp(i,k)
 enddo
 enddo
 ! 処理終了 ********************************************************************************************
 return
end subroutine ImpingementTemperature3D
!*******************************************************************************************************
!******** 衝突壁面積 (三次元)		      					                ********
!*******************************************************************************************************
subroutine ImpingementArea3D( &
&            is, ie, ks, ke, x, y, z, &
&            SA )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer, intent(in)  :: is, ie, ks, ke					! 格子数
 real   , intent(in)  :: x(is:ie, ks:ke), &
 &                       y(is:ie, ks:ke), &
 &                       z(is:ie, ks:ke)
 real   , intent(out) :: SA(is:ie, ks:ke)				! セル面積
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real   , pointer :: s1(:, :), s2(:, :), s3(:, :)
 integer :: i, k
 real    :: a1, a2, a3, b1, b2, b3, c1, c2, c3
 ! 処理開始 ********************************************************************************************
 ! 初期設定 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 allocate( s1(is:ie, ks:ke), s2(is:ie, ks:ke), s3(is:ie, ks:ke) )
 s1(:,:) = 0.0; s2(:,:) = 0.0; s3(:,:) = 0.0
 ! セル面積 (格子点周り４セルの平均) +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! 三角形の面積
 do k = ks, ke - 1
 do i = is, ie - 1
  a1 = x(i+1,k  ) - x(i,k)
  a2 = y(i+1,k  ) - y(i,k)
  a3 = z(i+1,k  ) - z(i,k)
  b1 = x(i  ,k+1) - x(i,k)
  b2 = y(i  ,k+1) - y(i,k)
  b3 = z(i  ,k+1) - z(i,k)
  c1 = a2 * b3 - a3 * b2
  c2 = a3 * b1 - a1 * b3
  c3 = a1 * b2 - a2 * b1
  s1(i,k) = 0.5 * sqrt(c1**2 + c2**2 + c3**2)
 enddo
 enddo
 do k = ks + 1, ke
 do i = is + 1, ie
  a1 = x(i-1,k  ) - x(i,k)
  a2 = y(i-1,k  ) - y(i,k)
  a3 = z(i-1,k  ) - z(i,k)
  b1 = x(i  ,k-1) - x(i,k)
  b2 = y(i  ,k-1) - y(i,k)
  b3 = z(i  ,k-1) - z(i,k)
  c1 = a2 * b3 - a3 * b2
  c2 = a3 * b1 - a1 * b3
  c3 = a1 * b2 - a2 * b1
  s2(i,k) = 0.5 * sqrt(c1**2 + c2**2 + c3**2)
 enddo
 enddo
 ! 三角形面積の和
 do k = ks, ke - 1
 do i = is, ie - 1
  s3(i,k) = s1(i,k) + s2(i+1,k+1)
 enddo
 enddo
 do k = ks +1, ke -1
  s3(ie,k) = s3(ie-1,k)
 enddo
 do i = is + 1, ie -1
  s3(i,ke) = s3(i,ke-1)
 enddo
 s3(is,ke) = s3(is,ke-1)
 s3(ie,ks) = s3(ie-1,ks)
 s3(ie,ke) = s3(ie-1,ke-1)
 ! 格子点周り４点の平均
 do k = ks + 1, ke - 1
 do i = is + 1, ie - 1
  SA(i,k) = 0.25 * ( s3(i,k) + s3(i-1,k) + s3(i,k-1) + s3(i-1,k-1) )
 enddo
 enddo
 do k = ks + 1, ke - 1
  SA(is,k) = 0.5 * ( S3(is,k-1) + S3(is,k) )
  SA(ie,k) = 0.5 * ( S3(ie,k-1) + S3(ie,k) )
 enddo
 do i = is + 1, ie - 1
  SA(i,ks) = 0.5 * ( S3(i-1,ks) + S3(i,ks) )
  SA(i,ke) = 0.5 * ( S3(i-1,ke) + S3(i,ks) )
 enddo
 SA(is,ks) = S3(is,ks)
 SA(ie,ks) = S3(ie,ks)
 SA(is,ke) = S3(is,ke)
 SA(ie,ke) = S3(ie,ke)
 ! メモリ解放 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 deallocate(s1, s2, s3)
 ! 処理終了 ********************************************************************************************
 return
end subroutine ImpingementArea3D
!*******************************************************************************************************
!******** 収集効率 (三次元)		                              				********
!******** ※ 液滴径分布無視                                        				********
!*******************************************************************************************************
subroutine CollectionEfficiency3D( &
&            is, ie, ks, ke, nDrp, MVD, LWC, Rhod, Ain, Uin, Nimp, SA, Mim, &
&            bet )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer, intent(in)  :: is, ie, ks, ke					! 格子数
 integer, intent(in)  :: nDrp						! 液滴数
 real   , intent(in)  :: MVD						! 平均液滴径
 real   , intent(in)  :: LWC						! 水分含有量
 real   , intent(in)  :: Rhod						! 液滴密度
 real   , intent(in)  :: Ain						! 液滴投入面積
 real   , intent(in)  :: Uin						! 液滴投入速度
 real   , intent(in)  :: Nimp(is:ie, ks:ke)				! 液滴衝突数
 real   , intent(in)  :: SA  (is:ie, ks:ke)				! セル面積
 real   , intent(in)  :: Mim (is:ie, ks:ke)				! 衝突質量
 real   , intent(out) :: bet (is:ie, ks:ke)				! 収集効率
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real   , pointer :: Ns(:, :)						! 液滴衝突率
 real   , pointer :: ImpN(:, :)						! 液滴衝突数
 integer :: i, k
 real    :: Qm, vMVD, Nin, Np
 ! 処理開始 ********************************************************************************************
 ! 初期設定 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 allocate( Ns(is:ie, ks:ke), ImpN(is:ie, ks:ke) )
 Ns(:,:) = 0.0; ImpN(:,:) = 0.0
 vMVD = 4.0 / 3.0 * pi * (0.5 * MVD)**3.0
 ! 各格子点に 1 s 当りに衝突する液滴の割合 Ns [s^-1] +++++++++++++++++++++++++++++++++++++++++++++++++++
 ! 検査体積内に流入する液滴の質量流量 Qm [kg / s] ------------------------------------------------------
 Qm = Ain * Uin * LWC
 ! 1 s 当りに流入する液滴数 Nin [s^-1] -----------------------------------------------------------------
 Nin = Qm / (vMVD * Rhod)
 do k = ks, ke
 do i = is, ie
!  write(*, '(a, i3, i3, e16.8e3)')' * i, k, Mim(i,k)',i, k, Mim(i,k)
!  write(*, '(a, i3, i3, e16.8e3)')' * i, k, Nimp(i,k)',i, k, Nimp(i,k)
 ! 衝突質量から衝突数を計算 ImpN -----------------------------------------------------------------------
  ImpN(i,k) = Mim(i,k) / ( vMVD * Rhod )
!  write(*,*)'* ImpN(', i, ',' ,k, ') = ',ImpN(i,k)
!  write(*,*)'* ImpN(', i, ',' ,k, ') = ',Nimp(i,k)
!  write(*,'(a, i3, i3, e16.8e3)')'* i, k, Nimp(i,k) = ',i, k, Nimp(i,k)
  ! 格子点に衝突する液滴の割合 Np [*]
  Np = Nimp(i,k) / real(nDrp)
!  Np = ImpN(i,k) / real(nDrp)
  ! 1 s 当りに格子点に衝突する液滴の割合 [s^-1]
  Ns(i,k) = Np * Nin
 enddo
 enddo
 ! 収集効率 bet [m^-2 * s^-1] ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 do k = ks, ke
 do i = is, ie
  bet(i,k) = Ns(i,k) / SA(i,k)
 enddo
 enddo
 deallocate(Ns)
 ! 処理終了 ********************************************************************************************
 return
end subroutine CollectionEfficiency3D
!*******************************************************************************************************
!******** スプラッシュモデル (三次元，LEWICE，NASA/TM 2008-215174)				********
!*******************************************************************************************************
subroutine SplashLEWICE3D( &
&            xp, yp, zp, up1, vp1, wp1, dp1, mr1, x1, y1, z1, x2, y2, z2, x3, y3, z3, &
&            LWC, Rhow, Sigw, muw, SLDLim, &
&            fImpi, up2, vp2, wp2, dp2, mr2, nSpl, nBou, n2Imp, ImpMass, Ohw, Rew, fSplash, fBounce, fImpi2 )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real   , intent(in)    :: xp, yp, zp					! 液滴座標
 real   , intent(in)    :: up1, vp1, wp1				! 液滴衝突速度
 real   , intent(in)    :: dp1						! 衝突前の液滴径
 real   , intent(in)    :: mr1						! 衝突前の液滴質量比
 real   , intent(in)    :: x1, y1, z1					! 壁面座標1
 real   , intent(in)    :: x2, y2, z2					! 壁面座標2
 real   , intent(in)    :: x3, y3, z3					! 壁面座標3
 real   , intent(in)    :: LWC						! 液滴水分含有率
 real   , intent(in)    :: Rhow						! 水の密度
 real   , intent(in)    :: Sigw						! 水の表面張力
 real   , intent(in)    :: muw						! 水の粘性係数
 real   , intent(in)    :: SLDLim					! SLDの閾値
 logical, intent(out)   :: fImpi					! 衝突判定
 real   , intent(out)   :: up2, vp2, wp2				! 液滴跳ね返り速度
 real   , intent(out)   :: dp2						! 衝突後の液滴径
 real   , intent(out)   :: mr2						! 衝突後の液滴質量比
 integer, intent(inout) :: nSpl						! スプラッシュの液滴数
 integer, intent(inout) :: nBou						! バウンドの液滴数
 integer, intent(inout) :: n2Imp					! 2回衝突した液滴数
 real   , intent(out)   :: Ohw, Rew
 real   , intent(out)   :: ImpMass
 logical, intent(inout)   :: fSplash, fBounce, fImpi2
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real :: Ax, Ay, Az, Bx, By, Bz						! 壁面位置v
 real :: Nx, Ny, Nz, Ni, Hx, Hy, Hz, Hi					! 壁面法線vと垂直v
 real :: dl								! 液滴と壁面の距離
 real :: Ux, Uy, Uz, UU							! 液滴速度v (計算座標)
 real :: Udotp								! 液滴速度vと壁面法線単位vの内積
 real :: Uh1, Un1, Uh2, Un2						! 液滴速度v (壁面直行座標)
 real :: alp1, bet1							! 液滴衝突角
 real :: alp2								! 液滴跳ね返り角
 real :: KK, KL, KR							! スプラッシュパラメータ
! real :: Rew								! レイノルズ数
 !real :: Ohw								! オーネゾルゲ数
 ! 処理開始 ********************************************************************************************
 ! 壁面衝突判定 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! 壁面法線方向単位ベクトル (外積から導出) -------------------------------------------------------------
 Ax = x2 - x1
 Ay = y2 - y1
 Az = z2 - z1
 Bx = x3 - x1
 By = y3 - y1
 Bz = z3 - z1
 Nx = Ay * Bz - Az * By
 Ny = Az * Bx - Ax * Bz
 Nz = Ax * By - Ay * Bx
 Ni = 1.0 / max(zero, sqrt(Nx**2 + Ny**2 + Nz**2))
 Nx = Nx * Ni
 Ny = Ny * Ni
 Nz = Nz * Ni
 ! 液滴と衝突面の距離 (内積から導出) -------------------------------------------------------------------
 dl = (xp - x1) * Nx + (yp - y1) * Ny + (zp - z1) * Nz
 ! 液滴と衝突面との距離が液滴径以下であれば衝突と判定 --------------------------------------------------
 if(dl <= 0.5 * dp1) then
   fImpi = .true.
    if(fSplash .or. fBounce)then
     fImpi2 = .true.
     n2Imp = n2Imp + 1
    else
     fImpi2 = .false.
    endif
  else
   fImpi = .false.
   fImpi2 = .false.
   up2 = up1; vp2 = vp1; wp2 = wp1; dp2 = dp1; mr2 = mr1
   return
 endif
 ! 衝突角と衝突速度 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! 衝突液滴の速度ベクトル ------------------------------------------------------------------------------
 Ux = up1
 Uy = vp1
 Uz = wp1
 UU = sqrt(Ux**2 + Uy**2 + Uz**2)
 ! 衝突角 (壁面法線ベクトルと液滴速度ベクトルの内積から導出) -------------------------------------------
 Udotp = Ux * Nx + Uy * Ny + Uz * Nz
 bet1  = min(0.5 * pi, max(0.0, acos(-1.0 * Udotp / max(UU, zero) ) ) )
 alp1  = 0.5 * pi - bet1
 ! 衝突速度の壁面水平成分と壁面垂直成分 (壁面直行座標系) -----------------------------------------------
 Uh1 = UU * cos(alp1)
 Un1 = UU * sin(alp1)
 Un1 = -1.0 * Un1
 ! スプラッシュパラメータ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! Ohnesorge数 -----------------------------------------------------------------------------------------
 Ohw = muw / sqrt(Rhow * Sigw * dp1)
 ! Reynolds数 ------------------------------------------------------------------------------------------
! Rew = Rhow * UU * dp1 / muw
 Rew = Rhow * abs(Un1) * dp1 / muw					! いそコードはこっち
 ! Splash変数 ------------------------------------------------------------------------------------------
 KK = Ohw * Rew**1.25
 KL = 0.859 * sqrt(KK) * (Rhow / LWC)**0.125 / max( zero, sin(alp1) )**1.25 
! KR = 8.72 * exp(-0.0281 * KK)
 ! スプラッシュ・バウンド判定 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 if(KL > 200.0) then
  KR = 8.72 * exp(-0.0281 * KK)
 ! 全質量衝突 ------------------------------------------------------------------------------------------
   if(KR <= 0.05) then	
    up2 = 0.0; vp2 = 0.0; wp2 = 0.0
    dp2 = 0.0; mr2 = 0.0
    ImpMass = Rhow * 4.0 / 3.0 * pi * (0.5 * dp1)**3.0
    return
 ! スプラッシュ ----------------------------------------------------------------------------------------
   else if(KR <= 1.0) then
    fSplash = .true.
    ! 液滴数のカウンター
    nSpl = nSpl + 1
    ! 衝突後の液滴径
    dp2 = KR * dp1
    ! 衝突後の液滴速度成分 (壁面直行座標系)
!    Uh2 = Uh1 * (1.075 - 0.0025 * alp1)
!    Un2 = Un1 * (0.300 - 0.0020 * alp1)
    Uh2 = Uh1 * (1.075 - 0.0025 * alp1 * 180.0 / pi)			! いそコードはこっち
    Un2 = Un1 * (0.300 - 0.0020 * alp1 * 180.0 / pi)
    ! 衝突後の質量比 (飛んでいく分)
!    mr2 = mr1 * ( 1.0 - 0.7 * ( 1.0 - sin(alp1) ) * ( 1.0 - exp( -0.0092026 * (KL - 200.0) ) ) )
    mr2 = mr1 * 0.7 * ( 1.0 - sin(alp1) ) * ( 1.0 - exp( -0.0092026 * (KL - 200.0) ) )
    ImpMass   = Rhow * 4.0 / 3.0 * pi * (0.5 * dp1)**3.0 * (1.0 - mr2)
!    write(*, '(a, e16.8e3)')' * ImpMass = ', ImpMass
    if(mr2 >= mr1) then
      write(*, '(a)') '!!!!! Error : Mass rate of splash droplet !!!!!'
      write(*, '(a,e16.8e3)') '* mr1 = ', mr1
      write(*, '(a,e16.8e3)') '* mr2 = ', mr2
    endif
 ! バウンド --------------------------------------------------------------------------------------------
   else if(KR > 1.0) then
    fBounce = .true.
    ! 液滴数のカウンター
    nBou = nBou + 1
    ! 衝突後の液滴径
    dp2 = dp1
    ! 衝突後の液滴速度成分 (壁面直行座標系)
    Uh2 = Uh1
    Un2 = Un1
    ! 衝突後の質量比
    mr2 = mr1 * 1.0
    ! 壁面衝突のフラグ
    fImpi = .false.
   endif
 ! 全質量衝突 ------------------------------------------------------------------------------------------
 else
  up2 = 0.0; vp2 = 0.0; wp2 = 0.0
  dp2 = 0.0; mr2 = 0.0
  ImpMass = Rhow * 4.0 / 3.0 * pi * (0.5 * dp1)**3.0
 endif
! ! スプラッシュ・バウンド判定 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! if(KL <= 200.0 .or. KR <= 0.05 .or. dp1 <= SLDLim) then
!   ! 全質量壁面付着 ------------------------------------------------------------------------------------
!   up2 = 0.0; vp2 = 0.0; wp2 = 0.0
!   dp2 = 0.0; mr2 = 0.0
!   ImpMass = Rhow * 4.0 / 3.0 * pi * (0.5 * dp1)**3.0
!!   write(*, '(a, e16.8e3)')' * ImpMass = ', ImpMass
!   return
!  else if(KR < 1.0) then
!   ! スプラッシュ --------------------------------------------------------------------------------------
!   ! 液滴数のカウンター
!   nSpl = nSpl + 1
!   ! 衝突後の液滴径
!   dp2 = KR * dp1
!   ! 衝突後の液滴速度成分 (壁面直行座標系)
!!   Uh2 = Uh1 * (1.075 - 0.0025 * alp1)
!!   Un2 = Un1 * (0.300 - 0.0020 * alp1)
!   Uh2 = Uh1 * (1.075 - 0.0025 * alp1 * 180.0 / pi)			! いそコードはこっち
!   Un2 = Un1 * (0.300 - 0.0020 * alp1 * 180.0 / pi)
!   ! 衝突後の質量比 (飛んでいく分)
!!   mr2 = mr1 * ( 1.0 - 0.7 * ( 1.0 - sin(alp1) ) * ( 1.0 - exp( -0.0092026 * (KL - 200.0) ) ) )
!   mr2 = mr1 * 0.7 * ( 1.0 - sin(alp1) ) * ( 1.0 - exp( -0.0092026 * (KL - 200.0) ) )
!   ImpMass = Rhow * 4.0 / 3.0 * pi * (0.5 * dp1)**3.0 * (1.0 - mr2)
!!   write(*, '(a, e16.8e3)')' * ImpMass = ', ImpMass
!   if(mr2 >= mr1) then
!     write(*, '(a)') '!!!!! Error : Mass rate of splash droplet !!!!!'
!     write(*, '(a,e16.8e3)') '* mr1 = ', mr1
!     write(*, '(a,e16.8e3)') '* mr2 = ', mr2
!   endif
!  else
!   ! バウンド ------------------------------------------------------------------------------------------
!   ! 液滴数のカウンター
!   nBou = nBou + 1
!   ! 衝突後の液滴径
!   dp2 = dp1
!   ! 衝突後の液滴速度成分 (壁面直行座標系)
!   Uh2 = Uh1
!   Un2 = Un1
!   ! 衝突後の質量比
!   mr2 = mr1 * 1.0
!   ! 壁面衝突のフラグ
!   fImpi = .false.
! endif
 ! スプラッシュ・バウンド (計算座標系) +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! 壁面水平方向単位ベクトル ----------------------------------------------------------------------------
 Hx = Ux - Udotp * Nx
 Hy = Uy - Udotp * Ny
 Hz = Uz - Udotp * Nz
 Hi = 1.0 / max( zero, sqrt(Hx**2 + Hy**2 + Hz**2) )
 Hx = Hx * Hi
 Hy = Hy * Hi
 Hz = Hz * Hi
 ! 跳ね返り後の液滴速度 --------------------------------------------------------------------------------
 Un2  = -1.0 * Un2
 alp2 = atan(Un2 / Uh2)
 up2  = Uh2 * Hx + Un2 * Nx
 vp2  = Uh2 * Hy + Un2 * Ny
 wp2  = Uh2 * Hz + Un2 * Nz
 ! 処理終了 ********************************************************************************************
 return
end subroutine SplashLEWICE3D
!**************************************************************************************************
! スプラッシュモデル (高速領域で計算可能？)
! Droplet interaction with shear-driven liquid films: analysis of deposition and secondary droplet characteristics
! W.Samenfink , International Journal of Heat and Fluid Flow 20 (1999) 462-469
!**************************************************************************************************
!Samefink Model ***********************************************************************************
subroutine SplashSamenfink( &
&             xp, yp, zp, up1, vp1, wp1, dp1, mr1, x1, y1, z1, x2, y2, z2, x3, y3, z3, &
&             LWC, Rhow, Sigw, muw, SLDlim, Chord, &
&             fImpi, up2, vp2, wp2, dp2, mr2, nSpl, nBou )
!変数宣言******************************************************************************************
implicit none
 real, parameter :: pi   = 3.1415926535897932
 real, parameter :: zero = 1.0e-20
!引数変数++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
real   , intent(in)    :: Chord						! 翼弦長
real   , intent(in)    :: xp, yp, zp					! 液滴座標
real   , intent(in)    :: up1, vp1, wp1					! 液滴衝突速度
real   , intent(in)    :: dp1						! 衝突前の液滴径
real   , intent(in)    :: mr1						! 衝突前の液滴質量比
real   , intent(in)    :: x1, y1, z1					! 壁面座標1
real   , intent(in)    :: x2, y2, z2					! 壁面座標2
real   , intent(in)    :: x3, y3, z3					! 壁面座標3
real   , intent(in)    :: LWC						! 液滴水分含有率
real   , intent(in)    :: Rhow						! 水の密度
real   , intent(in)    :: Sigw						! 水の表面張力
real   , intent(in)    :: muw						! 水の粘性係数
real   , intent(in)    :: SLDLim					! SLDの閾値
logical, intent(out)   :: fImpi						! 衝突判定
real   , intent(out)   :: up2, vp2, wp2					! 液滴跳ね返り速度
real   , intent(out)   :: dp2						! 衝突後の液滴径
real   , intent(out)   :: mr2						! 衝突後の液滴質量比
integer, intent(inout) :: nSpl						! スプラッシュの液滴数
integer, intent(inout) :: nBou						! バウンドの液滴数
! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
real :: Ax, Ay, Az, Bx, By, Bz						! 壁面位置v
real :: Nx, Ny, Nz, Ni, Hx, Hy, Hz, Hi					! 壁面法線vと垂直v
real :: dl								! 液滴と壁面の距離
real :: Ux, Uy, Uz, UU							! 液滴速度v (計算座標)
real :: Udotp								! 液滴速度vと壁面法線単位vの内積
real :: Uh1, Un1, Uh2, Un2						! 液滴速度v (壁面直行座標)
real :: alp1, bet1							! 液滴衝突角
real :: Thetas								! 液滴跳ね返り角
real :: S, La, KR							! スプラッシュパラメータ
real :: Rew								! レイノルズ数
real :: Ohw								! オーネゾルゲ数
real :: Wele								! 前縁でのウェーバー数
real :: Delta								! 水膜厚さ
real :: Dle								! 前縁の直径
real :: Vs								! スプラッシュ後の速度
! 局所定数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
real ,parameter :: Rho0 = 1.10						! 前縁曲率半径比
! 処理開始 ****************************************************************************************
! 壁面衝突判定 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! 壁面法線方向単位ベクトル (外積から導出) ---------------------------------------------------------
Ax = x2 - x1
Ay = y2 - y1
Az = z2 - z1
Bx = x3 - x1
By = y3 - y1
Bz = z3 - z1
Nx = Ay * Bz - Az * By
Ny = Az * Bx - Ax * Bz
Nz = Ax * By - Ay * Bx
Ni = 1.0 / max(zero, sqrt(Nx**2 + Ny**2 + Nz**2))
Nx = Nx * Ni
Ny = Ny * Ni
Nz = Nz * Ni
! 液滴と衝突面の距離 (内積から導出) ---------------------------------------------------------------
dl = (xp - x1) * Nx + (yp - y1) * Ny + (zp - z1) * Nz
! 液滴と衝突面との距離が液滴径以下であれば衝突と判定 ----------------------------------------------
if(dl <= 0.5 * dp1) then
  fImpi = .true.
 else
  fImpi = .false.
  up2 = up1; vp2 = vp1; wp2 = wp1; dp2 = dp1; mr2 = mr1
  return
endif
! 衝突角と衝突速度 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! 衝突液滴の速度ベクトル --------------------------------------------------------------------------
Ux = up1
Uy = vp1
Uz = wp1
UU = sqrt(Ux**2 + Uy**2 + Uz**2)
! 衝突角 (壁面法線ベクトルと液滴速度ベクトルの内積から導出) ---------------------------------------
Udotp = Ux * Nx + Uy * Ny + Uz * Nz
bet1  = min(0.5 * pi, max(0.0, acos(-1.0 * Udotp / max(UU, zero) ) ) )
alp1  = 0.5 * pi - bet1
! 衝突速度の壁面水平成分と壁面垂直成分 (壁面直行座標系) -------------------------------------------
Uh1 = UU * cos(alp1)
Un1 = UU * sin(alp1)
Un1 = -1.0 * Un1
! スプラッシュパラメータ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! Ohnesorge数 -------------------------------------------------------------------------------------
Ohw = muw / sqrt(Rhow * Sigw * dp1)
! Reynolds数 --------------------------------------------------------------------------------------
! Rew = Rhow * UU * dp1 / muw
Rew = Rhow * abs(Un1) * dp1 / muw					! いそコードはこっち
! 前縁の直径 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Dle = 2.0 * Rho0 * (0.12 * Chord) * 0.12**2				! 翼型学p2 ρ0の式を変形
! Weber数 -----------------------------------------------------------------------------------------
Wele = Rhow * Dle * UU / Sigw
! 水膜厚さ ----------------------------------------------------------------------------------------
Delta = 3.76 * (Dle / dp1)**1.25 * (LWC / Rhow)**0.5 * Wele**(-0.125)
! Splash変数 --------------------------------------------------------------------------------------
La = 1.0 / Ohw**2.0
S  = Rew / ( 24.0 * La**0.419)
KR = 1.0 - 0.03454 * S**0.175 * alp1**0.1239 * La**0.265
! スプラッシュ・バウンド判定 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
if(S <= 1.0 .or. S >= 5.0 .or. dp1 <= SLDLim) then
  ! 全質量壁面付着 --------------------------------------------------------------------------------
  up2 = 0.0; vp2 = 0.0; wp2 = 0.0
  dp2 = 0.0; mr2 = 0.0
  return
 else if(KR < 1.0) then
! スプラッシュ ------------------------------------------------------------------------------------
! 液滴数のカウンター
  nSpl = nSpl + 1
! 衝突後の液滴径
  dp2 = KR * dp1
!スプラッシュ角度
  Thetas = 2.154 * S**1.0946 * alp1**0.03389 * Delta**(-0.1589)
!衝突後の速度
  Vs = 0.08214 * S**(-0.3384) * alp1**0.2938 * Delta**(-0.03113) * La**0.01157 * UU
! 衝突後の液滴速度成分 (壁面直行座標系)
  Uh2 = Vs * cos(pi * Thetas / 180.0)
  Un1 = Vs * sin(pi * Thetas / 180.0)
! 衝突後の質量比
  mr2 = mr1 * 0.0866 * (S - 1)**0.3188 * alp1**0.1223 * Delta**(-0.9585)
   if(mr2 >= mr1) then
     write(*, '(a)') '!!!!! Error : Mass rate of splash droplet !!!!!'
     write(*, '(a,e16.8e3)') '* mr1 = ', mr1
     write(*, '(a,e16.8e3)') '* mr2 = ', mr2
   endif
  else
! バウンド ----------------------------------------------------------------------------------------
! 液滴数のカウンター
   nBou = nBou + 1
! 衝突後の液滴径
   dp2 = dp1
! 衝突後の液滴速度成分 (壁面直行座標系)
   Uh2 = Uh1
   Un2 = Un1
! 衝突後の質量比
   mr2 = mr1 * 1.0
! 壁面衝突のフラグ
   fImpi = .false.
endif
! スプラッシュ・バウンド (計算座標系) +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! 壁面水平方向単位ベクトル ------------------------------------------------------------------------
Hx = Ux - Udotp * Nx
Hy = Uy - Udotp * Ny
Hz = Uz - Udotp * Nz
Hi = 1.0 / max( zero, sqrt(Hx**2 + Hy**2 + Hz**2) )
Hx = Hx * Hi
Hy = Hy * Hi
Hz = Hz * Hi
! 跳ね返り後の液滴速度 ----------------------------------------------------------------------------
Un2  = -1.0 * Un2
! alp2 = atan(Un2 / Uh2)
up2  = Uh2 * Hx + Un2 * Nx
vp2  = Uh2 * Hy + Un2 * Ny
wp2  = Uh2 * Hz + Un2 * Nz
! 処理終了 ****************************************************************************************
return
end subroutine SplashSamenfink
!*******************************************************************************************************
!******** MicroAVS ファイル出力									********
!*******************************************************************************************************
subroutine MakeMAVSFileDroplet3D( &
&            strdir, strname, ext, lRef, aRef, iteration, x, y, z, u, v, w )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strdir*(*), strname*(*), ext*4
 real,      intent(in) :: lRef, aRef
 integer,   intent(in) :: iteration
 real,      intent(in) :: x(1:iteration), y(1:iteration), z(1:iteration)
 real,      intent(in) :: u(1:iteration), v(1:iteration), w(1:iteration)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: n
 ! 処理開始 ********************************************************************************************
 open(1, file = trim(strdir) // trim(strname) // ext, form = 'formatted', status = 'replace')
  ! ヘッダ出力 -----------------------------------------------------------------------------------------
  write(1, '(a)')     '# AVS field file'
  write(1, '(a)')     'ndim = 1'
  write(1, '(a, i6)') 'dim1 = ', iteration
  write(1, '(a)')     'nspace = 3'
  write(1, '(a)')     'veclen = 1'
  write(1, '(a)')     'data = float'
  write(1, '(a)')     'field = irregular'
  write(1, '(a)')     'label = vabs'
  ! データファイル設定 ---------------------------------------------------------------------------------
  write(1, '(3a)') 'variable 1 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 3 stride = 4 close = 1'
  write(1, '(3a)') 'coord    1 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 0 stride = 4 close = 1'
  write(1, '(3a)') 'coord    2 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 1 stride = 4 close = 1'
  write(1, '(3a)') 'coord    3 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 2 stride = 4 close = 1'
  write(1, '(a)') 'eot'
  write(1, '(a)') ''
  ! データ出力 -----------------------------------------------------------------------------------------
  do n = 1, iteration
   write(1, '(e16.8e3, 3(1x, e16.8e3))') x(n) * lRef, y(n) * lRef, z(n) * lRef, &
   &                                     sqrt( u(n)**2 + v(n)**2 + w(n)**2 ) * aRef
  enddo
 close(1)
 ! 処理終了 ********************************************************************************************
 return
end subroutine MakeMAVSFileDroplet3D
!*******************************************************************************************************
!******** MicroAVS ファイル出力									********
!*******************************************************************************************************
subroutine MakeMAVSFileDropletTemperature3D( &
&            strdir, strname, ext, lRef, aRef, iteration, x, y, z, t )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strdir*(*), strname*(*), ext*4
 integer,   intent(in) :: iteration
 real   ,   intent(in) :: lRef, aRef
 real   ,   intent(in) :: x(1:iteration), y(1:iteration), z(1:iteration)
 real   ,   intent(in) :: t(1:iteration)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: n
 ! 処理開始 ********************************************************************************************
 open(1, file = trim(strdir) // trim(strname) // ext, form = 'formatted', status = 'replace')
  ! ヘッダ出力 -----------------------------------------------------------------------------------------
  write(1, '(a)')     '# AVS field file'
  write(1, '(a)')     'ndim = 1'
  write(1, '(a, i6)') 'dim1 = ', iteration
  write(1, '(a)')     'nspace = 3'
  write(1, '(a)')     'veclen = 1'
  write(1, '(a)')     'data = float'
  write(1, '(a)')     'field = irregular'
  write(1, '(a)')     'label = vabs'
  ! データファイル設定 ---------------------------------------------------------------------------------
  write(1, '(3a)') 'variable 1 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 3 stride = 4 close = 1'
  write(1, '(3a)') 'coord    1 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 0 stride = 4 close = 1'
  write(1, '(3a)') 'coord    2 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 1 stride = 4 close = 1'
  write(1, '(3a)') 'coord    3 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 2 stride = 4 close = 1'
  write(1, '(a)') 'eot'
  write(1, '(a)') ''
  ! データ出力 -----------------------------------------------------------------------------------------
  do n = 1, iteration
   write(1, '(e16.8e3, 3(1x, e16.8e3))') x(n) * lRef, y(n) * lRef, z(n) * lRef, &
   &                                     t(n) * aRef**2
  enddo
 close(1)
 ! 処理終了 ********************************************************************************************
 return
end subroutine MakeMAVSFileDropletTemperature3D
!*******************************************************************************************************
!******** MicroAVS ファイル出力 (SLD)								********
!*******************************************************************************************************
subroutine MakeMAVSFileSLD3D( &
&            strdir, strname, ext, lRef, aRef, iteration, x, y, z, m )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strdir*(*), strname*(*), ext*4
 real,      intent(in) :: lRef, aRef
 integer,   intent(in) :: iteration
 real   ,   intent(in) :: x(1:iteration), y(1:iteration), z(1:iteration)
 real,      intent(in) :: m(1:iteration)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: n
 ! 処理開始 ********************************************************************************************
 open(1, file = trim(strdir) // trim(strname) // ext, form = 'formatted', status = 'replace')
  ! ヘッダ出力 -----------------------------------------------------------------------------------------
  write(1, '(a)')     '# AVS field file'
  write(1, '(a)')     'ndim = 1'
  write(1, '(a, i6)') 'dim1 = ', iteration
  write(1, '(a)')     'nspace = 3'
  write(1, '(a)')     'veclen = 1'
  write(1, '(a)')     'data = float'
  write(1, '(a)')     'field = irregular'
  write(1, '(a)')     'label = vabs'
  ! データファイル設定 ---------------------------------------------------------------------------------
  write(1, '(3a)') 'variable 1 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 3 stride = 4 close = 1'
  write(1, '(3a)') 'coord    1 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 0 stride = 4 close = 1'
  write(1, '(3a)') 'coord    2 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 1 stride = 4 close = 1'
  write(1, '(3a)') 'coord    3 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 2 stride = 4 close = 1'
  write(1, '(a)') 'eot'
  write(1, '(a)') ''
  ! データ出力 -----------------------------------------------------------------------------------------
  do n = 1, iteration
   write(1, '(e16.8e3, 4(1x, e16.8e3))') x(n) * lRef, y(n) * lRef, z(n) * lRef, &
   &                                     m(n)
  enddo
 close(1)
 ! 処理終了 ********************************************************************************************
 return
end subroutine MakeMAVSFileSLD3D
!*******************************************************************************************************
!******** MicroAVS ファイル出力	(We数)								********
!*******************************************************************************************************
subroutine MakeMAVSFileDropletWe3D( &
&            strdir, strname, ext, iteration, lRef, x, y, z, We )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strdir*(*), strname*(*), ext*4
 integer,   intent(in) :: iteration
 real   ,   intent(in) :: lRef
 real   ,   intent(in) :: x(1:iteration), y(1:iteration), z(1:iteration)
 real   ,   intent(in) :: We(1:iteration)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: n
 ! 処理開始 ********************************************************************************************
 open(1, file = trim(strdir) // trim(strname) // ext, form = 'formatted', status = 'replace')
  ! ヘッダ出力 -----------------------------------------------------------------------------------------
  write(1, '(a)')     '# AVS field file'
  write(1, '(a)')     'ndim = 1'
  write(1, '(a, i6)') 'dim1 = ', iteration
  write(1, '(a)')     'nspace = 3'
  write(1, '(a)')     'veclen = 1'
  write(1, '(a)')     'data = float'
  write(1, '(a)')     'field = irregular'
  write(1, '(a)')     'label = vabs'
  ! データファイル設定 ---------------------------------------------------------------------------------
  write(1, '(3a)') 'variable 1 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 3 stride = 4 close = 1'
  write(1, '(3a)') 'coord    1 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 0 stride = 4 close = 1'
  write(1, '(3a)') 'coord    2 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 1 stride = 4 close = 1'
  write(1, '(3a)') 'coord    3 file= ', trim(strname) // ext, &
  &                ' filetype = ascii skip = 14 offset = 2 stride = 4 close = 1'
  write(1, '(a)') 'eot'
  write(1, '(a)') ''
  ! データ出力 -----------------------------------------------------------------------------------------
  do n = 1, iteration
   write(1, '(e16.8e3, 3(1x, e16.8e3))') x(n) * lRef, y(n) * lRef, z(n) * lRef, &
   &                                     We(n)
  enddo
 close(1)
 ! 処理終了 ********************************************************************************************
 return
end subroutine MakeMAVSFileDropletWe3D
! 定義終了 *********************************************************************************************
end module Package_Droplet
```

## file "Mod_Package_Equation.f90"

```fortran
!***********************************************************************
!***********************************************************************
!**** パッケージ型モジュール                                        ****
!**** 方程式の解法及び近似用サブルーチン群                          ****
!****                         2008.12.01 PROGRAMED BY SUZUKI MASAYA ****
!****                         2011.10.15 UPDATED BY RYOSUKE HAYASHI ****
!***********************************************************************
!***********************************************************************
MODULE Package_Equation
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 局所定数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  PRIVATE
  ! サブルーチン宣言 ***************************************************
  ! 共有サブルーチン(正也さん作) +++++++++++++++++++++++++++++++++++++++
  PUBLIC :: Gauss
  PUBLIC :: NRM_SM
  PUBLIC :: LeastSquaresMethod
  PUBLIC :: LagrangeInterpolation
  PUBLIC :: DividedDifference, NewtonDividedDifference
  PUBLIC :: BSpline1, BSpline2, BSpline2dBC
  PUBLIC :: NormalizedBSpline, NormalizedBSplinedBC
  PUBLIC :: NSpline
  PUBLIC :: NaturalSpline
  PUBLIC :: SplineSecondInterpolationSet, SplineSecondInterpolationCalc
  PUBLIC :: SplineThirdInterpolationSet, SplineThirdInterpolationCalc
  PUBLIC :: BezierCurve, BSplineCurve
  PUBLIC :: BezierSurface, BSplineSurface
  ! 共有サブルーチン(自作) +++++++++++++++++++++++++++++++++++++++
  PUBLIC :: LinearInterpolation
! 内部手続き ***********************************************************
CONTAINS
!***********************************************************************
!**** Gauss の消去法                                                ****
!***********************************************************************
SUBROUTINE Gauss(DIMS, DIME, A, B, X)
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: DIMS, DIME
  REAL,    INTENT(IN)  :: A(DIMS:DIME, DIMS:DIME), B(DIMS:DIME)
  REAL,    INTENT(OUT) :: X(DIMS:DIME)
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL :: ML(DIMS:DIME, DIMS:DIME), MR(DIMS:DIME)
  INTEGER :: N, M, NP, MP, NN
  REAL :: P, SWAP
  REAL, PARAMETER :: ZeroLimit = 1.0E-10
  ! 処理開始 ***********************************************************
  ! 初期化 -------------------------------------------------------------
  DO M = DIMS, DIME
    DO N = DIMS, DIME
      ML(N, M) = A(N, M)
    ENDDO
  ENDDO
  DO N = DIMS, DIME
    MR(N) = B(N)
  ENDDO
  ! 前進消去 -----------------------------------------------------------
  DO N = DIMS, DIME
    ! ピボット選択
    P = ML(N, N)
    DO NP = N + 1, DIME
      IF( ABS(P) .LT. ABS(ML(NP, N)) ) THEN
        P = ML(NP, N)
        DO MP = DIMS, DIME
          SWAP       = ML(N,  MP)
          ML(N,  MP) = ML(NP, MP)
          ML(NP, MP) = SWAP
        ENDDO
          SWAP   = MR(N)
          MR(N ) = MR(NP)
          MR(NP) = SWAP
      ENDIF
    ENDDO
    IF(ABS(P) .LE. ZeroLimit) THEN
      WRITE(*, '(A)') 'Cant solve a simulaneous equation...'
      RETURN
    ENDIF
    ! ピボット行の標準化
    DO M = DIMS, DIME
      ML(N, M) = ML(N, M) / P
    ENDDO
    MR(N) = MR(N) / P
    ! ピボット行以下の掃き出し
    DO NN = N + 1, DIME
      IF(NN .EQ. N) CYCLE
      P = ML(NN, N)
      IF(ABS(P) .LE. ZeroLimit) CYCLE
      DO M = DIMS, DIME
        ML(NN, M) = ML(NN, M) - ML(N, M) * P
      ENDDO
      MR(NN) = MR(NN) - MR(N) * P
    ENDDO
  ENDDO
  ! 後進代入 -----------------------------------------------------------
  DO N = DIME, DIMS, -1
    DO M = N + 1, DIME
      MR(N) = MR(N) - ML(N, M) * MR(M)
    ENDDO
    MR(N) = MR(N) / ML(N, N)
    X(N)  = MR(N)
  ENDDO
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE Gauss
!***********************************************************************
!**** Newton-Raphson Method (Secant Method)                         ****
!***********************************************************************
SUBROUTINE NRM_SM(Func, NMAX, EPS, x_init, x_solv)
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    EXTERNAL    :: Func         ! 関数 Func(x) = 0
  INTEGER, INTENT(IN)  :: NMAX         ! 計算回数の最大値
  REAL,    INTENT(IN)  :: EPS          ! 収束判定値
  REAL,    INTENT(IN)  :: x_init       ! 初期値
  REAL,    INTENT(OUT) :: x_solv       ! Func(x) = 0 を満たす x の収束解
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: n
  REAL(8) :: x0, x1, x, dx, df
  ! 処理開始 ***********************************************************
  ! WRITE(*,'(A)') '------------ Newton-Raphson Method log ------------'
  x0 = DBLE(x_init)
  x  = DBLE(x_init) + 0.01D+0 * DBLE(x_init)
  DO n = 1, NMAX
    df = DBLE(Func(REAL(x)) - Func(REAL(x0)))
    IF(ABS(df) .LE. DBLE(EPS)) THEN
      EXIT
    ENDIF
    x1 = (x0 * DBLE(Func(REAL(x))) - x * DBLE(Func(REAL(x0)))) / df
    dx = ABS((x1 - x) / x1)
    x0 = x
    x  = x1
    ! WRITE(*,'(A, I4, 2X, A, 2X, A, E16.8E3, 2X, A, 2X, A, E16.8E3)') &
    ! &  'Iteration = ', n, '|', 'x = ', x, '|', 'dx = ', dx
    IF(dx .LE. DBLE(EPS)) THEN
      EXIT
    ENDIF
  ENDDO
  x_solv = REAL(x)
  ! WRITE(*,'(A)') '---------------------------------------------------'
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE NRM_SM
!***********************************************************************
!**** 最小2乗法(Least Squares Method)による関数作成                 ****
!***********************************************************************
SUBROUTINE LeastSquaresMethod( &
&            FuncDIM, DATAS, DATAE, X, F, Weight, Coefficient &
&          )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: FuncDIM, DATAS, DATAE
  REAL,    INTENT(IN)  :: X(DATAS:DATAE), F(DATAS:DATAE), &
  &                       Weight(DATAS:DATAE)
  REAL,    INTENT(OUT) :: Coefficient(0:FuncDIM)
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: L, N, M
  REAL :: MatrixLeft(0:FuncDIM, 0:FuncDIM), MatrixRight(0:FuncDIM)
  ! 処理開始 ***********************************************************
  ! 左辺、右辺配列初期化 +++++++++++++++++++++++++++++++++++++++++++++++
  DO M = 0, FuncDIM
    DO N = 0, FuncDIM
      MatrixLeft(N, M) = 0.0
    ENDDO
  ENDDO
  DO N = 0, FuncDIM
    MatrixRight(N) = 0.0
  ENDDO
  ! 左辺、右辺配列初期値 +++++++++++++++++++++++++++++++++++++++++++++++
  DO M = 0, FuncDIM
    DO N = 0, FuncDIM
      DO L = DATAS, DATAE
        MatrixLeft(N, M) = MatrixLeft(N, M) &
        &                + Weight(L) * PHI(X(L), N) * PHI(X(L), M)
      ENDDO
    ENDDO
  ENDDO
  DO N=0,FuncDIM
    DO L=DATAS,DATAE
      MatrixRight(N) = MatrixRight(N) &
      &              + Weight(L) * F(L) * PHI(X(L), N)
    ENDDO
  ENDDO
  ! ガウス法の消去法 +++++++++++++++++++++++++++++++++++++++++++++++++++
  CALL Gauss(0, FuncDIM, MatrixLeft, MatrixRight, Coefficient)
  ! 処理終了 ***********************************************************
  RETURN
! 内部手続き ***********************************************************
CONTAINS
!***********************************************************************
!**** 関数定義                                                      ****
!***********************************************************************
FUNCTION PHI(X, J)
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN) :: X
  INTEGER, INTENT(IN) :: J
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL PHI
  ! 処理開始 ***********************************************************
  IF( J .EQ. 0 ) THEN
    PHI = 1.0
  ELSE
    PHI = X**J
  ENDIF
  ! 処理終了 ***********************************************************
  RETURN
END FUNCTION PHI
! 定義終了 *************************************************************
END SUBROUTINE LeastSquaresMethod
!***********************************************************************
!**** Lagrangeの補間多項式                                          ****
!**** (節点数が多すぎるとルンゲの現象が生じるので注意)              ****
!***********************************************************************
SUBROUTINE LagrangeInterpolation( &
&            n, xn, yn, x, L &
&          )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: n             ! 節点数
  REAL,    INTENT(IN)  :: xn(n), yn(n)  ! 節点座標
  REAL,    INTENT(IN)  :: x             ! 補間点の x 座標
  REAL,    INTENT(OUT) :: L             ! 補間点の y 座標
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: i, j
  REAL    :: P
  ! 処理開始 ***********************************************************
  ! 例外処理 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  IF(n .LE. 1) THEN
    WRITE(*,'(A)') 'LagrangeInterpolation - Error : n <= 1'
    STOP
  ENDIF
  DO i = 1, n - 1
    IF(xn(i) .GE. xn(i + 1)) THEN
      WRITE(*,'(A)') 'LagrangeInterpolation - Error : xn(i) >= xn(i+1)'
      STOP
    ENDIF
  ENDDO
  ! 公式の計算 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  L = 0.0
  DO i = 1, n
    P = 1.0
    DO j = 1, i - 1
      P = P * (x - xn(j)) / (xn(i) - xn(j))
    ENDDO
    DO j = i + 1, n
      P = P * (x - xn(j)) / (xn(i) - xn(j))
    ENDDO
    L = L + P * yn(i)
  ENDDO
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE LagrangeInterpolation
!***********************************************************************
!**** 差分商                                                        ****
!***********************************************************************
REAL FUNCTION DividedDifference(n, xn, yn) RESULT(F)
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: n             ! データ点数 (n - 1階差分商)
  REAL,    INTENT(IN)  :: xn(n), yn(n)  ! 関数 y = f(x)
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: i
  ! 処理開始 ***********************************************************
  ! 例外処理 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  IF(n .LE. 1) THEN
    WRITE(*,'(A)') 'DividedDifference - Error : n <= 1'
    STOP
  ENDIF
  DO i = 1, n - 1
    IF(xn(i) .GE. xn(i + 1)) THEN
      WRITE(*,'(A)') 'DividedDifference - Error : xn(i) >= xn(i+1)'
      STOP
    ENDIF
  ENDDO
  ! 公式の計算 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  F = 0.0
  DO i = 1, n
    F = F + yn(i) / P(i, xn(i))
  ENDDO
  ! 処理終了 ***********************************************************
  RETURN
! 内部手続き ***********************************************************
CONTAINS
!***********************************************************************
!**** 関数定義                                                      ****
!***********************************************************************
REAL FUNCTION P(j, t)
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN) :: j
  REAL,    INTENT(IN) :: t
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: i
  ! 処理開始 ***********************************************************
  P = 1.0
  DO i = 1, j - 1
    P = P * (t - xn(i))
  ENDDO
  DO i = j + 1, n
    P = P * (t - xn(i))
  ENDDO
  ! 処理終了 ***********************************************************
  RETURN
END FUNCTION P
! 定義終了 *************************************************************
END FUNCTION DividedDifference
!***********************************************************************
!**** Newtonの差分商補間公式                                        ****
!***********************************************************************
REAL FUNCTION NewtonDividedDifference(n, xn, yn, x) RESULT(f)
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: n             ! データ点数
  REAL,    INTENT(IN)  :: xn(n), yn(n)  ! 関数 y = f(x)
  REAL,    INTENT(IN)  :: x             ! 補間点の x
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: k, i
  REAL    :: Fk
  ! 処理開始 ***********************************************************
  ! 例外処理 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  IF(n .LE. 1) THEN
    WRITE(*,'(A)') 'NewtonDividedDifference - Error : n <= 1'
    STOP
  ENDIF
  DO i = 1, n - 1
    IF(xn(i) .GE. xn(i + 1)) THEN
      WRITE(*,'(A)') 'NewtonDividedDifference - ' // &
      &              'Error : xn(i) >= xn(i+1)'
      STOP
    ENDIF
  ENDDO
  ! 公式の計算 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  f = yn(1)
  DO k = 1, n - 1
    Fk = DividedDifference(k + 1, xn(1: k + 1), yn(1: k + 1))
    DO i = 1, k
      Fk = Fk * (x - xn(i))
    ENDDO
    f = f + Fk
  ENDDO
  ! 処理終了 ***********************************************************
  RETURN
END FUNCTION NewtonDividedDifference
!***********************************************************************
!**** B-スプライン(Schoenbergの定義)                                ****
!***********************************************************************
REAL FUNCTION BSpline1(m, xm, x) RESULT(Mi)
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: m             ! 位数 (m-1次)
  REAL,    INTENT(IN)  :: xm(m + 1)     ! 節点
  REAL,    INTENT(IN)  :: x             ! 補間点の x
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: i
  REAL    :: ym(m + 1)
  ! 処理開始 ***********************************************************
  ! 例外処理 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  IF(m .LE. 1) THEN
    WRITE(*,'(A)') 'BSpline1 - Error : m <= 1'
    STOP
  ENDIF
  DO i = 1, m
    IF(xm(i) .GE. xm(i + 1)) THEN
      WRITE(*,'(A)') 'BSpline1 - Error : xm(i) >= xm(i+1)'
      STOP
    ENDIF
  ENDDO
  ! 公式の計算 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  DO i = 1, m + 1
    ym(i) = MM(x, xm(i))
  ENDDO
  Mi = DividedDifference(m + 1, xm, ym)
  ! 処理終了 ***********************************************************
  RETURN
! 内部手続き ***********************************************************
CONTAINS
!***********************************************************************
!**** 関数定義                                                      ****
!***********************************************************************
REAL FUNCTION MM(x, t)
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, INTENT(IN) :: x, t
  ! 処理開始 ***********************************************************
  IF(t - x .GT. 0.0) THEN
    MM = REAL(m) * (t - x)**(m - 1)
  ELSE
    MM = 0.0
  ENDIF
  ! 処理終了 ***********************************************************
  RETURN
END FUNCTION MM
! 定義終了 *************************************************************
END FUNCTION BSpline1
!***********************************************************************
!**** B-スプライン(de Boorの定義)                                   ****
!***********************************************************************
REAL FUNCTION BSpline2(k, xi_k, x) RESULT(M_ik)
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: k             ! 位数 (k-1次)
  REAL,    INTENT(IN)  :: xi_k(k + 1)   ! 節点
  REAL,    INTENT(IN)  :: x             ! 補間点の x
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: i
  REAL    :: M_k(k + 1)
  ! 処理開始 ***********************************************************
  ! 例外処理 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  IF(k .LE. 1) THEN
    WRITE(*,'(A)') 'BSpline2 - Error : k <= 1'
    STOP
  ENDIF
  DO i = 1, k
    IF(xi_k(i) .GE. xi_k(i + 1)) THEN
      WRITE(*,'(A)') 'BSpline2 - Error : xi_k(i) >= xi_k(i+1)'
      STOP
    ENDIF
  ENDDO
  ! 公式の計算 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  DO i = 1, k + 1
    M_k(i) = MM(x, xi_k(i))
  ENDDO
  M_ik = DividedDifference(k + 1, xi_k, M_k)
  ! 処理終了 ***********************************************************
  RETURN
! 内部手続き ***********************************************************
CONTAINS
!***********************************************************************
!**** 関数定義                                                      ****
!***********************************************************************
REAL FUNCTION MM(x, t)
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, INTENT(IN) :: x, t
  ! 処理開始 ***********************************************************
  IF(t - x .GT. 0.0) THEN
    MM = (t - x)**(k - 1)
  ELSE
    MM = 0.0
  ENDIF
  ! 処理終了 ***********************************************************
  RETURN
END FUNCTION MM
! 定義終了 *************************************************************
END FUNCTION BSpline2
!***********************************************************************
!**** Bスプライン(de Boorの定義, de Boor-Coxの算法)                 ****
!***********************************************************************
REAL FUNCTION BSpline2dBC(k, xi_k, x) RESULT(M_k)
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: k             ! 位数 (k-1次)
  REAL,    INTENT(IN)  :: xi_k(k + 1)   ! 節点
  REAL,    INTENT(IN)  :: x             ! 補間点の x
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: i, j
  REAL    :: M_ik(k, k), M_ik1, M_ik2
  ! 処理開始 ***********************************************************
  ! 例外処理 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  IF(k .LE. 1) THEN
    WRITE(*,'(A)') 'BSpline2dBC - Error : k <= 1'
    STOP
  ENDIF
  DO i = 1, k
    IF(xi_k(i) .GT. xi_k(i + 1)) THEN
      WRITE(*,'(A)') 'BSpline2dBC - Error : xi_k(i) >= xi_k(i+1)'
      STOP
    ENDIF
  ENDDO
  ! 0次BスプラインM_i,1を計算 ++++++++++++++++++++++++++++++++++++++++++
  ! 多重節点の場合、計算は破綻しないが不正確な値しか得られない
  DO i = 1, k
    IF(xi_k(i) .LE. x .AND. x .LT. xi_k(i + 1)) THEN
      M_ik(i, 1) = 1.0 / (xi_k(i + 1) - xi_k(i))
    ELSE
      M_ik(i, 1) = 0.0
    ENDIF
  ENDDO
  ! k-1次Bスプラインを計算 +++++++++++++++++++++++++++++++++++++++++++++
  DO j = 2, k
    DO i = 1, k - j + 1
      IF(xi_k(i + j) - xi_k(i + 1) .NE. 0.0) THEN
        M_ik1 = (xi_k(i + j) - x) / (xi_k(i + j) - xi_k(i)) &
        &     * M_ik(i + 1, j - 1)
      ELSE
        M_ik1 = 0.0
      ENDIF
      IF(xi_k(i + j - 1) - xi_k(i) .NE. 0.0) THEN
        M_ik2 = (xi_k(i) - x) / (xi_k(i + j) - xi_k(i)) &
        &     * M_ik(i, j - 1)
      ELSE
        M_ik2 = 0.0
      ENDIF
      M_ik(i, j) = M_ik1 - M_ik2
    ENDDO
  ENDDO
  M_k = M_ik(1, k)
  ! 処理終了 ***********************************************************
  RETURN
END FUNCTION BSpline2dBC
!***********************************************************************
!**** 正規化されたB-スプライン                                      ****
!***********************************************************************
REAL FUNCTION NormalizedBSpline(k, xi_k, x) RESULT(N_ik)
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: k             ! 位数 (k-1次)
  REAL,    INTENT(IN)  :: xi_k(k + 1)   ! 節点
  REAL,    INTENT(IN)  :: x             ! 補間点の x
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: i
  REAL    :: M_ik, M_k(k + 1)
  ! 処理開始 ***********************************************************
  ! 例外処理 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  IF(k .LE. 1) THEN
    WRITE(*,'(A)') 'NormalizedBSpline - Error : k <= 1'
    STOP
  ENDIF
  DO i = 1, k
    IF(xi_k(i) .GE. xi_k(i + 1)) THEN
      WRITE(*,'(A)') 'NormalizedBSpline - Error : xi_k(i) >= xi_k(i+1)'
      STOP
    ENDIF
  ENDDO
  ! Bスプライン(de Boorの定義)を計算 +++++++++++++++++++++++++++++++++++
  DO i = 1, k + 1
    M_k(i) = MM(x, xi_k(i))
  ENDDO
  M_ik = DividedDifference(k + 1, xi_k, M_k)
  ! 正規化 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  N_ik = (xi_k(k + 1) - xi_k(1)) * M_ik
  ! 処理終了 ***********************************************************
  RETURN
! 内部手続き ***********************************************************
CONTAINS
!***********************************************************************
!**** 関数定義                                                      ****
!***********************************************************************
REAL FUNCTION MM(x, t)
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, INTENT(IN) :: x, t
  ! 処理開始 ***********************************************************
  IF(t - x .GT. 0.0) THEN
    MM = (t - x)**(k - 1)
  ELSE
    MM = 0.0
  ENDIF
  ! 処理終了 ***********************************************************
  RETURN
END FUNCTION MM
! 定義終了 *************************************************************
END FUNCTION NormalizedBSpline
!***********************************************************************
!**** 正規化されたBスプライン(de Boor-Coxの算法)                    ****
!***********************************************************************
REAL FUNCTION NormalizedBSplinedBC(k, xi_k, x) RESULT(N_k)
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: k             ! 位数 (k-1次)
  REAL,    INTENT(IN)  :: xi_k(k + 1)   ! 節点
  REAL,    INTENT(IN)  :: x             ! 補間点の x
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: i, j
  REAL    :: N_ik(k, k), N_ik1, N_ik2
  ! 処理開始 ***********************************************************
  ! 例外処理 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  IF(k .LE. 1) THEN
    WRITE(*,'(A)') 'NormalizedBSplinedBC - Error : k <= 1'
    STOP
  ENDIF
  DO i = 1, k
    IF(xi_k(i) .GT. xi_k(i + 1)) THEN
      WRITE(*,'(A)') 'NormalizedBSplinedBC - ' // &
      &              'Error : xi_k(i) >= xi_k(i+1)'
      STOP
    ENDIF
  ENDDO
  ! 正規化された0次BスプラインN_i,1を計算 ++++++++++++++++++++++++++++++
  DO i = 1, k
    IF(xi_k(i) .LE. x .AND. x .LT. xi_k(i + 1)) THEN
      N_ik(i, 1) = 1.0
    ELSE
      N_ik(i, 1) = 0.0
    ENDIF
  ENDDO
  DO i = k, 1, - 1
    IF(ABS(xi_k(i) - xi_k(i + 1)) .LT. 1.0E-8 .AND. &
    &  ABS(xi_k(i) - x) .LT. 1.0E-8) THEN
      N_ik(i, 1) = 1.0
    ELSE
      EXIT
    ENDIF
  ENDDO
  ! 正規化されたk-1次Bスプラインを計算 +++++++++++++++++++++++++++++++++
  DO j = 2, k
    DO i = 1, k - j + 1
      IF(xi_k(i + j) - xi_k(i + 1) .NE. 0.0) THEN
        N_ik1 = (xi_k(i + j) - x) / (xi_k(i + j) - xi_k(i + 1)) &
        &     * N_ik(i + 1, j - 1)
      ELSE
        N_ik1 = N_ik(i + 1, j - 1)
      ENDIF
      IF(xi_k(i + j - 1) - xi_k(i) .NE. 0.0) THEN
        N_ik2 = (xi_k(i) - x) / (xi_k(i + j - 1) - xi_k(i)) &
        &     * N_ik(i, j - 1)
      ELSE
        N_ik2 = N_ik(i, j - 1)
      ENDIF
      N_ik(i, j) = N_ik1 - N_ik2
    ENDDO
  ENDDO
  N_k = N_ik(1, k)
  ! 処理終了 ***********************************************************
  RETURN
END FUNCTION NormalizedBSplinedBC
!***********************************************************************
!**** N-スプライン                                                  ****
!***********************************************************************
REAL FUNCTION NSpline(k, xk, x) RESULT(Ni)
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: k             ! 位数 (2k-1次の自然スプライン)
  REAL,    INTENT(IN)  :: xk(k + 1)     ! 節点
  REAL,    INTENT(IN)  :: x             ! 補間点の x
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: i
  REAL    :: yk(k + 1)
  ! 処理開始 ***********************************************************
  ! 例外処理 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  IF(k .LE. 1) THEN
    WRITE(*,'(A)') 'NSpline - Error : k <= 1'
    STOP
  ENDIF
  DO i = 1, k
    IF(xk(i) .GE. xk(i + 1)) THEN
      WRITE(*,'(A)') 'NSpline - Error : xk(i) >= xk(i+1)'
      STOP
    ENDIF
  ENDDO
  ! 公式の計算 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  DO i = 1, k + 1
    yk(i) = N(x, xk(i))
  ENDDO
  Ni = DividedDifference(k + 1, xk, yk)
  ! 処理終了 ***********************************************************
  RETURN
! 内部手続き ***********************************************************
CONTAINS
!***********************************************************************
!**** 関数定義                                                      ****
!***********************************************************************
REAL FUNCTION N(x, t)
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN) :: x, t
  ! 処理開始 ***********************************************************
  IF(x - t .GT. 0.0) THEN
    N = (x - t)**(2 * k - 1)
  ELSE
    N = 0.0
  ENDIF
  ! 処理終了 ***********************************************************
  RETURN
END FUNCTION N
! 定義終了 *************************************************************
END FUNCTION NSpline
!***********************************************************************
!**** 自然スプライン                                                ****
!***********************************************************************
SUBROUTINE NaturalSpline(n, xn, yn, k, x, y)
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: n             ! 節点数
  REAL,    INTENT(IN)  :: xn(n), yn(n)  ! 節点座標
  INTEGER, INTENT(IN)  :: k             ! 位数 (2k-1次)
  REAL,    INTENT(IN)  :: x             ! 補間値に対応する x の値
  REAL,    INTENT(OUT) :: y             ! 補間値 y = s(x)
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: i, j
  REAL    :: Ni1(n, n), Ni2(n, n), Nij(1: n - k, 1: n - k)
  REAL    :: delta(1: n - k)
  REAL    :: b(1: n - k)
  REAL    :: Nsp(1: n - k)
  REAL    :: P, Pk(1: k)
  ! 処理開始 ***********************************************************
  ! 例外処理 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  IF(n .LE. 1) THEN
    WRITE(*,'(A)') 'NaturalSpline - Error : n <= 1'
    STOP
  ENDIF
  DO i = 1, n - 1
    IF(xn(i) .GE. xn(i + 1)) THEN
      WRITE(*,'(A)') 'NaturalSpline - Error : xn(i) >= xn(i+1)'
      STOP
    ENDIF
  ENDDO
  ! スプライン係数の計算 +++++++++++++++++++++++++++++++++++++++++++++++
  DO j = 1, n
  DO i = 1, n
    Ni1(i, j) = NN(xn(j), xn(i))
  ENDDO
  ENDDO
  ! DO j = 1, n
  !   WRITE(*,*) (Ni1(i, j), i = 1, n)
  ! ENDDO
  DO j = 1, n
  DO i = 1, n - k
    Ni2(i, j) = DividedDifference(k + 1, xn(i: i + k), Ni1(i: i + k, j))
  ENDDO
  ENDDO
  ! DO j = 1, n
  !   WRITE(*,*) (Ni2(i, j), i = 1, n - k)
  ! ENDDO
  DO j = 1, n - k
  DO i = 1, n - k
    Nij(i, j) = DividedDifference(k + 1, xn(j: j + k), Ni2(i, j: j + k))
  ENDDO
  ENDDO
  ! DO j = 1, n - k
  !   WRITE(*,*) (Nij(i, j), i = 1, n - k)
  ! ENDDO
  DO j = 1, n - k
    delta(j) = DividedDifference(k + 1, xn(j: j + k), yn(j: j + k))
  ENDDO
  ! DO j = 1, n - k
  !   WRITE(*,*) delta(j)
  ! ENDDO
  CALL Gauss(1, n - k, Nij, delta, b)
  ! DO i = 1, n - k
  !   WRITE(*,*) b(i)
  ! ENDDO
  ! N-スプラインの計算 +++++++++++++++++++++++++++++++++++++++++++++++++
  DO i = 1, n - k
    Nsp(i) = NSpline(k, xn(i: i + k), x)
  ENDDO
  ! DO i = 1, n - k
  !   WRITE(*,*) Nsp(i)
  ! ENDDO
  ! k-1次多項式の計算 ++++++++++++++++++++++++++++++++++++++++++++++++++
  Pk(1) = yn(1)
  DO j = 2, k
    Pk(j) = DividedDifference(j, xn(1: j), yn(1: j))
    DO i = 1, n - k
      Pk(j) = Pk(j) - b(i) &
      &     * DividedDifference(k, xn(1: k), Ni2(i, 1: k))
    ENDDO
  ENDDO
  P = Pk(1)
  DO j = 2, k
    P = P + (x - xn(j - 1)) * Pk(j)
  ENDDO
  ! WRITE(*,*) P
  ! 自然スプラインの値を計算 +++++++++++++++++++++++++++++++++++++++++++
  y = P
  DO i = 1, n - k
    y = y + b(i) * NSp(i)
  ENDDO
  ! 処理終了 ***********************************************************
  RETURN
! 内部手続き ***********************************************************
CONTAINS
!***********************************************************************
!**** 関数定義                                                      ****
!***********************************************************************
REAL FUNCTION NN(x, t)
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN) :: x, t
  ! 処理開始 ***********************************************************
  IF(x - t .GT. 0.0) THEN
    NN = (x - t)**(2 * k - 1)
  ELSE
    NN = 0.0
  ENDIF
  ! 処理終了 ***********************************************************
  RETURN
END FUNCTION NN
! 定義終了 *************************************************************
END SUBROUTINE NaturalSpline
!***********************************************************************
!**** スプライン二次補間関数の導出                                  ****
!***********************************************************************
SUBROUTINE SplineSecondInterpolationSet( &
&            IS, IE, X, Y, SP &
&          )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: IS, IE
  REAL,    INTENT(IN)  :: X(IS: IE), Y(IS: IE)
  REAL,    INTENT(OUT) :: SP(1: 3, IS: IE - 1)
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL    :: DX(IS: IE - 1)
  INTEGER :: I
  ! 処理開始 ***********************************************************
  ! Xの変化量を求める(DXにおけるIはXにおけるI+1/2) ---------------------
  DO I = IS, IE - 1
    DX(I) =-X(I) + X(I+1)
  ENDDO
  ! スプライン関数を求める ---------------------------------------------
  ! SP1
  DO I = IS, IE - 1
    SP(1, I) = Y(I)
  ENDDO
  ! SP2
  DO I = IS + 1, IE - 1
    SP(2, I) =-DX(I) / (DX(I-1) * (DX(I-1) + DX(I))) * Y(I-1) &
    &        - (DX(I-1) - DX(I)) / (DX(I-1) * DX(I)) * Y(I  ) &
    &        + DX(I-1) / (DX(I) * (DX(I-1) + DX(I))) * Y(I+1)
  ENDDO
  I = IS
    SP(2, I) = (Y(I+1) - Y(I)) / DX(I)
    ! 理論的には正しいが DX(I) = 0.5 のときゼロ割が発生する
    ! SP(2, I) = (2.0 * (Y(I+1) - Y(I)) - SP(2, I+1)) &
    ! &        / (2.0 * DX(I) - 1.0)
  ! SP3
  DO I = IS + 1, IE - 2
    SP(3, I) = (SP(2, I+1) - SP(2, I)) / (2.0 * DX(I))
  ENDDO
  I = IS
    SP(3, I) = 0.0
    ! 理論的には正しいが DX(I) = 0.5 のとき使えない
    ! SP(3, I) = (SP(2, I+1) - SP(2, I)) / (2.0 * DX(I))
  I = IE - 1
    SP(3, I) = (-Y(I) + Y(I+1)) / DX(I-1)**2 &
    &        - SP(2, I) / DX(I-1)
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE SplineSecondInterpolationSet
!***********************************************************************
!**** スプライン二次補間による補間値の計算                          ****
!***********************************************************************
SUBROUTINE SplineSecondInterpolationCalc( &
&            IS, IE, X, Y, SP, X0, Y0 &
&          )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: IS, IE
  REAL,    INTENT(IN)  :: X(IS: IE), Y(IS: IE)
  REAL,    INTENT(IN)  :: SP(1: 3, IS: IE - 1)
  REAL,    INTENT(IN)  :: X0
  REAL,    INTENT(OUT) :: Y0
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I
  ! 処理開始 ***********************************************************
  Y0 = Y(IE)
  DO I = IS, IE - 1
    IF(X0 .GE. X(I) .AND. X0 .LT. X(I + 1)) THEN
      Y0 = SP(1, I) + (X0 - X(I)) * ( &
      &    SP(2, I) + (X0 - X(I)) * SP(3, I))
      EXIT
    ENDIF
  ENDDO
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE SplineSecondInterpolationCalc
!***********************************************************************
!**** スプライン三次補間関数の導出                                  ****
!***********************************************************************
SUBROUTINE SplineThirdInterpolationSet( &
&            IS, IE, X, Y, SP &
&          )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 局所定数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ! INTEGER, PARAMETER :: NMAX = 100
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: IS, IE
  REAL,    INTENT(IN)  :: X(IS: IE), Y(IS: IE)
  REAL,    INTENT(OUT) :: SP(1: 4, IS: IE - 1)
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL    :: DX(IS: IE), DY(IS: IE)
  REAL    :: A(IS: IE, IS: IE), B(IS: IE)
  INTEGER :: I, J
  ! INTEGER :: N
  ! 処理開始 ***********************************************************
  ! 連立方程式の各項を計算 ---------------------------------------------
  DO I = IS + 1, IE
    DX(I) = X(I) - X(I - 1)
  ENDDO
  I = IS
    DX(I) = DX(I + 1)
  DO I = IS, IE
    DO J = IS, IE
      A(J, I) = 0.0
    ENDDO
    B(I) = 0.0
  ENDDO
  DO I = IS + 1, IE - 1
    A(I, I - 1) = DX(I + 1)
    A(I, I    ) = 2.0 * (DX(I) + DX(I - 1))
    A(I, I + 1) = DX(I)
    B(I)        = 3.0 * ( &
    &               (Y(I) - Y(I - 1)) / DX(I) * DX(I + 1) &
    &             + (Y(I + 1) - Y(I)) / DX(I + 1) * DX(I) &
    &           )
  ENDDO
  I = IS
    A(I, I) = 1.0
    B(I)    = (Y(I + 1) - Y(I    )) / DX(I + 1)
  I = IE
    A(I, I) = 1.0
    B(I)    = (Y(I    ) - Y(I - 1)) / DX(I    )
  ! Gauss の消去法で連立方程式を解く -----------------------------------
  CALL Gauss(IS, IE, A, B, DY)
  ! 反復法で Y の勾配を再計算(Gauss の消去法の解を初期条件とする) ------
  ! DO N = 1, NMAX
  !   DO I = IS + 1, IE - 1
  !     DY(I) = ( &
  !     &         3.0 * ( &
  !     &           (Y(I  ) - Y(I-1)) * DX(I+1) / DX(I  ) &
  !     &         + (Y(I+1) - Y(I  )) * DX(I  ) / DX(I+1) &
  !     &       ) &
  !     &       - DX(I+1) * DY(I-1) &
  !     &       - DX(I  ) * DY(I+1) &
  !     &     ) * 0.5 / (DX(I) + DX(I-1))
  !   ENDDO
  !   DY(IS) = DY(IS + 1)
  !   DY(IE) = DY(IE - 1)
  ! ENDDO
  ! スプライン関数を求める ---------------------------------------------
  DO I = IS, IE - 1
    SP(1, I) = Y(I)
    SP(2, I) = DY(I)
    SP(4, I) = ( (DY(I + 1) + DY(I)) &
    &          - 2.0 * DBLE(Y(I + 1) - Y(I)) / DX(I + 1) &
    &        ) / DX(I + 1)**2
    SP(3, I) = ((Y(I + 1) - Y(I)) / DX(I + 1) - DY(I)) / DX(I + 1) &
    &          - SP(4, I) * DX(I + 1)
  ENDDO
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE SplineThirdInterpolationSet
!***********************************************************************
!**** スプライン三次補間による補間値の計算                          ****
!***********************************************************************
SUBROUTINE SplineThirdInterpolationCalc( &
&            IS, IE, X, Y, SP, X0, Y0 &
&          )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: IS, IE
  REAL,    INTENT(IN)  :: X(IS: IE), Y(IS: IE)
  REAL,    INTENT(IN)  :: SP(1: 4, IS: IE - 1)
  REAL,    INTENT(IN)  :: X0
  REAL,    INTENT(OUT) :: Y0
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I
  ! 処理開始 ***********************************************************
  Y0 = Y(IE)
  DO I = IS, IE - 1
    IF(X0 .GE. X(I) .AND. X0 .LT. X(I + 1)) THEN
      Y0 = SP(1, I) + (X0 - X(I)) * ( &
      &    SP(2, I) + (X0 - X(I)) * ( &
      &    SP(3, I) + (X0 - X(I)) * SP(4, I)))
      EXIT
    ENDIF
  ENDDO
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE SplineThirdInterpolationCalc
!***********************************************************************
!**** Bezier曲線                                                    ****
!***********************************************************************
SUBROUTINE BezierCurve( &
&            n, Px, Py, t, x, Y &
&          )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: n                  ! 制御点数
  REAL,    INTENT(IN)  :: Px(0: n), Py(0: n) ! 制御点座標
  REAL,    INTENT(IN)  :: t                  ! 媒介変数 (0 <= t <= 1)
  REAL,    INTENT(OUT) :: x, y               ! Bezier曲線座標
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: i, l
  INTEGER :: A, B, C
  REAL    :: J
  ! 処理開始 ***********************************************************
  ! 例外処理 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  IF(n .LE. 0) THEN
    WRITE(*,'(A)') 'BezierCurve - Error : n <= 0'
    STOP
  ENDIF
  IF(t .LT. 0.0 .OR. 1.0 .LT. t) THEN
    WRITE(*,'(A)') 'BezierCurve - Error : t < 0 or 1 < t'
    STOP
  ENDIF
  ! Bezier 曲線の計算 ++++++++++++++++++++++++++++++++++++++++++++++++++
  x = 0.0
  y = 0.0
  DO i = 0, n
    A = 1
    DO l = 1, n
      A = A * l
    ENDDO
    B = 1
    DO l = 1, i
      B = B * l
    ENDDO
    C = 1
    DO l = 1, n - i
      C = C * l
    ENDDO
    J = REAL(A) / REAL(B * C) * t**i * (1.0 - t)**(n - i)
    x = x + Px(i) * J
    y = y + Py(i) * J
  ENDDO
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE BezierCurve
!***********************************************************************
!**** B-スプライン曲線(正規化されたB-スプラインを基底として使用)    ****
!***********************************************************************
SUBROUTINE BSplineCurve(l, P_ix, P_iy, k, t, x, y)
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: l                     ! 節点数
  REAL,    INTENT(IN)  :: P_ix(0: l), P_iy(0: l)! 節点座標
  INTEGER, INTENT(IN)  :: k                     ! 位数 (k-1次)
  REAL,    INTENT(IN)  :: t           ! 媒介変数 (0 <= t <= l - k + 2)
  REAL,    INTENT(OUT) :: x, y        ! B-スプライン曲線座標
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: i
  REAL    :: xi_i(- k + 1: l + 1)
  REAL    :: N_ik
  ! 処理開始 ***********************************************************
  ! 例外処理 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  IF(l .LE. 0) THEN
    WRITE(*,'(A)') 'BSplineCurve - Error : l <= 0'
    STOP
  ENDIF
  IF(k .GE. l + 2) THEN
    WRITE(*,'(A)') 'BSplineCurve - Error : k >= l + 2'
    STOP
  ENDIF
  IF(t .LT. 0.0 .OR. REAL(l - k + 2) .LT. t) THEN
    WRITE(*,'(A)') 'BSplineCurve - Error : t < 0 or l - k + 2 < t'
    STOP
  ENDIF
  ! 節点 xi_i の計算(内部節点+付加節点) ++++++++++++++++++++++++++++++++
  DO i = - k + 1, 0
    xi_i(i) = 0.0
  ENDDO
  DO i = 0, l - k + 2
    xi_i(i) = REAL(i)
  ENDDO
  DO i = l - k + 2, l + 1
    xi_i(i) = REAL(l - k + 2)
  ENDDO
  ! B-スプライン曲線の計算 +++++++++++++++++++++++++++++++++++++++++++++
  x = 0.0
  y = 0.0
  DO i = 0, l
    N_ik = NormalizedBSplinedBC(k, xi_i(i - k + 1: i + 1), t)
    x = x + P_ix(i) * N_ik
    y = y + P_iy(i) * N_ik
  ENDDO
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE BSplineCurve
!***********************************************************************
!**** Bezier曲面                                                    ****
!***********************************************************************
SUBROUTINE BezierSurface( &
&            n, m, Px, Py, Pz, t, u, x, y, z &
&          )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: n, m               ! 制御点数
  REAL,    INTENT(IN)  :: Px(0: n, 0: m), &  ! 制御点座標 (x)
  &                       Py(0: n, 0: m), &  !            (y)
  &                       Pz(0: n, 0: m)     !            (z)
  REAL,    INTENT(IN)  :: t, &               ! 媒介変数 (0 <= t <= 1)
  &                       u                  !          (0 <= u <= 1)
  REAL,    INTENT(OUT) :: x, y, z            ! Bezier曲線座標 (x, y, z)
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: i, j, l
  INTEGER :: A, B, C
  REAL    :: Jn, Km
  ! 処理開始 ***********************************************************
  ! 例外処理 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  IF(n .LE. 0) THEN
    WRITE(*,'(A)') 'BezierSurface - Error : n <= 0'
    STOP
  ENDIF
  IF(m .LE. 0) THEN
    WRITE(*,'(A)') 'BezierSurface - Error : m <= 0'
    STOP
  ENDIF
  IF(t .LT. 0.0 .OR. 1.0 .LT. t) THEN
    WRITE(*,'(A)') 'BezierSurface - Error : t < 0 or 1 < t'
    STOP
  ENDIF
  IF(u .LT. 0.0 .OR. 1.0 .LT. u) THEN
    WRITE(*,'(A)') 'BezierSurface - Error : u < 0 or 1 < u'
    STOP
  ENDIF
  ! Bezier 曲線の計算 ++++++++++++++++++++++++++++++++++++++++++++++++++
  x = 0.0
  y = 0.0
  z = 0.0
  DO j = 0, m
  DO i = 0, n
    ! J_n,i (t) --------------------------------------------------------
    A = 1
    DO l = 1, n
      A = A * l
    ENDDO
    B = 1
    DO l = 1, i
      B = B * l
    ENDDO
    C = 1
    DO l = 1, n - i
      C = C * l
    ENDDO
    Jn = REAL(A) / REAL(B * C) * t**i * (1.0 - t)**(n - i)
    ! K_m,j (u) --------------------------------------------------------
    A = 1
    DO l = 1, m
      A = A * l
    ENDDO
    B = 1
    DO l = 1, j
      B = B * l
    ENDDO
    C = 1
    DO l = 1, m - j
      C = C * l
    ENDDO
    Km = REAL(A) / REAL(B * C) * u**j * (1.0 - u)**(m - j)
    ! x, y, z ----------------------------------------------------------
    x = x + Px(i,j) * Jn * Km
    y = y + Py(i,j) * Jn * Km
    z = z + Pz(i,j) * Jn * Km
  ENDDO
  ENDDO
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE BezierSurface
!***********************************************************************
!**** B-スプライン曲面(正規化されたB-スプラインを基底として使用)    ****
!***********************************************************************
SUBROUTINE BSplineSurface(n, m, Px, Py, Pz, k, l, t, u, x, y, z)
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ! 制御点 -------------------------------------------------------------
  INTEGER, INTENT(IN)  :: n, m              ! 制御点数
  REAL,    INTENT(IN)  :: Px(0: n, 0: m), & ! 座標 x
  &                       Py(0: n, 0: m), & ! 座標 y
  &                       Pz(0: n, 0: m)    ! 座標 z
  ! 位数 ---------------------------------------------------------------
  INTEGER, INTENT(IN)  :: k, l              ! k - 1次, l - 1次
  ! 媒介変数 -----------------------------------------------------------
  REAL,    INTENT(IN)  :: t, &              ! 0 <= t <= n - k + 2
  &                       u                 ! 0 <= u <= m - l + 2
  ! B-スプライン曲線座標 -----------------------------------------------
  REAL,    INTENT(OUT) :: x, y, z           ! x, y, z
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: i, j
  REAL    :: xi_i(- k + 1: n + 1), xi_j(- l + 1: m + 1)
  REAL    :: N_ik, N_jl
  ! 処理開始 ***********************************************************
  ! 例外処理 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  IF(n .LE. 0) THEN
    WRITE(*,'(A)') 'BSplineSurface - Error : n <= 0'
    STOP
  ENDIF
  IF(m .LE. 0) THEN
    WRITE(*,'(A)') 'BSplineSurface - Error : m <= 0'
    STOP
  ENDIF
  IF(k .GE. n + 2) THEN
    WRITE(*,'(A)') 'BSplineSurface - Error : k >= n + 2'
    STOP
  ENDIF
  IF(l .GE. m + 2) THEN
    WRITE(*,'(A)') 'BSplineSurface - Error : l >= m + 2'
    STOP
  ENDIF
  IF(t .LT. 0.0 .OR. REAL(n - k + 2) .LT. t) THEN
    WRITE(*,'(A)') 'BSplineSurface - Error : t < 0 or n - k + 2 < t'
    STOP
  ENDIF
  IF(u .LT. 0.0 .OR. REAL(m - l + 2) .LT. u) THEN
    WRITE(*,'(A)') 'BSplineSurface - Error : u < 0 or m - l + 2 < u'
    STOP
  ENDIF
  ! 節点 xi_i の計算(内部節点+付加節点) ++++++++++++++++++++++++++++++++
  DO i = - k + 1, 0
    xi_i(i) = 0.0
  ENDDO
  DO i = 0, n - k + 2
    xi_i(i) = REAL(i)
  ENDDO
  DO i = n - k + 2, n + 1
    xi_i(i) = REAL(n - k + 2)
  ENDDO
  ! 節点 xi_j の計算(内部節点+付加節点) ++++++++++++++++++++++++++++++++
  DO j = - l + 1, 0
    xi_j(j) = 0.0
  ENDDO
  DO j = 0, m - l + 2
    xi_j(j) = REAL(j)
  ENDDO
  DO j = m - l + 2, m + 1
    xi_j(j) = REAL(m - l + 2)
  ENDDO
  ! B-スプライン曲線の計算 +++++++++++++++++++++++++++++++++++++++++++++
  x = 0.0
  y = 0.0
  z = 0.0
  DO j = 0, m
  DO i = 0, n
    N_ik = NormalizedBSplinedBC(k, xi_i(i - k + 1: i + 1), t)
    N_jl = NormalizedBSplinedBC(l, xi_j(j - l + 1: j + 1), u)
    x = x + Px(i,j) * N_ik * N_jl
    y = y + Py(i,j) * N_ik * N_jl
    z = z + Pz(i,j) * N_ik * N_jl
  ENDDO
  ENDDO
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE BSplineSurface
!***********************************************************************
!**** 線形補間                                                      ****
!***********************************************************************
SUBROUTINE LinearInterpolation(NS, NE, X, Y, XP, YP)
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ! 制御点 -------------------------------------------------------------
  INTEGER, INTENT(IN)  :: NS, NE
  REAL   , INTENT(IN)  :: X(NS:NE), Y(NS:NE)
  ! 補間点 -------------------------------------------------------------
  REAL   , INTENT(IN)  :: XP
  REAL   , INTENT(OUT) :: YP
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: N
  REAL    :: mm, nn
  ! 処理開始 ***********************************************************
  DO N = NS, NE
    IF( XP < X(N) ) EXIT
  ENDDO
  IF(N == NS) THEN
    YP = Y(NS)
   ELSE IF(N == NE+1) THEN
    YP = Y(NE)
   ELSE
    mm = XP - X(N-1)
    nn = X(N) - XP
    YP = (nn * Y(N-1) + mm * Y(N)) / (mm + nn)
  ENDIF
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE LinearInterpolation
! 定義終了 *************************************************************
END MODULE Package_Equation
```

## file "Mod_Package_FileIO.f90"

```fortran
!*******************************************************************************************************
!*******************************************************************************************************
!******** パッケージ型モジュール								********
!******** ファイル入出力									********
!******** 			                      2013.01.27  PROGRAMMED BY RYOSUKE HAYASHI ********
!******** 			                      2013.06.17     UPDATED BY RYOSUKE HAYASHI ********
!*******************************************************************************************************
!*******************************************************************************************************
module Package_FileIO
 ! 変数宣言 ********************************************************************************************
 implicit none
 private
 ! 拡張子設定 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, parameter, public :: bckdir * 3 = '../'
 character, parameter, public :: strdir * 2 = './'
 character, parameter, public :: strbin * 4 = '.bin'
 character, parameter, public :: strdat * 4 = '.dat'
 character, parameter, public :: strfld * 4 = '.fld'
 character, parameter, public :: strtxt * 4 = '.txt'
 ! 共有サブルーチン ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 public :: Input_Resolution1D, Output_Resolution1D
 public :: Input_Resolution2D, Output_Resolution2D, Input_Resolution3D, Output_Resolution3D
 public :: Input_Grid2D      , Output_Grid2D      , Input_Grid3D      , Output_Grid3D
 public :: Input_Metrics2D   , Output_Metrics2D   , Input_Metrics3D   , Output_Metrics3D
 public :: Input_Flux2D      , Output_Flux2D      , Input_Flux3D      , Output_Flux3D
 public :: Input_OversetCoe2D, Output_OversetCoe2D, Input_OversetCoe3D, Output_OversetCoe3D
 public :: Input_Physics2D   , Output_Physics2D   , Input_Physics3D   , Output_Physics3D
 public :: Input_ArrayReal1D , Output_ArrayReal1D , Input_ArrayReal2D , Output_ArrayReal2D, &
 &         Input_ArrayReal3D , Output_ArrayReal3D
 public :: Input_ArrayInt1D  , Output_ArrayInt1D  , Input_ArrayInt2D  , Output_ArrayInt2D, &
 &         Input_ArrayInt3D  , Output_ArrayInt3D
 public :: Input_GridPoint , Output_GridPoint
 public :: Input_DropInCondition, Output_DropInCondition
 public :: Input_Impingement3D  , Output_Impingement3D
 public :: Input_CollectionEfficiency3D, Output_CollectionEfficiency3D
 public :: Input_IceThickTem2D    , Output_IceThickTem2D
 public :: Input_IceThickTem3D    , Output_IceThickTem3D
 public :: Input_OrgMessingerPara2D, Output_OrgMessingerPara2D
 public :: Input_ExtMessingerPara2D, Output_ExtMessingerPara2D
 public :: Input_OrgMessingerPara3D, Output_OrgMessingerPara3D
 public :: Input_ExtMessingerPara3D, Output_ExtMessingerPara3D
 public :: Input_IceBladeSurface2D, Output_IceBladeSurface2D
 public :: Input_IceBladeSurface3D, Output_IceBladeSurface3D
 ! 内部手続き ******************************************************************************************
 contains
!*******************************************************************************************************
!******** 解像度入力 (一次元) 									********
!*******************************************************************************************************
subroutine Input_Resolution1D( &
&            strname, ext, is, ie )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 integer  , intent(out) :: is, ie
 ! 処理開始 ********************************************************************************************
 open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
  read(1, '(i4,x,i4)') is, ie
 close(1)
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_Resolution1D
!*******************************************************************************************************
!******** 解像度出力 (一次元) 									********
!*******************************************************************************************************
subroutine Output_Resolution1D( &
&            strname, ext, is, ie )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 integer  , intent(in) :: is, ie
 ! 処理開始 ********************************************************************************************
 open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
  write(1, '(i4,x,i4)') is, ie
 close(1)
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_Resolution1D
!*******************************************************************************************************
!******** 解像度入力 (二次元) 									********
!*******************************************************************************************************
subroutine Input_Resolution2D( &
&            strname, ext, is, ie, js, je )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 integer  , intent(out) :: is, ie, js, je
 ! 処理開始 ********************************************************************************************
 open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
  read(1, '(i4,3(x,i4))') is, ie, js, je
 close(1)
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_Resolution2D
!*******************************************************************************************************
!******** 解像度出力 (二次元) 									********
!*******************************************************************************************************
subroutine Output_Resolution2D( &
&            strname, ext, is, ie, js, je )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 integer  , intent(in) :: is, ie, js, je
 ! 処理開始 ********************************************************************************************
 open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
  write(1, '(i4,3(x,i4))') is, ie, js, je
 close(1)
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_Resolution2D
!*******************************************************************************************************
!******** 解像度入力 (三次元) 									********
!*******************************************************************************************************
subroutine Input_Resolution3D( &
&            strname, ext, is, ie, js, je, ks, ke )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 integer  , intent(out) :: is, ie, js, je, ks, ke
 ! 処理開始 ********************************************************************************************
 open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
  read(1, '(i4,5(x,i4))') is, ie, js, je, ks, ke
 close(1)
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_Resolution3D
!*******************************************************************************************************
!******** 解像度出力 (三次元) 									********
!*******************************************************************************************************
subroutine Output_Resolution3D( &
&            strname, ext, is, ie, js, je, ks, ke )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 integer  , intent(in) :: is, ie, js, je, ks, ke
 ! 処理開始 ********************************************************************************************
 open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
  write(1, '(i4,5(x,i4))') is, ie, js, je, ks, ke
 close(1)
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_Resolution3D
!*******************************************************************************************************
!******** 格子座標入力 (二次元) 								********
!*******************************************************************************************************
subroutine Input_Grid2D( &
&            strname, ext, is, ie, js, je, x, y )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 integer  , intent(in)  :: is, ie, js, je
 real     , intent(out) :: x(is:ie, js:je), y(is:ie, js:je)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i, j
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'old')
    read(1) ((x(i,j), i = is, ie), j = js, je)
    read(1) ((y(i,j), i = is, ie), j = js, je)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
    do j = js, je
    do i = is, ie
     read(1, '(e16.8e3,1(x,e16.8e3))') x(i,j), y(i,j)
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_Grid2D
!*******************************************************************************************************
!******** 格子座標出力 (二次元) 								********
!*******************************************************************************************************
subroutine Output_Grid2D( &
&            strname, ext, is, ie, js, je, x, y )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 integer  , intent(in) :: is, ie, js, je
 real     , intent(in) :: x(is:ie, js:je), y(is:ie, js:je)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i, j
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'replace')
    write(1) ((x(i,j), i = is, ie), j = js, je)
    write(1) ((y(i,j), i = is, ie), j = js, je)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
    do j = js, je
    do i = is, ie
     write(1, '(e16.8e3,1(x,e16.8e3))') x(i,j), y(i,j)
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_Grid2D
!*******************************************************************************************************
!******** 格子座標入力  (三次元)								********
!*******************************************************************************************************
subroutine Input_Grid3D( &
&            strname, ext, is, ie, js, je, ks, ke, x, y, z )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 integer  , intent(in)  :: is, ie, js, je, ks, ke
 real     , intent(out) :: x(is:ie, js:je, ks:ke), y(is:ie, js:je, ks:ke), z(is:ie, js:je, ks:ke)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i, j, k
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'old')
    read(1) (((x(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) (((y(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) (((z(i,j,k), i = is, ie), j = js, je), k = ks, ke)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
    do k = ks, ke
    do j = js, je
    do i = is, ie
     read(1, '(e16.8e3,2(x,e16.8e3))') x(i,j,k), y(i,j,k), z(i,j,k)
    enddo
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_Grid3D
!*******************************************************************************************************
!******** 格子座標出力 (三次元)									********
!*******************************************************************************************************
subroutine Output_Grid3D( &
&            strname, ext, is, ie, js, je, ks, ke, x, y, z )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 integer  , intent(in) :: is, ie, js, je, ks, ke
 real     , intent(in) :: x(is:ie, js:je, ks:ke), y(is:ie, js:je, ks:ke), z(is:ie, js:je, ks:ke)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i, j, k
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'replace')
    write(1) (((x(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) (((y(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) (((z(i,j,k), i = is, ie), j = js, je), k = ks, ke)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
    do k = ks, ke
    do j = js, je
    do i = is, ie
     write(1, '(e16.8e3,2(x,e16.8e3))') x(i,j,k), y(i,j,k), z(i,j,k)
    enddo
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_Grid3D
!*******************************************************************************************************
!******** メトリックス入力 (二次元) 								********
!*******************************************************************************************************
subroutine Input_Metrics2D( &
&            strname, ext, is, ie, js, je, jac, xix, xiy, etx, ety )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 integer  , intent(in)  :: is, ie, js, je
 real     , intent(out) :: jac(is:ie, js:je)
 real     , intent(out) :: xix(is:ie, js:je), xiy(is:ie, js:je), &
 &                         etx(is:ie, js:je), ety(is:ie, js:je)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i, j
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'old')
    read(1) ((jac(i,j), i = is, ie), j = js, je)
    read(1) ((xix(i,j), i = is, ie), j = js, je)
    read(1) ((xiy(i,j), i = is, ie), j = js, je)
    read(1) ((etx(i,j), i = is, ie), j = js, je)
    read(1) ((ety(i,j), i = is, ie), j = js, je)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
    do j = js, je
    do i = is, ie
     read(1, '(e16.8e3,4(x,e16.8e3))') jac(i,j), xix(i,j), xiy(i,j), etx(i,j), ety(i,j)
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_Metrics2D
!*******************************************************************************************************
!******** メトリックス出力 (二次元) 								********
!*******************************************************************************************************
subroutine Output_Metrics2D( &
&            strname, ext, is, ie, js, je, jac, xix, xiy, etx, ety )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 integer  , intent(in) :: is, ie, js, je
 real     , intent(in) :: jac(is:ie, js:je)
 real     , intent(in) :: xix(is:ie, js:je), xiy(is:ie, js:je), &
 &                        etx(is:ie, js:je), ety(is:ie, js:je)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i, j
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'replace')
    write(1) ((jac(i,j), i = is, ie), j = js, je)
    write(1) ((xix(i,j), i = is, ie), j = js, je)
    write(1) ((xiy(i,j), i = is, ie), j = js, je)
    write(1) ((etx(i,j), i = is, ie), j = js, je)
    write(1) ((ety(i,j), i = is, ie), j = js, je)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
    do j = js, je
    do i = is, ie
     write(1, '(e16.8e3,4(x,e16.8e3))') jac(i,j), xix(i,j), xiy(i,j), etx(i,j), ety(i,j)
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_Metrics2D
!*******************************************************************************************************
!******** メトリックス入力 (三次元) 								********
!*******************************************************************************************************
subroutine Input_Metrics3D( &
&            strname, ext, is, ie, js, je, ks, ke, jac, xix, xiy, xiz, etx, ety, etz, zex, zey, zez )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 integer  , intent(in)  :: is, ie, js, je, ks, ke
 real     , intent(out) :: jac(is:ie, js:je, ks:ke)
 real     , intent(out) :: xix(is:ie, js:je, ks:ke), &
 &                         xiy(is:ie, js:je, ks:ke), &
 &                         xiz(is:ie, js:je, ks:ke), &
 &                         etx(is:ie, js:je, ks:ke), &
 &                         ety(is:ie, js:je, ks:ke), &
 &                         etz(is:ie, js:je, ks:ke), &
 &                         zex(is:ie, js:je, ks:ke), &
 &                         zey(is:ie, js:je, ks:ke), &
 &                         zez(is:ie, js:je, ks:ke)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i, j, k
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'old')
    read(1) (((jac(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) (((xix(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) (((xiy(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) (((xiz(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) (((etx(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) (((ety(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) (((etz(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) (((zex(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) (((zey(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) (((zez(i,j,k), i = is, ie), j = js, je), k = ks, ke)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
    do k = ks, ke
    do j = js, je
    do i = is, ie
     read(1, '(e16.8e3,9(x,e16.8e3))') jac(i,j,k), &
     &                                 xix(i,j,k), xiy(i,j,k), xiz(i,j,k), &
     &                                 etx(i,j,k), ety(i,j,k), etz(i,j,k), &
     &                                 zex(i,j,k), zey(i,j,k), zez(i,j,k)
    enddo
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_Metrics3D
!*******************************************************************************************************
!******** メトリックス出力 (三次元) 								********
!*******************************************************************************************************
subroutine Output_Metrics3D( &
&            strname, ext, is, ie, js, je, ks, ke, jac, xix, xiy, xiz, etx, ety, etz, zex, zey, zez )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 integer  , intent(in) :: is, ie, js, je, ks, ke
 real     , intent(in) :: jac(is:ie, js:je, ks:ke)
 real     , intent(in) :: xix(is:ie, js:je, ks:ke), &
 &                        xiy(is:ie, js:je, ks:ke), &
 &                        xiz(is:ie, js:je, ks:ke), &
 &                        etx(is:ie, js:je, ks:ke), &
 &                        ety(is:ie, js:je, ks:ke), &
 &                        etz(is:ie, js:je, ks:ke), &
 &                        zex(is:ie, js:je, ks:ke), &
 &                        zey(is:ie, js:je, ks:ke), &
 &                        zez(is:ie, js:je, ks:ke)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i, j, k
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'replace')
    write(1) (((jac(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) (((xix(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) (((xiy(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) (((xiz(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) (((etx(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) (((ety(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) (((etz(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) (((zex(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) (((zey(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) (((zez(i,j,k), i = is, ie), j = js, je), k = ks, ke)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
    do k = ks, ke
    do j = js, je
    do i = is, ie
     write(1, '(e16.8e3,9(x,e16.8e3))') jac(i,j,k), &
     &                                  xix(i,j,k), xiy(i,j,k), xiz(i,j,k), &
     &                                  etx(i,j,k), ety(i,j,k), etz(i,j,k), &
     &                                  zex(i,j,k), zey(i,j,k), zez(i,j,k)
    enddo
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_Metrics3D
!*******************************************************************************************************
!******** 流束入力 (二次元) 									********
!*******************************************************************************************************
subroutine Input_Flux2D( &
&            strname, ext, is, ie, js, je, ls, le, qh )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 integer  , intent(in)  :: is, ie, js, je
 integer  , intent(in)  :: ls, le
 real     , intent(out) :: qh(is:ie, js:je, ls:le)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character :: strnum
 integer   :: i, j, l
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'old')
    do l = ls, le
     read(1) ((qh(i,j,l), i = is, ie), j = js, je)
    enddo
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   write(strnum, '(i1)') le-ls
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
    do j = js, je
    do i = is, ie
     read(1, '(e16.8e3, ' // strnum // '(x,e16.8e3))') qh(i,j,ls:le)
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_Flux2D
!*******************************************************************************************************
!******** 流束出力 (二次元) 									********
!*******************************************************************************************************
subroutine Output_Flux2D( &
&            strname, ext, is, ie, js, je, ls, le, qh )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 integer  , intent(in) :: is, ie, js, je
 integer  , intent(in) :: ls, le
 real     , intent(in) :: qh(is:ie, js:je, ls:le)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character :: strnum
 integer   :: i, j, l
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'replace')
    do l = ls, le
     write(1) ((qh(i,j,l), i = is, ie), j = js, je)
    enddo
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   write(strnum, '(i1)') le-ls
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
    do j = js, je
    do i = is, ie
     write(1, '(e16.8e3, ' // strnum // '(x,e16.8e3))') qh(i,j,ls:le)
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_Flux2D
!*******************************************************************************************************
!******** 流束入力 (三次元) 									********
!*******************************************************************************************************
subroutine Input_Flux3D( &
&            strname, ext, is, ie, js, je, ks, ke, ls, le, qh )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 integer  , intent(in)  :: is, ie, js, je, ks, ke
 integer  , intent(in)  :: ls, le
 real     , intent(out) :: qh(is:ie, js:je, ks:ke, ls:le)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character :: strnum
 integer   :: i, j, k, l
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'old')
    do l = ls, le
     read(1) (((qh(i,j,k,l), i = is, ie), j = js, je), k = ks, ke)
    enddo
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   write(strnum, '(i1)') le-ls
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
    do k = ks, ke
    do j = js, je
    do i = is, ie
     read(1, '(e16.8e3, ' // strnum // '(x,e16.8e3))') qh(i,j,k,ls:le)
    enddo
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_Flux3D
!*******************************************************************************************************
!******** 流束出力 (三次元) 									********
!*******************************************************************************************************
subroutine Output_Flux3D( &
&            strname, ext, is, ie, js, je, ks, ke, ls, le, qh )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 integer  , intent(in) :: is, ie, js, je, ks, ke
 integer  , intent(in) :: ls, le
 real     , intent(in) :: qh(is:ie, js:je, ks:ke, ls:le)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character :: strnum
 integer   :: i, j, k, l
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'replace')
    do l = ls, le
     write(1) (((qh(i,j,k,l), i = is, ie), j = js, je), k = ks, ke)
    enddo
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   write(strnum, '(i1)') le-ls
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
    do k = ks, ke
    do j = js, je
    do i = is, ie
     write(1, '(e16.8e3, ' // strnum // '(x,e16.8e3))') qh(i,j,k,ls:le)
    enddo
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_Flux3D
!*******************************************************************************************************
!******** 重合格子法補間係数入力 (二次元)							********
!*******************************************************************************************************
subroutine Input_OversetCoe2D( &
&            strname, ext, is, ie, js, je, fover, ip, jp, term1, term2, term3, term4 )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 integer  , intent(in)  :: is, ie, js, je
 integer  , intent(out) :: fover(is:ie, js:je)
 integer  , intent(out) :: ip(is:ie, js:je), jp(is:ie, js:je)
 real     , intent(out) :: term1(is:ie, js:je), term2(is:ie, js:je), &
 &                         term3(is:ie, js:je), term4(is:ie, js:je)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer   :: i, j
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'old')
    read(1) ((fover(i,j), i = is, ie), j = js, je)
    read(1) ((   ip(i,j), i = is, ie), j = js, je)
    read(1) ((   jp(i,j), i = is, ie), j = js, je)
    read(1) ((term1(i,j), i = is, ie), j = js, je)
    read(1) ((term2(i,j), i = is, ie), j = js, je)
    read(1) ((term3(i,j), i = is, ie), j = js, je)
    read(1) ((term4(i,j), i = is, ie), j = js, je)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
    do j = js, je
    do i = is, ie
     read(1, '(i1,2(x,i4),4(x,e16.8e3))') fover(i,j), ip(i,j), jp(i,j), &
     &                                    term1(i,j), term2(i,j), term3(i,j), term4(i,j)
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_OversetCoe2D
!*******************************************************************************************************
!******** 重合格子法補間係数出力 (二次元)							********
!*******************************************************************************************************
subroutine Output_OversetCoe2D( &
&            strname, ext, is, ie, js, je, fover, ip, jp, term1, term2, term3, term4 )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 integer  , intent(in) :: is, ie, js, je
 integer  , intent(in) :: fover(is:ie, js:je)
 integer  , intent(in) :: ip(is:ie, js:je), jp(is:ie, js:je)
 real     , intent(in) :: term1(is:ie, js:je), term2(is:ie, js:je), &
 &                        term3(is:ie, js:je), term4(is:ie, js:je)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer   :: i, j
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'replace')
    write(1) ((fover(i,j), i = is, ie), j = js, je)
    write(1) ((   ip(i,j), i = is, ie), j = js, je)
    write(1) ((   jp(i,j), i = is, ie), j = js, je)
    write(1) ((term1(i,j), i = is, ie), j = js, je)
    write(1) ((term2(i,j), i = is, ie), j = js, je)
    write(1) ((term3(i,j), i = is, ie), j = js, je)
    write(1) ((term4(i,j), i = is, ie), j = js, je)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
    do j = js, je
    do i = is, ie
     write(1, '(i1,2(x,i4),4(x,e16.8e3))') fover(i,j), ip(i,j), jp(i,j), &
     &                                     term1(i,j), term2(i,j), term3(i,j), term4(i,j)
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_OversetCoe2D
!*******************************************************************************************************
!******** 重合格子法補間係数入力 (三次元)							********
!*******************************************************************************************************
subroutine Input_OversetCoe3D( &
&            strname, ext, is, ie, js, je, ks, ke, fover, ip, jp, kp, &
&            term1, term2, term3, term4, term5, term6, term7, term8 )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 integer  , intent(in)  :: is, ie, js, je, ks, ke
 integer  , intent(out) :: fover(is:ie, js:je, ks:ke)
 integer  , intent(out) :: ip(is:ie, js:je, ks:ke), jp(is:ie, js:je, ks:ke), kp(is:ie, js:je, ks:ke)
 real     , intent(out) :: term1(is:ie, js:je, ks:ke), term2(is:ie, js:je, ks:ke), &
 &                         term3(is:ie, js:je, ks:ke), term4(is:ie, js:je, ks:ke), &
 &                         term5(is:ie, js:je, ks:ke), term6(is:ie, js:je, ks:ke), &
 &                         term7(is:ie, js:je, ks:ke), term8(is:ie, js:je, ks:ke)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer   :: i, j, k
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'old')
    read(1) (((fover(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) (((   ip(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) (((   jp(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) (((   kp(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) (((term1(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) (((term2(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) (((term3(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) (((term4(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) (((term5(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) (((term6(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) (((term7(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) (((term8(i,j,k), i = is, ie), j = js, je), k = ks, ke)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
    do k = ks, ke
    do j = js, je
    do i = is, ie
     read(1, '(i1,3(x,i4),8(x,e16.8e3))') fover(i,j,k), ip(i,j,k), jp(i,j,k), kp(i,j,k), &
     &                                    term1(i,j,k), term2(i,j,k), term3(i,j,k), term4(i,j,k), &
     &                                    term5(i,j,k), term6(i,j,k), term7(i,j,k), term8(i,j,k)
    enddo
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_OversetCoe3D
!*******************************************************************************************************
!******** 重合格子法補間係数出力 (三次元)							********
!*******************************************************************************************************
subroutine Output_OversetCoe3D( &
&            strname, ext, is, ie, js, je, ks, ke, fover, ip, jp, kp, &
&            term1, term2, term3, term4, term5, term6, term7, term8 )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 integer  , intent(in) :: is, ie, js, je, ks, ke
 integer  , intent(in) :: fover(is:ie, js:je, ks:ke)
 integer  , intent(in) :: ip(is:ie, js:je, ks:ke), jp(is:ie, js:je, ks:ke), kp(is:ie, js:je, ks:ke)
 real     , intent(in) :: term1(is:ie, js:je, ks:ke), term2(is:ie, js:je, ks:ke), &
 &                        term3(is:ie, js:je, ks:ke), term4(is:ie, js:je, ks:ke), &
 &                        term5(is:ie, js:je, ks:ke), term6(is:ie, js:je, ks:ke), &
 &                        term7(is:ie, js:je, ks:ke), term8(is:ie, js:je, ks:ke)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer   :: i, j, k
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'replace')
    write(1) (((fover(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) (((   ip(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) (((   jp(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) (((   kp(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) (((term1(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) (((term2(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) (((term3(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) (((term4(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) (((term5(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) (((term6(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) (((term7(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) (((term8(i,j,k), i = is, ie), j = js, je), k = ks, ke)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
    do k = ks, ke
    do j = js, je
    do i = is, ie
     write(1, '(i1,3(x,i4),8(x,e16.8e3))') fover(i,j,k), ip(i,j,k), jp(i,j,k), kp(i,j,k), &
     &                                     term1(i,j,k), term2(i,j,k), term3(i,j,k), term4(i,j,k), &
     &                                     term5(i,j,k), term6(i,j,k), term7(i,j,k), term8(i,j,k)
    enddo
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_OversetCoe3D
!*******************************************************************************************************
!******** 物理量入力 (二次元)									********
!*******************************************************************************************************
subroutine Input_Physics2D( &
&            strname, ext, is, ie, js, je, rho, u, v, ps, ts, mu, kin, eps, mut )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 integer  , intent(in)  :: is, ie, js, je
 real     , intent(out) :: rho(is:ie, js:je), u(is:ie, js:je), v(is:ie, js:je), &
 &                         ps(is:ie, js:je), ts(is:ie, js:je), mu(is:ie, js:je), &
 &                         kin(is:ie, js:je), eps(is:ie, js:je), mut(is:ie, js:je)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer   :: i, j
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'old')
    read(1) ((rho(i,j), i = is, ie), j = js, je)
    read(1) ((  u(i,j), i = is, ie), j = js, je)
    read(1) ((  v(i,j), i = is, ie), j = js, je)
    read(1) (( ps(i,j), i = is, ie), j = js, je)
    read(1) (( ts(i,j), i = is, ie), j = js, je)
    read(1) (( mu(i,j), i = is, ie), j = js, je)
    read(1) ((kin(i,j), i = is, ie), j = js, je)
    read(1) ((eps(i,j), i = is, ie), j = js, je)
    read(1) ((mut(i,j), i = is, ie), j = js, je)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
    do j = js, je
    do i = is, ie
     read(1, '(e16.8e3,8(x,e16.8e3))') rho(i,j), u(i,j), v(i,j), ps(i,j), ts(i,j), mu(i,j), &
     &                                 kin(i,j), eps(i,j), mut(i,j)
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_Physics2D
!*******************************************************************************************************
!******** 物理量出力 (二次元)									********
!*******************************************************************************************************
subroutine Output_Physics2D( &
&            strname, ext, is, ie, js, je, rho, u, v, ps, ts, mu, kin, eps, mut )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 integer  , intent(in) :: is, ie, js, je
 real     , intent(in) :: rho(is:ie, js:je), u(is:ie, js:je), v(is:ie, js:je), &
 &                        ps(is:ie, js:je), ts(is:ie, js:je), mu(is:ie, js:je), &
 &                        kin(is:ie, js:je), eps(is:ie, js:je), mut(is:ie, js:je)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer   :: i, j
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'replace')
    write(1) ((rho(i,j), i = is, ie), j = js, je)
    write(1) ((  u(i,j), i = is, ie), j = js, je)
    write(1) ((  v(i,j), i = is, ie), j = js, je)
    write(1) (( ps(i,j), i = is, ie), j = js, je)
    write(1) (( ts(i,j), i = is, ie), j = js, je)
    write(1) (( mu(i,j), i = is, ie), j = js, je)
    write(1) ((kin(i,j), i = is, ie), j = js, je)
    write(1) ((eps(i,j), i = is, ie), j = js, je)
    write(1) ((mut(i,j), i = is, ie), j = js, je)
    write(1) ((mut(i,j), i = is, ie), j = js, je)
    write(1) ((mut(i,j), i = is, ie), j = js, je)
    write(1) ((mut(i,j), i = is, ie), j = js, je)


   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
    do j = js, je
    do i = is, ie
     write(1, '(e16.8e3,8(x,e16.8e3))') rho(i,j), u(i,j), v(i,j), ps(i,j), ts(i,j), mu(i,j), &
     &                                  kin(i,j), eps(i,j), mut(i,j)
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_Physics2D
!*******************************************************************************************************
!******** 物理量入力 (三次元)									********
!*******************************************************************************************************
subroutine Input_Physics3D( &
&            strname, ext, is, ie, js, je, ks, ke, rho, u, v, w, ps, ts, mu, kin, eps, mut )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 integer  , intent(in)  :: is, ie, js, je, ks, ke
 real     , intent(out) :: rho(is:ie, js:je, ks:ke), &
 &                         u(is:ie, js:je, ks:ke), v(is:ie, js:je, ks:ke), w(is:ie, js:je, ks:ke), &
 &                         ps(is:ie, js:je, ks:ke), ts(is:ie, js:je, ks:ke), mu(is:ie, js:je, ks:ke), &
 &                         kin(is:ie, js:je, ks:ke), eps(is:ie, js:je, ks:ke), mut(is:ie, js:je, ks:ke)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer   :: i, j, k
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'old')
    read(1) (((rho(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) (((  u(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) (((  v(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) (((  w(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) ((( ps(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) ((( ts(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) ((( mu(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) (((kin(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) (((eps(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    read(1) (((mut(i,j,k), i = is, ie), j = js, je), k = ks, ke)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
    do k = ks, ke
    do j = js, je
    do i = is, ie
     read(1, '(e16.8e3,9(x,e16.8e3))') rho(i,j,k), u(i,j,k), v(i,j,k), w(i,j,k), &
     &                                 ps(i,j,k), ts(i,j,k), mu(i,j,k), &
     &                                 kin(i,j,k), eps(i,j,k), mut(i,j,k)
    enddo
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_Physics3D
!*******************************************************************************************************
!******** 物理量出力 (三次元)									********
!*******************************************************************************************************
subroutine Output_Physics3D( &
&            strname, ext, is, ie, js, je, ks, ke, rho, u, v, w, ps, ts, mu, kin, eps, mut )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 integer  , intent(in) :: is, ie, js, je, ks, ke
 real     , intent(in) :: rho(is:ie, js:je, ks:ke), &
 &                        u(is:ie, js:je, ks:ke), v(is:ie, js:je, ks:ke), w(is:ie, js:je, ks:ke), &
 &                        ps(is:ie, js:je, ks:ke), ts(is:ie, js:je, ks:ke), mu(is:ie, js:je, ks:ke), &
 &                        kin(is:ie, js:je, ks:ke), eps(is:ie, js:je, ks:ke), mut(is:ie, js:je, ks:ke)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer   :: i, j, k
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'replace')
    write(1) (((rho(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) (((  u(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) (((  v(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) (((  w(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) ((( ps(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) ((( ts(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) ((( mu(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) (((kin(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) (((eps(i,j,k), i = is, ie), j = js, je), k = ks, ke)
    write(1) (((mut(i,j,k), i = is, ie), j = js, je), k = ks, ke)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
    do k = ks, ke
    do j = js, je
    do i = is, ie
     write(1, '(e16.8e3,9(x,e16.8e3))') rho(i,j,k), u(i,j,k), v(i,j,k), w(i,j,k), &
     &                                  ps(i,j,k), ts(i,j,k), mu(i,j,k), &
     &                                  kin(i,j,k), eps(i,j,k), mut(i,j,k)
    enddo
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_Physics3D
!*******************************************************************************************************
!******** 一次元配列ファイル入力（実数）                                                        ********
!*******************************************************************************************************
subroutine Input_ArrayReal1D( &
&            strname, ext, is, ie, q )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 integer  , intent(in)  :: is, ie
 real     , intent(out) :: q(is:ie)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'old')
    read(1) (q(i), i = is, ie)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
    do i = is, ie
     read(1, '(e16.8e3)') q(i)
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_ArrayReal1D
!*******************************************************************************************************
!******** 一次元配列ファイル出力（実数）                                                        ********
!*******************************************************************************************************
subroutine Output_ArrayReal1D( &
&            strname, ext, is, ie, q )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 integer  , intent(in) :: is, ie
 real     , intent(in) :: q(is:ie)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'replace')
    write(1) (q(i), i = is, ie)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
    do i = is, ie
     write(1, '(e16.8e3)') q(i)
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_ArrayReal1D
!*******************************************************************************************************
!******** 二次元配列ファイル入力（実数）                                                        ********
!*******************************************************************************************************
subroutine Input_ArrayReal2D( &
&            strname, ext, is, ie, js, je, q )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 integer  , intent(in)  :: is, ie, js, je
 real     , intent(out) :: q(is:ie, js:je)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i, j
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'old')
    read(1) ((q(i,j), i = is, ie), j = js, je)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
    do j = js, je
    do i = is, ie
     read(1, '(e16.8e3)') q(i,j)
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_ArrayReal2D
!*******************************************************************************************************
!******** 二次元配列ファイル出力（実数）                                                        ********
!*******************************************************************************************************
subroutine Output_ArrayReal2D( &
&            strname, ext, is, ie, js, je, q )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 integer  , intent(in) :: is, ie, js, je
 real     , intent(in) :: q(is:ie, js:je)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i, j
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'replace')
    write(1) ((q(i,j), i = is, ie), j = js, je)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
    do j = js, je
    do i = is, ie
     write(1, '(e16.8e3)') q(i,j)
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_ArrayReal2D
!*******************************************************************************************************
!******** 三次元配列ファイル入力（実数）                                                        ********
!*******************************************************************************************************
subroutine Input_ArrayReal3D( &
&            strname, ext, is, ie, js, je, ks, ke, q )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 integer  , intent(in)  :: is, ie, js, je, ks, ke
 real     , intent(out) :: q(is:ie, js:je, ks:ke)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i, j, k
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'old')
    read(1) (((q(i,j,k), i = is, ie), j = js, je), k = ks, ke)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
    do k = ks, ke
    do j = js, je
    do i = is, ie
     read(1, '(e16.8e3)') q(i,j,k)
    enddo
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_ArrayReal3D
!*******************************************************************************************************
!******** 三次元配列ファイル出力（実数）                                                        ********
!*******************************************************************************************************
subroutine Output_ArrayReal3D( &
&            strname, ext, is, ie, js, je, ks, ke, q )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 integer  , intent(in) :: is, ie, js, je, ks, ke
 real     , intent(in) :: q(is:ie, js:je, ks:ke)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i, j, k
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'replace')
    write(1) (((q(i,j,k), i = is, ie), j = js, je), k = ks, ke)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
    do k = ks, ke
    do j = js, je
    do i = is, ie
     write(1, '(e16.8e3)') q(i,j,k)
    enddo
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_ArrayReal3D
!*******************************************************************************************************
!******** 一次元配列ファイル入力（整数）                                                        ********
!*******************************************************************************************************
subroutine Input_ArrayInt1D( &
&            strname, ext, is, ie, q )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 integer  , intent(in)  :: is, ie
 integer  , intent(out) :: q(is:ie)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'old')
    read(1) (q(i), i = is, ie)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
    do i = is, ie
     read(1, '(i16)') q(i)
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_ArrayInt1D
!*******************************************************************************************************
!******** 一次元配列ファイル出力（整数）                                                        ********
!*******************************************************************************************************
subroutine Output_ArrayInt1D( &
&            strname, ext, is, ie, q )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 integer  , intent(in) :: is, ie
 integer  , intent(in) :: q(is:ie)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'replace')
    write(1) (q(i), i = is, ie)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
    do i = is, ie
     write(1, '(i16)') q(i)
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_ArrayInt1D
!*******************************************************************************************************
!******** 二次元配列ファイル入力（整数）                                                        ********
!*******************************************************************************************************
subroutine Input_ArrayInt2D( &
&            strname, ext, is, ie, js, je, q )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 integer  , intent(in)  :: is, ie, js, je
 integer  , intent(out) :: q(is:ie, js:je)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i, j
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'old')
    read(1) ((q(i,j), i = is, ie), j = js, je)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
    do j = js, je
    do i = is, ie
     read(1, '(i16)') q(i,j)
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_ArrayInt2D
!*******************************************************************************************************
!******** 二次元配列ファイル出力（整数）                                                        ********
!*******************************************************************************************************
subroutine Output_ArrayInt2D( &
&            strname, ext, is, ie, js, je, q )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 integer  , intent(in) :: is, ie, js, je
 integer  , intent(in) :: q(is:ie, js:je)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i, j
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'replace')
    write(1) ((q(i,j), i = is, ie), j = js, je)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
    do j = js, je
    do i = is, ie
     write(1, '(i16)') q(i,j)
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_ArrayInt2D
!*******************************************************************************************************
!******** 三次元配列ファイル入力（整数）                                                        ********
!*******************************************************************************************************
subroutine Input_ArrayInt3D( &
&            strname, ext, is, ie, js, je, ks, ke, q )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 integer  , intent(in)  :: is, ie, js, je, ks, ke
 integer  , intent(out) :: q(is:ie, js:je, ks:ke)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i, j, k
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'old')
    read(1) (((q(i,j,k), i = is, ie), j = js, je), k = ks, ke)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
    do k = ks, ke
    do j = js, je
    do i = is, ie
     read(1, '(i16)') q(i,j,k)
    enddo
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_ArrayInt3D
!*******************************************************************************************************
!******** 三次元配列ファイル出力（整数）                                                        ********
!*******************************************************************************************************
subroutine Output_ArrayInt3D( &
&            strname, ext, is, ie, js, je, ks, ke, q )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 integer  , intent(in) :: is, ie, js, je, ks, ke
 integer  , intent(in) :: q(is:ie, js:je, ks:ke)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i, j, k
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'replace')
    write(1) (((q(i,j,k), i = is, ie), j = js, je), k = ks, ke)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
    do k = ks, ke
    do j = js, je
    do i = is, ie
     write(1, '(i16)') q(i,j,k)
    enddo
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_ArrayInt3D
!*******************************************************************************************************
!******** 計算格子分割点入力 									********
!*******************************************************************************************************
subroutine Input_GridPoint( &
&            strname, ext, ip )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 integer  , intent(out) :: ip
 ! 処理開始 ********************************************************************************************
 open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
  read(1, '(i4)') ip
 close(1)
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_GridPoint
!*******************************************************************************************************
!******** 計算格子分割点出力 									********
!*******************************************************************************************************
subroutine Output_GridPoint( &
&            strname, ext, ip )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 integer  , intent(in) :: ip
 ! 処理開始 ********************************************************************************************
 open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
  write(1, '(i4)') ip
 close(1)
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_GridPoint
!*******************************************************************************************************
!******** 液滴投入条件入力 									********
!*******************************************************************************************************
subroutine Input_DropInCondition( &
&            strname, ext, a, u )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 real     , intent(out) :: a, u
 ! 処理開始 ********************************************************************************************
 open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
  read(1, '(e16.8e3)') a
  read(1, '(e16.8e3)') u
 close(1)
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_DropInCondition
!*******************************************************************************************************
!******** 液滴投入条件出力 									********
!*******************************************************************************************************
subroutine Output_DropInCondition( &
&            strname, ext, a, u )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 real     , intent(in) :: a, u
 ! 処理開始 ********************************************************************************************
 open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
  write(1, '(e16.8e3)') a
  write(1, '(e16.8e3)') u
 close(1)
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_DropInCondition
!*******************************************************************************************************
!******** 液滴衝突データ入力 (三次元)								********
!*******************************************************************************************************
subroutine Input_Impingement3D( &
&            strname, ext, is, ie, ks, ke, Nimp, Uimp, Vimp, Wimp )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 integer  , intent(in)  :: is, ie, ks, ke
 real     , intent(out) :: Nimp(is:ie, ks:ke)				! 衝突個数
 real     , intent(out) :: Uimp(is:ie, ks:ke), &
 &                         Vimp(is:ie, ks:ke), &
 &                         Wimp(is:ie, ks:ke)				! 衝突速度の和
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer   :: i, k
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'old')
    read(1) ((Nimp(i,k), i = is, ie), k = ks, ke)
    read(1) ((Uimp(i,k), i = is, ie), k = ks, ke)
    read(1) ((Vimp(i,k), i = is, ie), k = ks, ke)
    read(1) ((Wimp(i,k), i = is, ie), k = ks, ke)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
    do k = ks, ke
    do i = is, ie
     read(1, '(e16.8e3,3(x,e16.8e3))') Nimp(i,k), Uimp(i,k), Vimp(i,k), Wimp(i,k)
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_Impingement3D
!*******************************************************************************************************
!******** 液滴衝突データ出力 (三次元)								********
!*******************************************************************************************************
subroutine Output_Impingement3D( &
&            strname, ext, is, ie, ks, ke, Nimp, Uimp, Vimp, Wimp )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 integer  , intent(in) :: is, ie, ks, ke
 real     , intent(in) :: Nimp(is:ie, ks:ke)				! 衝突個数
 real     , intent(in) :: Uimp(is:ie, ks:ke), &
 &                        Vimp(is:ie, ks:ke), &
 &                        Wimp(is:ie, ks:ke)				! 衝突速度の和
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer   :: i, k
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'replace')
    write(1) ((Nimp(i,k), i = is, ie), k = ks, ke)
    write(1) ((Uimp(i,k), i = is, ie), k = ks, ke)
    write(1) ((Vimp(i,k), i = is, ie), k = ks, ke)
    write(1) ((Wimp(i,k), i = is, ie), k = ks, ke)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
    do k = ks, ke
    do i = is, ie
     write(1, '(e16.8e3,3(x,e16.8e3))') Nimp(i,k), Uimp(i,k), Vimp(i,k), Wimp(i,k)
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_Impingement3D
!*******************************************************************************************************
!******** 収集効率入力 (三次元)									********
!*******************************************************************************************************
subroutine Input_CollectionEfficiency3D( &
&            strname, ext, is, ie, ks, ke, CE, u, v, w )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 integer  , intent(in)  :: is, ie, ks, ke
 real     , intent(out) :: CE(is:ie, ks:ke)
 real     , intent(out) :: u(is:ie, ks:ke), v(is:ie, ks:ke), w(is:ie, ks:ke)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer   :: i, k
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'old')
    read(1) ((CE(i,k), i = is, ie), k = ks, ke)
    read(1) ((u (i,k), i = is, ie), k = ks, ke)
    read(1) ((v (i,k), i = is, ie), k = ks, ke)
    read(1) ((w (i,k), i = is, ie), k = ks, ke)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
    do k = ks, ke
    do i = is, ie
     read(1, '(e16.8e3,3(x,e16.8e3))') CE(i,k), u(i,k), v(i,k), w(i,k)
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_CollectionEfficiency3D
!*******************************************************************************************************
!******** 収集効率出力 (三次元)									********
!*******************************************************************************************************
subroutine Output_CollectionEfficiency3D( &
&            strname, ext, is, ie, ks, ke, CE, u, v, w )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 integer  , intent(in) :: is, ie, ks, ke
 real     , intent(in) :: CE(is:ie, ks:ke)
 real     , intent(in) :: u(is:ie, ks:ke), v(is:ie, ks:ke), w(is:ie, ks:ke)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer   :: i, k
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'replace')
    write(1) ((CE(i,k), i = is, ie), k = ks, ke)
    write(1) ((u (i,k), i = is, ie), k = ks, ke)
    write(1) ((v (i,k), i = is, ie), k = ks, ke)
    write(1) ((w (i,k), i = is, ie), k = ks, ke)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
    do k = ks, ke
    do i = is, ie
     write(1, '(e16.8e3,3(x,e16.8e3))') CE(i,k), u(i,k), v(i,k), w(i,k)
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_CollectionEfficiency3D
!*******************************************************************************************************
!******** 氷層厚さ・温度入力 (二次元)								********
!*******************************************************************************************************
subroutine Input_IceThickTem2D( &
&            strname, ext, is, ie, f, Bi, dBi, Ti )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 integer  , intent(in)  :: is, ie
 integer  , intent(out) :: f  (is:ie)					! 着氷箇所のフラグ
 real     , intent(out) :: Bi (is:ie)					! 氷層厚さ (絶対量)
 real     , intent(out) :: dBi(is:ie)					! 氷層厚さ (変化量)
 real     , intent(out) :: Ti (is:ie)					! 氷層温度
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer   :: i
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'old')
    read(1) (f  (i), i = is, ie)
    read(1) (Bi (i), i = is, ie)
    read(1) (dBi(i), i = is, ie)
    read(1) (Ti (i), i = is, ie)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
    do i = is, ie
     read(1, '(i1,3(x,e16.8e3))') f(i), Bi(i), dBi(i), Ti(i)
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_IceThickTem2D
!*******************************************************************************************************
!******** 氷層厚さ・温度出力 (二次元)								********
!*******************************************************************************************************
subroutine Output_IceThickTem2D( &
&            strname, ext, is, ie, f, Bi, dBi, Ti )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 integer  , intent(in) :: is, ie
 integer  , intent(in) :: f  (is:ie)					! 着氷箇所のフラグ
 real     , intent(in) :: Bi (is:ie)					! 氷層厚さ (絶対量)
 real     , intent(in) :: dBi(is:ie)					! 氷層厚さ (変化量)
 real     , intent(in) :: Ti (is:ie)					! 氷層温度
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer   :: i
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'replace')
    write(1) (f  (i), i = is, ie)
    write(1) (Bi (i), i = is, ie)
    write(1) (dBi(i), i = is, ie)
    write(1) (Ti (i), i = is, ie)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
    do i = is, ie
     write(1, '(i1,3(x,e16.8e3))') f(i), Bi(i), dBi(i), Ti(i)
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_IceThickTem2D
!*******************************************************************************************************
!******** 氷層厚さ・温度入力 (三次元)								********
!*******************************************************************************************************
subroutine Input_IceThickTem3D( &
&            strname, ext, is, ie, ks, ke, f, Bi, dBi, Ti )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 integer  , intent(in)  :: is, ie, ks, ke
 integer  , intent(out) :: f  (is:ie, ks:ke)				! 着氷箇所のフラグ
 real     , intent(out) :: Bi (is:ie, ks:ke)				! 氷層厚さ (絶対量)
 real     , intent(out) :: dBi(is:ie, ks:ke)				! 氷層厚さ (変化量)
 real     , intent(out) :: Ti (is:ie, ks:ke)				! 氷層温度
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer   :: i, k
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'old')
    read(1) ((f  (i,k), i = is, ie), k = ks, ke)
    read(1) ((Bi (i,k), i = is, ie), k = ks, ke)
    read(1) ((dBi(i,k), i = is, ie), k = ks, ke)
    read(1) ((Ti (i,k), i = is, ie), k = ks, ke)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
    do k = ks, ke
    do i = is, ie
     read(1, '(i1,3(x,e16.8e3))') f(i,k), Bi(i,k), dBi(i,k), Ti(i,k)
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_IceThickTem3D
!*******************************************************************************************************
!******** 氷層厚さ・温度出力 (三次元)								********
!*******************************************************************************************************
subroutine Output_IceThickTem3D( &
&            strname, ext, is, ie, ks, ke, f, Bi, dBi, Ti )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 integer  , intent(in) :: is, ie, ks, ke
 integer  , intent(in) :: f (is:ie, ks:ke)				! 着氷箇所のフラグ
 real     , intent(in) :: Bi(is:ie, ks:ke)				! 氷層厚さ (絶対量)
 real     , intent(in) :: dBi(is:ie, ks:ke)				! 氷層厚さ (変化量)
 real     , intent(in) :: Ti(is:ie, ks:ke)				! 氷層温度
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer   :: i, k
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'replace')
    write(1) ((f (i,k), i = is, ie), k = ks, ke)
    write(1) ((Bi(i,k), i = is, ie), k = ks, ke)
    write(1) ((dBi(i,k), i = is, ie), k = ks, ke)
    write(1) ((Ti(i,k), i = is, ie), k = ks, ke)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
    do k = ks, ke
    do i = is, ie
     write(1, '(i1,3(x,e16.8e3))') f(i,k), Bi(i,k), dBi(i,k), Ti(i,k)
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_IceThickTem3D
!*******************************************************************************************************
!******** Original Messinger モデルの変数入力 (二次元)						********
!*******************************************************************************************************
subroutine Input_OrgMessingerPara2D( &
&            strname, ext, is, ie, Mac, Mes, Mim, Min, Mout, Mre )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 integer  , intent(in)  :: is, ie
 real     , intent(out) :: Mac (is:ie)					! 堆積する氷の質量
 real     , intent(out) :: Mes (is:ie)					! 蒸発・昇華する質量
 real     , intent(out) :: Mim (is:ie)					! 衝突する質量
 real     , intent(out) :: Min (is:ie)					! Runback-in する質量
 real     , intent(out) :: Mout(is:ie)					! Runback-out する質量
 real     , intent(out) :: Mre (is:ie)					! 検査体積内に残る質量
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer   :: i
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'old')
    read(1) (Mac   (i), i = is, ie)
    read(1) (Mes   (i), i = is, ie)
    read(1) (Mim   (i), i = is, ie)
    read(1) (Min   (i), i = is, ie)
    read(1) (Mout  (i), i = is, ie)
    read(1) (Mre   (i), i = is, ie)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
    do i = is, ie
     read(1, '(e16.8e3,5(x,e16.8e3))') Mac(i), Mes(i), Mim(i), Min(i), Mout(i), Mre(i)
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_OrgMessingerPara2D
!*******************************************************************************************************
!******** Original Messinger モデルの変数出力 (二次元)						********
!*******************************************************************************************************
subroutine Output_OrgMessingerPara2D( &
&            strname, ext, is, ie, Mac, Mes, Mim, Min, Mout, Mre )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 integer  , intent(in) :: is, ie
 real     , intent(in) :: Mac (is:ie)					! 堆積する氷の質量
 real     , intent(in) :: Mes (is:ie)					! 蒸発・昇華する質量
 real     , intent(in) :: Mim (is:ie)					! 衝突する質量
 real     , intent(in) :: Min (is:ie)					! Runback-in する質量
 real     , intent(in) :: Mout(is:ie)					! Runback-out する質量
 real     , intent(in) :: Mre (is:ie)					! 検査体積内に残る質量
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer   :: i
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'replace')
    write(1) (Mac   (i), i = is, ie)
    write(1) (Mes   (i), i = is, ie)
    write(1) (Mim   (i), i = is, ie)
    write(1) (Min   (i), i = is, ie)
    write(1) (Mout  (i), i = is, ie)
    write(1) (Mre   (i), i = is, ie)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
    do i = is, ie
     write(1, '(e16.8e3,5(x,e16.8e3))') Mac(i), Mes(i), Mim(i), Min(i), Mout(i), Mre(i)
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_OrgMessingerPara2D
!*******************************************************************************************************
!******** Extended-Messinger モデルの変数入力 (二次元)						********
!*******************************************************************************************************
subroutine Input_ExtMessingerPara2D( &
&            strname, ext, is, ie, nPhase, Mes, Mim, Min, Mout, Mre )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 integer  , intent(in)  :: is, ie
 integer  , intent(out) :: nPhase(is:ie)				! 壁面の状態
 real     , intent(out) :: Mes   (is:ie)				! 蒸発・昇華する質量流束
 real     , intent(out) :: Mim   (is:ie)				! 衝突する質量流束
 real     , intent(out) :: Min   (is:ie)				! Runback-in する質量流束
 real     , intent(out) :: Mout  (is:ie)				! Runback-out する質量流束
 real     , intent(out) :: Mre   (is:ie)				! 検査体積内に残る質量流束
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer   :: i
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'old')
    read(1) (nPhase(i), i = is, ie)
    read(1) (Mes   (i), i = is, ie)
    read(1) (Mim   (i), i = is, ie)
    read(1) (Min   (i), i = is, ie)
    read(1) (Mout  (i), i = is, ie)
    read(1) (Mre   (i), i = is, ie)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
    do i = is, ie
     read(1, '(i1,5(x,e16.8e3))') nPhase(i), Mes(i), Mim(i), Min(i), Mout(i), Mre(i)
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_ExtMessingerPara2D
!*******************************************************************************************************
!******** Extended-Messinger モデルの変数出力 (二次元)						********
!*******************************************************************************************************
subroutine Output_ExtMessingerPara2D( &
&            strname, ext, is, ie, nPhase, Mes, Mim, Min, Mout, Mre )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 integer  , intent(in) :: is, ie
 integer  , intent(in) :: nPhase(is:ie)					! 壁面の状態
 real     , intent(in) :: Mes (is:ie)					! 蒸発・昇華する質量流束
 real     , intent(in) :: Mim (is:ie)					! 衝突する質量流束
 real     , intent(in) :: Min (is:ie)					! Runback-in する質量流束
 real     , intent(in) :: Mout(is:ie)					! Runback-out する質量流束
 real     , intent(in) :: Mre (is:ie)					! 検査体積内に残る質量流束
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer   :: i
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'replace')
    write(1) (nPhase(i), i = is, ie)
    write(1) (Mes   (i), i = is, ie)
    write(1) (Mim   (i), i = is, ie)
    write(1) (Min   (i), i = is, ie)
    write(1) (Mout  (i), i = is, ie)
    write(1) (Mre   (i), i = is, ie)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
    do i = is, ie
     write(1, '(i1,5(x,e16.8e3))') nPhase(i), Mes(i), Mim(i), Min(i), Mout(i), Mre(i)
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_ExtMessingerPara2D
!*******************************************************************************************************
!******** Original Messinger モデルの変数入力 (三次元)						********
!*******************************************************************************************************
subroutine Input_OrgMessingerPara3D( &
&            strname, ext, is, ie, ks, ke, Mac, Mes, Mim, Min, Mout, Mre )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 integer  , intent(in)  :: is, ie, ks, ke
 real     , intent(out) :: Mac (is:ie, ks:ke)				! 堆積する氷の質量
 real     , intent(out) :: Mes (is:ie, ks:ke)				! 蒸発・昇華する質量
 real     , intent(out) :: Mim (is:ie, ks:ke)				! 衝突する質量
 real     , intent(out) :: Min (is:ie, ks:ke)				! Runback-in する質量
 real     , intent(out) :: Mout(is:ie, ks:ke)				! Runback-out する質量
 real     , intent(out) :: Mre (is:ie, ks:ke)				! 検査体積内に残る質量
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer   :: i, k
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'old')
    read(1) ((Mac   (i,k), i = is, ie), k = ks, ke)
    read(1) ((Mes   (i,k), i = is, ie), k = ks, ke)
    read(1) ((Mim   (i,k), i = is, ie), k = ks, ke)
    read(1) ((Min   (i,k), i = is, ie), k = ks, ke)
    read(1) ((Mout  (i,k), i = is, ie), k = ks, ke)
    read(1) ((Mre   (i,k), i = is, ie), k = ks, ke)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
    do k = ks, ke
    do i = is, ie
     read(1, '(e16.8e3,5(x,e16.8e3))') Mac(i,k), Mes(i,k), Mim(i,k), Min(i,k), Mout(i,k), Mre(i,k)
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_OrgMessingerPara3D
!*******************************************************************************************************
!******** Original Messinger モデルの変数出力 (三次元)						********
!*******************************************************************************************************
subroutine Output_OrgMessingerPara3D( &
&            strname, ext, is, ie, ks, ke, Mac, Mes, Mim, Min, Mout, Mre )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 integer  , intent(in) :: is, ie, ks, ke
 real     , intent(in) :: Mac (is:ie, ks:ke)				! 堆積する氷の質量
 real     , intent(in) :: Mes (is:ie, ks:ke)				! 蒸発・昇華する質量
 real     , intent(in) :: Mim (is:ie, ks:ke)				! 衝突する質量
 real     , intent(in) :: Min (is:ie, ks:ke)				! Runback-in する質量
 real     , intent(in) :: Mout(is:ie, ks:ke)				! Runback-out する質量
 real     , intent(in) :: Mre (is:ie, ks:ke)				! 検査体積内に残る質量
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer   :: i, k
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'replace')
    write(1) ((Mac   (i,k), i = is, ie), k = ks, ke)
    write(1) ((Mes   (i,k), i = is, ie), k = ks, ke)
    write(1) ((Mim   (i,k), i = is, ie), k = ks, ke)
    write(1) ((Min   (i,k), i = is, ie), k = ks, ke)
    write(1) ((Mout  (i,k), i = is, ie), k = ks, ke)
    write(1) ((Mre   (i,k), i = is, ie), k = ks, ke)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
    do k = ks, ke
    do i = is, ie
     write(1, '(e16.8e3,5(x,e16.8e3))') Mac(i,k), Mes(i,k), Mim(i,k), Min(i,k), Mout(i,k), Mre(i,k)
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_OrgMessingerPara3D
!*******************************************************************************************************
!******** Extended-Messinger モデルの変数入力 (三次元)						********
!*******************************************************************************************************
subroutine Input_ExtMessingerPara3D( &
&            strname, ext, is, ie, ks, ke, nPhase, Mes, Mim, Min, Mout, Mre )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 integer  , intent(in)  :: is, ie, ks, ke
 integer  , intent(out) :: nPhase(is:ie, ks:ke)				! 壁面の状態
 real     , intent(out) :: Mes   (is:ie, ks:ke)				! 蒸発・昇華する質量流束
 real     , intent(out) :: Mim   (is:ie, ks:ke)				! 衝突する質量流束
 real     , intent(out) :: Min   (is:ie, ks:ke)				! Runback-in する質量流束
 real     , intent(out) :: Mout  (is:ie, ks:ke)				! Runback-out する質量流束
 real     , intent(out) :: Mre   (is:ie, ks:ke)				! 検査体積内に残る質量流束
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer   :: i, k
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'old')
    read(1) ((nPhase(i,k), i = is, ie), k = ks, ke)
    read(1) ((Mes   (i,k), i = is, ie), k = ks, ke)
    read(1) ((Mim   (i,k), i = is, ie), k = ks, ke)
    read(1) ((Min   (i,k), i = is, ie), k = ks, ke)
    read(1) ((Mout  (i,k), i = is, ie), k = ks, ke)
    read(1) ((Mre   (i,k), i = is, ie), k = ks, ke)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
    do k = ks, ke
    do i = is, ie
     read(1, '(i1,5(x,e16.8e3))') nPhase(i,k), Mes(i,k), Mim(i,k), Min(i,k), Mout(i,k), Mre(i,k)
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_ExtMessingerPara3D
!*******************************************************************************************************
!******** Extended-Messinger モデルの変数出力 (三次元)						********
!*******************************************************************************************************
subroutine Output_ExtMessingerPara3D( &
&            strname, ext, is, ie, ks, ke, nPhase, Mes, Mim, Min, Mout, Mre )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 integer  , intent(in) :: is, ie, ks, ke
 integer  , intent(in) :: nPhase(is:ie, ks:ke)				! 壁面の状態
 real     , intent(in) :: Mes (is:ie, ks:ke)				! 蒸発・昇華する質量流束
 real     , intent(in) :: Mim (is:ie, ks:ke)				! 衝突する質量流束
 real     , intent(in) :: Min (is:ie, ks:ke)				! Runback-in する質量流束
 real     , intent(in) :: Mout(is:ie, ks:ke)				! Runback-out する質量流束
 real     , intent(in) :: Mre (is:ie, ks:ke)				! 検査体積内に残る質量流束
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer   :: i, k
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'replace')
    write(1) ((nPhase(i,k), i = is, ie), k = ks, ke)
    write(1) ((Mes   (i,k), i = is, ie), k = ks, ke)
    write(1) ((Mim   (i,k), i = is, ie), k = ks, ke)
    write(1) ((Min   (i,k), i = is, ie), k = ks, ke)
    write(1) ((Mout  (i,k), i = is, ie), k = ks, ke)
    write(1) ((Mre   (i,k), i = is, ie), k = ks, ke)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
    do k = ks, ke
    do i = is, ie
     write(1, '(i1,5(x,e16.8e3))') nPhase(i,k), Mes(i,k), Mim(i,k), Min(i,k), Mout(i,k), Mre(i,k)
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_ExtMessingerPara3D
!*******************************************************************************************************
!******** 着氷翼表面座標入力  (二次元)								********
!*******************************************************************************************************
subroutine Input_IceBladeSurface2D( &
&            strname, ext, is, ie, x, y )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 integer  , intent(in)  :: is, ie
 real     , intent(out) :: x(is:ie), y(is:ie)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'old')
    read(1) (x(i), i = is, ie)
    read(1) (y(i), i = is, ie)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
    do i = is, ie
     read(1, '(e16.8e3,x,e16.8e3)') x(i), y(i)
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_IceBladeSurface2D
!*******************************************************************************************************
!******** 着氷翼表面座標出力  (二次元)								********
!*******************************************************************************************************
subroutine Output_IceBladeSurface2D( &
&            strname, ext, is, ie, x, y )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 integer  , intent(in) :: is, ie
 real     , intent(in) :: x(is:ie), y(is:ie)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'replace')
    write(1) (x(i), i = is, ie)
    write(1) (y(i), i = is, ie)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
    do i = is, ie
     write(1, '(e16.8e3,x,e16.8e3)') x(i), y(i)
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_IceBladeSurface2D
!*******************************************************************************************************
!******** 着氷翼表面座標入力  (三次元)								********
!*******************************************************************************************************
subroutine Input_IceBladeSurface3D( &
&            strname, ext, is, ie, ks, ke, x, y, z )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*), ext*4
 integer  , intent(in)  :: is, ie, ks, ke
 real     , intent(out) :: x(is:ie, ks:ke), y(is:ie, ks:ke), z(is:ie, ks:ke)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i, k
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'old')
    read(1) ((x(i,k), i = is, ie), k = ks, ke)
    read(1) ((y(i,k), i = is, ie), k = ks, ke)
    read(1) ((z(i,k), i = is, ie), k = ks, ke)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'old')
    do k = ks, ke
    do i = is, ie
     read(1, '(e16.8e3,2(x,e16.8e3))') x(i,k), y(i,k), z(i,k)
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_IceBladeSurface3D
!*******************************************************************************************************
!******** 着氷翼表面座標出力  (三次元)								********
!*******************************************************************************************************
subroutine Output_IceBladeSurface3D( &
&            strname, ext, is, ie, ks, ke, x, y, z )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*), ext*4
 integer  , intent(in) :: is, ie, ks, ke
 real     , intent(in) :: x(is:ie, ks:ke), y(is:ie, ks:ke), z(is:ie, ks:ke)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i, k
 ! 処理開始 ********************************************************************************************
 select case(ext)
  ! Binary ---------------------------------------------------------------------------------------------
  case(strbin)
   open(1, file = trim(strname) // ext, form = 'unformatted', status = 'replace')
    write(1) ((x(i,k), i = is, ie), k = ks, ke)
    write(1) ((y(i,k), i = is, ie), k = ks, ke)
    write(1) ((z(i,k), i = is, ie), k = ks, ke)
   close(1)
  ! Aschii ---------------------------------------------------------------------------------------------
  case default
   open(1, file = trim(strname) // ext, form = 'formatted', status = 'replace')
    do k = ks, ke
    do i = is, ie
     write(1, '(e16.8e3,2(x,e16.8e3))') x(i,k), y(i,k), z(i,k)
    enddo
    enddo
   close(1)
 end select
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_IceBladeSurface3D
! 定義終了 *********************************************************************************************
end module Package_FileIO
```

## file "Mod_Package_Flow.f90"

```fortran
!***********************************************************************
!***********************************************************************
!**** �p�b�P�[�W�^���W���[��                                        ****
!**** �����v�Z�p�T�u���[�`���Q                                    ****
!****                         2011.09.05 PROGRAMED BY SUZUKI MASAYA ****
!***********************************************************************
!***********************************************************************
MODULE Package_Flow
  ! ���W���[���錾 *****************************************************
  !$USE omp_lib
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  PRIVATE
  ! �T�u���[�`���錾 ***************************************************
  ! ���L�T�u���[�`�� +++++++++++++++++++++++++++++++++++++++++++++++++++
  PUBLIC :: SetFlux2D, SetFlux3D
  PUBLIC :: SetFlux2DKEM, SetFlux3DKEM
  PUBLIC :: SetFlux2DRSM, SetFlux3DRSM
  PUBLIC :: SetPhysics2D, SetPhysics3D
  PUBLIC :: SetPhysics2DKEM, SetPhysics3DKEM
  PUBLIC :: SetPhysics2DRSM, SetPhysics3DRSM
  PUBLIC :: ViscosityCoefficient2D, ViscosityCoefficient3D
  PUBLIC :: CalLocalDt2D, CalLocalDt3D
  PUBLIC :: CalDt2D, CalDt3D
  PUBLIC :: RungeKutta2D, RungeKutta3D
  PUBLIC :: LUADI2D, LUADI3D
  PUBLIC :: Convection2D, Convection3D
  PUBLIC :: RotationForce2D, RotationForce3D
  PUBLIC :: Viscosity2D, Viscosity3D
  PUBLIC :: Turbulence2DEvmStd, Turbulence2DEvmStdKL, &
  &         Turbulence3DEvmStd, Turbulence3DEvmStdKL
  PUBLIC :: Turbulence2DEvmLS, Turbulence3DEvmLS
  PUBLIC :: Turbulence3DEvmAKN
  PUBLIC :: Turbulence2DNlEvmkeCLS, Turbulence3DNlEvmkeCLS
  PUBLIC :: Turbulence2DRSMGL, Turbulence3DRSMGL
  PUBLIC :: Turbulence2DRSMSSG, Turbulence3DRSMSSG
  PUBLIC :: Turbulence2DRSMLS, Turbulence3DRSMLS
  PUBLIC :: Turbulence2DLESCSM, Turbulence3DLESCSM
  PUBLIC :: Limiter2DKEM, Limiter3DKEM
  PUBLIC :: Limiter2DRSM, Limiter3DRSM
  PUBLIC :: CalResidual2D, CalResidual3D
  PUBLIC :: YapCorrection2D, YapCorrection3D
  PUBLIC :: WallFunctionKEM1S, WallFunctionRSM1S, &
  &         WallFunctionKEM2S, WallFunctionRSM2S, CalUtauS
  PUBLIC :: WallFunctionKEM1R, WallFunctionRSM1R, &
  &         WallFunctionKEM2R, WallFunctionRSM2R, CalUtauR
  ! ���L�T�u���[�`�� (����) +++++++++++++++++++++++++++++++++++++++++++
  PUBLIC :: SaveFlux3DKEM, SumDQH3D
! �����葱�� ***********************************************************
CONTAINS
!***********************************************************************
!**** �����ʂ���ۑ��ʗ������v�Z                                    ****
!**** �v�Z�Ώ� : �P��, �񎟌�, ���k��, �w��                         ****
!***********************************************************************
SUBROUTINE SetFlux2D( &
&            GAMMA, &
&            IS, IE, JS, JE, LS, LE, &
&            QH, AJA, RHO, U, V, P, &
&            YY &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)            :: GAMMA
  INTEGER, INTENT(IN)            :: IS, IE, JS, JE
  INTEGER, INTENT(IN)            :: LS, LE
  REAL,    INTENT(OUT)           :: QH (IS:IE, JS:JE, LS:LE)
  REAL,    INTENT(IN)            :: AJA(IS:IE, JS:JE)
  REAL,    INTENT(IN)            :: RHO(IS:IE, JS:JE), &
  &                                 U  (IS:IE, JS:JE), &
  &                                 V  (IS:IE, JS:JE), &
  &                                 P  (IS:IE, JS:JE)
  REAL,    INTENT(IN),  OPTIONAL :: YY (IS:IE, JS:JE, 5: LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 4) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �ۑ��ʗ������畨���ʂ��v�Z +++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I, J)
  DO J = JS, JE
  DO I = IS, IE
  IF(RHO(I,J) .GT. 0.0) THEN
    QH(I,J,1) = RHO(I,J) / AJA(I,J)
    QH(I,J,2) = QH(I,J,1) * U(I,J)
    QH(I,J,3) = QH(I,J,1) * V(I,J)
    QH(I,J,4) = P(I,J) / ((GAMMA - 1.0) * AJA(I,J)) &
    &         + QH(I,J,1) * 0.5 * (U(I,J)**2 + V(I,J)**2)
    IF(.NOT. PRESENT(YY)) CYCLE
    QH(I,J,5:LE) = QH(I,J,1) * YY(I,J,5:LE)
  ELSE
    QH(I,J,:) = 0.0
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE SetFlux2D
!***********************************************************************
!**** �����ʂ���ۑ��ʗ������v�Z                                    ****
!**** �v�Z�Ώ� : �P��, �O����, ���k��, �w��                         ****
!***********************************************************************
SUBROUTINE SetFlux3D( &
&            GAMMA, &
&            IS, IE, JS, JE, KS, KE, LS, LE, &
&            QH, AJA, RHO, U, V, W, P, &
&            YY &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)            :: GAMMA
  INTEGER, INTENT(IN)            :: IS, IE, JS, JE, KS, KE
  INTEGER, INTENT(IN)            :: LS, LE
  REAL,    INTENT(OUT)           :: QH (IS:IE, JS:JE, KS:KE, LS:LE)
  REAL,    INTENT(IN)            :: AJA(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)            :: RHO(IS:IE, JS:JE, KS:KE), &
  &                                 U  (IS:IE, JS:JE, KS:KE), &
  &                                 V  (IS:IE, JS:JE, KS:KE), &
  &                                 W  (IS:IE, JS:JE, KS:KE), &
  &                                 P  (IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN),  OPTIONAL :: YY (IS:IE, JS:JE, KS:KE, 6: LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 5) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �ۑ��ʗ������畨���ʂ��v�Z +++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I, J, K)
  DO K = KS, KE
  DO J = JS, JE
  DO I = IS, IE
  IF(RHO(I,J,K) .GT. 0.0) THEN
    QH(I,J,K,1) = RHO(I,J,K) / AJA(I,J,K)
    QH(I,J,K,2) = QH(I,J,K,1) * U(I,J,K)
    QH(I,J,K,3) = QH(I,J,K,1) * V(I,J,K)
    QH(I,J,K,4) = QH(I,J,K,1) * W(I,J,K)
    QH(I,J,K,5) = P(I,J,K) / ((GAMMA - 1.0) * AJA(I,J,K)) &
    &           + QH(I,J,K,1) * 0.5 * ( &
    &               U(I,J,K)**2 + V(I,J,K)**2 + W(I,J,K)**2 &
    &           )
    IF(.NOT. PRESENT(YY)) CYCLE
    QH(I,J,K,6:LE) = QH(I,J,K,1) * YY(I,J,K,6:LE)
  ELSE
    QH(I,J,K,:) = 0.0
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE SetFlux3D
!***********************************************************************
!**** �����ʂ���ۑ��ʗ������v�Z                                    ****
!**** �v�Z�Ώ� : �P��, �񎟌�, ���k��, k-e                          ****
!***********************************************************************
SUBROUTINE SetFlux2DKEM( &
&            GAMMA, &
&            IS, IE, JS, JE, LS, LE, &
&            QH, AJA, RHO, U, V, P, AK, EPS, &
&            YY &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)            :: GAMMA
  INTEGER, INTENT(IN)            :: IS, IE, JS, JE
  INTEGER, INTENT(IN)            :: LS, LE
  REAL,    INTENT(OUT)           :: QH (IS:IE, JS:JE, LS:LE)
  REAL,    INTENT(IN)            :: AJA(IS:IE, JS:JE)
  REAL,    INTENT(IN)            :: RHO(IS:IE, JS:JE), &
  &                                 U  (IS:IE, JS:JE), &
  &                                 V  (IS:IE, JS:JE), &
  &                                 P  (IS:IE, JS:JE), &
  &                                 AK (IS:IE, JS:JE), &
  &                                 EPS(IS:IE, JS:JE)
  REAL,    INTENT(IN),  OPTIONAL :: YY (IS:IE, JS:JE, 7: LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 6) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �ۑ��ʗ������畨���ʂ��v�Z +++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I, J)
  DO J = JS, JE
  DO I = IS, IE
  IF(RHO(I,J) .GT. 0.0) THEN
    QH(I,J,1) = RHO(I,J) / AJA(I,J)
    QH(I,J,2) = QH(I,J,1) * U(I,J)
    QH(I,J,3) = QH(I,J,1) * V(I,J)
    QH(I,J,4) = P(I,J) / ((GAMMA - 1.0) * AJA(I,J)) &
    &         + QH(I,J,1) * 0.5 * (U(I,J)**2 + V(I,J)**2) &
    &         + QH(I,J,1) * AK(I,J)
    QH(I,J,5) = QH(I,J,1) * AK(I,J)
    QH(I,J,6) = QH(I,J,1) * EPS(I,J)
    IF(.NOT. PRESENT(YY)) CYCLE
    QH(I,J,7:LE) = QH(I,J,1) * YY(I,J,7:LE)
  ELSE
    QH(I,J,:) = 0.0
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE SetFlux2DKEM
!***********************************************************************
!**** �����ʂ���ۑ��ʗ������v�Z                                    ****
!**** �v�Z�Ώ� : �P��, �O����, ���k��, k-e                          ****
!***********************************************************************
SUBROUTINE SetFlux3DKEM( &
&            GAMMA, &
&            IS, IE, JS, JE, KS, KE, LS, LE, &
&            QH, AJA, RHO, U, V, W, P, AK, EPS, &
&            YY &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)            :: GAMMA
  INTEGER, INTENT(IN)            :: IS, IE, JS, JE, KS, KE
  INTEGER, INTENT(IN)            :: LS, LE
  REAL,    INTENT(OUT)           :: QH (IS:IE, JS:JE, KS:KE, LS:LE)
  REAL,    INTENT(IN)            :: AJA(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)            :: RHO(IS:IE, JS:JE, KS:KE), &
  &                                 U  (IS:IE, JS:JE, KS:KE), &
  &                                 V  (IS:IE, JS:JE, KS:KE), &
  &                                 W  (IS:IE, JS:JE, KS:KE), &
  &                                 P  (IS:IE, JS:JE, KS:KE), &
  &                                 AK (IS:IE, JS:JE, KS:KE), &
  &                                 EPS(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN),  OPTIONAL :: YY (IS:IE, JS:JE, KS:KE, 8: LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 7) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �ۑ��ʗ������畨���ʂ��v�Z +++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I, J, K)
  DO K = KS, KE
  DO J = JS, JE
  DO I = IS, IE
  IF(RHO(I,J,K) .GT. 0.0) THEN
    QH(I,J,K,1) = RHO(I,J,K) / AJA(I,J,K)
    QH(I,J,K,2) = QH(I,J,K,1) * U(I,J,K)
    QH(I,J,K,3) = QH(I,J,K,1) * V(I,J,K)
    QH(I,J,K,4) = QH(I,J,K,1) * W(I,J,K)
    QH(I,J,K,5) = P(I,J,K) / ((GAMMA - 1.0) * AJA(I,J,K)) &
    &           + QH(I,J,K,1) * 0.5 * ( &
    &               U(I,J,K)**2 + V(I,J,K)**2 + W(I,J,K)**2 &
    &           ) &
    &           + QH(I,J,K,1) * AK(I,J,K)
    QH(I,J,K,6) = QH(I,J,K,1) * AK(I,J,K)
    QH(I,J,K,7) = QH(I,J,K,1) * EPS(I,J,K)
    IF(.NOT. PRESENT(YY)) CYCLE
    QH(I,J,K,8:LE) = QH(I,J,K,1) * YY(I,J,K,8:LE)
  ELSE
    QH(I,J,K,:) = 0.0
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE SetFlux3DKEM
!***********************************************************************
!**** �����ʂ���ۑ��ʗ������v�Z                                    ****
!**** �v�Z�Ώ� : �P��, �񎟌�, ���k��, RSM                          ****
!***********************************************************************
SUBROUTINE SetFlux2DRSM( &
&            GAMMA, &
&            IS, IE, JS, JE, LS, LE, &
&            QH, AJA, RHO, U, V, P, uu, vv, ww, uv, EPS, &
&            YY &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)            :: GAMMA
  INTEGER, INTENT(IN)            :: IS, IE, JS, JE
  INTEGER, INTENT(IN)            :: LS, LE
  REAL,    INTENT(OUT)           :: QH (IS:IE, JS:JE, LS:LE)
  REAL,    INTENT(IN)            :: AJA(IS:IE, JS:JE)
  REAL,    INTENT(IN)            :: RHO(IS:IE, JS:JE), &
  &                                 U  (IS:IE, JS:JE), &
  &                                 V  (IS:IE, JS:JE), &
  &                                 P  (IS:IE, JS:JE), &
  &                                 uu (IS:IE, JS:JE), &
  &                                 vv (IS:IE, JS:JE), &
  &                                 ww (IS:IE, JS:JE), &
  &                                 uv (IS:IE, JS:JE), &
  &                                 EPS(IS:IE, JS:JE)
  REAL,    INTENT(IN),  OPTIONAL :: YY (IS:IE, JS:JE, 10: LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 9) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �ۑ��ʗ������畨���ʂ��v�Z +++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I, J)
  DO J = JS, JE
  DO I = IS, IE
  IF(RHO(I,J) .GT. 0.0) THEN
    QH(I,J,1) = RHO(I,J) / AJA(I,J)
    QH(I,J,2) = QH(I,J,1) * U(I,J)
    QH(I,J,3) = QH(I,J,1) * V(I,J)
    QH(I,J,4) = P(I,J) / ((GAMMA - 1.0) * AJA(I,J)) &
    &         + QH(I,J,1) * 0.5 * ( &
    &             U(I,J)**2 + V(I,J)**2 &
    &           + uu(I,J) + vv(I,J) + ww(I,J) &
    &         )
    QH(I,J,5) = QH(I,J,1) * uu(I,J)
    QH(I,J,6) = QH(I,J,1) * vv(I,J)
    QH(I,J,7) = QH(I,J,1) * ww(I,J)
    QH(I,J,8) = QH(I,J,1) * uv(I,J)
    QH(I,J,9) = QH(I,J,1) * EPS(I,J)
    IF(.NOT. PRESENT(YY)) CYCLE
    QH(I,J,10:LE) = QH(I,J,1) * YY(I,J,10:LE)
  ELSE
    QH(I,J,:) = 0.0
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE SetFlux2DRSM
!***********************************************************************
!**** �����ʂ���ۑ��ʗ������v�Z                                    ****
!**** �v�Z�Ώ� : �P��, �O����, ���k��, RSM                          ****
!***********************************************************************
SUBROUTINE SetFlux3DRSM( &
&            GAMMA, &
&            IS, IE, JS, JE, KS, KE, LS, LE, &
&            QH, AJA, RHO, U, V, W, P, uu, vv, ww, uv, vw, wu, EPS, &
&            YY &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)            :: GAMMA
  INTEGER, INTENT(IN)            :: IS, IE, JS, JE, KS, KE
  INTEGER, INTENT(IN)            :: LS, LE
  REAL,    INTENT(OUT)           :: QH (IS:IE, JS:JE, KS:KE, LS:LE)
  REAL,    INTENT(IN)            :: AJA(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)            :: RHO(IS:IE, JS:JE, KS:KE), &
  &                                 U  (IS:IE, JS:JE, KS:KE), &
  &                                 V  (IS:IE, JS:JE, KS:KE), &
  &                                 W  (IS:IE, JS:JE, KS:KE), &
  &                                 P  (IS:IE, JS:JE, KS:KE), &
  &                                 uu (IS:IE, JS:JE, KS:KE), &
  &                                 vv (IS:IE, JS:JE, KS:KE), &
  &                                 ww (IS:IE, JS:JE, KS:KE), &
  &                                 uv (IS:IE, JS:JE, KS:KE), &
  &                                 vw (IS:IE, JS:JE, KS:KE), &
  &                                 wu (IS:IE, JS:JE, KS:KE), &
  &                                 EPS(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN),  OPTIONAL :: YY (IS:IE, JS:JE, KS:KE, 13: LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 12) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �ۑ��ʗ������畨���ʂ��v�Z +++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I, J, K)
  DO K = KS, KE
  DO J = JS, JE
  DO I = IS, IE
  IF(RHO(I,J,K) .GT. 0.0) THEN
    QH(I,J,K, 1) = RHO(I,J,K) / AJA(I,J,K)
    QH(I,J,K, 2) = QH(I,J,K,1) * U(I,J,K)
    QH(I,J,K, 3) = QH(I,J,K,1) * V(I,J,K)
    QH(I,J,K, 4) = QH(I,J,K,1) * W(I,J,K)
    QH(I,J,K, 5) = P(I,J,K) / ((GAMMA - 1.0) * AJA(I,J,K)) &
    &            + QH(I,J,K,1) * 0.5 * ( &
    &                U(I,J,K)**2 + V(I,J,K)**2 + W(I,J,K)**2 &
    &              + uu(I,J,K) + vv(I,J,K) + ww(I,J,K) &
    &            )
    QH(I,J,K, 6) = QH(I,J,K,1) * uu(I,J,K)
    QH(I,J,K, 7) = QH(I,J,K,1) * vv(I,J,K)
    QH(I,J,K, 8) = QH(I,J,K,1) * ww(I,J,K)
    QH(I,J,K, 9) = QH(I,J,K,1) * uv(I,J,K)
    QH(I,J,K,10) = QH(I,J,K,1) * vw(I,J,K)
    QH(I,J,K,11) = QH(I,J,K,1) * wu(I,J,K)
    QH(I,J,K,12) = QH(I,J,K,1) * EPS(I,J,K)
    IF(.NOT. PRESENT(YY)) CYCLE
    QH(I,J,K,13:LE) = QH(I,J,K,1) * YY(I,J,K,13:LE)
  ELSE
    QH(I,J,K, :) = 0.0
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE SetFlux3DRSM
!***********************************************************************
!**** �ۑ��ʗ������畨���ʂ��v�Z                                    ****
!**** �v�Z�Ώ� : �P��, �񎟌�, ���k��, �w��                         ****
!***********************************************************************
SUBROUTINE SetPhysics2D( &
&            RG, GAMMA, &
&            IS, IE, JS, JE, LS, LE, &
&            QH, AJA, RHO, U, V, P, T, &
&            YY &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)            :: RG, GAMMA
  INTEGER, INTENT(IN)            :: IS, IE, JS, JE
  INTEGER, INTENT(IN)            :: LS, LE
  REAL,    INTENT(IN)            :: QH (IS:IE, JS:JE, LS:LE)
  REAL,    INTENT(IN)            :: AJA(IS:IE, JS:JE)
  REAL,    INTENT(OUT)           :: RHO(IS:IE, JS:JE), &
  &                                 U  (IS:IE, JS:JE), &
  &                                 V  (IS:IE, JS:JE), &
  &                                 P  (IS:IE, JS:JE), &
  &                                 T  (IS:IE, JS:JE)
  REAL,    INTENT(OUT), OPTIONAL :: YY (IS:IE, JS:JE, 5: LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 4) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �ۑ��ʗ������畨���ʂ��v�Z +++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I, J)
  DO J = JS, JE
  DO I = IS, IE
  IF(QH(I,J,1) .GT. 0.0) THEN
    RHO(I,J) = AJA(I,J) * QH(I,J,1)
    U(I,J)   = QH(I,J,2) / QH(I,J,1)
    V(I,J)   = QH(I,J,3) / QH(I,J,1)
    P(I,J)   = ( QH(I,J,4) &
    &          - 0.5 * (QH(I,J,2)**2 + QH(I,J,3)**2) / QH(I,J,1) &
    &        ) * (GAMMA - 1.0) * AJA(I,J)
    T(I,J)   = P(I,J) / (RHO(I,J) * RG)
    IF(.NOT. PRESENT(YY)) CYCLE
    YY(I,J,5:LE) = YY(I,J,5:LE) / QH(I,J,1)
  ELSE
    RHO(I,J) = 0.0
    U(I,J)   = 0.0
    V(I,J)   = 0.0
    P(I,J)   = 0.0
    T(I,J)   = 0.0
    IF(.NOT. PRESENT(YY)) CYCLE
    YY(I,J,5:LE) = 0.0
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE SetPhysics2D
!***********************************************************************
!**** �ۑ��ʗ������畨���ʂ��v�Z                                    ****
!**** �v�Z�Ώ� : �P��, �O����, ���k��, �w��                         ****
!***********************************************************************
SUBROUTINE SetPhysics3D( &
&            RG, GAMMA, &
&            IS, IE, JS, JE, KS, KE, LS, LE, &
&            QH, AJA, RHO, U, V, W, P, T, &
&            YY &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)            :: RG, GAMMA
  INTEGER, INTENT(IN)            :: IS, IE, JS, JE, KS, KE
  INTEGER, INTENT(IN)            :: LS, LE
  REAL,    INTENT(IN)            :: QH (IS:IE, JS:JE, KS:KE, LS:LE)
  REAL,    INTENT(IN)            :: AJA(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(OUT)           :: RHO(IS:IE, JS:JE, KS:KE), &
  &                                 U  (IS:IE, JS:JE, KS:KE), &
  &                                 V  (IS:IE, JS:JE, KS:KE), &
  &                                 W  (IS:IE, JS:JE, KS:KE), &
  &                                 P  (IS:IE, JS:JE, KS:KE), &
  &                                 T  (IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(OUT), OPTIONAL :: YY (IS:IE, JS:JE, KS:KE, 6: LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 5) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �ۑ��ʗ������畨���ʂ��v�Z +++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I, J, K)
  DO K = KS, KE
  DO J = JS, JE
  DO I = IS, IE
  IF(QH(I,J,K,1) .GT. 0.0) THEN
    RHO(I,J,K) = AJA(I,J,K) * QH(I,J,K,1)
    U(I,J,K)   = QH(I,J,K,2) / QH(I,J,K,1)
    V(I,J,K)   = QH(I,J,K,3) / QH(I,J,K,1)
    W(I,J,K)   = QH(I,J,K,4) / QH(I,J,K,1)
    P(I,J,K)   = ( QH(I,J,K,5) &
    &            - 0.5 * ( QH(I,J,K,2)**2 &
    &                    + QH(I,J,K,3)**2 &
    &                    + QH(I,J,K,4)**2 ) / QH(I,J,K,1) &
    &          ) * (GAMMA - 1.0) * AJA(I,J,K)
    T(I,J,K)   = P(I,J,K) / (RHO(I,J,K) * RG)
    IF(.NOT. PRESENT(YY)) CYCLE
    YY(I,J,K,6:LE) = QH(I,J,K,6:LE) / QH(I,J,K,1)
  ELSE
    RHO(I,J,K) = 0.0
    U(I,J,K)   = 0.0
    V(I,J,K)   = 0.0
    W(I,J,K)   = 0.0
    P(I,J,K)   = 0.0
    T(I,J,K)   = 0.0
    IF(.NOT. PRESENT(YY)) CYCLE
    YY(I,J,K,6:LE) = 0.0
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE SetPhysics3D
!***********************************************************************
!**** �ۑ��ʗ������畨���ʂ��v�Z                                    ****
!**** �v�Z�Ώ� : �P��, �񎟌�, ���k��, k-e                          ****
!***********************************************************************
SUBROUTINE SetPhysics2DKEM( &
&            RG, GAMMA, &
&            IS, IE, JS, JE, LS, LE, &
&            QH, AJA, RHO, U, V, P, T, AK, EPS, &
&            YY &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)            :: RG, GAMMA
  INTEGER, INTENT(IN)            :: IS, IE, JS, JE
  INTEGER, INTENT(IN)            :: LS, LE
  REAL,    INTENT(IN)            :: QH (IS:IE, JS:JE, LS:LE)
  REAL,    INTENT(IN)            :: AJA(IS:IE, JS:JE)
  REAL,    INTENT(OUT)           :: RHO(IS:IE, JS:JE), &
  &                                 U  (IS:IE, JS:JE), &
  &                                 V  (IS:IE, JS:JE), &
  &                                 P  (IS:IE, JS:JE), &
  &                                 T  (IS:IE, JS:JE), &
  &                                 AK (IS:IE, JS:JE), &
  &                                 EPS(IS:IE, JS:JE)
  REAL,    INTENT(OUT), OPTIONAL :: YY (IS:IE, JS:JE, 7: LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 6) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �ۑ��ʗ������畨���ʂ��v�Z +++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I, J)
  DO J = JS, JE
  DO I = IS, IE
  IF(QH(I,J,1) .GT. 0.0) THEN
    RHO(I,J) = AJA(I,J) * QH(I,J,1)
    U(I,J)   = QH(I,J,2) / QH(I,J,1)
    V(I,J)   = QH(I,J,3) / QH(I,J,1)
    P(I,J)   = ( QH(I,J,4) - QH(I,J,5) &
    &          - 0.5 * (QH(I,J,2)**2 + QH(I,J,3)**2) / QH(I,J,1) &
    &        ) * (GAMMA - 1.0) * AJA(I,J)
    T(I,J)   = P(I,J) / (RHO(I,J) * RG)
    AK(I,J)  = QH(I,J,5) / QH(I,J,1)
    EPS(I,J) = QH(I,J,6) / QH(I,J,1)
    IF(.NOT. PRESENT(YY)) CYCLE
    YY(I,J,7:LE) = YY(I,J,7:LE) / QH(I,J,1)
  ELSE
    RHO(I,J) = 0.0
    U(I,J)   = 0.0
    V(I,J)   = 0.0
    P(I,J)   = 0.0
    T(I,J)   = 0.0
    AK(I,J)  = 0.0
    EPS(I,J) = 0.0
    IF(.NOT. PRESENT(YY)) CYCLE
    YY(I,J,7:LE) = 0.0
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE SetPhysics2DKEM
!***********************************************************************
!**** �ۑ��ʗ������畨���ʂ��v�Z                                    ****
!**** �v�Z�Ώ� : �P��, �O����, ���k��, k-e                          ****
!***********************************************************************
SUBROUTINE SetPhysics3DKEM( &
&            RG, GAMMA, &
&            IS, IE, JS, JE, KS, KE, LS, LE, &
&            QH, AJA, RHO, U, V, W, P, T, AK, EPS, &
&            YY &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)            :: RG, GAMMA
  INTEGER, INTENT(IN)            :: IS, IE, JS, JE, KS, KE
  INTEGER, INTENT(IN)            :: LS, LE
  REAL,    INTENT(IN)            :: QH (IS:IE, JS:JE, KS:KE, LS:LE)
  REAL,    INTENT(IN)            :: AJA(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(OUT)           :: RHO(IS:IE, JS:JE, KS:KE), &
  &                                 U  (IS:IE, JS:JE, KS:KE), &
  &                                 V  (IS:IE, JS:JE, KS:KE), &
  &                                 W  (IS:IE, JS:JE, KS:KE), &
  &                                 P  (IS:IE, JS:JE, KS:KE), &
  &                                 T  (IS:IE, JS:JE, KS:KE), &
  &                                 AK (IS:IE, JS:JE, KS:KE), &
  &                                 EPS(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(OUT), OPTIONAL :: YY (IS:IE, JS:JE, KS:KE, 8: LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 7) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �ۑ��ʗ������畨���ʂ��v�Z +++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I, J, K)
  DO K = KS, KE
  DO J = JS, JE
  DO I = IS, IE
  IF( QH(I,J,K,1) .GT. 0.0 ) THEN
    RHO(I,J,K) = AJA(I,J,K) * QH(I,J,K,1)
    U(I,J,K)   = QH(I,J,K,2) / QH(I,J,K,1)
    V(I,J,K)   = QH(I,J,K,3) / QH(I,J,K,1)
    W(I,J,K)   = QH(I,J,K,4) / QH(I,J,K,1)
    P(I,J,K)   = ( QH(I,J,K,5) &
    &            - QH(I,J,K,6) &
    &            - 0.5 * ( QH(I,J,K,2)**2 &
    &                    + QH(I,J,K,3)**2 &
    &                    + QH(I,J,K,4)**2 ) / QH(I,J,K,1) &
    &          ) * (GAMMA - 1.0) * AJA(I,J,K)
    T(I,J,K)   = P(I,J,K) / (RHO(I,J,K) * RG)
    AK(I,J,K)  = QH(I,J,K,6) / QH(I,J,K,1)
    EPS(I,J,K) = QH(I,J,K,7) / QH(I,J,K,1)
    IF(.NOT. PRESENT(YY)) CYCLE
    YY(I,J,K,8:LE) = QH(I,J,K,8:LE) / QH(I,J,K,1)
  ELSE
    RHO(I,J,K) = 0.0
    U(I,J,K)   = 0.0
    V(I,J,K)   = 0.0
    W(I,J,K)   = 0.0
    P(I,J,K)   = 0.0
    T(I,J,K)   = 0.0
    AK(I,J,K)  = 0.0
    EPS(I,J,K) = 0.0
    IF(.NOT. PRESENT(YY)) CYCLE
    YY(I,J,K,8:LE) = 0.0
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE SetPhysics3DKEM
!***********************************************************************
!**** �ۑ��ʗ������畨���ʂ��v�Z                                    ****
!**** �v�Z�Ώ� : �P��, �񎟌�, ���k��, RSM                          ****
!***********************************************************************
SUBROUTINE SetPhysics2DRSM( &
&            RG, GAMMA, &
&            IS, IE, JS, JE, LS, LE, &
&            QH, AJA, RHO, U, V, P, T, uu, vv, ww, uv, EPS, &
&            YY &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)            :: RG, GAMMA
  INTEGER, INTENT(IN)            :: IS, IE, JS, JE
  INTEGER, INTENT(IN)            :: LS, LE
  REAL,    INTENT(IN)            :: QH (IS:IE, JS:JE, LS:LE)
  REAL,    INTENT(IN)            :: AJA(IS:IE, JS:JE)
  REAL,    INTENT(OUT)           :: RHO(IS:IE, JS:JE), &
  &                                 U  (IS:IE, JS:JE), &
  &                                 V  (IS:IE, JS:JE), &
  &                                 P  (IS:IE, JS:JE), &
  &                                 T  (IS:IE, JS:JE), &
  &                                 uu (IS:IE, JS:JE), &
  &                                 vv (IS:IE, JS:JE), &
  &                                 ww (IS:IE, JS:JE), &
  &                                 uv (IS:IE, JS:JE), &
  &                                 EPS(IS:IE, JS:JE)
  REAL,    INTENT(OUT), OPTIONAL :: YY (IS:IE, JS:JE, 10: LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 9) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �ۑ��ʗ������畨���ʂ��v�Z +++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I, J)
  DO J = JS, JE
  DO I = IS, IE
  IF(QH(I,J,1) .GT. 0.0) THEN
    RHO(I,J) = AJA(I,J) * QH(I,J,1)
    U(I,J)   = QH(I,J,2) / QH(I,J,1)
    V(I,J)   = QH(I,J,3) / QH(I,J,1)
    P(I,J)   = ( QH(I,J,4) &
    &          - 0.5 * (QH(I,J,2)**2 + QH(I,J,3)**2) / QH(I,J,1) &
    &          - 0.5 * (QH(I,J,5) + QH(I,J,6) + QH(I,J,7)) &
    &        ) * (GAMMA - 1.0) * AJA(I,J)
    T(I,J)   = P(I,J) / (RHO(I,J) * RG)
    uu(I,J)  = QH(I,J,5) / QH(I,J,1)
    vv(I,J)  = QH(I,J,6) / QH(I,J,1)
    ww(I,J)  = QH(I,J,7) / QH(I,J,1)
    uv(I,J)  = QH(I,J,8) / QH(I,J,1)
    EPS(I,J) = QH(I,J,9) / QH(I,J,1)
    IF(.NOT. PRESENT(YY)) CYCLE
    YY(I,J,10:LE) = YY(I,J,10:LE) / QH(I,J,1)
  ELSE
    RHO(I,J) = 0.0
    U(I,J)   = 0.0
    V(I,J)   = 0.0
    P(I,J)   = 0.0
    T(I,J)   = 0.0
    uu(I,J)  = 0.0
    vv(I,J)  = 0.0
    ww(I,J)  = 0.0
    uv(I,J)  = 0.0
    EPS(I,J) = 0.0
    IF(.NOT. PRESENT(YY)) CYCLE
    YY(I,J,10:LE) = 0.0
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE SetPhysics2DRSM
!***********************************************************************
!**** �ۑ��ʗ������畨���ʂ��v�Z                                    ****
!**** �v�Z�Ώ� : �P��, �O����, ���k��, RSM                          ****
!***********************************************************************
SUBROUTINE SetPhysics3DRSM( &
&            RG, GAMMA, &
&            IS, IE, JS, JE, KS, KE, LS, LE, &
&            QH, AJA, RHO, U, V, W, P, T, uu, vv, ww, uv, vw, wu, EPS, &
&            YY &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)            :: RG, GAMMA
  INTEGER, INTENT(IN)            :: IS, IE, JS, JE, KS, KE
  INTEGER, INTENT(IN)            :: LS, LE
  REAL,    INTENT(IN)            :: QH (IS:IE, JS:JE, KS:KE, LS:LE)
  REAL,    INTENT(IN)            :: AJA(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(OUT)           :: RHO(IS:IE, JS:JE, KS:KE), &
  &                                 U  (IS:IE, JS:JE, KS:KE), &
  &                                 V  (IS:IE, JS:JE, KS:KE), &
  &                                 W  (IS:IE, JS:JE, KS:KE), &
  &                                 P  (IS:IE, JS:JE, KS:KE), &
  &                                 T  (IS:IE, JS:JE, KS:KE), &
  &                                 uu (IS:IE, JS:JE, KS:KE), &
  &                                 vv (IS:IE, JS:JE, KS:KE), &
  &                                 ww (IS:IE, JS:JE, KS:KE), &
  &                                 uv (IS:IE, JS:JE, KS:KE), &
  &                                 vw (IS:IE, JS:JE, KS:KE), &
  &                                 wu (IS:IE, JS:JE, KS:KE), &
  &                                 EPS(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(OUT), OPTIONAL :: YY (IS:IE, JS:JE, KS:KE, 13: LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 12) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �ۑ��ʗ������畨���ʂ��v�Z +++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I, J, K)
  DO K = KS, KE
  DO J = JS, JE
  DO I = IS, IE
  IF(QH(I,J,K,1) .GT. 0.0) THEN
    RHO(I,J,K) = AJA(I,J,K) * QH(I,J,K,1)
    U(I,J,K)   = QH(I,J,K,2) / QH(I,J,K,1)
    V(I,J,K)   = QH(I,J,K,3) / QH(I,J,K,1)
    W(I,J,K)   = QH(I,J,K,4) / QH(I,J,K,1)
    P(I,J,K)   = ( QH(I,J,K,5) &
    &            - 0.5 * ( QH(I,J,K,2)**2 &
    &                    + QH(I,J,K,3)**2 &
    &                    + QH(I,J,K,4)**2 ) / QH(I,J,K,1) &
    &            - 0.5 * (QH(I,J,K,6) + QH(I,J,K,7) + QH(I,J,K,8)) &
    &          ) * (GAMMA - 1.0) * AJA(I,J,K)
    T(I,J,K)   = P(I,J,K) / (RHO(I,J,K) * RG)
    uu(I,J,K)  = QH(I,J,K, 6) / QH(I,J,K,1)
    vv(I,J,K)  = QH(I,J,K, 7) / QH(I,J,K,1)
    ww(I,J,K)  = QH(I,J,K, 8) / QH(I,J,K,1)
    uv(I,J,K)  = QH(I,J,K, 9) / QH(I,J,K,1)
    vw(I,J,K)  = QH(I,J,K,10) / QH(I,J,K,1)
    wu(I,J,K)  = QH(I,J,K,11) / QH(I,J,K,1)
    EPS(I,J,K) = QH(I,J,K,12) / QH(I,J,K,1)
    IF(.NOT. PRESENT(YY)) CYCLE
    YY(I,J,K,13:LE) = QH(I,J,K,13:LE) / QH(I,J,K,1)
  ELSE
    RHO(I,J,K) = 0.0
    U(I,J,K)   = 0.0
    V(I,J,K)   = 0.0
    W(I,J,K)   = 0.0
    P(I,J,K)   = 0.0
    T(I,J,K)   = 0.0
    uu(I,J,K)  = 0.0
    vv(I,J,K)  = 0.0
    ww(I,J,K)  = 0.0
    uv(I,J,K)  = 0.0
    vw(I,J,K)  = 0.0
    wu(I,J,K)  = 0.0
    EPS(I,J,K) = 0.0
    IF(.NOT. PRESENT(YY)) CYCLE
    YY(I,J,K,13:LE) = 0.0
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE SetPhysics3DRSM
!***********************************************************************
!**** �S���W���v�Z                                                  ****
!**** �v�Z�Ώ� : �P��, �񎟌�, ���k��                               ****
!***********************************************************************
SUBROUTINE ViscosityCoefficient2D( &
&            AMUINF, TINF, S1, &
&            IS, IE, JS, JE, &
&            T, AMU &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: AMUINF, TINF, S1
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE
  REAL,    INTENT(IN)  :: T(IS:IE, JS:JE)
  REAL,    INTENT(OUT) :: AMU(IS:IE, JS:JE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I, J)
  DO J = JS, JE
  DO I = IS, IE
  IF(T(I,J) .GT. 0.0) THEN
    AMU(I,J) = AMUINF * (T(I,J) / TINF)**1.5 &
    &        * (TINF + S1) / (T(I,J) + S1)
  ELSE
    AMU(I,J) = 0.0
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE ViscosityCoefficient2D
!***********************************************************************
!**** �S���W���v�Z                                                  ****
!**** �v�Z�Ώ� : �P��, �O����, ���k��                               ****
!***********************************************************************
SUBROUTINE ViscosityCoefficient3D( &
&            AMUINF, TINF, S1, &
&            IS, IE, JS, JE, KS, KE, &
&            T, AMU &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: AMUINF, TINF, S1
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE, KS, KE
  REAL,    INTENT(IN)  :: T(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(OUT) :: AMU(IS:IE, JS:JE, KS:KE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I, J, K)
  DO K = KS, KE
  DO J = JS, JE
  DO I = IS, IE
  IF(T(I,J,K) .GT. 0.0) THEN
    AMU(I,J,K) = AMUINF * (T(I,J,K) / TINF)**1.5 &
    &          * (TINF + S1) / (T(I,J,K) + S1)
  ELSE
    AMU(I,J,K) = 0.0
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE ViscosityCoefficient3D
!***********************************************************************
!**** ���ԍ��݌v�Z - �Ǐ����ԍ��ݖ@(Local time step method)         ****
!**** �v�Z�Ώ� : �P��, �񎟌�, ���k��                               ****
!***********************************************************************
SUBROUTINE CalLocalDt2D( &
&            CN, RG, GAMMA, &
&            IS, IE, JS, JE, &
&            XIX, XIY, ETX, ETY, &
&            RHO, U, V, T, AMU, &
&            DTLOCL &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, PARAMETER :: ZERO = 1.0E-20
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: CN, RG, GAMMA
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE
  REAL,    INTENT(IN)  :: XIX(IS:IE, JS:JE), XIY(IS:IE, JS:JE), &
  &                       ETX(IS:IE, JS:JE), ETY(IS:IE, JS:JE)
  REAL,    INTENT(IN)  :: RHO(IS:IE, JS:JE)
  REAL,    INTENT(IN)  :: U(IS:IE, JS:JE)
  REAL,    INTENT(IN)  :: V(IS:IE, JS:JE)
  REAL,    INTENT(IN)  :: T(IS:IE, JS:JE)
  REAL,    INTENT(IN)  :: AMU(IS:IE, JS:JE)
  REAL,    INTENT(OUT) :: DTLOCL(IS:IE, JS:JE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: UU, VV, A, nueff
  REAL    :: ALCXI, ALCET
  REAL    :: ALDXI, ALDET
  REAL    :: ALXI, ALET
  ! �����J�n ***********************************************************
  ! �e�i�q�_�̋Ǐ����ԍ��݂��v�Z ---------------------------------------
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, UU, VV, A, nueff, ALCXI, ALCET, ALDXI, ALDET, ALXI, ALET &
!$OMP& )
  DO J = JS, JE
  DO I = IS, IE
  IF(RHO(I,J) .GT. 0.0) THEN
    ! �Η���
    UU = XIX(I,J) * U(I,J) + XIY(I,J) * V(I,J)
    VV = ETX(I,J) * U(I,J) + ETY(I,J) * V(I,J)
    A  = SQRT(GAMMA * RG * T(I,J))
    ALCXI = ABS(UU) + A * SQRT(XIX(I,J)**2 + XIY(I,J)**2)
    ALCET = ABS(VV) + A * SQRT(ETX(I,J)**2 + ETY(I,J)**2)
    ! �g�U��
    nueff = 2.0 * AMU(I,J) / RHO(I,J)
    ALDXI = nueff * (XIX(I,J)**2 + XIY(I,J)**2)
    ALDET = nueff * (ETX(I,J)**2 + ETY(I,J)**2)
    ! �S�Ă̍��ɂ��Ǐ����ԍ���
    ALXI = ALCXI + ALDXI
    ALET = ALCET + ALDET
    DTLOCL(I,J) = CN / MAX(ZERO, ALXI, ALET)
  ELSE
    DTLOCL(I,J) = 0.0
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE CalLocalDt2D
!***********************************************************************
!**** ���ԍ��݌v�Z - �Ǐ����ԍ��ݖ@(Local time step method)         ****
!**** �v�Z�Ώ� : �P��, �O����, ���k��                               ****
!***********************************************************************
SUBROUTINE CalLocalDt3D( &
&            CN, RG, GAMMA, &
&            IS, IE, JS, JE, KS, KE, &
&            XIX, XIY, XIZ, ETX, ETY, ETZ, ZEX, ZEY, ZEZ, &
&            RHO, U, V, W, T, AMU, &
&            DTLOCL &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, PARAMETER :: ZERO = 1.0E-20
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: CN, RG, GAMMA
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE, KS, KE
  REAL,    INTENT(IN)  :: XIX(IS:IE, JS:JE, KS:KE), &
  &                       XIY(IS:IE, JS:JE, KS:KE), &
  &                       XIZ(IS:IE, JS:JE, KS:KE), &
  &                       ETX(IS:IE, JS:JE, KS:KE), &
  &                       ETY(IS:IE, JS:JE, KS:KE), &
  &                       ETZ(IS:IE, JS:JE, KS:KE), &
  &                       ZEX(IS:IE, JS:JE, KS:KE), &
  &                       ZEY(IS:IE, JS:JE, KS:KE), &
  &                       ZEZ(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)  :: RHO(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)  :: U(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)  :: V(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)  :: W(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)  :: T(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)  :: AMU(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(OUT) :: DTLOCL(IS:IE, JS:JE, KS:KE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: UU, VV, WW, A, nueff
  REAL    :: ALCXI, ALCET, ALCZE
  REAL    :: ALDXI, ALDET, ALDZE
  REAL    :: ALXI, ALET, ALZE
  ! �����J�n ***********************************************************
  ! �e�i�q�_�̋Ǐ����ԍ��݂��v�Z ---------------------------------------
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, UU, VV, WW, A, nueff, &
!$OMP& ALCXI, ALCET, ALCZE, ALDXI, ALDET, ALDZE, ALXI, ALET, ALZE &
!$OMP& )
  DO K = KS, KE
  DO J = JS, JE
  DO I = IS, IE
  IF(RHO(I,J,K) .GT. 0.0) THEN
    ! �Η���
    UU = XIX(I,J,K)*U(I,J,K)+XIY(I,J,K)*V(I,J,K)+XIZ(I,J,K)*W(I,J,K)
    VV = ETX(I,J,K)*U(I,J,K)+ETY(I,J,K)*V(I,J,K)+ETZ(I,J,K)*W(I,J,K)
    WW = ZEX(I,J,K)*U(I,J,K)+ZEY(I,J,K)*V(I,J,K)+ZEZ(I,J,K)*W(I,J,K)
    A  = SQRT(GAMMA * RG * T(I,J,K))
    ALCXI = ABS(UU) &
    &     + A * SQRT(XIX(I,J,K)**2 + XIY(I,J,K)**2 + XIZ(I,J,K)**2)
    ALCET = ABS(VV) &
    &     + A * SQRT(ETX(I,J,K)**2 + ETY(I,J,K)**2 + ETZ(I,J,K)**2)
    ALCZE = ABS(WW) &
    &     + A * SQRT(ZEX(I,J,K)**2 + ZEY(I,J,K)**2 + ZEZ(I,J,K)**2)
    ! �g�U��
    nueff = 2.0 * AMU(I,J,K) / RHO(I,J,K)
    ALDXI = nueff * (XIX(I,J,K)**2 + XIY(I,J,K)**2 + XIZ(I,J,K)**2)
    ALDET = nueff * (ETX(I,J,K)**2 + ETY(I,J,K)**2 + ETZ(I,J,K)**2)
    ALDZE = nueff * (ZEX(I,J,K)**2 + ZEY(I,J,K)**2 + ZEZ(I,J,K)**2)
    ! �S�Ă̍��ɂ��Ǐ����ԍ���
    ALXI = ALCXI + ALDXI
    ALET = ALCET + ALDET
    ALZE = ALCZE + ALDZE
    DTLOCL(I,J,K) = CN / MAX(ZERO, ALXI, ALET, ALZE)
   ELSE
    DTLOCL(I,J,K) = 0.0
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE CalLocalDt3D
!***********************************************************************
!**** ���ԍ��݌v�Z                                                  ****
!**** �v�Z�Ώ� : �P��, �񎟌�, ���k��                               ****
!***********************************************************************
SUBROUTINE CalDt2D( &
&            IS, IE, JS, JE, DTLOCL, DTMIN, DTMAX, DT &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE
  REAL,    INTENT(IN)  :: DTLOCL(IS:IE, JS:JE)
  REAL,    INTENT(IN)  :: DTMIN, DTMAX
  REAL,    INTENT(OUT) :: DT
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  ! �����J�n ***********************************************************
  DT = DTMAX
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF(DTLOCL(I,J) .GT. 0.0) THEN
    DT = MIN(DT, DTLOCL(I,J))
  ENDIF
  ENDDO
  ENDDO
  DT = MAX(DT, DTMIN)
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE CalDt2D
!***********************************************************************
!**** ���ԍ��݌v�Z                                                  ****
!**** �v�Z�Ώ� : �P��, �O����, ���k��                               ****
!***********************************************************************
SUBROUTINE CalDt3D( &
&            IS, IE, JS, JE, KS, KE, DTLOCL, DTMIN, DTMAX, DT &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE, KS, KE
  REAL,    INTENT(IN)  :: DTLOCL(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)  :: DTMIN, DTMAX
  REAL,    INTENT(OUT) :: DT
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  ! �����J�n ***********************************************************
  DT = DTMAX
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF(DTLOCL(I,J,K) .GT. 0.0) THEN
    DT = MIN(DT, DTLOCL(I,J,K))
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  DT = MAX(DT, DTMIN)
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE CalDt3D
!***********************************************************************
!**** Runge-Kutta�@(Jameson-Baker, 1983) : NMAX�i�K, N�i��          ****
!**** �v�Z�Ώ� : �񎟌�                                             ****
!***********************************************************************
SUBROUTINE RungeKutta2D( &
&            IS, IE, JS, JE, LS, LE, &
&            N, NMAX, DTLOCL, &
&            DQH, QH0, QH1 &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE
  INTEGER, INTENT(IN)  :: LS, LE
  INTEGER, INTENT(IN)  :: N, NMAX
  REAL,    INTENT(IN)  :: DTLOCL(IS: IE, JS: JE)
  REAL,    INTENT(IN)  :: DQH(IS: IE, JS: JE, LS: LE)
  REAL,    INTENT(IN)  :: QH0(IS: IE, JS: JE, LS: LE)
  REAL,    INTENT(OUT) :: QH1(IS: IE, JS: JE, LS: LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, L
  REAL    :: A
  ! �����J�n ***********************************************************
  A = 1.0 / REAL(NMAX + 1 - N)
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE(I, J, L)
  DO L = LS, LE
  !$OMP DO
  DO J = JS, JE
  DO I = IS, IE
  IF(QH0(I,J,1) .GT. 0.0) THEN
    QH1(I,J,L) = QH0(I,J,L) + A * DTLOCL(I,J) * DQH(I,J,L)
  ENDIF
  ENDDO
  ENDDO
  !$OMP END DO
  ENDDO
  !$OMP END PARALLEL
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE RungeKutta2D
!***********************************************************************
!**** Runge-Kutta�@(Jameson-Baker, 1983) : NMAX�i�K, N�i��          ****
!**** �v�Z�Ώ� : �O����                                             ****
!***********************************************************************
SUBROUTINE RungeKutta3D( &
&            IS, IE, JS, JE, KS, KE, LS, LE, &
&            N, NMAX, DTLOCL, &
&            DQH, QH0, QH1 &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE, KS, KE
  INTEGER, INTENT(IN)  :: LS, LE
  INTEGER, INTENT(IN)  :: N, NMAX
  REAL,    INTENT(IN)  :: DTLOCL(IS: IE, JS: JE, KS: KE)
  REAL,    INTENT(IN)  :: DQH(IS: IE, JS: JE, KS: KE, LS: LE)
  REAL,    INTENT(IN)  :: QH0(IS: IE, JS: JE, KS: KE, LS: LE)
  REAL,    INTENT(OUT) :: QH1(IS: IE, JS: JE, KS: KE, LS: LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K, L
  REAL    :: A
  ! �����J�n ***********************************************************
  A = 1.0 / REAL(NMAX + 1 - N)
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE(I, J, K, L)
  DO L = LS, LE
  !$OMP DO
  DO K = KS, KE
  DO J = JS, JE
  DO I = IS, IE
  IF(QH0(I,J,K,1) .GT. 0.0) THEN
    QH1(I,J,K,L) = QH0(I,J,K,L) + A * DTLOCL(I,J,K) * DQH(I,J,K,L)
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END DO
  ENDDO
  !$OMP END PARALLEL
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE RungeKutta3D
!***********************************************************************
!**** �A��@                                                        ****
!**** �v�Z�Ώ� : �P��, �񎟌�, ���k��                               ****
!**** �v�Z�X�L�[�� : �f���^�`��LU-ADI�@                             ****
!***********************************************************************
SUBROUTINE LUADI2D( &
&            lambda, &
&            RG, GAMMA, &
&            IS, IE, JS, JE, LS, LE, &
&            XIX, XIY, ETX, ETY, AJA, &
&            RHO, U, V, T, AMU, &
&            DTLOCL, &
&            RHS0, RHS1, QH0, QH1 &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)    :: lambda
  REAL,    INTENT(IN)    :: RG, GAMMA
  INTEGER, INTENT(IN)    :: IS, IE, JS, JE
  INTEGER, INTENT(IN)    :: LS, LE
  REAL,    INTENT(IN)    :: XIX   (IS: IE, JS: JE), &
  &                         XIY   (IS: IE, JS: JE), &
  &                         ETX   (IS: IE, JS: JE), &
  &                         ETY   (IS: IE, JS: JE), &
  &                         AJA   (IS: IE, JS: JE)
  REAL,    INTENT(IN)    :: RHO   (IS: IE, JS: JE)
  REAL,    INTENT(IN)    :: U     (IS: IE, JS: JE), &
  &                         V     (IS: IE, JS: JE)
  REAL,    INTENT(IN)    :: T     (IS: IE, JS: JE)
  REAL,    INTENT(IN)    :: AMU   (IS: IE, JS: JE)
  REAL,    INTENT(IN)    :: DTLOCL(IS: IE, JS: JE)
  REAL,    INTENT(IN)    :: RHS0  (IS: IE, JS: JE, LS: LE)
  REAL,    INTENT(IN)    :: RHS1  (IS: IE, JS: JE, LS: LE)
  REAL,    INTENT(IN)    :: QH0   (IS: IE, JS: JE, LS: LE)
  REAL,    INTENT(INOUT) :: QH1   (IS: IE, JS: JE, LS: LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER              :: I, J, L
  REAL                 :: UU, VV, C
  REAL                 :: THI, PHI, BETA, TIL, AKXT, AKYT, THIT
  REAL                 :: CT, VIS
  REAL,    ALLOCATABLE :: DQH(:, :, :)
  REAL,    ALLOCATABLE :: D1(:, :), D2(:, :)
  REAL,    ALLOCATABLE :: EE(:, :), EA(:, :), EP(:, :), EM(:, :)
  REAL,    ALLOCATABLE :: RR(:, :, :), RI(:, :, :)
  ! �����J�n ***********************************************************
  ALLOCATE(DQH(IS: IE, JS: JE, LS: LE))
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, L, UU, VV, C, &
!$OMP& THI, PHI, BETA, TIL, AKXT, AKYT, THIT, CT, VIS, &
!$OMP& D1, D2, EE, EA, EP, EM, RR, RI &
!$OMP& )
  ! �����ݒ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  DO L = LS, LE
  !$OMP DO
  DO J = JS, JE
  DO I = IS, IE
  IF(QH0(I,J,1) .GT. 0.0) THEN
    DQH(I,J,L) = QH0(I,J,L) - QH1(I,J,L) &
    &          + DTLOCL(I,J) * ( &
    &              (1.0 - lambda) * RHS0(I,J,L) &
    &            + lambda         * RHS1(I,J,L) &
    &          )
  ENDIF
  ENDDO
  ENDDO
  !$OMP END DO
  ENDDO
  ! XI���� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ! �������m�� =========================================================
  ALLOCATE(D1(IS: IE, LS: LE))
  ALLOCATE(D2(IS: IE, LS: LE))
  ALLOCATE(EE(IS: IE, LS: LE))
  ALLOCATE(EA(IS: IE, LS: LE))
  ALLOCATE(EP(IS: IE, LS: LE))
  ALLOCATE(EM(IS: IE, LS: LE))
  ALLOCATE(RR(IS: IE, LS:  4, LS:  4))
  ALLOCATE(RI(IS: IE, LS:  4, LS:  4))
  ! �s�񔽓]���� =======================================================
  !$OMP DO
  DO J = JS + 1, JE - 1
    ! ��� -------------------------------------------------------------
    DO L = LS, LE
    DO I = IS, IE
    IF(QH0(I,J,1) .GT. 0.0) THEN
      D1(I,L) = DQH(I,J,L)
    ENDIF
    ENDDO
    ENDDO
    ! �Ίp�� -----------------------------------------------------------
    DO I = IS, IE
    IF(QH0(I,J,1) .GT. 0.0) THEN
      ! ����
      UU   = U(I,J)
      VV   = V(I,J)
      C    = SQRT(GAMMA * RG * T(I,J))
      THI  = XIX(I,J) * UU + XIY(I,J) * VV
      PHI  = 0.5 * (GAMMA - 1.0) * (UU**2 + VV**2)
      BETA = 1.0 / (2.0 * C**2)
      TIL  = SQRT(XIX(I,J)**2 + XIY(I,J)**2)
      AKXT = XIX(I,J) / TIL
      AKYT = XIY(I,J) / TIL
      THIT = AKXT * UU + AKYT * VV
      CT   = C * TIL
      VIS  = 2.0 * AMU(I,J) / RHO(I,J) * TIL**2
      ! RR
      RR(I,1,1) = 1.0
      RR(I,1,2) = 0.0
      RR(I,1,3) = 1.0
      RR(I,1,4) = 1.0
      RR(I,2,1) = UU
      RR(I,2,2) = AKYT
      RR(I,2,3) = UU + AKXT * C
      RR(I,2,4) = UU - AKXT * C
      RR(I,3,1) = VV
      RR(I,3,2) =-AKXT
      RR(I,3,3) = VV + AKYT * C
      RR(I,3,4) = VV - AKYT * C
      RR(I,4,1) = PHI / (GAMMA - 1.0)
      RR(I,4,2) = AKYT * UU - AKXT * VV
      RR(I,4,3) = (PHI + C**2) / (GAMMA - 1.0) + C * THIT
      RR(I,4,4) = (PHI + C**2) / (GAMMA - 1.0) - C * THIT
      ! RI
      RI(I,1,1) = 1.0 - PHI / C**2
      RI(I,1,2) = (GAMMA - 1.0) * UU / C**2
      RI(I,1,3) = (GAMMA - 1.0) * VV / C**2
      RI(I,1,4) =-(GAMMA - 1.0) / C**2
      RI(I,2,1) =-AKYT * UU + AKXT * VV
      RI(I,2,2) = AKYT
      RI(I,2,3) =-AKXT
      RI(I,2,4) = 0.0
      RI(I,3,1) = BETA * (PHI - C * THIT)
      RI(I,3,2) = BETA * (AKXT * C - (GAMMA - 1.0) * UU)
      RI(I,3,3) = BETA * (AKYT * C - (GAMMA - 1.0) * VV)
      RI(I,3,4) = BETA * (GAMMA - 1.0)
      RI(I,4,1) = BETA * (PHI + C * THIT)
      RI(I,4,2) =-BETA * (AKXT * C + (GAMMA - 1.0) * UU)
      RI(I,4,3) =-BETA * (AKYT * C + (GAMMA - 1.0) * VV)
      RI(I,4,4) = BETA * (GAMMA - 1.0)
      ! EE
      EE(I,1) = THI
      EE(I,2) = THI
      EE(I,3) = THI + CT
      EE(I,4) = THI - CT
      DO L = 5, LE
        EE(I,L) = THI
      ENDDO
      ! EA
      DO L = LS, LE
        EA(I,L) = ABS(EE(I,L)) + VIS ! + DEL * CT
      ENDDO
      ! EP
      DO L = LS, LE
        EP(I,L) = 0.5 * (EE(I,L) + EA(I,L))
      ENDDO
      ! EM
      DO L = LS, LE
        EM(I,L) = 0.5 * (EE(I,L) - EA(I,L))
      ENDDO
    ENDIF
    ENDDO
    ! RR���] -----------------------------------------------------------
    DO I = IS, IE
    IF(QH0(I,J,1) .GT. 0.0) THEN
      DO L = LS, 4
        D2(I,L) = RI(I,L,1) * D1(I,1) + RI(I,L,2) * D1(I,2) &
        &       + RI(I,L,3) * D1(I,3) + RI(I,L,4) * D1(I,4)
      ENDDO
      DO L = 5, LE
        D2(I,L) = D1(I,L)
      ENDDO
    ENDIF
    ENDDO
    ! �O�i�X�C�[�v -----------------------------------------------------
    D1(:,:) = 0.0
    DO I = IS + 1, IE - 1, + 1
    IF(QH0(I-1,J,1) .GT. 0.0 .AND. QH0(I,J,1) .GT. 0.0) THEN
      DO L = LS, LE
        D1(I,L) = ( D2(I,L) + DTLOCL(I,J) * lambda &
        &         * EP(I-1,L) * D1(I-1,L) ) &
        &       / (1.0 + DTLOCL(I,J) * lambda * EA(I,L))
      ENDDO
    ENDIF
    ENDDO
    ! �X�J���[���Z -----------------------------------------------------
    DO I = IS, IE
    IF(QH0(I,J,1) .GT. 0.0) THEN
      DO L = LS, LE
        D1(I,L) = D1(I,L) * (1.0 + DTLOCL(I,J) * lambda * EA(I,L))
      ENDDO
    ENDIF
    ENDDO
    ! ��ރX�C�[�v -----------------------------------------------------
    D2(:,:) = 0.0
    DO I = IE - 1, IS + 1, - 1
    IF(QH0(I,J,1) .GT. 0.0 .AND. QH0(I+1,J,1) .GT. 0.0) THEN
      DO L = LS, LE
        D2(I,L) = ( D1(I,L) - DTLOCL(I,J) * lambda &
        &         * EM(I+1,L) * D2(I+1,L) ) &
        &       / (1.0 + DTLOCL(I,J) * lambda * EA(I,L))
      ENDDO
    ENDIF
    ENDDO
    ! RI���] -----------------------------------------------------------
    DO I = IS, IE
    IF(QH0(I,J,1) .GT. 0.0) THEN
      DO L = LS, 4
        D1(I,L) = RR(I,L,1) * D2(I,1) + RR(I,L,2) * D2(I,2) &
        &       + RR(I,L,3) * D2(I,3) + RR(I,L,4) * D2(I,4)
      ENDDO
      DO L = 5, LE
        D1(I,L) = D2(I,L)
      ENDDO
    ENDIF
    ENDDO
    ! ��� -------------------------------------------------------------
    DO L = LS, LE
    DO I = IS, IE
    IF(QH0(I,J,1) .GT. 0.0) THEN
      DQH(I,J,L) = D1(I,L)
    ENDIF
    ENDDO
    ENDDO
  ENDDO
  !$OMP END DO
  ! ��������� =========================================================
  DEALLOCATE(D1, D2, EE, EA, EP, EM, RR, RI)
  ! ET���� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ! �������m�� =========================================================
  ALLOCATE(D1(JS: JE, LS: LE))
  ALLOCATE(D2(JS: JE, LS: LE))
  ALLOCATE(EE(JS: JE, LS: LE))
  ALLOCATE(EA(JS: JE, LS: LE))
  ALLOCATE(EP(JS: JE, LS: LE))
  ALLOCATE(EM(JS: JE, LS: LE))
  ALLOCATE(RR(JS: JE, LS:  4, LS:  4))
  ALLOCATE(RI(JS: JE, LS:  4, LS:  4))
  ! �s�񔽓]���� =======================================================
  !$OMP DO
  DO I = IS + 1, IE - 1
    ! ��� -------------------------------------------------------------
    DO L = LS, LE
    DO J = JS, JE
    IF(QH0(I,J,1) .GT. 0.0) THEN
      D1(J,L) = DQH(I,J,L)
    ENDIF
    ENDDO
    ENDDO
    ! �Ίp�� -----------------------------------------------------------
    DO J = JS, JE
    IF(QH0(I,J,1) .GT. 0.0) THEN
      ! ����
      UU   = U(I,J)
      VV   = V(I,J)
      C    = SQRT(GAMMA * RG * T(I,J))
      THI  = ETX(I,J) * UU + ETY(I,J) * VV
      PHI  = 0.5 * (GAMMA - 1.0) * (UU**2 + VV**2)
      BETA = 1.0 / (2.0 * C**2)
      TIL  = SQRT(ETX(I,J)**2 + ETY(I,J)**2)
      AKXT = ETX(I,J) / TIL
      AKYT = ETY(I,J) / TIL
      THIT = AKXT * UU + AKYT * VV
      CT   = C * TIL
      VIS  = 2.0 * AMU(I,J) / RHO(I,J) * TIL**2
      ! RR
      RR(J,1,1) = 1.0
      RR(J,1,2) = 0.0
      RR(J,1,3) = 1.0
      RR(J,1,4) = 1.0
      RR(J,2,1) = UU
      RR(J,2,2) = AKYT
      RR(J,2,3) = UU + AKXT * C
      RR(J,2,4) = UU - AKXT * C
      RR(J,3,1) = VV
      RR(J,3,2) =-AKXT
      RR(J,3,3) = VV + AKYT * C
      RR(J,3,4) = VV - AKYT * C
      RR(J,4,1) = PHI / (GAMMA - 1.0)
      RR(J,4,2) = AKYT * UU - AKXT * VV
      RR(J,4,3) = (PHI + C**2) / (GAMMA - 1.0) + C * THIT
      RR(J,4,4) = (PHI + C**2) / (GAMMA - 1.0) - C * THIT
      ! RI
      RI(J,1,1) = 1.0 - PHI / C**2
      RI(J,1,2) = (GAMMA - 1.0) * UU / C**2
      RI(J,1,3) = (GAMMA - 1.0) * VV / C**2
      RI(J,1,4) =-(GAMMA - 1.0) / C**2
      RI(J,2,1) =-AKYT * UU + AKXT * VV
      RI(J,2,2) = AKYT
      RI(J,2,3) =-AKXT
      RI(J,2,4) = 0.0
      RI(J,3,1) = BETA * (PHI - C * THIT)
      RI(J,3,2) = BETA * (AKXT * C - (GAMMA - 1.0) * UU)
      RI(J,3,3) = BETA * (AKYT * C - (GAMMA - 1.0) * VV)
      RI(J,3,4) = BETA * (GAMMA - 1.0)
      RI(J,4,1) = BETA * (PHI + C * THIT)
      RI(J,4,2) =-BETA * (AKXT * C + (GAMMA - 1.0) * UU)
      RI(J,4,3) =-BETA * (AKYT * C + (GAMMA - 1.0) * VV)
      RI(J,4,4) = BETA * (GAMMA - 1.0)
      ! EE
      EE(J,1) = THI
      EE(J,2) = THI
      EE(J,3) = THI + CT
      EE(J,4) = THI - CT
      DO L = 5, LE
        EE(J,L) = THI
      ENDDO
      ! EA
      DO L = LS, LE
        EA(J,L) = ABS(EE(J,L)) + VIS ! + DEL * CT
      ENDDO
      ! EP
      DO L = LS, LE
        EP(J,L) = 0.5 * (EE(J,L) + EA(J,L))
      ENDDO
      ! EM
      DO L = LS, LE
        EM(J,L) = 0.5 * (EE(J,L) - EA(J,L))
      ENDDO
    ENDIF
    ENDDO
    ! RR���] -----------------------------------------------------------
    DO J = JS, JE
    IF(QH0(I,J,1) .GT. 0.0) THEN
      DO L = LS, 4
        D2(J,L) = RI(J,L,1) * D1(J,1) + RI(J,L,2) * D1(J,2) &
        &       + RI(J,L,3) * D1(J,3) + RI(J,L,4) * D1(J,4)
      ENDDO
      DO L = 5, LE
        D2(J,L) = D1(J,L)
      ENDDO
    ENDIF
    ENDDO
    ! �O�i�X�C�[�v -----------------------------------------------------
    D1(:,:) = 0.0
    DO J = JS + 1, JE - 1, + 1
    IF(QH0(I,J-1,1) .GT. 0.0 .AND. QH0(I,J,1) .GT. 0.0) THEN
      DO L = LS, LE
        D1(J,L) = ( D2(J,L) + DTLOCL(I,J) * lambda &
        &         * EP(J-1,L) * D1(J-1,L) ) &
        &       / (1.0 + DTLOCL(I,J) * lambda * EA(J,L))
      ENDDO
    ENDIF
    ENDDO
    ! �X�J���[���Z -----------------------------------------------------
    DO J = JS, JE
    IF(QH0(I,J,1) .GT. 0.0) THEN
      DO L = LS, LE
        D1(J,L) = D1(J,L) * (1.0 + DTLOCL(I,J) * lambda * EA(J,L))
      ENDDO
    ENDIF
    ENDDO
    ! ��ރX�C�[�v -----------------------------------------------------
    D2(:,:) = 0.0
    DO J = JE - 1, JS + 1, - 1
    IF(QH0(I,J,1) .GT. 0.0 .AND. QH0(I,J+1,1) .GT. 0.0) THEN
      DO L = LS, LE
        D2(J,L) = ( D1(J,L) - DTLOCL(I,J) * lambda &
        &         * EM(J+1,L) * D2(J+1,L) ) &
        &       / (1.0 + DTLOCL(I,J) * lambda * EA(J,L))
      ENDDO
    ENDIF
    ENDDO
    ! RI���] -----------------------------------------------------------
    DO J = JS, JE
    IF(QH0(I,J,1) .GT. 0.0) THEN
      DO L = LS, 4
        D1(J,L) = RR(J,L,1) * D2(J,1) + RR(J,L,2) * D2(J,2) &
        &       + RR(J,L,3) * D2(J,3) + RR(J,L,4) * D2(J,4)
      ENDDO
      DO L = 5, LE
        D1(J,L) = D2(J,L)
      ENDDO
    ENDIF
    ENDDO
    ! ��� -------------------------------------------------------------
    DO L = LS, LE
    DO J = JS, JE
    IF(QH0(I,J,1) .GT. 0.0) THEN
      DQH(I,J,L) = D1(J,L)
    ENDIF
    ENDDO
    ENDDO
  ENDDO
  !$OMP END DO
  ! ��������� =========================================================
  DEALLOCATE(D1, D2, EE, EA, EP, EM, RR, RI)
  ! �f���^�`�����痬���֐��̎��Ԃ�i�߂� +++++++++++++++++++++++++++++++
  DO L = LS, LE
  !$OMP DO
  DO J = JS, JE
  DO I = IS, IE
  IF(QH0(I,J,1) .GT. 0.0) THEN
    QH1(I,J,L) = QH1(I,J,L) + DQH(I,J,L)
  ENDIF
  ENDDO
  ENDDO
  !$OMP END DO
  ENDDO
  ! ��������� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP END PARALLEL
  DEALLOCATE(DQH)
  ! �����I�� ***********************************************************
  RETURN
! ��`�I�� *************************************************************
END SUBROUTINE LUADI2D
!***********************************************************************
!**** �A��@                                                        ****
!**** �v�Z�Ώ� : �P��, �O����, ���k��                               ****
!**** �v�Z�X�L�[�� : �f���^�`��LU-ADI�@                             ****
!***********************************************************************
SUBROUTINE LUADI3D( &
&            lambda, &
&            RG, GAMMA, &
&            IS, IE, JS, JE, KS, KE, LS, LE, &
&            XIX, XIY, XIZ, ETX, ETY, ETZ, ZEX, ZEY, ZEZ, AJA, &
&            RHO, U, V, W, T, AMU, &
&            DTLOCL, &
&            RHS0, RHS1, QH0, QH1 &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)    :: lambda
  REAL,    INTENT(IN)    :: RG, GAMMA
  INTEGER, INTENT(IN)    :: IS, IE, JS, JE, KS, KE
  INTEGER, INTENT(IN)    :: LS, LE
  REAL,    INTENT(IN)    :: XIX   (IS: IE, JS: JE, KS: KE), &
  &                         XIY   (IS: IE, JS: JE, KS: KE), &
  &                         XIZ   (IS: IE, JS: JE, KS: KE), &
  &                         ETX   (IS: IE, JS: JE, KS: KE), &
  &                         ETY   (IS: IE, JS: JE, KS: KE), &
  &                         ETZ   (IS: IE, JS: JE, KS: KE), &
  &                         ZEX   (IS: IE, JS: JE, KS: KE), &
  &                         ZEY   (IS: IE, JS: JE, KS: KE), &
  &                         ZEZ   (IS: IE, JS: JE, KS: KE), &
  &                         AJA   (IS: IE, JS: JE, KS: KE)
  REAL,    INTENT(IN)    :: RHO   (IS: IE, JS: JE, KS: KE)
  REAL,    INTENT(IN)    :: U     (IS: IE, JS: JE, KS: KE), &
  &                         V     (IS: IE, JS: JE, KS: KE), &
  &                         W     (IS: IE, JS: JE, KS: KE)
  REAL,    INTENT(IN)    :: T     (IS: IE, JS: JE, KS: KE)
  REAL,    INTENT(IN)    :: AMU   (IS: IE, JS: JE, KS: KE)
  REAL,    INTENT(IN)    :: DTLOCL(IS: IE, JS: JE, KS: KE)
  REAL,    INTENT(IN)    :: RHS0  (IS: IE, JS: JE, KS: KE, LS: LE)
  REAL,    INTENT(IN)    :: RHS1  (IS: IE, JS: JE, KS: KE, LS: LE)
  REAL,    INTENT(IN)    :: QH0   (IS: IE, JS: JE, KS: KE, LS: LE)
  REAL,    INTENT(INOUT) :: QH1   (IS: IE, JS: JE, KS: KE, LS: LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER              :: I, J, K, L
  REAL                 :: UU, VV, WW, C
  REAL                 :: THI, PHI, BETA, TIL, AKXT, AKYT, AKZT, THIT
  REAL                 :: CT, VIS
  REAL,    ALLOCATABLE :: DQH(:, :, :, :)
  REAL,    ALLOCATABLE :: D1(:, :), D2(:, :)
  REAL,    ALLOCATABLE :: EE(:, :), EA(:, :), EP(:, :), EM(:, :)
  REAL,    ALLOCATABLE :: RR(:, :, :), RI(:, :, :)
  ! �����J�n ***********************************************************
  ALLOCATE(DQH(IS: IE, JS: JE, KS: KE, LS: LE))
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, L, UU, VV, WW, C, &
!$OMP& THI, PHI, BETA, TIL, AKXT, AKYT, AKZT, THIT, CT, VIS, &
!$OMP& D1, D2, EE, EA, EP, EM, RR, RI &
!$OMP& )
  ! �����ݒ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  DO L = LS, LE
  !$OMP DO
  DO K = KS, KE
  DO J = JS, JE
  DO I = IS, IE
  IF(QH0(I,J,K,1) .GT. 0.0) THEN
    DQH(I,J,K,L) = QH0(I,J,K,L) - QH1(I,J,K,L) &
    &            + DTLOCL(I,J,K) * ( &
    &                (1.0 - lambda) * RHS0(I,J,K,L) &
    &              + lambda         * RHS1(I,J,K,L) &
    &            )
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END DO
  ENDDO
  ! XI���� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ! �������m�� =========================================================
  ALLOCATE(D1(IS: IE, LS: LE))
  ALLOCATE(D2(IS: IE, LS: LE))
  ALLOCATE(EE(IS: IE, LS: LE))
  ALLOCATE(EA(IS: IE, LS: LE))
  ALLOCATE(EP(IS: IE, LS: LE))
  ALLOCATE(EM(IS: IE, LS: LE))
  ALLOCATE(RR(IS: IE, LS:  5, LS:  5))
  ALLOCATE(RI(IS: IE, LS:  5, LS:  5))
  ! �s�񔽓]���� =======================================================
  !$OMP DO
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
    ! ��� -------------------------------------------------------------
    DO L = LS, LE
    DO I = IS, IE
    IF(QH0(I,J,K,1) .GT. 0.0) THEN
      D1(I,L) = DQH(I,J,K,L)
    ENDIF
    ENDDO
    ENDDO
    ! �Ίp�� -----------------------------------------------------------
    DO I = IS, IE
    IF(QH0(I,J,K,1) .GT. 0.0) THEN
      ! ����
      UU   = U(I,J,K)
      VV   = V(I,J,K)
      WW   = W(I,J,K)
      C    = SQRT(GAMMA * RG * T(I,J,K))
      THI  = XIX(I,J,K) * UU + XIY(I,J,K) * VV + XIZ(I,J,K) * WW
      PHI  = 0.5 * (GAMMA - 1.0) * (UU**2 + VV**2 + WW**2)
      BETA = 1.0 / (2.0 * C**2)
      TIL  = SQRT(XIX(I,J,K)**2 + XIY(I,J,K)**2 + XIZ(I,J,K)**2)
      AKXT = XIX(I,J,K) / TIL
      AKYT = XIY(I,J,K) / TIL
      AKZT = XIZ(I,J,K) / TIL
      THIT = AKXT * UU + AKYT * VV + AKZT * WW
      CT   = C * TIL
      VIS  = 2.0 * AMU(I,J,K) / RHO(I,J,K) * TIL**2
      ! RR
      RR(I,1,1) = AKXT
      RR(I,2,1) = AKXT * UU
      RR(I,3,1) = AKXT * VV + AKZT
      RR(I,4,1) = AKXT * WW - AKYT
      RR(I,5,1) = AKXT * PHI / (GAMMA - 1.0) + AKZT * VV - AKYT * WW
      RR(I,1,2) = AKYT
      RR(I,2,2) = AKYT * UU - AKZT
      RR(I,3,2) = AKYT * VV
      RR(I,4,2) = AKYT * WW + AKXT
      RR(I,5,2) = AKYT * PHI / (GAMMA - 1.0) + AKXT * WW - AKZT * UU
      RR(I,1,3) = AKZT
      RR(I,2,3) = AKZT * UU + AKYT
      RR(I,3,3) = AKZT * VV - AKXT
      RR(I,4,3) = AKZT * WW
      RR(I,5,3) = AKZT * PHI / (GAMMA - 1.0) + AKYT * UU - AKXT * VV
      RR(I,1,4) = 1.0
      RR(I,2,4) = UU + AKXT * C
      RR(I,3,4) = VV + AKYT * C
      RR(I,4,4) = WW + AKZT * C
      RR(I,5,4) = (PHI + C**2) / (GAMMA - 1.0) + C * THIT
      RR(I,1,5) = 1.0
      RR(I,2,5) = UU - AKXT * C
      RR(I,3,5) = VV - AKYT * C
      RR(I,4,5) = WW - AKZT * C
      RR(I,5,5) = (PHI + C**2) / (GAMMA - 1.0) - C * THIT
      ! RI
      RI(I,1,1) = AKXT - AKXT * PHI / C**2 + AKYT * WW - AKZT * VV
      RI(I,2,1) = AKYT - AKYT * PHI / C**2 + AKZT * UU - AKXT * WW
      RI(I,3,1) = AKZT - AKZT * PHI / C**2 + AKXT * VV - AKYT * UU
      RI(I,4,1) = BETA * (PHI - C * THIT)
      RI(I,5,1) = BETA * (PHI + C * THIT)
      RI(I,1,2) = (GAMMA - 1.0) * AKXT * UU / C**2
      RI(I,2,2) = (GAMMA - 1.0) * AKYT * UU / C**2 - AKZT
      RI(I,3,2) = (GAMMA - 1.0) * AKZT * UU / C**2 + AKYT
      RI(I,4,2) = BETA * (AKXT * C - (GAMMA - 1.0) * UU)
      RI(I,5,2) =-BETA * (AKXT * C + (GAMMA - 1.0) * UU)
      RI(I,1,3) = (GAMMA - 1.0) * AKXT * VV / C**2 + AKZT
      RI(I,2,3) = (GAMMA - 1.0) * AKYT * VV / C**2
      RI(I,3,3) = (GAMMA - 1.0) * AKZT * VV / C**2 - AKXT
      RI(I,4,3) = BETA * (AKYT * C - (GAMMA - 1.0) * VV)
      RI(I,5,3) =-BETA * (AKYT * C + (GAMMA - 1.0) * VV)
      RI(I,1,4) = (GAMMA - 1.0) * AKXT * WW / C**2 - AKYT
      RI(I,2,4) = (GAMMA - 1.0) * AKYT * WW / C**2 + AKXT
      RI(I,3,4) = (GAMMA - 1.0) * AKZT * WW / C**2
      RI(I,4,4) = BETA * (AKZT * C - (GAMMA - 1.0) * WW)
      RI(I,5,4) =-BETA * (AKZT * C + (GAMMA - 1.0) * WW)
      RI(I,1,5) =-(GAMMA - 1.0) * AKXT / C**2
      RI(I,2,5) =-(GAMMA - 1.0) * AKYT / C**2
      RI(I,3,5) =-(GAMMA - 1.0) * AKZT / C**2
      RI(I,4,5) = BETA * (GAMMA - 1.0)
      RI(I,5,5) = BETA * (GAMMA - 1.0)
      ! EE
      EE(I,1) = THI
      EE(I,2) = THI
      EE(I,3) = THI
      EE(I,4) = THI + CT
      EE(I,5) = THI - CT
      DO L = 6, LE
        EE(I,L) = THI
      ENDDO
      ! EA
      DO L = LS, LE
        EA(I,L) = ABS(EE(I,L)) + VIS ! + DEL * CT
      ENDDO
      ! EP
      DO L = LS, LE
        EP(I,L) = 0.5 * (EE(I,L) + EA(I,L))
      ENDDO
      ! EM
      DO L = LS, LE
        EM(I,L) = 0.5 * (EE(I,L) - EA(I,L))
      ENDDO
    ENDIF
    ENDDO
    ! RR���] -----------------------------------------------------------
    DO I = IS, IE
    IF(QH0(I,J,K,1) .GT. 0.0) THEN
      DO L = LS, 5
        D2(I,L) = RI(I,L,1) * D1(I,1) + RI(I,L,2) * D1(I,2) &
        &       + RI(I,L,3) * D1(I,3) + RI(I,L,4) * D1(I,4) &
        &       + RI(I,L,5) * D1(I,5)
      ENDDO
      DO L = 6, LE
        D2(I,L) = D1(I,L)
      ENDDO
    ENDIF
    ENDDO
    ! �O�i�X�C�[�v -----------------------------------------------------
    D1(:,:) = 0.0
    DO I = IS + 1, IE - 1, + 1
    IF(QH0(I-1,J,K,1) .GT. 0.0 .AND. QH0(I,J,K,1) .GT. 0.0) THEN
      DO L = LS, LE
        D1(I,L) = ( D2(I,L) + DTLOCL(I,J,K) * lambda &
        &         * EP(I-1,L) * D1(I-1,L) ) &
        &       / (1.0 + DTLOCL(I,J,K) * lambda * EA(I,L))
      ENDDO
    ENDIF
    ENDDO
    ! �X�J���[���Z -----------------------------------------------------
    DO I = IS, IE
    IF(QH0(I,J,K,1) .GT. 0.0) THEN
      DO L = LS, LE
        D1(I,L) = D1(I,L) * (1.0 + DTLOCL(I,J,K) * lambda * EA(I,L))
      ENDDO
    ENDIF
    ENDDO
    ! ��ރX�C�[�v -----------------------------------------------------
    D2(:,:) = 0.0
    DO I = IE - 1, IS + 1, - 1
    IF(QH0(I,J,K,1) .GT. 0.0 .AND. QH0(I+1,J,K,1) .GT. 0.0) THEN
      DO L = LS, LE
        D2(I,L) = ( D1(I,L) - DTLOCL(I,J,K) * lambda &
        &         * EM(I+1,L) * D2(I+1,L) ) &
        &       / (1.0 + DTLOCL(I,J,K) * lambda * EA(I,L))
      ENDDO
    ENDIF
    ENDDO
    ! RI���] -----------------------------------------------------------
    DO I = IS, IE
    IF(QH0(I,J,K,1) .GT. 0.0) THEN
      DO L = LS, 5
        D1(I,L) = RR(I,L,1) * D2(I,1) + RR(I,L,2) * D2(I,2) &
        &       + RR(I,L,3) * D2(I,3) + RR(I,L,4) * D2(I,4) &
        &       + RR(I,L,5) * D2(I,5)
      ENDDO
      DO L = 6, LE
        D1(I,L) = D2(I,L)
      ENDDO
    ENDIF
    ENDDO
    ! ��� -------------------------------------------------------------
    DO L = LS, LE
    DO I = IS, IE
    IF(QH0(I,J,K,1) .GT. 0.0) THEN
      DQH(I,J,K,L) = D1(I,L)
    ENDIF
    ENDDO
    ENDDO
  ENDDO
  ENDDO
  !$OMP END DO
  ! ��������� =========================================================
  DEALLOCATE(D1, D2, EE, EA, EP, EM, RR, RI)
  ! ET���� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ! �������m�� =========================================================
  ALLOCATE(D1(JS: JE, LS: LE))
  ALLOCATE(D2(JS: JE, LS: LE))
  ALLOCATE(EE(JS: JE, LS: LE))
  ALLOCATE(EA(JS: JE, LS: LE))
  ALLOCATE(EP(JS: JE, LS: LE))
  ALLOCATE(EM(JS: JE, LS: LE))
  ALLOCATE(RR(JS: JE, LS:  5, LS:  5))
  ALLOCATE(RI(JS: JE, LS:  5, LS:  5))
  ! �s�񔽓]���� =======================================================
  !$OMP DO
  DO K = KS + 1, KE - 1
  DO I = IS + 1, IE - 1
    ! ��� -------------------------------------------------------------
    DO L = LS, LE
    DO J = JS, JE
    IF(QH0(I,J,K,1) .GT. 0.0) THEN
      D1(J,L) = DQH(I,J,K,L)
    ENDIF
    ENDDO
    ENDDO
    ! �Ίp�� -----------------------------------------------------------
    DO J = JS, JE
    IF(QH0(I,J,K,1) .GT. 0.0) THEN
      ! ����
      UU   = U(I,J,K)
      VV   = V(I,J,K)
      WW   = W(I,J,K)
      C    = SQRT(GAMMA * RG * T(I,J,K))
      THI  = ETX(I,J,K) * UU + ETY(I,J,K) * VV + ETZ(I,J,K) * WW
      PHI  = 0.5 * (GAMMA - 1.0) * (UU**2 + VV**2 + WW**2)
      BETA = 1.0 / (2.0 * C**2)
      TIL  = SQRT(ETX(I,J,K)**2 + ETY(I,J,K)**2 + ETZ(I,J,K)**2)
      AKXT = ETX(I,J,K) / TIL
      AKYT = ETY(I,J,K) / TIL
      AKZT = ETZ(I,J,K) / TIL
      THIT = AKXT * UU + AKYT * VV + AKZT * WW
      CT   = C * TIL
      VIS  = 2.0 * AMU(I,J,K) / RHO(I,J,K) * TIL**2
      ! RR
      RR(J,1,1) = AKXT
      RR(J,2,1) = AKXT * UU
      RR(J,3,1) = AKXT * VV + AKZT
      RR(J,4,1) = AKXT * WW - AKYT
      RR(J,5,1) = AKXT * PHI / (GAMMA - 1.0) + AKZT * VV - AKYT * WW
      RR(J,1,2) = AKYT
      RR(J,2,2) = AKYT * UU - AKZT
      RR(J,3,2) = AKYT * VV
      RR(J,4,2) = AKYT * WW + AKXT
      RR(J,5,2) = AKYT * PHI / (GAMMA - 1.0) + AKXT * WW - AKZT * UU
      RR(J,1,3) = AKZT
      RR(J,2,3) = AKZT * UU + AKYT
      RR(J,3,3) = AKZT * VV - AKXT
      RR(J,4,3) = AKZT * WW
      RR(J,5,3) = AKZT * PHI / (GAMMA - 1.0) + AKYT * UU - AKXT * VV
      RR(J,1,4) = 1.0
      RR(J,2,4) = UU + AKXT * C
      RR(J,3,4) = VV + AKYT * C
      RR(J,4,4) = WW + AKZT * C
      RR(J,5,4) = (PHI + C**2) / (GAMMA - 1.0) + C * THIT
      RR(J,1,5) = 1.0
      RR(J,2,5) = UU - AKXT * C
      RR(J,3,5) = VV - AKYT * C
      RR(J,4,5) = WW - AKZT * C
      RR(J,5,5) = (PHI + C**2) / (GAMMA - 1.0) - C * THIT
      ! RI
      RI(J,1,1) = AKXT - AKXT * PHI / C**2 + AKYT * WW - AKZT * VV
      RI(J,2,1) = AKYT - AKYT * PHI / C**2 + AKZT * UU - AKXT * WW
      RI(J,3,1) = AKZT - AKZT * PHI / C**2 + AKXT * VV - AKYT * UU
      RI(J,4,1) = BETA * (PHI - C * THIT)
      RI(J,5,1) = BETA * (PHI + C * THIT)
      RI(J,1,2) = (GAMMA - 1.0) * AKXT * UU / C**2
      RI(J,2,2) = (GAMMA - 1.0) * AKYT * UU / C**2 - AKZT
      RI(J,3,2) = (GAMMA - 1.0) * AKZT * UU / C**2 + AKYT
      RI(J,4,2) = BETA * (AKXT * C - (GAMMA - 1.0) * UU)
      RI(J,5,2) =-BETA * (AKXT * C + (GAMMA - 1.0) * UU)
      RI(J,1,3) = (GAMMA - 1.0) * AKXT * VV / C**2 + AKZT
      RI(J,2,3) = (GAMMA - 1.0) * AKYT * VV / C**2
      RI(J,3,3) = (GAMMA - 1.0) * AKZT * VV / C**2 - AKXT
      RI(J,4,3) = BETA * (AKYT * C - (GAMMA - 1.0) * VV)
      RI(J,5,3) =-BETA * (AKYT * C + (GAMMA - 1.0) * VV)
      RI(J,1,4) = (GAMMA - 1.0) * AKXT * WW / C**2 - AKYT
      RI(J,2,4) = (GAMMA - 1.0) * AKYT * WW / C**2 + AKXT
      RI(J,3,4) = (GAMMA - 1.0) * AKZT * WW / C**2
      RI(J,4,4) = BETA * (AKZT * C - (GAMMA - 1.0) * WW)
      RI(J,5,4) =-BETA * (AKZT * C + (GAMMA - 1.0) * WW)
      RI(J,1,5) =-(GAMMA - 1.0) * AKXT / C**2
      RI(J,2,5) =-(GAMMA - 1.0) * AKYT / C**2
      RI(J,3,5) =-(GAMMA - 1.0) * AKZT / C**2
      RI(J,4,5) = BETA * (GAMMA - 1.0)
      RI(J,5,5) = BETA * (GAMMA - 1.0)
      ! EE
      EE(J,1) = THI
      EE(J,2) = THI
      EE(J,3) = THI
      EE(J,4) = THI + CT
      EE(J,5) = THI - CT
      DO L = 6, LE
        EE(J,L) = THI
      ENDDO
      ! EA
      DO L = LS, LE
        EA(J,L) = ABS(EE(J,L)) + VIS ! + DEL * CT
      ENDDO
      ! EP
      DO L = LS, LE
        EP(J,L) = 0.5 * (EE(J,L) + EA(J,L))
      ENDDO
      ! EM
      DO L = LS, LE
        EM(J,L) = 0.5 * (EE(J,L) - EA(J,L))
      ENDDO
    ENDIF
    ENDDO
    ! RR���] -----------------------------------------------------------
    DO J = JS, JE
    IF(QH0(I,J,K,1) .GT. 0.0) THEN
      DO L = LS, 5
        D2(J,L) = RI(J,L,1) * D1(J,1) + RI(J,L,2) * D1(J,2) &
        &       + RI(J,L,3) * D1(J,3) + RI(J,L,4) * D1(J,4) &
        &       + RI(J,L,5) * D1(J,5)
      ENDDO
      DO L = 6, LE
        D2(J,L) = D1(J,L)
      ENDDO
    ENDIF
    ENDDO
    ! �O�i�X�C�[�v -----------------------------------------------------
    D1(:,:) = 0.0
    DO J = JS + 1, JE - 1, + 1
    IF(QH0(I,J-1,K,1) .GT. 0.0 .AND. QH0(I,J,K,1) .GT. 0.0) THEN
      DO L = LS, LE
        D1(J,L) = ( D2(J,L) + DTLOCL(I,J,K) * lambda &
        &         * EP(J-1,L) * D1(J-1,L) ) &
        &       / (1.0 + DTLOCL(I,J,K) * lambda * EA(J,L))
      ENDDO
    ENDIF
    ENDDO
    ! �X�J���[���Z -----------------------------------------------------
    DO J = JS, JE
    IF(QH0(I,J,K,1) .GT. 0.0) THEN
      DO L = LS, LE
        D1(J,L) = D1(J,L) * (1.0 + DTLOCL(I,J,K) * lambda * EA(J,L))
      ENDDO
    ENDIF
    ENDDO
    ! ��ރX�C�[�v -----------------------------------------------------
    D2(:,:) = 0.0
    DO J = JE - 1, JS + 1, - 1
    IF(QH0(I,J,K,1) .GT. 0.0 .AND. QH0(I,J+1,K,1) .GT. 0.0) THEN
      DO L = LS, LE
        D2(J,L) = ( D1(J,L) - DTLOCL(I,J,K) * lambda &
        &         * EM(J+1,L) * D2(J+1,L) ) &
        &       / (1.0 + DTLOCL(I,J,K) * lambda * EA(J,L))
      ENDDO
    ENDIF
    ENDDO
    ! RI���] -----------------------------------------------------------
    DO J = JS, JE
    IF(QH0(I,J,K,1) .GT. 0.0) THEN
      DO L = LS, 5
        D1(J,L) = RR(J,L,1) * D2(J,1) + RR(J,L,2) * D2(J,2) &
        &       + RR(J,L,3) * D2(J,3) + RR(J,L,4) * D2(J,4) &
        &       + RR(J,L,5) * D2(J,5)
      ENDDO
      DO L = 6, LE
        D1(J,L) = D2(J,L)
      ENDDO
    ENDIF
    ENDDO
    ! ��� -------------------------------------------------------------
    DO L = LS, LE
    DO J = JS, JE
    IF(QH0(I,J,K,1) .GT. 0.0) THEN
      DQH(I,J,K,L) = D1(J,L)
    ENDIF
    ENDDO
    ENDDO
  ENDDO
  ENDDO
  !$OMP END DO
  ! ��������� =========================================================
  DEALLOCATE(D1, D2, EE, EA, EP, EM, RR, RI)
  ! ZE���� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ! �������m�� =========================================================
  ALLOCATE(D1(KS: KE, LS: LE))
  ALLOCATE(D2(KS: KE, LS: LE))
  ALLOCATE(EE(KS: KE, LS: LE))
  ALLOCATE(EA(KS: KE, LS: LE))
  ALLOCATE(EP(KS: KE, LS: LE))
  ALLOCATE(EM(KS: KE, LS: LE))
  ALLOCATE(RR(KS: KE, LS:  5, LS:  5))
  ALLOCATE(RI(KS: KE, LS:  5, LS:  5))
  ! �s�񔽓]���� =======================================================
  !$OMP DO
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
    ! ��� -------------------------------------------------------------
    DO L = LS, LE
    DO K = KS, KE
    IF(QH0(I,J,K,1) .GT. 0.0) THEN
      D1(K,L) = DQH(I,J,K,L)
    ENDIF
    ENDDO
    ENDDO
    ! �Ίp�� -----------------------------------------------------------
    DO K = KS, KE
    IF(QH0(I,J,K,1) .GT. 0.0) THEN
      ! ����
      UU   = U(I,J,K)
      VV   = V(I,J,K)
      WW   = W(I,J,K)
      C    = SQRT(GAMMA * RG * T(I,J,K))
      THI  = ZEX(I,J,K) * UU + ZEY(I,J,K) * VV + ZEZ(I,J,K) * WW
      PHI  = 0.5 * (GAMMA - 1.0) * (UU**2 + VV**2 + WW**2)
      BETA = 1.0 / (2.0 * C**2)
      TIL  = SQRT(ZEX(I,J,K)**2 + ZEY(I,J,K)**2 + ZEZ(I,J,K)**2)
      AKXT = ZEX(I,J,K) / TIL
      AKYT = ZEY(I,J,K) / TIL
      AKZT = ZEZ(I,J,K) / TIL
      THIT = AKXT * UU + AKYT * VV + AKZT * WW
      CT   = C * TIL
      VIS  = 2.0 * AMU(I,J,K) / RHO(I,J,K) * TIL**2
      ! RR
      RR(K,1,1) = AKXT
      RR(K,2,1) = AKXT * UU
      RR(K,3,1) = AKXT * VV + AKZT
      RR(K,4,1) = AKXT * WW - AKYT
      RR(K,5,1) = AKXT * PHI / (GAMMA - 1.0) + AKZT * VV - AKYT * WW
      RR(K,1,2) = AKYT
      RR(K,2,2) = AKYT * UU - AKZT
      RR(K,3,2) = AKYT * VV
      RR(K,4,2) = AKYT * WW + AKXT
      RR(K,5,2) = AKYT * PHI / (GAMMA - 1.0) + AKXT * WW - AKZT * UU
      RR(K,1,3) = AKZT
      RR(K,2,3) = AKZT * UU + AKYT
      RR(K,3,3) = AKZT * VV - AKXT
      RR(K,4,3) = AKZT * WW
      RR(K,5,3) = AKZT * PHI / (GAMMA - 1.0) + AKYT * UU - AKXT * VV
      RR(K,1,4) = 1.0
      RR(K,2,4) = UU + AKXT * C
      RR(K,3,4) = VV + AKYT * C
      RR(K,4,4) = WW + AKZT * C
      RR(K,5,4) = (PHI + C**2) / (GAMMA - 1.0) + C * THIT
      RR(K,1,5) = 1.0
      RR(K,2,5) = UU - AKXT * C
      RR(K,3,5) = VV - AKYT * C
      RR(K,4,5) = WW - AKZT * C
      RR(K,5,5) = (PHI + C**2) / (GAMMA - 1.0) - C * THIT
      ! RI
      RI(K,1,1) = AKXT - AKXT * PHI / C**2 + AKYT * WW - AKZT * VV
      RI(K,2,1) = AKYT - AKYT * PHI / C**2 + AKZT * UU - AKXT * WW
      RI(K,3,1) = AKZT - AKZT * PHI / C**2 + AKXT * VV - AKYT * UU
      RI(K,4,1) = BETA * (PHI - C * THIT)
      RI(K,5,1) = BETA * (PHI + C * THIT)
      RI(K,1,2) = (GAMMA - 1.0) * AKXT * UU / C**2
      RI(K,2,2) = (GAMMA - 1.0) * AKYT * UU / C**2 - AKZT
      RI(K,3,2) = (GAMMA - 1.0) * AKZT * UU / C**2 + AKYT
      RI(K,4,2) = BETA * (AKXT * C - (GAMMA - 1.0) * UU)
      RI(K,5,2) =-BETA * (AKXT * C + (GAMMA - 1.0) * UU)
      RI(K,1,3) = (GAMMA - 1.0) * AKXT * VV / C**2 + AKZT
      RI(K,2,3) = (GAMMA - 1.0) * AKYT * VV / C**2
      RI(K,3,3) = (GAMMA - 1.0) * AKZT * VV / C**2 - AKXT
      RI(K,4,3) = BETA * (AKYT * C - (GAMMA - 1.0) * VV)
      RI(K,5,3) =-BETA * (AKYT * C + (GAMMA - 1.0) * VV)
      RI(K,1,4) = (GAMMA - 1.0) * AKXT * WW / C**2 - AKYT
      RI(K,2,4) = (GAMMA - 1.0) * AKYT * WW / C**2 + AKXT
      RI(K,3,4) = (GAMMA - 1.0) * AKZT * WW / C**2
      RI(K,4,4) = BETA * (AKZT * C - (GAMMA - 1.0) * WW)
      RI(K,5,4) =-BETA * (AKZT * C + (GAMMA - 1.0) * WW)
      RI(K,1,5) =-(GAMMA - 1.0) * AKXT / C**2
      RI(K,2,5) =-(GAMMA - 1.0) * AKYT / C**2
      RI(K,3,5) =-(GAMMA - 1.0) * AKZT / C**2
      RI(K,4,5) = BETA * (GAMMA - 1.0)
      RI(K,5,5) = BETA * (GAMMA - 1.0)
      ! EE
      EE(K,1) = THI
      EE(K,2) = THI
      EE(K,3) = THI
      EE(K,4) = THI + CT
      EE(K,5) = THI - CT
      DO L = 6, LE
        EE(K,L) = THI
      ENDDO
      ! EA
      DO L = LS, LE
        EA(K,L) = ABS(EE(K,L)) + VIS ! + DEL * CT
      ENDDO
      ! EP
      DO L = LS, LE
        EP(K,L) = 0.5 * (EE(K,L) + EA(K,L))
      ENDDO
      ! EM
      DO L = LS, LE
        EM(K,L) = 0.5 * (EE(K,L) - EA(K,L))
      ENDDO
    ENDIF
    ENDDO
    ! RR���] -----------------------------------------------------------
    DO K = KS, KE
    IF(QH0(I,J,K,1) .GT. 0.0) THEN
      DO L = LS, 5
        D2(K,L) = RI(K,L,1) * D1(K,1) + RI(K,L,2) * D1(K,2) &
        &       + RI(K,L,3) * D1(K,3) + RI(K,L,4) * D1(K,4) &
        &       + RI(K,L,5) * D1(K,5)
      ENDDO
      DO L = 6, LE
        D2(K,L) = D1(K,L)
      ENDDO
    ENDIF
    ENDDO
    ! �O�i�X�C�[�v -----------------------------------------------------
    D1(:,:) = 0.0
    DO K = KS + 1, KE - 1, + 1
    IF(QH0(I,J,K-1,1) .GT. 0.0 .AND. QH0(I,J,K,1) .GT. 0.0) THEN
      DO L = LS, LE
        D1(K,L) = ( D2(K,L) + DTLOCL(I,J,K) * lambda &
        &         * EP(K-1,L) * D1(K-1,L) ) &
        &       / (1.0 + DTLOCL(I,J,K) * lambda * EA(K,L))
      ENDDO
    ENDIF
    ENDDO
    ! �X�J���[���Z -----------------------------------------------------
    DO K = KS, KE
    IF(QH0(I,J,K,1) .GT. 0.0) THEN
      DO L = LS, LE
        D1(K,L) = D1(K,L) * (1.0 + DTLOCL(I,J,K) * lambda * EA(K,L))
      ENDDO
    ENDIF
    ENDDO
    ! ��ރX�C�[�v -----------------------------------------------------
    D2(:,:) = 0.0
    DO K = KE - 1, KS + 1, - 1
    IF(QH0(I,J,K,1) .GT. 0.0 .AND. QH0(I,J,K+1,1) .GT. 0.0) THEN
      DO L = LS, LE
        D2(K,L) = ( D1(K,L) - DTLOCL(I,J,K) * lambda &
        &         * EM(K+1,L) * D2(K+1,L) ) &
        &       / (1.0 + DTLOCL(I,J,K) * lambda * EA(K,L))
      ENDDO
    ENDIF
    ENDDO
    ! RI���] -----------------------------------------------------------
    DO K = KS, KE
    IF(QH0(I,J,K,1) .GT. 0.0) THEN
      DO L = LS, 5
        D1(K,L) = RR(K,L,1) * D2(K,1) + RR(K,L,2) * D2(K,2) &
        &       + RR(K,L,3) * D2(K,3) + RR(K,L,4) * D2(K,4) &
        &       + RR(K,L,5) * D2(K,5)
      ENDDO
      DO L = 6, LE
        D1(K,L) = D2(K,L)
      ENDDO
    ENDIF
    ENDDO
    ! ��� -------------------------------------------------------------
    DO L = LS, LE
    DO K = KS, KE
    IF(QH0(I,J,K,1) .GT. 0.0) THEN
      DQH(I,J,K,L) = D1(K,L)
    ENDIF
    ENDDO
    ENDDO
  ENDDO
  ENDDO
  !$OMP END DO
  ! ��������� =========================================================
  DEALLOCATE(D1, D2, EE, EA, EP, EM, RR, RI)
  ! �f���^�`�����痬���֐��̎��Ԃ�i�߂� +++++++++++++++++++++++++++++++
  DO L = LS, LE
  !$OMP DO
  DO K = KS, KE
  DO J = JS, JE
  DO I = IS, IE
  IF(QH0(I,J,K,1) .GT. 0.0) THEN
    QH1(I,J,K,L) = QH1(I,J,K,L) + DQH(I,J,K,L)
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END DO
  ENDDO
  ! ��������� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP END PARALLEL
  DEALLOCATE(DQH)
  ! �����I�� ***********************************************************
  RETURN
! ��`�I�� *************************************************************
END SUBROUTINE LUADI3D
!***********************************************************************
!**** �Η����v�Z                                                    ****
!**** �v�Z�Ώ� : �P��, �񎟌�, ���k��                               ****
!**** �v�Z�X�L�[�� : �񎟐��x���S����                               ****
!****                �ꎟ���x���㍷��                               ****
!****                �񎟐��xTVD�X�L�[�� (Yee-Harten)               ****
!****                �O�����xTVD�X�L�[�� (Chakravarthy-Osher)       ****
!****                �l�����xTVD�X�L�[�� (Yamamoto-Daiguji)         ****
!***********************************************************************
SUBROUTINE Convection2D( &
&            Order, DEL, RG, GAMMA, &
&            IS, IE, JS, JE, LS, LE, &
&            XIX, XIY, ETX, ETY, AJA, &
&            QH, U, V, P, T, &
&            DQC &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, PARAMETER :: b1 = 4.0, b2 = 2.0
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: Order
  REAL,    INTENT(IN)  :: DEL
  REAL,    INTENT(IN)  :: RG, GAMMA
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE
  INTEGER, INTENT(IN)  :: LS, LE
  REAL,    INTENT(IN)  :: XIX(IS: IE, JS: JE), XIY(IS: IE, JS: JE), &
  &                       ETX(IS: IE, JS: JE), ETY(IS: IE, JS: JE), &
  &                       AJA(IS: IE, JS: JE)
  REAL,    INTENT(IN)  :: QH(IS: IE, JS: JE, LS: LE)
  REAL,    INTENT(IN)  :: U(IS: IE, JS: JE), V(IS: IE, JS: JE), &
  &                       P(IS: IE, JS: JE), T(IS: IE, JS: JE)
  REAL,    INTENT(OUT) :: DQC(IS: IE, JS: JE, LS: LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, L
  REAL, ALLOCATABLE :: ET(:, :, :), FT(:, :, :)
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 4) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �������m�� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ALLOCATE(ET(IS: IE, JS: JE, LS: LE), FT(IS: IE, JS: JE, LS: LE))
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ET (:, :, :) = 0.0
  FT (:, :, :) = 0.0
  DQC(:, :, :) = 0.0
  ! �e�����̋�ԍ��� +++++++++++++++++++++++++++++++++++++++++++++++++++
  CALL TVDXI
  CALL TVDET
  ! �Η����x�N�g���̋�ԍ��� +++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE(I, J, L)
  DO L = LS, LE
  !$OMP DO
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( (QH(I  ,J-1,1) .GT. 0.0) .AND. (QH(I-1,J  ,1) .GT. 0.0) .AND. &
  &   (QH(I  ,J  ,1) .GT. 0.0) .AND. &
  &   (QH(I+1,J  ,1) .GT. 0.0) .AND. (QH(I  ,J+1,1) .GT. 0.0) &
  & ) THEN
    DQC(I,J,L) = ET(I-1,J  ,L) - ET(I,J,L) &
    &          + FT(I  ,J-1,L) - FT(I,J,L)
  ENDIF
  ENDDO
  ENDDO
  !$OMP END DO
  ENDDO
  !$OMP END PARALLEL
  ! �����I�� ***********************************************************
  RETURN
! �����葱�� ***********************************************************
CONTAINS
!***********************************************************************
!**** TVD�X�L�[��(XI����)                                           ****
!***********************************************************************
SUBROUTINE TVDXI
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, L
  REAL    :: AKX, AKY
  REAL    :: RWL, RWR, RWD, UM, VM, HM, CM
  REAL    :: THI, PHI, BETA, TIL, AKXT, AKYT, THIT, PH
  REAL    :: FSIGMA, FGAMMA, ABSA, AP, AM
  REAL    :: D3FP1, D3FP2, D3FP3, D3FM1, D3FM2, D3FM3
  REAL, ALLOCATABLE :: F(:, :), EIG(:, :)
  REAL, ALLOCATABLE :: RR(:, :, :), RI(:, :, :), EIGM(:, :), DELTA(:, :)
  REAL, ALLOCATABLE :: DU(:, :), DUR(:, :)
  REAL, ALLOCATABLE :: GG(:, :), PHIM(:, :)
  REAL, ALLOCATABLE :: DFP(:, :), DFM(:, :)
  REAL, ALLOCATABLE :: D3FP(:, :), D3FM(:, :)
  REAL, ALLOCATABLE :: DFBP(:, :), DFBM(:, :)
  REAL, ALLOCATABLE :: DFTP(:, :), DFTM(:, :)
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, L, &
!$OMP& AKX, AKY, RWL, RWR, RWD, UM, VM, HM, CM, &
!$OMP& THI, PHI, BETA, TIL, AKXT, AKYT, THIT, PH, &
!$OMP& FSIGMA, FGAMMA, ABSA, AP, AM, &
!$OMP& D3FP1, D3FP2, D3FP3, D3FM1, D3FM2, D3FM3, &
!$OMP& F, EIG, RR, RI, EIGM, DELTA, DU, DUR, &
!$OMP& GG, PHIM, DFP, DFM, D3FP, D3FM, &
!$OMP& DFBP, DFBM, DFTP, DFTM &
!$OMP& )
  ALLOCATE(F(IS: IE, LS: LE), EIG(IS: IE, LS: LE))
  ALLOCATE(RR(IS: IE - 1, LS: 4, LS: 4))
  ALLOCATE(RI(IS: IE - 1, LS: 4, LS: 4))
  ALLOCATE(EIGM(IS: IE - 1, LS: LE))
  ALLOCATE(DELTA(IS: IE - 1, LS: LE))
  ALLOCATE(DU(IS: IE - 1, LS: LE), DUR(IS: IE - 1, LS: LE))
  ALLOCATE(GG(IS: IE, LS: LE), PHIM(IS: IE - 1, LS: LE))
  ALLOCATE(DFP (IS    : IE - 1, LS: LE), DFM (IS    : IE - 1, LS: LE))
  ALLOCATE(D3FP(IS + 1: IE - 2, LS: LE), D3FM(IS + 1: IE - 2, LS: LE))
  ALLOCATE(DFBP(IS    : IE - 3, LS: LE), DFBM(IS + 1: IE - 2, LS: LE))
  ALLOCATE(DFTP(IS + 1: IE - 2, LS: LE), DFTM(IS + 2: IE - 1, LS: LE))
  !$OMP DO
  DO J = JS + 1, JE - 1
    ! �񎟐��x���S���� +++++++++++++++++++++++++++++++++++++++++++++++++
    DO I = IS, IE
    IF(QH(I,J,1) .GT. 0.0) THEN
      THI = XIX(I,J) * U(I,J) + XIY(I,J) * V(I,J)
      TIL = SQRT(XIX(I,J)**2 + XIY(I,J)**2)
      CM  = SQRT(GAMMA * RG * T(I,J))
      PH  = P(I,J) / AJA(I,J)
      F(I,1) = QH(I,J,1) * THI
      F(I,2) = QH(I,J,2) * THI + PH * XIX(I,J)
      F(I,3) = QH(I,J,3) * THI + PH * XIY(I,J)
      F(I,4) = QH(I,J,4) * THI + PH * THI
      DO L = 5, LE
        F(I,L) = QH(I,J,L) * THI
      ENDDO
      EIG(I,1) = THI
      EIG(I,2) = THI
      EIG(I,3) = THI + CM * TIL
      EIG(I,4) = THI - CM * TIL
      DO L = 5, LE
        EIG(I,L) = THI
      ENDDO
    ENDIF
    ENDDO
    ! ���l����
    DO L = LS, LE
    DO I = IS, IE - 1
    IF(QH(I,J,1) .GT. 0.0 .AND. QH(I+1,J,1) .GT. 0.0) THEN
      ET(I,J,L) = 0.5 * (F(I,L) + F(I+1,L))
    ENDIF
    ENDDO
    ENDDO
    IF(Order .EQ. 0) CYCLE
    ! �Ίp�� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    DO I = IS, IE - 1
    IF(QH(I,J,1) .GT. 0.0 .AND. QH(I+1,J,1) .GT. 0.0) THEN
      AKX  = 0.5 * (XIX(I,J) + XIX(I+1,J))
      AKY  = 0.5 * (XIY(I,J) + XIY(I+1,J))
      ! Roe ����
      RWD  = 1.0 / ( SQRT(QH(I  ,J,1) * AJA(I  ,J)) &
      &            + SQRT(QH(I+1,J,1) * AJA(I+1,J)) )
      RWL  = SQRT(QH(I  ,J,1) * AJA(I  ,J)) * RWD
      RWR  = SQRT(QH(I+1,J,1) * AJA(I+1,J)) * RWD
      UM   = RWL * U(I,J) + RWR * U(I+1,J)
      VM   = RWL * V(I,J) + RWR * V(I+1,J)
      HM   = RWL * ( &
      &        0.5 * (U(I  ,J)**2 + V(I  ,J)**2) &
      &      + GAMMA * RG / (GAMMA - 1.0) * T(I  ,J) &
      &    ) &
      &    + RWR * ( &
      &        0.5 * (U(I+1,J)**2 + V(I+1,J)**2) &
      &      + GAMMA * RG / (GAMMA - 1.0) * T(I+1,J) &
      &    )
      CM   = SQRT((GAMMA - 1.0) * (HM - 0.5 * (UM**2 + VM**2)))
      ! �Ίp��
      THI  = AKX * UM + AKY * VM
      PHI  = 0.5 * (GAMMA - 1.0) * (UM**2 + VM**2)
      BETA = 1.0 / (2.0 * CM**2)
      TIL  = SQRT(AKX**2 + AKY**2)
      AKXT = AKX / TIL
      AKYT = AKY / TIL
      THIT = AKXT * UM + AKYT * VM
      RR(I,1,1) = 1.0
      RR(I,2,1) = UM
      RR(I,3,1) = VM
      RR(I,4,1) = PHI / (GAMMA - 1.0)
      RR(I,1,2) = 0.0
      RR(I,2,2) = AKYT
      RR(I,3,2) =-AKXT
      RR(I,4,2) = AKYT * UM - AKXT * VM
      RR(I,1,3) = 1.0
      RR(I,2,3) = UM + AKXT * CM
      RR(I,3,3) = VM + AKYT * CM
      RR(I,4,3) = (PHI + CM**2) / (GAMMA - 1.0) + CM * THIT
      RR(I,1,4) = 1.0
      RR(I,2,4) = UM - AKXT * CM
      RR(I,3,4) = VM - AKYT * CM
      RR(I,4,4) = (PHI + CM**2) / (GAMMA - 1.0) - CM * THIT
      RI(I,1,1) = 1.0 - PHI / CM**2
      RI(I,2,1) =-AKYT * UM + AKXT * VM
      RI(I,3,1) = BETA * (PHI - CM * THIT)
      RI(I,4,1) = BETA * (PHI + CM * THIT)
      RI(I,1,2) = (GAMMA - 1.0) * UM / CM**2
      RI(I,2,2) = AKYT
      RI(I,3,2) = BETA * (AKXT * CM - (GAMMA - 1.0) * UM)
      RI(I,4,2) =-BETA * (AKXT * CM + (GAMMA - 1.0) * UM)
      RI(I,1,3) = (GAMMA - 1.0) * VM / CM**2
      RI(I,2,3) =-AKXT
      RI(I,3,3) = BETA * (AKYT * CM - (GAMMA - 1.0) * VM)
      RI(I,4,3) =-BETA * (AKYT * CM + (GAMMA - 1.0) * VM)
      RI(I,1,4) =-(GAMMA - 1.0) / CM**2
      RI(I,2,4) = 0.0
      RI(I,3,4) = BETA * (GAMMA - 1.0)
      RI(I,4,4) = BETA * (GAMMA - 1.0)
      EIGM(I,1) = THI
      EIGM(I,2) = THI
      EIGM(I,3) = THI + CM * TIL
      EIGM(I,4) = THI - CM * TIL
      DO L = 5, LE
        EIGM(I,L) = THI
      ENDDO
      DO L = LS, LE
        DELTA(I,L) = MAX( &
        &              0.0, &
        &              EIGM(I,L) - EIG(I,L), EIG(I+1,L) - EIGM(I,L) &
        &            ) + DEL * CM * TIL
      ENDDO
    ENDIF
    ENDDO
    ! Delta u
    DO L = LS, LE
    DO I = IS, IE - 1
    IF(QH(I,J,1) .GT. 0.0 .AND. QH(I+1,J,1) .GT. 0.0) THEN
      DU(I,L) = - QH(I  ,J,L) * AJA(I  ,J) &
      &         + QH(I+1,J,L) * AJA(I+1,J)
      DU(I,L) = DU(I,L) * 2.0 / (AJA(I,J) + AJA(I+1,J))
    ENDIF
    ENDDO
    ENDDO
    ! R^-1 Delta u
    DO L = LS, LE
    DO I = IS, IE - 1
    IF(QH(I,J,1) .GT. 0.0 .AND. QH(I+1,J,1) .GT. 0.0) THEN
      IF(L .LE. 4) THEN
        DUR(I,L) = RI(I,L,1) * DU(I,1) + RI(I,L,2) * DU(I,2) &
        &        + RI(I,L,3) * DU(I,3) + RI(I,L,4) * DU(I,4)
      ELSE
        DUR(I,L) = DU(I,L)
      ENDIF
    ENDIF
    ENDDO
    ENDDO
    ! �񎟐��xTVD�X�L�[�� ++++++++++++++++++++++++++++++++++++++++++++++
    IF(Order .EQ. 2) THEN
      ! g
      DO L = LS, LE
      I = IS
      IF(QH(I,J,1) .GT. 0.0 .AND. QH(I+1,J,1) .GT. 0.0) THEN
        GG(I,L) = DUR(I,L)
      ENDIF
      DO I = IS + 1, IE - 1
      IF(QH(I,J,1) .LE. 0.0) CYCLE
      IF(QH(I-1,J,1) .GT. 0.0 .AND. QH(I+1,J,1) .GT. 0.0) THEN
        GG(I,L) = minmod2(DUR(I,L), DUR(I-1,L))
      ELSEIF(QH(I-1,J,1) .GT. 0.0) THEN
        GG(I,L) = DUR(I-1,L)
      ELSEIF(QH(I+1,J,1) .GT. 0.0) THEN
        GG(I,L) = DUR(I,L)
      ENDIF
      ENDDO
      I = IE
      IF(QH(I-1,J,1) .GT. 0.0 .AND. QH(I,J,1) .GT. 0.0) THEN
        GG(I,L) = DUR(I-1,L)
      ENDIF
      ENDDO
      ! phi
      DO L = LS, LE
      DO I = IS, IE - 1
      IF(QH(I,J,1) .GT. 0.0 .AND. QH(I+1,J,1) .GT. 0.0) THEN
        FSIGMA = Func_sigma(Func_psi(EIGM(I,L), DELTA(I,L)))
        FGAMMA = Func_gamma(FSIGMA, GG(I,L), GG(I+1,L), DUR(I,L))
        PHIM(I,L) = FSIGMA * (GG(I,L) + GG(I+1,L)) &
        &         - Func_psi(EIGM(I,L) + FGAMMA, DELTA(I,L)) * DUR(I,L)
      ENDIF
      ENDDO
      ENDDO
      ! ���l����
      DO L = LS, LE
      DO I = IS, IE - 1
      IF(QH(I,J,1) .GT. 0.0 .AND. QH(I+1,J,1) .GT. 0.0) THEN
        IF(L .LE. 4) THEN
          ET(I,J,L) = ET(I,J,L) + 0.5 * ( RR(I,L,1) * PHIM(I,1) &
          &                             + RR(I,L,2) * PHIM(I,2) &
          &                             + RR(I,L,3) * PHIM(I,3) &
          &                             + RR(I,L,4) * PHIM(I,4) )
        ELSE
          ET(I,J,L) = ET(I,J,L) + 0.5 * PHIM(I,L)
        ENDIF
      ENDIF
      ENDDO
      ENDDO
      CYCLE
    ENDIF
    ! �ꎟ���x���㍷�� +++++++++++++++++++++++++++++++++++++++++++++++++
    ! Delta f^+-
    DO L = LS, LE
    DO I = IS, IE - 1
    IF(QH(I,J,1) .GT. 0.0 .AND. QH(I+1,J,1) .GT. 0.0) THEN
      ABSA  = Func_psi(EIGM(I,L), DELTA(I,L))
      AP    = 0.5 * (EIGM(I,L) + ABSA)
      AM    = 0.5 * (EIGM(I,L) - ABSA)
      DFP(I,L) = AP * DUR(I,L)
      DFM(I,L) = AM * DUR(I,L)
    ENDIF
    ENDDO
    ENDDO
    ! ���l����
    DO L = LS, LE
    DO I = IS, IE - 1
    IF(QH(I,J,1) .GT. 0.0 .AND. QH(I+1,J,1) .GT. 0.0) THEN
      IF(L .LE. 4) THEN
        ET(I,J,L) = ET(I,J,L) - 0.5 * ( RR(I,L,1) * DFP(I,1) &
        &                             + RR(I,L,2) * DFP(I,2) &
        &                             + RR(I,L,3) * DFP(I,3) &
        &                             + RR(I,L,4) * DFP(I,4) &
        &                             - RR(I,L,1) * DFM(I,1) &
        &                             - RR(I,L,2) * DFM(I,2) &
        &                             - RR(I,L,3) * DFM(I,3) &
        &                             - RR(I,L,4) * DFM(I,4) )
      ELSE
        ET(I,J,L) = ET(I,J,L) - 0.5 * (DFP(I,L) - DFM(I,L))
      ENDIF
    ENDIF
    ENDDO
    ENDDO
    IF(Order .EQ. 1) CYCLE
    ! �O��&�l�����xTVD�X�L�[�� +++++++++++++++++++++++++++++++++++++++++
    IF(Order .EQ. 4) THEN
      ! Delta^3 bar(f)^+-
      DO L = LS, LE
      DO I = IS + 1, IE - 2
      IF( QH(I-1,J,1) .GT. 0.0 .AND. QH(I  ,J,1) .GT. 0.0 .AND. &
      &   QH(I+1,J,1) .GT. 0.0 .AND. QH(I+2,J,1) .GT. 0.0 ) THEN
        D3FP1 = minmod3(DFP(I-1,L), b2 * DFP(I  ,L), b2 * DFP(I+1,L))
        D3FP2 = minmod3(DFP(I  ,L), b2 * DFP(I+1,L), b2 * DFP(I-1,L))
        D3FP3 = minmod3(DFP(I+1,L), b2 * DFP(I-1,L), b2 * DFP(I  ,L))
        D3FM1 = minmod3(DFM(I-1,L), b2 * DFM(I  ,L), b2 * DFM(I+1,L))
        D3FM2 = minmod3(DFM(I  ,L), b2 * DFM(I+1,L), b2 * DFM(I-1,L))
        D3FM3 = minmod3(DFM(I+1,L), b2 * DFM(I-1,L), b2 * DFM(I  ,L))
        D3FP(I,L) = D3FP1 - 2.0 * D3FP2 + D3FP3
        D3FM(I,L) = D3FM1 - 2.0 * D3FM2 + D3FM3
      ENDIF
      ENDDO
      ENDDO
      ! Delta^asterisk f^+-
      DO L = LS, LE
      DO I = IS + 1, IE - 2
      IF( QH(I-1,J,1) .GT. 0.0 .AND. QH(I  ,J,1) .GT. 0.0 .AND. &
      &   QH(I+1,J,1) .GT. 0.0 .AND. QH(I+2,J,1) .GT. 0.0 ) THEN
        DFP(I,L) = DFP(I,L) - D3FP(I,L) / 6.0
        DFM(I,L) = DFM(I,L) - D3FM(I,L) / 6.0
      ENDIF
      ENDDO
      ENDDO
    ENDIF
    ! Delta bar(f)^+-, Delta tilde(f)^+-
    DO L = LS, LE
    DO I = IS + 1, IE - 2
    IF( QH(I-1,J,1) .GT. 0.0 .AND. QH(I  ,J,1) .GT. 0.0 .AND. &
    &   QH(I+1,J,1) .GT. 0.0 .AND. QH(I+2,J,1) .GT. 0.0 ) THEN
      DFBP(I-1,L) = minmod2(DFP(I-1,L), b1 * DFP(I  ,L))
      DFBM(I  ,L) = minmod2(DFM(I  ,L), b1 * DFM(I+1,L))
      DFTP(I  ,L) = minmod2(DFP(I  ,L), b1 * DFP(I-1,L))
      DFTM(I+1,L) = minmod2(DFM(I+1,L), b1 * DFM(I  ,L))
    ENDIF
    ENDDO
    ENDDO
    ! ���l����
    DO L = LS, LE
    DO I = IS + 1, IE - 2
    IF( QH(I-1,J,1) .GT. 0.0 .AND. QH(I  ,J,1) .GT. 0.0 .AND. &
    &   QH(I+1,J,1) .GT. 0.0 .AND. QH(I+2,J,1) .GT. 0.0 ) THEN
      IF(L .LE. 4) THEN
        ET(I,J,L) = ET(I,J,L) &
        &         + ( 1.0 * RR(I-1,L,1) * DFBP(I-1,1) &
        &           + 1.0 * RR(I-1,L,2) * DFBP(I-1,2) &
        &           + 1.0 * RR(I-1,L,3) * DFBP(I-1,3) &
        &           + 1.0 * RR(I-1,L,4) * DFBP(I-1,4) &
        &           + 2.0 * RR(I  ,L,1) * DFTP(I  ,1) &
        &           + 2.0 * RR(I  ,L,2) * DFTP(I  ,2) &
        &           + 2.0 * RR(I  ,L,3) * DFTP(I  ,3) &
        &           + 2.0 * RR(I  ,L,4) * DFTP(I  ,4) &
        &           - 2.0 * RR(I  ,L,1) * DFBM(I  ,1) &
        &           - 2.0 * RR(I  ,L,2) * DFBM(I  ,2) &
        &           - 2.0 * RR(I  ,L,3) * DFBM(I  ,3) &
        &           - 2.0 * RR(I  ,L,4) * DFBM(I  ,4) &
        &           - 1.0 * RR(I+1,L,1) * DFTM(I+1,1) &
        &           - 1.0 * RR(I+1,L,2) * DFTM(I+1,2) &
        &           - 1.0 * RR(I+1,L,3) * DFTM(I+1,3) &
        &           - 1.0 * RR(I+1,L,4) * DFTM(I+1,4) &
        &         ) / 6.0
      ELSE
        ET(I,J,L) = ET(I,J,L) &
        &         + ( 1.0 * DFBP(I-1,L) + 2.0 * DFTP(I  ,L) &
        &           - 2.0 * DFBM(I  ,L) - 1.0 * DFTM(I+1,L) ) / 6.0
      ENDIF
    ENDIF
    ENDDO
    ENDDO
  ENDDO
  !$OMP END DO
  !$OMP END PARALLEL
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE TVDXI
!***********************************************************************
!**** TVD�X�L�[��(ET����)                                           ****
!***********************************************************************
SUBROUTINE TVDET
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, L
  REAL    :: AKX, AKY
  REAL    :: RWL, RWR, RWD, UM, VM, HM, CM
  REAL    :: THI, PHI, BETA, TIL, AKXT, AKYT, THIT, PH
  REAL    :: FSIGMA, FGAMMA, ABSA, AP, AM
  REAL    :: D3FP1, D3FP2, D3FP3, D3FM1, D3FM2, D3FM3
  REAL, ALLOCATABLE :: F(:, :), EIG(:, :)
  REAL, ALLOCATABLE :: RR(:, :, :), RI(:, :, :), EIGM(:, :), DELTA(:, :)
  REAL, ALLOCATABLE :: DU(:, :), DUR(:, :)
  REAL, ALLOCATABLE :: GG(:, :), PHIM(:, :)
  REAL, ALLOCATABLE :: DFP(:, :), DFM(:, :)
  REAL, ALLOCATABLE :: D3FP(:, :), D3FM(:, :)
  REAL, ALLOCATABLE :: DFBP(:, :), DFBM(:, :)
  REAL, ALLOCATABLE :: DFTP(:, :), DFTM(:, :)
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, L, &
!$OMP& AKX, AKY, RWL, RWR, RWD, UM, VM, HM, CM, &
!$OMP& THI, PHI, BETA, TIL, AKXT, AKYT, THIT, PH, &
!$OMP& FSIGMA, FGAMMA, ABSA, AP, AM, &
!$OMP& D3FP1, D3FP2, D3FP3, D3FM1, D3FM2, D3FM3, &
!$OMP& F, EIG, RR, RI, EIGM, DELTA, DU, DUR, &
!$OMP& GG, PHIM, DFP, DFM, D3FP, D3FM, &
!$OMP& DFBP, DFBM, DFTP, DFTM &
!$OMP& )
  ALLOCATE(F(JS: JE, LS: LE), EIG(JS: JE, LS: LE))
  ALLOCATE(RR(JS: JE - 1, LS: 4, LS: 4))
  ALLOCATE(RI(JS: JE - 1, LS: 4, LS: 4))
  ALLOCATE(EIGM(JS: JE - 1, LS: LE))
  ALLOCATE(DELTA(JS: JE - 1, LS: LE))
  ALLOCATE(DU(JS: JE - 1, LS: LE), DUR(JS: JE - 1, LS: LE))
  ALLOCATE(GG(JS: JE, LS: LE), PHIM(JS: JE - 1, LS: LE))
  ALLOCATE(DFP (JS    : JE - 1, LS: LE), DFM (JS    : JE - 1, LS: LE))
  ALLOCATE(D3FP(JS + 1: JE - 2, LS: LE), D3FM(JS + 1: JE - 2, LS: LE))
  ALLOCATE(DFBP(JS    : JE - 3, LS: LE), DFBM(JS + 1: JE - 2, LS: LE))
  ALLOCATE(DFTP(JS + 1: JE - 2, LS: LE), DFTM(JS + 2: JE - 1, LS: LE))
  !$OMP DO
  DO I = IS + 1, IE - 1
    ! �񎟐��x���S���� +++++++++++++++++++++++++++++++++++++++++++++++++
    DO J = JS, JE
    IF(QH(I,J,1) .GT. 0.0) THEN
      THI = ETX(I,J) * U(I,J) + ETY(I,J) * V(I,J)
      TIL = SQRT(ETX(I,J)**2 + ETY(I,J)**2)
      CM  = SQRT(GAMMA * RG * T(I,J))
      PH  = P(I,J) / AJA(I,J)
      F(J,1) = QH(I,J,1) * THI
      F(J,2) = QH(I,J,2) * THI + PH * ETX(I,J)
      F(J,3) = QH(I,J,3) * THI + PH * ETY(I,J)
      F(J,4) = QH(I,J,4) * THI + PH * THI
      DO L = 5, LE
        F(J,L) = QH(I,J,L) * THI
      ENDDO
      EIG(J,1) = THI
      EIG(J,2) = THI
      EIG(J,3) = THI + CM * TIL
      EIG(J,4) = THI - CM * TIL
      DO L = 5, LE
        EIG(J,L) = THI
      ENDDO
    ENDIF
    ENDDO
    ! ���l����
    DO L = LS, LE
    DO J = JS, JE - 1
    IF(QH(I,J,1) .GT. 0.0 .AND. QH(I,J+1,1) .GT. 0.0) THEN
      FT(I,J,L) = 0.5 * (F(J,L) + F(J+1,L))
    ENDIF
    ENDDO
    ENDDO
    IF(Order .EQ. 0) CYCLE
    ! �Ίp�� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    DO J = JS, JE - 1
    IF(QH(I,J,1) .GT. 0.0 .AND. QH(I,J+1,1) .GT. 0.0) THEN
      AKX  = 0.5 * (ETX(I,J) + ETX(I,J+1))
      AKY  = 0.5 * (ETY(I,J) + ETY(I,J+1))
      ! Roe ����
      RWD  = 1.0 / ( SQRT(QH(I,J  ,1) * AJA(I,J  )) &
      &            + SQRT(QH(I,J+1,1) * AJA(I,J+1)) )
      RWL  = SQRT(QH(I,J  ,1) * AJA(I,J  )) * RWD
      RWR  = SQRT(QH(I,J+1,1) * AJA(I,J+1)) * RWD
      UM   = RWL * U(I,J) + RWR * U(I,J+1)
      VM   = RWL * V(I,J) + RWR * V(I,J+1)
      HM   = RWL * ( &
      &        0.5 * (U(I,J  )**2 + V(I,J  )**2) &
      &      + GAMMA * RG / (GAMMA - 1.0) * T(I,J  ) &
      &    ) &
      &    + RWR * ( &
      &        0.5 * (U(I,J+1)**2 + V(I,J+1)**2) &
      &      + GAMMA * RG / (GAMMA - 1.0) * T(I,J+1) &
      &    )
      CM   = SQRT((GAMMA - 1.0) * (HM - 0.5 * (UM**2 + VM**2)))
      ! �Ίp��
      THI  = AKX * UM + AKY * VM
      PHI  = 0.5 * (GAMMA - 1.0) * (UM**2 + VM**2)
      BETA = 1.0 / (2.0 * CM**2)
      TIL  = SQRT(AKX**2 + AKY**2)
      AKXT = AKX / TIL
      AKYT = AKY / TIL
      THIT = AKXT * UM + AKYT * VM
      RR(J,1,1) = 1.0
      RR(J,2,1) = UM
      RR(J,3,1) = VM
      RR(J,4,1) = PHI / (GAMMA - 1.0)
      RR(J,1,2) = 0.0
      RR(J,2,2) = AKYT
      RR(J,3,2) =-AKXT
      RR(J,4,2) = AKYT * UM - AKXT * VM
      RR(J,1,3) = 1.0
      RR(J,2,3) = UM + AKXT * CM
      RR(J,3,3) = VM + AKYT * CM
      RR(J,4,3) = (PHI + CM**2) / (GAMMA - 1.0) + CM * THIT
      RR(J,1,4) = 1.0
      RR(J,2,4) = UM - AKXT * CM
      RR(J,3,4) = VM - AKYT * CM
      RR(J,4,4) = (PHI + CM**2) / (GAMMA - 1.0) - CM * THIT
      RI(J,1,1) = 1.0 - PHI / CM**2
      RI(J,2,1) =-AKYT * UM + AKXT * VM
      RI(J,3,1) = BETA * (PHI - CM * THIT)
      RI(J,4,1) = BETA * (PHI + CM * THIT)
      RI(J,1,2) = (GAMMA - 1.0) * UM / CM**2
      RI(J,2,2) = AKYT
      RI(J,3,2) = BETA * (AKXT * CM - (GAMMA - 1.0) * UM)
      RI(J,4,2) =-BETA * (AKXT * CM + (GAMMA - 1.0) * UM)
      RI(J,1,3) = (GAMMA - 1.0) * VM / CM**2
      RI(J,2,3) =-AKXT
      RI(J,3,3) = BETA * (AKYT * CM - (GAMMA - 1.0) * VM)
      RI(J,4,3) =-BETA * (AKYT * CM + (GAMMA - 1.0) * VM)
      RI(J,1,4) =-(GAMMA - 1.0) / CM**2
      RI(J,2,4) = 0.0
      RI(J,3,4) = BETA * (GAMMA - 1.0)
      RI(J,4,4) = BETA * (GAMMA - 1.0)
      EIGM(J,1) = THI
      EIGM(J,2) = THI
      EIGM(J,3) = THI + CM * TIL
      EIGM(J,4) = THI - CM * TIL
      DO L = 5, LE
        EIGM(J,L) = THI
      ENDDO
      DO L = LS, LE
        DELTA(J,L) = MAX( &
        &              0.0, &
        &              EIGM(J,L) - EIG(J,L), EIG(J+1,L) - EIGM(J,L) &
        &            ) + DEL * CM * TIL
      ENDDO
    ENDIF
    ENDDO
    ! Delta u
    DO L = LS, LE
    DO J = JS, JE - 1
    IF(QH(I,J,1) .GT. 0.0 .AND. QH(I,J+1,1) .GT. 0.0) THEN
      DU(J,L) = - QH(I,J  ,L) * AJA(I,J  ) &
      &         + QH(I,J+1,L) * AJA(I,J+1)
      DU(J,L) = DU(J,L) * 2.0 / (AJA(I,J) + AJA(I,J+1))
    ENDIF
    ENDDO
    ENDDO
    ! R^-1 Delta u
    DO L = LS, LE
    DO J = JS, JE - 1
    IF(QH(I,J,1) .GT. 0.0 .AND. QH(I,J+1,1) .GT. 0.0) THEN
      IF(L .LE. 4) THEN
        DUR(J,L) = RI(J,L,1) * DU(J,1) + RI(J,L,2) * DU(J,2) &
        &        + RI(J,L,3) * DU(J,3) + RI(J,L,4) * DU(J,4)
      ELSE
        DUR(J,L) = DU(J,L)
      ENDIF
    ENDIF
    ENDDO
    ENDDO
    ! �񎟐��xTVD�X�L�[�� ++++++++++++++++++++++++++++++++++++++++++++++
    IF(Order .EQ. 2) THEN
      ! g
      DO L = LS, LE
      J = JS
      IF(QH(I,J,1) .GT. 0.0 .AND. QH(I,J+1,1) .GT. 0.0) THEN
        GG(J,L) = DUR(J,L)
      ENDIF
      DO J = JS + 1, JE - 1
      IF(QH(I,J,1) .LE. 0.0) CYCLE
      IF(QH(I,J-1,1) .GT. 0.0 .AND. QH(I,J+1,1) .GT. 0.0) THEN
        GG(J,L) = minmod2(DUR(J,L), DUR(J-1,L))
      ELSEIF(QH(I,J-1,1) .GT. 0.0) THEN
        GG(J,L) = DUR(J-1,L)
      ELSEIF(QH(I,J+1,1) .GT. 0.0) THEN
        GG(J,L) = DUR(J,L)
      ENDIF
      ENDDO
      J = JE
      IF(QH(I,J-1,1) .GT. 0.0 .AND. QH(I,J,1) .GT. 0.0) THEN
        GG(J,L) = DUR(J-1,L)
      ENDIF
      ENDDO
      ! phi
      DO L = LS, LE
      DO J = JS, JE - 1
      IF(QH(I,J,1) .GT. 0.0 .AND. QH(I,J+1,1) .GT. 0.0) THEN
        FSIGMA = Func_sigma(Func_psi(EIGM(J,L), DELTA(J,L)))
        FGAMMA = Func_gamma(FSIGMA, GG(J,L), GG(J+1,L), DUR(J,L))
        PHIM(J,L) = FSIGMA * (GG(J,L) + GG(J+1,L)) &
        &         - Func_psi(EIGM(J,L) + FGAMMA, DELTA(J,L)) * DUR(J,L)
      ENDIF
      ENDDO
      ENDDO
      ! ���l����
      DO L = LS, LE
      DO J = JS, JE - 1
      IF(QH(I,J,1) .GT. 0.0 .AND. QH(I,J+1,1) .GT. 0.0) THEN
        IF(L .LE. 4) THEN
          FT(I,J,L) = FT(I,J,L) + 0.5 * ( RR(J,L,1) * PHIM(J,1) &
          &                             + RR(J,L,2) * PHIM(J,2) &
          &                             + RR(J,L,3) * PHIM(J,3) &
          &                             + RR(J,L,4) * PHIM(J,4) )
        ELSE
          FT(I,J,L) = FT(I,J,L) + 0.5 * PHIM(J,L)
        ENDIF
      ENDIF
      ENDDO
      ENDDO
      CYCLE
    ENDIF
    ! �ꎟ���x���㍷�� +++++++++++++++++++++++++++++++++++++++++++++++++
    ! Delta f^+-
    DO L = LS, LE
    DO J = JS, JE - 1
    IF(QH(I,J,1) .GT. 0.0 .AND. QH(I,J+1,1) .GT. 0.0) THEN
      ABSA  = Func_psi(EIGM(J,L), DELTA(J,L))
      AP    = 0.5 * (EIGM(J,L) + ABSA)
      AM    = 0.5 * (EIGM(J,L) - ABSA)
      DFP(J,L) = AP * DUR(J,L)
      DFM(J,L) = AM * DUR(J,L)
    ENDIF
    ENDDO
    ENDDO
    ! ���l����
    DO L = LS, LE
    DO J = JS, JE - 1
    IF(QH(I,J,1) .GT. 0.0 .AND. QH(I,J+1,1) .GT. 0.0) THEN
      IF(L .LE. 4) THEN
        FT(I,J,L) = FT(I,J,L) - 0.5 * ( RR(J,L,1) * DFP(J,1) &
        &                             + RR(J,L,2) * DFP(J,2) &
        &                             + RR(J,L,3) * DFP(J,3) &
        &                             + RR(J,L,4) * DFP(J,4) &
        &                             - RR(J,L,1) * DFM(J,1) &
        &                             - RR(J,L,2) * DFM(J,2) &
        &                             - RR(J,L,3) * DFM(J,3) &
        &                             - RR(J,L,4) * DFM(J,4) )
      ELSE
        FT(I,J,L) = FT(I,J,L) - 0.5 * (DFP(J,L) - DFM(J,L))
      ENDIF
    ENDIF
    ENDDO
    ENDDO
    IF(Order .EQ. 1) CYCLE
    ! �O��&�l�����xTVD�X�L�[�� +++++++++++++++++++++++++++++++++++++++++
    IF(Order .EQ. 4) THEN
      ! Delta^3 bar(f)^+-
      DO L = LS, LE
      DO J = JS + 1, JE - 2
      IF( QH(I,J-1,1) .GT. 0.0 .AND. QH(I,J  ,1) .GT. 0.0 .AND. &
      &   QH(I,J+1,1) .GT. 0.0 .AND. QH(I,J+2,1) .GT. 0.0 ) THEN
        D3FP1 = minmod3(DFP(J-1,L), b2 * DFP(J  ,L), b2 * DFP(J+1,L))
        D3FP2 = minmod3(DFP(J  ,L), b2 * DFP(J+1,L), b2 * DFP(J-1,L))
        D3FP3 = minmod3(DFP(J+1,L), b2 * DFP(J-1,L), b2 * DFP(J  ,L))
        D3FM1 = minmod3(DFM(J-1,L), b2 * DFM(J  ,L), b2 * DFM(J+1,L))
        D3FM2 = minmod3(DFM(J  ,L), b2 * DFM(J+1,L), b2 * DFM(J-1,L))
        D3FM3 = minmod3(DFM(J+1,L), b2 * DFM(J-1,L), b2 * DFM(J  ,L))
        D3FP(J,L) = D3FP1 - 2.0 * D3FP2 + D3FP3
        D3FM(J,L) = D3FM1 - 2.0 * D3FM2 + D3FM3
      ENDIF
      ENDDO
      ENDDO
      ! Delta^asterisk f^+-
      DO L = LS, LE
      DO J = JS + 1, JE - 2
      IF( QH(I,J-1,1) .GT. 0.0 .AND. QH(I,J  ,1) .GT. 0.0 .AND. &
      &   QH(I,J+1,1) .GT. 0.0 .AND. QH(I,J+2,1) .GT. 0.0 ) THEN
        DFP(J,L) = DFP(J,L) - D3FP(J,L) / 6.0
        DFM(J,L) = DFM(J,L) - D3FM(J,L) / 6.0
      ENDIF
      ENDDO
      ENDDO
    ENDIF
    ! Delta bar(f)^+-, Delta tilde(f)^+-
    DO L = LS, LE
    DO J = JS + 1, JE - 2
    IF( QH(I,J-1,1) .GT. 0.0 .AND. QH(I,J  ,1) .GT. 0.0 .AND. &
    &   QH(I,J+1,1) .GT. 0.0 .AND. QH(I,J+2,1) .GT. 0.0 ) THEN
      DFBP(J-1,L) = minmod2(DFP(J-1,L), b1 * DFP(J  ,L))
      DFBM(J  ,L) = minmod2(DFM(J  ,L), b1 * DFM(J+1,L))
      DFTP(J  ,L) = minmod2(DFP(J  ,L), b1 * DFP(J-1,L))
      DFTM(J+1,L) = minmod2(DFM(J+1,L), b1 * DFM(J  ,L))
    ENDIF
    ENDDO
    ENDDO
    ! ���l����
    DO L = LS, LE
    DO J = JS + 1, JE - 2
    IF( QH(I,J-1,1) .GT. 0.0 .AND. QH(I,J  ,1) .GT. 0.0 .AND. &
    &   QH(I,J+1,1) .GT. 0.0 .AND. QH(I,J+2,1) .GT. 0.0 ) THEN
      IF(L .LE. 4) THEN
        FT(I,J,L) = FT(I,J,L) &
        &         + ( 1.0 * RR(J-1,L,1) * DFBP(J-1,1) &
        &           + 1.0 * RR(J-1,L,2) * DFBP(J-1,2) &
        &           + 1.0 * RR(J-1,L,3) * DFBP(J-1,3) &
        &           + 1.0 * RR(J-1,L,4) * DFBP(J-1,4) &
        &           + 2.0 * RR(J  ,L,1) * DFTP(J  ,1) &
        &           + 2.0 * RR(J  ,L,2) * DFTP(J  ,2) &
        &           + 2.0 * RR(J  ,L,3) * DFTP(J  ,3) &
        &           + 2.0 * RR(J  ,L,4) * DFTP(J  ,4) &
        &           - 2.0 * RR(J  ,L,1) * DFBM(J  ,1) &
        &           - 2.0 * RR(J  ,L,2) * DFBM(J  ,2) &
        &           - 2.0 * RR(J  ,L,3) * DFBM(J  ,3) &
        &           - 2.0 * RR(J  ,L,4) * DFBM(J  ,4) &
        &           - 1.0 * RR(J+1,L,1) * DFTM(J+1,1) &
        &           - 1.0 * RR(J+1,L,2) * DFTM(J+1,2) &
        &           - 1.0 * RR(J+1,L,3) * DFTM(J+1,3) &
        &           - 1.0 * RR(J+1,L,4) * DFTM(J+1,4) &
        &         ) / 6.0
      ELSE
        FT(I,J,L) = FT(I,J,L) &
        &         + ( 1.0 * DFBP(J-1,L) + 2.0 * DFTP(J  ,L) &
        &           - 2.0 * DFBM(J  ,L) - 1.0 * DFTM(J+1,L) ) / 6.0
      ENDIF
    ENDIF
    ENDDO
    ENDDO
  ENDDO
  !$OMP END DO
  !$OMP END PARALLEL
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE TVDET
! ��`�I�� *************************************************************
END SUBROUTINE Convection2D
!***********************************************************************
!**** �Η����v�Z                                                    ****
!**** �v�Z�Ώ� : �P��, �O����, ���k��                               ****
!**** �v�Z�X�L�[�� : �񎟐��x���S����                               ****
!****                �ꎟ���x���㍷��                               ****
!****                �񎟐��xTVD�X�L�[�� (Yee-Harten)               ****
!****                �O�����xTVD�X�L�[�� (Chakravarthy-Osher)       ****
!****                �l�����xTVD�X�L�[�� (Yamamoto-Daiguji)         ****
!***********************************************************************
SUBROUTINE Convection3D( &
&            Order, DEL, RG, GAMMA, &
&            IS, IE, JS, JE, KS, KE, LS, LE, &
&            XIX, XIY, XIZ, ETX, ETY, ETZ, ZEX, ZEY, ZEZ, AJA, &
&            QH, U, V, W, P, T, &
&            DQC &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, PARAMETER :: b1 = 4.0, b2 = 2.0
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: Order
  REAL,    INTENT(IN)  :: DEL
  REAL,    INTENT(IN)  :: RG, GAMMA
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE, KS, KE
  INTEGER, INTENT(IN)  :: LS, LE
  REAL,    INTENT(IN)  :: XIX(IS: IE, JS: JE, KS: KE), &
  &                       XIY(IS: IE, JS: JE, KS: KE), &
  &                       XIZ(IS: IE, JS: JE, KS: KE), &
  &                       ETX(IS: IE, JS: JE, KS: KE), &
  &                       ETY(IS: IE, JS: JE, KS: KE), &
  &                       ETZ(IS: IE, JS: JE, KS: KE), &
  &                       ZEX(IS: IE, JS: JE, KS: KE), &
  &                       ZEY(IS: IE, JS: JE, KS: KE), &
  &                       ZEZ(IS: IE, JS: JE, KS: KE), &
  &                       AJA(IS: IE, JS: JE, KS: KE)
  REAL,    INTENT(IN)  :: QH(IS: IE, JS: JE, KS: KE, LS: LE)
  REAL,    INTENT(IN)  :: U(IS: IE, JS: JE, KS: KE), &
  &                       V(IS: IE, JS: JE, KS: KE), &
  &                       W(IS: IE, JS: JE, KS: KE), &
  &                       P(IS: IE, JS: JE, KS: KE), &
  &                       T(IS: IE, JS: JE, KS: KE)
  REAL,    INTENT(OUT) :: DQC(IS: IE, JS: JE, KS: KE, LS: LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K, L
  REAL, ALLOCATABLE :: ET(:, :, :, :), FT(:, :, :, :), GT(:, :, :, :)
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 5) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �������m�� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ALLOCATE(ET(IS: IE, JS: JE, KS: KE, LS: LE))
  ALLOCATE(FT(IS: IE, JS: JE, KS: KE, LS: LE))
  ALLOCATE(GT(IS: IE, JS: JE, KS: KE, LS: LE))
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ET (:, :, :, :) = 0.0
  FT (:, :, :, :) = 0.0
  GT (:, :, :, :) = 0.0
  DQC(:, :, :, :) = 0.0
  ! �e�����̋�ԍ��� +++++++++++++++++++++++++++++++++++++++++++++++++++
  CALL TVDXI
  CALL TVDET
  CALL TVDZE
  ! �Η����x�N�g���̋�ԍ��� +++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE(I, J, K, L)
  DO L = LS, LE
  !$OMP DO
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( ( QH(I  ,J  ,K-1,1) .GT. 0.0 ) .AND. &
  &   ( QH(I  ,J-1,K  ,1) .GT. 0.0 ) .AND. &
  &   ( QH(I-1,J  ,K  ,1) .GT. 0.0 ) .AND. &
  &   ( QH(I  ,J  ,K  ,1) .GT. 0.0 ) .AND. &
  &   ( QH(I+1,J  ,K  ,1) .GT. 0.0 ) .AND. &
  &   ( QH(I  ,J+1,K  ,1) .GT. 0.0 ) .AND. &
  &   ( QH(I  ,J  ,K+1,1) .GT. 0.0 ) &
  & ) THEN
    DQC(I,J,K,L) = ET(I-1,J  ,K  ,L) - ET(I,J,K,L) &
    &            + FT(I  ,J-1,K  ,L) - FT(I,J,K,L) &
    &            + GT(I  ,J  ,K-1,L) - GT(I,J,K,L)
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END DO
  ENDDO
  !$OMP END PARALLEL
  ! ��������� =========================================================
  DEALLOCATE(ET,FT,GT)
  ! �����I�� ***********************************************************
  RETURN
! �����葱�� ***********************************************************
CONTAINS
!***********************************************************************
!**** TVD�X�L�[��(XI����)                                           ****
!***********************************************************************
SUBROUTINE TVDXI
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K, L
  REAL    :: AKX, AKY, AKZ
  REAL    :: RWL, RWR, RWD, UM, VM, WM, HM, CM
  REAL    :: THI, PHI, BETA, TIL, AKXT, AKYT, AKZT, THIT, PH
  REAL    :: FSIGMA, FGAMMA, ABSA, AP, AM
  REAL    :: D3FP1, D3FP2, D3FP3, D3FM1, D3FM2, D3FM3
  REAL, ALLOCATABLE :: F(:, :), EIG(:, :)
  REAL, ALLOCATABLE :: RR(:, :, :), RI(:, :, :), EIGM(:, :), DELTA(:, :)
  REAL, ALLOCATABLE :: DU(:, :), DUR(:, :)
  REAL, ALLOCATABLE :: GG(:, :), PHIM(:, :)
  REAL, ALLOCATABLE :: DFP(:, :), DFM(:, :)
  REAL, ALLOCATABLE :: D3FP(:, :), D3FM(:, :)
  REAL, ALLOCATABLE :: DFBP(:, :), DFBM(:, :)
  REAL, ALLOCATABLE :: DFTP(:, :), DFTM(:, :)
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, L, &
!$OMP& AKX, AKY, AKZ, RWL, RWR, RWD, UM, VM, WM, HM, CM, &
!$OMP& THI, PHI, BETA, TIL, AKXT, AKYT, AKZT, THIT, PH, &
!$OMP& FSIGMA, FGAMMA, ABSA, AP, AM, &
!$OMP& D3FP1, D3FP2, D3FP3, D3FM1, D3FM2, D3FM3, &
!$OMP& F, EIG, RR, RI, EIGM, DELTA, DU, DUR, &
!$OMP& GG, PHIM, DFP, DFM, D3FP, D3FM, &
!$OMP& DFBP, DFBM, DFTP, DFTM &
!$OMP& )
  ALLOCATE(F(IS: IE, LS: LE), EIG(IS: IE, LS: LE))
  ALLOCATE(RR(IS: IE - 1, LS: 5, LS: 5))
  ALLOCATE(RI(IS: IE - 1, LS: 5, LS: 5))
  ALLOCATE(EIGM(IS: IE - 1, LS: LE))
  ALLOCATE(DELTA(IS: IE - 1, LS: LE))
  ALLOCATE(DU(IS: IE - 1, LS: LE), DUR(IS: IE - 1, LS: LE))
  ALLOCATE(GG(IS: IE, LS: LE), PHIM(IS: IE - 1, LS: LE))
  ALLOCATE(DFP (IS    : IE - 1, LS: LE), DFM (IS    : IE - 1, LS: LE))
  ALLOCATE(D3FP(IS + 1: IE - 2, LS: LE), D3FM(IS + 1: IE - 2, LS: LE))
  ALLOCATE(DFBP(IS    : IE - 3, LS: LE), DFBM(IS + 1: IE - 2, LS: LE))
  ALLOCATE(DFTP(IS + 1: IE - 2, LS: LE), DFTM(IS + 2: IE - 1, LS: LE))
  !$OMP DO
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
    ! �񎟐��x���S���� +++++++++++++++++++++++++++++++++++++++++++++++++
    DO I = IS, IE
    IF(QH(I,J,K,1) .GT. 0.0) THEN
      THI = XIX(I,J,K) * U(I,J,K) &
      &   + XIY(I,J,K) * V(I,J,K) &
      &   + XIZ(I,J,K) * W(I,J,K)
      TIL = SQRT(XIX(I,J,K)**2 + XIY(I,J,K)**2 + XIZ(I,J,K)**2)
      CM  = SQRT(GAMMA * RG * T(I,J,K))
      PH  = P(I,J,K) / AJA(I,J,K)
      F(I,1) = QH(I,J,K,1) * THI
      F(I,2) = QH(I,J,K,2) * THI + PH * XIX(I,J,K)
      F(I,3) = QH(I,J,K,3) * THI + PH * XIY(I,J,K)
      F(I,4) = QH(I,J,K,4) * THI + PH * XIZ(I,J,K)
      F(I,5) = QH(I,J,K,5) * THI + PH * THI
      DO L = 6, LE
        F(I,L) = QH(I,J,K,L) * THI
      ENDDO
      EIG(I,1) = THI
      EIG(I,2) = THI
      EIG(I,3) = THI
      EIG(I,4) = THI + CM * TIL
      EIG(I,5) = THI - CM * TIL
      DO L = 6, LE
        EIG(I,L) = THI
      ENDDO
    ENDIF
    ENDDO
    ! ���l����
    DO L = LS, LE
    DO I = IS, IE - 1
    IF(QH(I,J,K,1) .GT. 0.0 .AND. QH(I+1,J,K,1) .GT. 0.0) THEN
      ET(I,J,K,L) = 0.5 * (F(I,L) + F(I+1,L))
    ENDIF
    ENDDO
    ENDDO
    IF(Order .EQ. 0) CYCLE
    ! �Ίp�� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    DO I = IS, IE - 1
    IF(QH(I,J,K,1) .GT. 0.0 .AND. QH(I+1,J,K,1) .GT. 0.0) THEN
      AKX  = 0.5 * (XIX(I,J,K) + XIX(I+1,J,K))
      AKY  = 0.5 * (XIY(I,J,K) + XIY(I+1,J,K))
      AKZ  = 0.5 * (XIZ(I,J,K) + XIZ(I+1,J,K))
      ! Roe ����
      RWD  = 1.0 / ( SQRT(QH(I  ,J,K,1) * AJA(I  ,J,K)) &
      &            + SQRT(QH(I+1,J,K,1) * AJA(I+1,J,K)) )
      RWL  = SQRT(QH(I  ,J,K,1) * AJA(I  ,J,K)) * RWD
      RWR  = SQRT(QH(I+1,J,K,1) * AJA(I+1,J,K)) * RWD
      UM   = RWL * U(I,J,K) + RWR * U(I+1,J,K)
      VM   = RWL * V(I,J,K) + RWR * V(I+1,J,K)
      WM   = RWL * W(I,J,K) + RWR * W(I+1,J,K)
      HM   = RWL * ( &
      &        0.5 * (U(I  ,J,K)**2 + V(I  ,J,K)**2 + W(I  ,J,K)**2) &
      &      + GAMMA * RG / (GAMMA - 1.0) * T(I  ,J,K) &
      &    ) &
      &    + RWR * ( &
      &        0.5 * (U(I+1,J,K)**2 + V(I+1,J,K)**2 + W(I+1,J,K)**2) &
      &      + GAMMA * RG / (GAMMA - 1.0) * T(I+1,J,K) &
      &    )
      CM   = SQRT((GAMMA - 1.0) * (HM - 0.5 * (UM**2 + VM**2 + WM**2)))
      ! �Ίp��
      THI  = AKX * UM + AKY * VM + AKZ * WM
      PHI  = 0.5 * (GAMMA - 1.0) * (UM**2 + VM**2 + WM**2)
      BETA = 1.0 / (2.0 * CM**2)
      TIL  = SQRT(AKX**2 + AKY**2 + AKZ**2)
      AKXT = AKX / TIL
      AKYT = AKY / TIL
      AKZT = AKZ / TIL
      THIT = AKXT * UM + AKYT * VM + AKZT * WM
      RR(I,1,1) = AKXT
      RR(I,2,1) = AKXT * UM
      RR(I,3,1) = AKXT * VM + AKZT
      RR(I,4,1) = AKXT * WM - AKYT
      RR(I,5,1) = AKXT * PHI / (GAMMA - 1.0) + AKZT * VM - AKYT * WM
      RR(I,1,2) = AKYT
      RR(I,2,2) = AKYT * UM - AKZT
      RR(I,3,2) = AKYT * VM
      RR(I,4,2) = AKYT * WM + AKXT
      RR(I,5,2) = AKYT * PHI / (GAMMA - 1.0) + AKXT * WM - AKZT * UM
      RR(I,1,3) = AKZT
      RR(I,2,3) = AKZT * UM + AKYT
      RR(I,3,3) = AKZT * VM - AKXT
      RR(I,4,3) = AKZT * WM
      RR(I,5,3) = AKZT * PHI / (GAMMA - 1.0) + AKYT * UM - AKXT * VM
      RR(I,1,4) = 1.0
      RR(I,2,4) = UM + AKXT * CM
      RR(I,3,4) = VM + AKYT * CM
      RR(I,4,4) = WM + AKZT * CM
      RR(I,5,4) = (PHI + CM**2) / (GAMMA - 1.0) + CM * THIT
      RR(I,1,5) = 1.0
      RR(I,2,5) = UM - AKXT * CM
      RR(I,3,5) = VM - AKYT * CM
      RR(I,4,5) = WM - AKZT * CM
      RR(I,5,5) = (PHI + CM**2) / (GAMMA - 1.0) - CM * THIT
      RI(I,1,1) = AKXT - AKXT * PHI / CM**2 + AKYT * WM - AKZT * VM
      RI(I,2,1) = AKYT - AKYT * PHI / CM**2 + AKZT * UM - AKXT * WM
      RI(I,3,1) = AKZT - AKZT * PHI / CM**2 + AKXT * VM - AKYT * UM
      RI(I,4,1) = BETA * (PHI - CM * THIT)
      RI(I,5,1) = BETA * (PHI + CM * THIT)
      RI(I,1,2) = (GAMMA - 1.0) * AKXT * UM / CM**2
      RI(I,2,2) = (GAMMA - 1.0) * AKYT * UM / CM**2 - AKZT
      RI(I,3,2) = (GAMMA - 1.0) * AKZT * UM / CM**2 + AKYT
      RI(I,4,2) = BETA * (AKXT * CM - (GAMMA - 1.0) * UM)
      RI(I,5,2) =-BETA * (AKXT * CM + (GAMMA - 1.0) * UM)
      RI(I,1,3) = (GAMMA - 1.0) * AKXT * VM / CM**2 + AKZT
      RI(I,2,3) = (GAMMA - 1.0) * AKYT * VM / CM**2
      RI(I,3,3) = (GAMMA - 1.0) * AKZT * VM / CM**2 - AKXT
      RI(I,4,3) = BETA * (AKYT * CM - (GAMMA - 1.0) * VM)
      RI(I,5,3) =-BETA * (AKYT * CM + (GAMMA - 1.0) * VM)
      RI(I,1,4) = (GAMMA - 1.0) * AKXT * WM / CM**2 - AKYT
      RI(I,2,4) = (GAMMA - 1.0) * AKYT * WM / CM**2 + AKXT
      RI(I,3,4) = (GAMMA - 1.0) * AKZT * WM / CM**2
      RI(I,4,4) = BETA * (AKZT * CM - (GAMMA - 1.0) * WM)
      RI(I,5,4) =-BETA * (AKZT * CM + (GAMMA - 1.0) * WM)
      RI(I,1,5) =-(GAMMA - 1.0) * AKXT / CM**2
      RI(I,2,5) =-(GAMMA - 1.0) * AKYT / CM**2
      RI(I,3,5) =-(GAMMA - 1.0) * AKZT / CM**2
      RI(I,4,5) = BETA * (GAMMA - 1.0)
      RI(I,5,5) = BETA * (GAMMA - 1.0)
      EIGM(I,1) = THI
      EIGM(I,2) = THI
      EIGM(I,3) = THI
      EIGM(I,4) = THI + CM * TIL
      EIGM(I,5) = THI - CM * TIL
      DO L = 6, LE
        EIGM(I,L) = THI
      ENDDO
      DO L = LS, LE
        DELTA(I,L) = MAX( &
        &              0.0, &
        &              EIGM(I,L) - EIG(I,L), EIG(I+1,L) - EIGM(I,L) &
        &            ) + DEL * CM * TIL
      ENDDO
    ENDIF
    ENDDO
    ! Delta u
    DO L = LS, LE
    DO I = IS, IE - 1
    IF(QH(I,J,K,1) .GT. 0.0 .AND. QH(I+1,J,K,1) .GT. 0.0) THEN
      DU(I,L) = - QH(I  ,J,K,L) * AJA(I  ,J,K) &
      &         + QH(I+1,J,K,L) * AJA(I+1,J,K)
      DU(I,L) = DU(I,L) * 2.0 / (AJA(I,J,K) + AJA(I+1,J,K))
    ENDIF
    ENDDO
    ENDDO
    ! R^-1 Delta u
    DO L = LS, LE
    DO I = IS, IE - 1
    IF(QH(I,J,K,1) .GT. 0.0 .AND. QH(I+1,J,K,1) .GT. 0.0) THEN
      IF(L .LE. 5) THEN
        DUR(I,L) = RI(I,L,1) * DU(I,1) + RI(I,L,2) * DU(I,2) &
        &        + RI(I,L,3) * DU(I,3) + RI(I,L,4) * DU(I,4) &
        &        + RI(I,L,5) * DU(I,5)
      ELSE
        DUR(I,L) = DU(I,L)
      ENDIF
    ENDIF
    ENDDO
    ENDDO
    ! �񎟐��xTVD�X�L�[�� ++++++++++++++++++++++++++++++++++++++++++++++
    IF(Order .EQ. 2) THEN
      ! g
      DO L = LS, LE
      I = IS
      IF(QH(I,J,K,1) .GT. 0.0 .AND. QH(I+1,J,K,1) .GT. 0.0) THEN
        GG(I,L) = DUR(I,L)
      ENDIF
      DO I = IS + 1, IE - 1
      IF(QH(I,J,K,1) .LE. 0.0) CYCLE
      IF(QH(I-1,J,K,1) .GT. 0.0 .AND. QH(I+1,J,K,1) .GT. 0.0) THEN
        GG(I,L) = minmod2(DUR(I,L), DUR(I-1,L))
      ELSEIF(QH(I-1,J,K,1) .GT. 0.0) THEN
        GG(I,L) = DUR(I-1,L)
      ELSEIF(QH(I+1,J,K,1) .GT. 0.0) THEN
        GG(I,L) = DUR(I,L)
      ENDIF
      ENDDO
      I = IE
      IF(QH(I-1,J,K,1) .GT. 0.0 .AND. QH(I,J,K,1) .GT. 0.0) THEN
        GG(I,L) = DUR(I-1,L)
      ENDIF
      ENDDO
      ! phi
      DO L = LS, LE
      DO I = IS, IE - 1
      IF(QH(I,J,K,1) .GT. 0.0 .AND. QH(I+1,J,K,1) .GT. 0.0) THEN
        FSIGMA = Func_sigma(Func_psi(EIGM(I,L), DELTA(I,L)))
        FGAMMA = Func_gamma(FSIGMA, GG(I,L), GG(I+1,L), DUR(I,L))
        PHIM(I,L) = FSIGMA * (GG(I,L) + GG(I+1,L)) &
        &         - Func_psi(EIGM(I,L) + FGAMMA, DELTA(I,L)) * DUR(I,L)
      ENDIF
      ENDDO
      ENDDO
      ! ���l����
      DO L = LS, LE
      DO I = IS, IE - 1
      IF(QH(I,J,K,1) .GT. 0.0 .AND. QH(I+1,J,K,1) .GT. 0.0) THEN
        IF(L .LE. 5) THEN
          ET(I,J,K,L) = ET(I,J,K,L) + 0.5 * ( RR(I,L,1) * PHIM(I,1) &
          &                                 + RR(I,L,2) * PHIM(I,2) &
          &                                 + RR(I,L,3) * PHIM(I,3) &
          &                                 + RR(I,L,4) * PHIM(I,4) &
          &                                 + RR(I,L,5) * PHIM(I,5) )
        ELSE
          ET(I,J,K,L) = ET(I,J,K,L) + 0.5 * PHIM(I,L)
        ENDIF
      ENDIF
      ENDDO
      ENDDO
      CYCLE
    ENDIF
    ! �ꎟ���x���㍷�� +++++++++++++++++++++++++++++++++++++++++++++++++
    ! Delta f^+-
    DO L = LS, LE
    DO I = IS, IE - 1
    IF(QH(I,J,K,1) .GT. 0.0 .AND. QH(I+1,J,K,1) .GT. 0.0) THEN
      ABSA  = Func_psi(EIGM(I,L), DELTA(I,L))
      AP    = 0.5 * (EIGM(I,L) + ABSA)
      AM    = 0.5 * (EIGM(I,L) - ABSA)
      DFP(I,L) = AP * DUR(I,L)
      DFM(I,L) = AM * DUR(I,L)
    ENDIF
    ENDDO
    ENDDO
    ! ���l����
    DO L = LS, LE
    DO I = IS, IE - 1
    IF(QH(I,J,K,1) .GT. 0.0 .AND. QH(I+1,J,K,1) .GT. 0.0) THEN
      IF(L .LE. 5) THEN
        ET(I,J,K,L) = ET(I,J,K,L) - 0.5 * ( RR(I,L,1) * DFP(I,1) &
        &                                 + RR(I,L,2) * DFP(I,2) &
        &                                 + RR(I,L,3) * DFP(I,3) &
        &                                 + RR(I,L,4) * DFP(I,4) &
        &                                 + RR(I,L,5) * DFP(I,5) &
        &                                 - RR(I,L,1) * DFM(I,1) &
        &                                 - RR(I,L,2) * DFM(I,2) &
        &                                 - RR(I,L,3) * DFM(I,3) &
        &                                 - RR(I,L,4) * DFM(I,4) &
        &                                 - RR(I,L,5) * DFM(I,5) )
      ELSE
        ET(I,J,K,L) = ET(I,J,K,L) - 0.5 * (DFP(I,L) - DFM(I,L))
      ENDIF
    ENDIF
    ENDDO
    ENDDO
    IF(Order .EQ. 1) CYCLE
    ! �O��&�l�����xTVD�X�L�[�� +++++++++++++++++++++++++++++++++++++++++
    IF(Order .EQ. 4) THEN
      ! Delta^3 bar(f)^+-
      DO L = LS, LE
      DO I = IS + 1, IE - 2
      IF( QH(I-1,J,K,1) .GT. 0.0 .AND. QH(I  ,J,K,1) .GT. 0.0 .AND. &
      &   QH(I+1,J,K,1) .GT. 0.0 .AND. QH(I+2,J,K,1) .GT. 0.0 ) THEN
        D3FP1 = minmod3(DFP(I-1,L), b2 * DFP(I  ,L), b2 * DFP(I+1,L))
        D3FP2 = minmod3(DFP(I  ,L), b2 * DFP(I+1,L), b2 * DFP(I-1,L))
        D3FP3 = minmod3(DFP(I+1,L), b2 * DFP(I-1,L), b2 * DFP(I  ,L))
        D3FM1 = minmod3(DFM(I-1,L), b2 * DFM(I  ,L), b2 * DFM(I+1,L))
        D3FM2 = minmod3(DFM(I  ,L), b2 * DFM(I+1,L), b2 * DFM(I-1,L))
        D3FM3 = minmod3(DFM(I+1,L), b2 * DFM(I-1,L), b2 * DFM(I  ,L))
        D3FP(I,L) = D3FP1 - 2.0 * D3FP2 + D3FP3
        D3FM(I,L) = D3FM1 - 2.0 * D3FM2 + D3FM3
      ENDIF
      ENDDO
      ENDDO
      ! Delta^asterisk f^+-
      DO L = LS, LE
      DO I = IS + 1, IE - 2
      IF( QH(I-1,J,K,1) .GT. 0.0 .AND. QH(I  ,J,K,1) .GT. 0.0 .AND. &
      &   QH(I+1,J,K,1) .GT. 0.0 .AND. QH(I+2,J,K,1) .GT. 0.0 ) THEN
        DFP(I,L) = DFP(I,L) - D3FP(I,L) / 6.0
        DFM(I,L) = DFM(I,L) - D3FM(I,L) / 6.0
      ENDIF
      ENDDO
      ENDDO
    ENDIF
    ! Delta bar(f)^+-, Delta tilde(f)^+-
    DO L = LS, LE
    DO I = IS + 1, IE - 2
    IF( QH(I-1,J,K,1) .GT. 0.0 .AND. QH(I  ,J,K,1) .GT. 0.0 .AND. &
    &   QH(I+1,J,K,1) .GT. 0.0 .AND. QH(I+2,J,K,1) .GT. 0.0 ) THEN
      DFBP(I-1,L) = minmod2(DFP(I-1,L), b1 * DFP(I  ,L))
      DFBM(I  ,L) = minmod2(DFM(I  ,L), b1 * DFM(I+1,L))
      DFTP(I  ,L) = minmod2(DFP(I  ,L), b1 * DFP(I-1,L))
      DFTM(I+1,L) = minmod2(DFM(I+1,L), b1 * DFM(I  ,L))
    ENDIF
    ENDDO
    ENDDO
    ! ���l����
    DO L = LS, LE
    DO I = IS + 1, IE - 2
    IF( QH(I-1,J,K,1) .GT. 0.0 .AND. QH(I  ,J,K,1) .GT. 0.0 .AND. &
    &   QH(I+1,J,K,1) .GT. 0.0 .AND. QH(I+2,J,K,1) .GT. 0.0 ) THEN
      IF(L .LE. 5) THEN
        ET(I,J,K,L) = ET(I,J,K,L) &
        &           + ( 1.0 * RR(I-1,L,1) * DFBP(I-1,1) &
        &             + 1.0 * RR(I-1,L,2) * DFBP(I-1,2) &
        &             + 1.0 * RR(I-1,L,3) * DFBP(I-1,3) &
        &             + 1.0 * RR(I-1,L,4) * DFBP(I-1,4) &
        &             + 1.0 * RR(I-1,L,5) * DFBP(I-1,5) &
        &             + 2.0 * RR(I  ,L,1) * DFTP(I  ,1) &
        &             + 2.0 * RR(I  ,L,2) * DFTP(I  ,2) &
        &             + 2.0 * RR(I  ,L,3) * DFTP(I  ,3) &
        &             + 2.0 * RR(I  ,L,4) * DFTP(I  ,4) &
        &             + 2.0 * RR(I  ,L,5) * DFTP(I  ,5) &
        &             - 2.0 * RR(I  ,L,1) * DFBM(I  ,1) &
        &             - 2.0 * RR(I  ,L,2) * DFBM(I  ,2) &
        &             - 2.0 * RR(I  ,L,3) * DFBM(I  ,3) &
        &             - 2.0 * RR(I  ,L,4) * DFBM(I  ,4) &
        &             - 2.0 * RR(I  ,L,5) * DFBM(I  ,5) &
        &             - 1.0 * RR(I+1,L,1) * DFTM(I+1,1) &
        &             - 1.0 * RR(I+1,L,2) * DFTM(I+1,2) &
        &             - 1.0 * RR(I+1,L,3) * DFTM(I+1,3) &
        &             - 1.0 * RR(I+1,L,4) * DFTM(I+1,4) &
        &             - 1.0 * RR(I+1,L,5) * DFTM(I+1,5) &
        &           ) / 6.0
      ELSE
        ET(I,J,K,L) = ET(I,J,K,L) &
        &           + ( 1.0 * DFBP(I-1,L) + 2.0 * DFTP(I  ,L) &
        &             - 2.0 * DFBM(I  ,L) - 1.0 * DFTM(I+1,L) ) / 6.0
      ENDIF
    ENDIF
    ENDDO
    ENDDO
  ENDDO
  ENDDO
  !$OMP END DO
  ! ��������� =========================================================
  DEALLOCATE(F,EIG,RR,RI,EIGM,DELTA,DU,DUR,GG,PHIM,DFP,DFM,D3FP,D3FM,DFBP,DFBM,DFTP,DFTM)
  !$OMP END PARALLEL
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE TVDXI
!***********************************************************************
!**** TVD�X�L�[��(ET����)                                           ****
!***********************************************************************
SUBROUTINE TVDET
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K, L
  REAL    :: AKX, AKY, AKZ
  REAL    :: RWL, RWR, RWD, UM, VM, WM, HM, CM
  REAL    :: THI, PHI, BETA, TIL, AKXT, AKYT, AKZT, THIT, PH
  REAL    :: FSIGMA, FGAMMA, ABSA, AP, AM
  REAL    :: D3FP1, D3FP2, D3FP3, D3FM1, D3FM2, D3FM3
  REAL, ALLOCATABLE :: F(:, :), EIG(:, :)
  REAL, ALLOCATABLE :: RR(:, :, :), RI(:, :, :), EIGM(:, :), DELTA(:, :)
  REAL, ALLOCATABLE :: DU(:, :), DUR(:, :)
  REAL, ALLOCATABLE :: GG(:, :), PHIM(:, :)
  REAL, ALLOCATABLE :: DFP(:, :), DFM(:, :)
  REAL, ALLOCATABLE :: D3FP(:, :), D3FM(:, :)
  REAL, ALLOCATABLE :: DFBP(:, :), DFBM(:, :)
  REAL, ALLOCATABLE :: DFTP(:, :), DFTM(:, :)
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, L, &
!$OMP& AKX, AKY, AKZ, RWL, RWR, RWD, UM, VM, WM, HM, CM, &
!$OMP& THI, PHI, BETA, TIL, AKXT, AKYT, AKZT, THIT, PH, &
!$OMP& FSIGMA, FGAMMA, ABSA, AP, AM, &
!$OMP& D3FP1, D3FP2, D3FP3, D3FM1, D3FM2, D3FM3, &
!$OMP& F, EIG, RR, RI, EIGM, DELTA, DU, DUR, &
!$OMP& GG, PHIM, DFP, DFM, D3FP, D3FM, &
!$OMP& DFBP, DFBM, DFTP, DFTM &
!$OMP& )
  ALLOCATE(F(JS: JE, LS: LE), EIG(JS: JE, LS: LE))
  ALLOCATE(RR(JS: JE - 1, LS: 5, LS: 5))
  ALLOCATE(RI(JS: JE - 1, LS: 5, LS: 5))
  ALLOCATE(EIGM(JS: JE - 1, LS: LE))
  ALLOCATE(DELTA(JS: JE - 1, LS: LE))
  ALLOCATE(DU(JS: JE - 1, LS: LE), DUR(JS: JE - 1, LS: LE))
  ALLOCATE(GG(JS: JE, LS: LE), PHIM(JS: JE - 1, LS: LE))
  ALLOCATE(DFP (JS    : JE - 1, LS: LE), DFM (JS    : JE - 1, LS: LE))
  ALLOCATE(D3FP(JS + 1: JE - 2, LS: LE), D3FM(JS + 1: JE - 2, LS: LE))
  ALLOCATE(DFBP(JS    : JE - 3, LS: LE), DFBM(JS + 1: JE - 2, LS: LE))
  ALLOCATE(DFTP(JS + 1: JE - 2, LS: LE), DFTM(JS + 2: JE - 1, LS: LE))
  !$OMP DO
  DO K = KS + 1, KE - 1
  DO I = IS + 1, IE - 1
    ! �񎟐��x���S���� +++++++++++++++++++++++++++++++++++++++++++++++++
    DO J = JS, JE
    IF(QH(I,J,K,1) .GT. 0.0) THEN
      THI = ETX(I,J,K) * U(I,J,K) &
      &   + ETY(I,J,K) * V(I,J,K) &
      &   + ETZ(I,J,K) * W(I,J,K)
      TIL = SQRT(ETX(I,J,K)**2 + ETY(I,J,K)**2 + ETZ(I,J,K)**2)
      CM  = SQRT(GAMMA * RG * T(I,J,K))
      PH  = P(I,J,K) / AJA(I,J,K)
      F(J,1) = QH(I,J,K,1) * THI
      F(J,2) = QH(I,J,K,2) * THI + PH * ETX(I,J,K)
      F(J,3) = QH(I,J,K,3) * THI + PH * ETY(I,J,K)
      F(J,4) = QH(I,J,K,4) * THI + PH * ETZ(I,J,K)
      F(J,5) = QH(I,J,K,5) * THI + PH * THI
      DO L = 6, LE
        F(J,L) = QH(I,J,K,L) * THI
      ENDDO
      EIG(J,1) = THI
      EIG(J,2) = THI
      EIG(J,3) = THI
      EIG(J,4) = THI + CM * TIL
      EIG(J,5) = THI - CM * TIL
      DO L = 6, LE
        EIG(J,L) = THI
      ENDDO
    ENDIF
    ENDDO
    ! ���l����
    DO L = LS, LE
    DO J = JS, JE - 1
    IF(QH(I,J,K,1) .GT. 0.0 .AND. QH(I,J+1,K,1) .GT. 0.0) THEN
      FT(I,J,K,L) = 0.5 * (F(J,L) + F(J+1,L))
    ENDIF
    ENDDO
    ENDDO
    IF(Order .EQ. 0) CYCLE
    ! �Ίp�� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    DO J = JS, JE - 1
    IF(QH(I,J,K,1) .GT. 0.0 .AND. QH(I,J+1,K,1) .GT. 0.0) THEN
      AKX  = 0.5 * (ETX(I,J,K) + ETX(I,J+1,K))
      AKY  = 0.5 * (ETY(I,J,K) + ETY(I,J+1,K))
      AKZ  = 0.5 * (ETZ(I,J,K) + ETZ(I,J+1,K))
      ! Roe ����
      RWD  = 1.0 / ( SQRT(QH(I,J  ,K,1) * AJA(I,J  ,K)) &
      &            + SQRT(QH(I,J+1,K,1) * AJA(I,J+1,K)) )
      RWL  = SQRT(QH(I,J  ,K,1) * AJA(I,J  ,K)) * RWD
      RWR  = SQRT(QH(I,J+1,K,1) * AJA(I,J+1,K)) * RWD
      UM   = RWL * U(I,J,K) + RWR * U(I,J+1,K)
      VM   = RWL * V(I,J,K) + RWR * V(I,J+1,K)
      WM   = RWL * W(I,J,K) + RWR * W(I,J+1,K)
      HM   = RWL * ( &
      &        0.5 * (U(I,J  ,K)**2 + V(I,J  ,K)**2 + W(I,J  ,K)**2) &
      &      + GAMMA * RG / (GAMMA - 1.0) * T(I,J  ,K) &
      &    ) &
      &    + RWR * ( &
      &        0.5 * (U(I,J+1,K)**2 + V(I,J+1,K)**2 + W(I,J+1,K)**2) &
      &      + GAMMA * RG / (GAMMA - 1.0) * T(I,J+1,K) &
      &    )
      CM   = SQRT((GAMMA - 1.0) * (HM - 0.5 * (UM**2 + VM**2 + WM**2)))
      ! �Ίp��
      THI  = AKX * UM + AKY * VM + AKZ * WM
      PHI  = 0.5 * (GAMMA - 1.0) * (UM**2 + VM**2 + WM**2)
      BETA = 1.0 / (2.0 * CM**2)
      TIL  = SQRT(AKX**2 + AKY**2 + AKZ**2)
      AKXT = AKX / TIL
      AKYT = AKY / TIL
      AKZT = AKZ / TIL
      THIT = AKXT * UM + AKYT * VM + AKZT * WM
      RR(J,1,1) = AKXT
      RR(J,2,1) = AKXT * UM
      RR(J,3,1) = AKXT * VM + AKZT
      RR(J,4,1) = AKXT * WM - AKYT
      RR(J,5,1) = AKXT * PHI / (GAMMA - 1.0) + AKZT * VM - AKYT * WM
      RR(J,1,2) = AKYT
      RR(J,2,2) = AKYT * UM - AKZT
      RR(J,3,2) = AKYT * VM
      RR(J,4,2) = AKYT * WM + AKXT
      RR(J,5,2) = AKYT * PHI / (GAMMA - 1.0) + AKXT * WM - AKZT * UM
      RR(J,1,3) = AKZT
      RR(J,2,3) = AKZT * UM + AKYT
      RR(J,3,3) = AKZT * VM - AKXT
      RR(J,4,3) = AKZT * WM
      RR(J,5,3) = AKZT * PHI / (GAMMA - 1.0) + AKYT * UM - AKXT * VM
      RR(J,1,4) = 1.0
      RR(J,2,4) = UM + AKXT * CM
      RR(J,3,4) = VM + AKYT * CM
      RR(J,4,4) = WM + AKZT * CM
      RR(J,5,4) = (PHI + CM**2) / (GAMMA - 1.0) + CM * THIT
      RR(J,1,5) = 1.0
      RR(J,2,5) = UM - AKXT * CM
      RR(J,3,5) = VM - AKYT * CM
      RR(J,4,5) = WM - AKZT * CM
      RR(J,5,5) = (PHI + CM**2) / (GAMMA - 1.0) - CM * THIT
      RI(J,1,1) = AKXT - AKXT * PHI / CM**2 + AKYT * WM - AKZT * VM
      RI(J,2,1) = AKYT - AKYT * PHI / CM**2 + AKZT * UM - AKXT * WM
      RI(J,3,1) = AKZT - AKZT * PHI / CM**2 + AKXT * VM - AKYT * UM
      RI(J,4,1) = BETA * (PHI - CM * THIT)
      RI(J,5,1) = BETA * (PHI + CM * THIT)
      RI(J,1,2) = (GAMMA - 1.0) * AKXT * UM / CM**2
      RI(J,2,2) = (GAMMA - 1.0) * AKYT * UM / CM**2 - AKZT
      RI(J,3,2) = (GAMMA - 1.0) * AKZT * UM / CM**2 + AKYT
      RI(J,4,2) = BETA * (AKXT * CM - (GAMMA - 1.0) * UM)
      RI(J,5,2) =-BETA * (AKXT * CM + (GAMMA - 1.0) * UM)
      RI(J,1,3) = (GAMMA - 1.0) * AKXT * VM / CM**2 + AKZT
      RI(J,2,3) = (GAMMA - 1.0) * AKYT * VM / CM**2
      RI(J,3,3) = (GAMMA - 1.0) * AKZT * VM / CM**2 - AKXT
      RI(J,4,3) = BETA * (AKYT * CM - (GAMMA - 1.0) * VM)
      RI(J,5,3) =-BETA * (AKYT * CM + (GAMMA - 1.0) * VM)
      RI(J,1,4) = (GAMMA - 1.0) * AKXT * WM / CM**2 - AKYT
      RI(J,2,4) = (GAMMA - 1.0) * AKYT * WM / CM**2 + AKXT
      RI(J,3,4) = (GAMMA - 1.0) * AKZT * WM / CM**2
      RI(J,4,4) = BETA * (AKZT * CM - (GAMMA - 1.0) * WM)
      RI(J,5,4) =-BETA * (AKZT * CM + (GAMMA - 1.0) * WM)
      RI(J,1,5) =-(GAMMA - 1.0) * AKXT / CM**2
      RI(J,2,5) =-(GAMMA - 1.0) * AKYT / CM**2
      RI(J,3,5) =-(GAMMA - 1.0) * AKZT / CM**2
      RI(J,4,5) = BETA * (GAMMA - 1.0)
      RI(J,5,5) = BETA * (GAMMA - 1.0)
      EIGM(J,1) = THI
      EIGM(J,2) = THI
      EIGM(J,3) = THI
      EIGM(J,4) = THI + CM * TIL
      EIGM(J,5) = THI - CM * TIL
      DO L = 6, LE
        EIGM(J,L) = THI
      ENDDO
      DO L = LS, LE
        DELTA(J,L) = MAX( &
        &              0.0, &
        &              EIGM(J,L) - EIG(J,L), EIG(J+1,L) - EIGM(J,L) &
        &            ) + DEL * CM * TIL
      ENDDO
    ENDIF
    ENDDO
    ! Delta u
    DO L = LS, LE
    DO J = JS, JE - 1
    IF(QH(I,J,K,1) .GT. 0.0 .AND. QH(I,J+1,K,1) .GT. 0.0) THEN
      DU(J,L) = - QH(I,J  ,K,L) * AJA(I,J  ,K) &
      &         + QH(I,J+1,K,L) * AJA(I,J+1,K)
      DU(J,L) = DU(J,L) * 2.0 / (AJA(I,J,K) + AJA(I,J+1,K))
    ENDIF
    ENDDO
    ENDDO
    ! R^-1 Delta u
    DO L = LS, LE
    DO J = JS, JE - 1
    IF(QH(I,J,K,1) .GT. 0.0 .AND. QH(I,J+1,K,1) .GT. 0.0) THEN
      IF(L .LE. 5) THEN
        DUR(J,L) = RI(J,L,1) * DU(J,1) + RI(J,L,2) * DU(J,2) &
        &        + RI(J,L,3) * DU(J,3) + RI(J,L,4) * DU(J,4) &
        &        + RI(J,L,5) * DU(J,5)
      ELSE
        DUR(J,L) = DU(J,L)
      ENDIF
    ENDIF
    ENDDO
    ENDDO
    ! �񎟐��xTVD�X�L�[�� ++++++++++++++++++++++++++++++++++++++++++++++
    IF(Order .EQ. 2) THEN
      ! g
      DO L = LS, LE
      J = JS
      IF(QH(I,J,K,1) .GT. 0.0 .AND. QH(I,J+1,K,1) .GT. 0.0) THEN
        GG(J,L) = DUR(J,L)
      ENDIF
      DO J = JS + 1, JE - 1
      IF(QH(I,J,K,1) .LE. 0.0) CYCLE
      IF(QH(I,J-1,K,1) .GT. 0.0 .AND. QH(I,J+1,K,1) .GT. 0.0) THEN
        GG(J,L) = minmod2(DUR(J,L), DUR(J-1,L))
      ELSEIF(QH(I,J-1,K,1) .GT. 0.0) THEN
        GG(J,L) = DUR(J-1,L)
      ELSEIF(QH(I,J+1,K,1) .GT. 0.0) THEN
        GG(J,L) = DUR(J,L)
      ENDIF
      ENDDO
      J = JE
      IF(QH(I,J-1,K,1) .GT. 0.0 .AND. QH(I,J,K,1) .GT. 0.0) THEN
        GG(J,L) = DUR(J-1,L)
      ENDIF
      ENDDO
      ! phi
      DO L = LS, LE
      DO J = JS, JE - 1
      IF(QH(I,J,K,1) .GT. 0.0 .AND. QH(I,J+1,K,1) .GT. 0.0) THEN
        FSIGMA = Func_sigma(Func_psi(EIGM(J,L), DELTA(J,L)))
        FGAMMA = Func_gamma(FSIGMA, GG(J,L), GG(J+1,L), DUR(J,L))
        PHIM(J,L) = FSIGMA * (GG(J,L) + GG(J+1,L)) &
        &         - Func_psi(EIGM(J,L) + FGAMMA, DELTA(J,L)) * DUR(J,L)
      ENDIF
      ENDDO
      ENDDO
      ! ���l����
      DO L = LS, LE
      DO J = JS, JE - 1
      IF(QH(I,J,K,1) .GT. 0.0 .AND. QH(I,J+1,K,1) .GT. 0.0) THEN
        IF(L .LE. 5) THEN
          FT(I,J,K,L) = FT(I,J,K,L) + 0.5 * ( RR(J,L,1) * PHIM(J,1) &
          &                                 + RR(J,L,2) * PHIM(J,2) &
          &                                 + RR(J,L,3) * PHIM(J,3) &
          &                                 + RR(J,L,4) * PHIM(J,4) &
          &                                 + RR(J,L,5) * PHIM(J,5) )
        ELSE
          FT(I,J,K,L) = FT(I,J,K,L) + 0.5 * PHIM(J,L)
        ENDIF
      ENDIF
      ENDDO
      ENDDO
      CYCLE
    ENDIF
    ! �ꎟ���x���㍷�� +++++++++++++++++++++++++++++++++++++++++++++++++
    ! Delta f^+-
    DO L = LS, LE
    DO J = JS, JE - 1
    IF(QH(I,J,K,1) .GT. 0.0 .AND. QH(I,J+1,K,1) .GT. 0.0) THEN
      ABSA  = Func_psi(EIGM(J,L), DELTA(J,L))
      AP    = 0.5 * (EIGM(J,L) + ABSA)
      AM    = 0.5 * (EIGM(J,L) - ABSA)
      DFP(J,L) = AP * DUR(J,L)
      DFM(J,L) = AM * DUR(J,L)
    ENDIF
    ENDDO
    ENDDO
    ! ���l����
    DO L = LS, LE
    DO J = JS, JE - 1
    IF(QH(I,J,K,1) .GT. 0.0 .AND. QH(I,J+1,K,1) .GT. 0.0) THEN
      IF(L .LE. 5) THEN
        FT(I,J,K,L) = FT(I,J,K,L) - 0.5 * ( RR(J,L,1) * DFP(J,1) &
        &                                 + RR(J,L,2) * DFP(J,2) &
        &                                 + RR(J,L,3) * DFP(J,3) &
        &                                 + RR(J,L,4) * DFP(J,4) &
        &                                 + RR(J,L,5) * DFP(J,5) &
        &                                 - RR(J,L,1) * DFM(J,1) &
        &                                 - RR(J,L,2) * DFM(J,2) &
        &                                 - RR(J,L,3) * DFM(J,3) &
        &                                 - RR(J,L,4) * DFM(J,4) &
        &                                 - RR(J,L,5) * DFM(J,5) )
      ELSE
        FT(I,J,K,L) = FT(I,J,K,L) - 0.5 * (DFP(J,L) - DFM(J,L))
      ENDIF
    ENDIF
    ENDDO
    ENDDO
    IF(Order .EQ. 1) CYCLE
    ! �O��&�l�����xTVD�X�L�[�� +++++++++++++++++++++++++++++++++++++++++
    IF(Order .EQ. 4) THEN
      ! Delta^3 bar(f)^+-
      DO L = LS, LE
      DO J = JS + 1, JE - 2
      IF( QH(I,J-1,K,1) .GT. 0.0 .AND. QH(I,J  ,K,1) .GT. 0.0 .AND. &
      &   QH(I,J+1,K,1) .GT. 0.0 .AND. QH(I,J+2,K,1) .GT. 0.0 ) THEN
        D3FP1 = minmod3(DFP(J-1,L), b2 * DFP(J  ,L), b2 * DFP(J+1,L))
        D3FP2 = minmod3(DFP(J  ,L), b2 * DFP(J+1,L), b2 * DFP(J-1,L))
        D3FP3 = minmod3(DFP(J+1,L), b2 * DFP(J-1,L), b2 * DFP(J  ,L))
        D3FM1 = minmod3(DFM(J-1,L), b2 * DFM(J  ,L), b2 * DFM(J+1,L))
        D3FM2 = minmod3(DFM(J  ,L), b2 * DFM(J+1,L), b2 * DFM(J-1,L))
        D3FM3 = minmod3(DFM(J+1,L), b2 * DFM(J-1,L), b2 * DFM(J  ,L))
        D3FP(J,L) = D3FP1 - 2.0 * D3FP2 + D3FP3
        D3FM(J,L) = D3FM1 - 2.0 * D3FM2 + D3FM3
      ENDIF
      ENDDO
      ENDDO
      ! Delta^asterisk f^+-
      DO L = LS, LE
      DO J = JS + 1, JE - 2
      IF( QH(I,J-1,K,1) .GT. 0.0 .AND. QH(I,J  ,K,1) .GT. 0.0 .AND. &
      &   QH(I,J+1,K,1) .GT. 0.0 .AND. QH(I,J+2,K,1) .GT. 0.0 ) THEN
        DFP(J,L) = DFP(J,L) - D3FP(J,L) / 6.0
        DFM(J,L) = DFM(J,L) - D3FM(J,L) / 6.0
      ENDIF
      ENDDO
      ENDDO
    ENDIF
    ! Delta bar(f)^+-, Delta tilde(f)^+-
    DO L = LS, LE
    DO J = JS + 1, JE - 2
    IF( QH(I,J-1,K,1) .GT. 0.0 .AND. QH(I,J  ,K,1) .GT. 0.0 .AND. &
    &   QH(I,J+1,K,1) .GT. 0.0 .AND. QH(I,J+2,K,1) .GT. 0.0 ) THEN
      DFBP(J-1,L) = minmod2(DFP(J-1,L), b1 * DFP(J  ,L))
      DFBM(J  ,L) = minmod2(DFM(J  ,L), b1 * DFM(J+1,L))
      DFTP(J  ,L) = minmod2(DFP(J  ,L), b1 * DFP(J-1,L))
      DFTM(J+1,L) = minmod2(DFM(J+1,L), b1 * DFM(J  ,L))
    ENDIF
    ENDDO
    ENDDO
    ! ���l����
    DO L = LS, LE
    DO J = JS + 1, JE - 2
    IF( QH(I,J-1,K,1) .GT. 0.0 .AND. QH(I,J  ,K,1) .GT. 0.0 .AND. &
    &   QH(I,J+1,K,1) .GT. 0.0 .AND. QH(I,J+2,K,1) .GT. 0.0 ) THEN
      IF(L .LE. 5) THEN
        FT(I,J,K,L) = FT(I,J,K,L) &
        &           + ( 1.0 * RR(J-1,L,1) * DFBP(J-1,1) &
        &             + 1.0 * RR(J-1,L,2) * DFBP(J-1,2) &
        &             + 1.0 * RR(J-1,L,3) * DFBP(J-1,3) &
        &             + 1.0 * RR(J-1,L,4) * DFBP(J-1,4) &
        &             + 1.0 * RR(J-1,L,5) * DFBP(J-1,5) &
        &             + 2.0 * RR(J  ,L,1) * DFTP(J  ,1) &
        &             + 2.0 * RR(J  ,L,2) * DFTP(J  ,2) &
        &             + 2.0 * RR(J  ,L,3) * DFTP(J  ,3) &
        &             + 2.0 * RR(J  ,L,4) * DFTP(J  ,4) &
        &             + 2.0 * RR(J  ,L,5) * DFTP(J  ,5) &
        &             - 2.0 * RR(J  ,L,1) * DFBM(J  ,1) &
        &             - 2.0 * RR(J  ,L,2) * DFBM(J  ,2) &
        &             - 2.0 * RR(J  ,L,3) * DFBM(J  ,3) &
        &             - 2.0 * RR(J  ,L,4) * DFBM(J  ,4) &
        &             - 2.0 * RR(J  ,L,5) * DFBM(J  ,5) &
        &             - 1.0 * RR(J+1,L,1) * DFTM(J+1,1) &
        &             - 1.0 * RR(J+1,L,2) * DFTM(J+1,2) &
        &             - 1.0 * RR(J+1,L,3) * DFTM(J+1,3) &
        &             - 1.0 * RR(J+1,L,4) * DFTM(J+1,4) &
        &             - 1.0 * RR(J+1,L,5) * DFTM(J+1,5) &
        &           ) / 6.0
      ELSE
        FT(I,J,K,L) = FT(I,J,K,L) &
        &           + ( 1.0 * DFBP(J-1,L) + 2.0 * DFTP(J  ,L) &
        &             - 2.0 * DFBM(J  ,L) - 1.0 * DFTM(J+1,L) ) / 6.0
      ENDIF
    ENDIF
    ENDDO
    ENDDO
  ENDDO
  ENDDO
  !$OMP END DO
  ! ��������� =========================================================
  DEALLOCATE(F,EIG,RR,RI,EIGM,DELTA,DU,DUR,GG,PHIM,DFP,DFM,D3FP,D3FM,DFBP,DFBM,DFTP,DFTM)
  !$OMP END PARALLEL
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE TVDET
!***********************************************************************
!**** TVD�X�L�[��(ZE����)                                           ****
!***********************************************************************
SUBROUTINE TVDZE
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K, L
  REAL    :: AKX, AKY, AKZ
  REAL    :: RWL, RWR, RWD, UM, VM, WM, HM, CM
  REAL    :: THI, PHI, BETA, TIL, AKXT, AKYT, AKZT, THIT, PH
  REAL    :: FSIGMA, FGAMMA, ABSA, AP, AM
  REAL    :: D3FP1, D3FP2, D3FP3, D3FM1, D3FM2, D3FM3
  REAL, ALLOCATABLE :: F(:, :), EIG(:, :)
  REAL, ALLOCATABLE :: RR(:, :, :), RI(:, :, :), EIGM(:, :), DELTA(:, :)
  REAL, ALLOCATABLE :: DU(:, :), DUR(:, :)
  REAL, ALLOCATABLE :: GG(:, :), PHIM(:, :)
  REAL, ALLOCATABLE :: DFP(:, :), DFM(:, :)
  REAL, ALLOCATABLE :: D3FP(:, :), D3FM(:, :)
  REAL, ALLOCATABLE :: DFBP(:, :), DFBM(:, :)
  REAL, ALLOCATABLE :: DFTP(:, :), DFTM(:, :)
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, L, &
!$OMP& AKX, AKY, AKZ, RWL, RWR, RWD, UM, VM, WM, HM, CM, &
!$OMP& THI, PHI, BETA, TIL, AKXT, AKYT, AKZT, THIT, PH, &
!$OMP& FSIGMA, FGAMMA, ABSA, AP, AM, &
!$OMP& D3FP1, D3FP2, D3FP3, D3FM1, D3FM2, D3FM3, &
!$OMP& F, EIG, RR, RI, EIGM, DELTA, DU, DUR, &
!$OMP& GG, PHIM, DFP, DFM, D3FP, D3FM, &
!$OMP& DFBP, DFBM, DFTP, DFTM &
!$OMP& )
  ALLOCATE(F(KS: KE, LS: LE), EIG(KS: KE, LS: LE))
  ALLOCATE(RR(KS: KE - 1, LS: 5, LS: 5))
  ALLOCATE(RI(KS: KE - 1, LS: 5, LS: 5))
  ALLOCATE(EIGM(KS: KE - 1, LS: LE))
  ALLOCATE(DELTA(KS: KE - 1, LS: LE))
  ALLOCATE(DU(KS: KE - 1, LS: LE), DUR(KS: KE - 1, LS: LE))
  ALLOCATE(GG(KS: KE, LS: LE), PHIM(KS: KE - 1, LS: LE))
  ALLOCATE(DFP (KS    : KE - 1, LS: LE), DFM (KS    : KE - 1, LS: LE))
  ALLOCATE(D3FP(KS + 1: KE - 2, LS: LE), D3FM(KS + 1: KE - 2, LS: LE))
  ALLOCATE(DFBP(KS    : KE - 3, LS: LE), DFBM(KS + 1: KE - 2, LS: LE))
  ALLOCATE(DFTP(KS + 1: KE - 2, LS: LE), DFTM(KS + 2: KE - 1, LS: LE))
  !$OMP DO
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
    ! �񎟐��x���S���� +++++++++++++++++++++++++++++++++++++++++++++++++
    DO K = KS, KE
    IF(QH(I,J,K,1) .GT. 0.0) THEN
      THI = ZEX(I,J,K) * U(I,J,K) &
      &   + ZEY(I,J,K) * V(I,J,K) &
      &   + ZEZ(I,J,K) * W(I,J,K)
      TIL = SQRT(ZEX(I,J,K)**2 + ZEY(I,J,K)**2 + ZEZ(I,J,K)**2)
      CM  = SQRT(GAMMA * RG * T(I,J,K))
      PH  = P(I,J,K) / AJA(I,J,K)
      F(K,1) = QH(I,J,K,1) * THI
      F(K,2) = QH(I,J,K,2) * THI + PH * ZEX(I,J,K)
      F(K,3) = QH(I,J,K,3) * THI + PH * ZEY(I,J,K)
      F(K,4) = QH(I,J,K,4) * THI + PH * ZEZ(I,J,K)
      F(K,5) = QH(I,J,K,5) * THI + PH * THI
      DO L = 6, LE
        F(K,L) = QH(I,J,K,L) * THI
      ENDDO
      EIG(K,1) = THI
      EIG(K,2) = THI
      EIG(K,3) = THI
      EIG(K,4) = THI + CM * TIL
      EIG(K,5) = THI - CM * TIL
      DO L = 6, LE
        EIG(K,L) = THI
      ENDDO
    ENDIF
    ENDDO
    ! ���l����
    DO L = LS, LE
    DO K = KS, KE - 1
    IF(QH(I,J,K,1) .GT. 0.0 .AND. QH(I,J,K+1,1) .GT. 0.0) THEN
      GT(I,J,K,L) = 0.5 * (F(K,L) + F(K+1,L))
    ENDIF
    ENDDO
    ENDDO
    IF(Order .EQ. 0) CYCLE
    ! �Ίp�� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    DO K = KS, KE - 1
    IF(QH(I,J,K,1) .GT. 0.0 .AND. QH(I,J,K+1,1) .GT. 0.0) THEN
      AKX  = 0.5 * (ZEX(I,J,K) + ZEX(I,J,K+1))
      AKY  = 0.5 * (ZEY(I,J,K) + ZEY(I,J,K+1))
      AKZ  = 0.5 * (ZEZ(I,J,K) + ZEZ(I,J,K+1))
      ! Roe ����
      RWD  = 1.0 / ( SQRT(QH(I,J,K  ,1) * AJA(I,J,K  )) &
      &            + SQRT(QH(I,J,K+1,1) * AJA(I,J,K+1)) )
      RWL  = SQRT(QH(I,J,K  ,1) * AJA(I,J,K  )) * RWD
      RWR  = SQRT(QH(I,J,K+1,1) * AJA(I,J,K+1)) * RWD
      UM   = RWL * U(I,J,K) + RWR * U(I,J,K+1)
      VM   = RWL * V(I,J,K) + RWR * V(I,J,K+1)
      WM   = RWL * W(I,J,K) + RWR * W(I,J,K+1)
      HM   = RWL * ( &
      &        0.5 * (U(I,J,K  )**2 + V(I,J,K  )**2 + W(I,J,K  )**2) &
      &      + GAMMA * RG / (GAMMA - 1.0) * T(I,J,K  ) &
      &    ) &
      &    + RWR * ( &
      &        0.5 * (U(I,J,K+1)**2 + V(I,J,K+1)**2 + W(I,J,K+1)**2) &
      &      + GAMMA * RG / (GAMMA - 1.0) * T(I,J,K+1) &
      &    )
      CM   = SQRT((GAMMA - 1.0) * (HM - 0.5 * (UM**2 + VM**2 + WM**2)))
      ! �Ίp��
      THI  = AKX * UM + AKY * VM + AKZ * WM
      PHI  = 0.5 * (GAMMA - 1.0) * (UM**2 + VM**2 + WM**2)
      BETA = 1.0 / (2.0 * CM**2)
      TIL  = SQRT(AKX**2 + AKY**2 + AKZ**2)
      AKXT = AKX / TIL
      AKYT = AKY / TIL
      AKZT = AKZ / TIL
      THIT = AKXT * UM + AKYT * VM + AKZT * WM
      RR(K,1,1) = AKXT
      RR(K,2,1) = AKXT * UM
      RR(K,3,1) = AKXT * VM + AKZT
      RR(K,4,1) = AKXT * WM - AKYT
      RR(K,5,1) = AKXT * PHI / (GAMMA - 1.0) + AKZT * VM - AKYT * WM
      RR(K,1,2) = AKYT
      RR(K,2,2) = AKYT * UM - AKZT
      RR(K,3,2) = AKYT * VM
      RR(K,4,2) = AKYT * WM + AKXT
      RR(K,5,2) = AKYT * PHI / (GAMMA - 1.0) + AKXT * WM - AKZT * UM
      RR(K,1,3) = AKZT
      RR(K,2,3) = AKZT * UM + AKYT
      RR(K,3,3) = AKZT * VM - AKXT
      RR(K,4,3) = AKZT * WM
      RR(K,5,3) = AKZT * PHI / (GAMMA - 1.0) + AKYT * UM - AKXT * VM
      RR(K,1,4) = 1.0
      RR(K,2,4) = UM + AKXT * CM
      RR(K,3,4) = VM + AKYT * CM
      RR(K,4,4) = WM + AKZT * CM
      RR(K,5,4) = (PHI + CM**2) / (GAMMA - 1.0) + CM * THIT
      RR(K,1,5) = 1.0
      RR(K,2,5) = UM - AKXT * CM
      RR(K,3,5) = VM - AKYT * CM
      RR(K,4,5) = WM - AKZT * CM
      RR(K,5,5) = (PHI + CM**2) / (GAMMA - 1.0) - CM * THIT
      RI(K,1,1) = AKXT - AKXT * PHI / CM**2 + AKYT * WM - AKZT * VM
      RI(K,2,1) = AKYT - AKYT * PHI / CM**2 + AKZT * UM - AKXT * WM
      RI(K,3,1) = AKZT - AKZT * PHI / CM**2 + AKXT * VM - AKYT * UM
      RI(K,4,1) = BETA * (PHI - CM * THIT)
      RI(K,5,1) = BETA * (PHI + CM * THIT)
      RI(K,1,2) = (GAMMA - 1.0) * AKXT * UM / CM**2
      RI(K,2,2) = (GAMMA - 1.0) * AKYT * UM / CM**2 - AKZT
      RI(K,3,2) = (GAMMA - 1.0) * AKZT * UM / CM**2 + AKYT
      RI(K,4,2) = BETA * (AKXT * CM - (GAMMA - 1.0) * UM)
      RI(K,5,2) =-BETA * (AKXT * CM + (GAMMA - 1.0) * UM)
      RI(K,1,3) = (GAMMA - 1.0) * AKXT * VM / CM**2 + AKZT
      RI(K,2,3) = (GAMMA - 1.0) * AKYT * VM / CM**2
      RI(K,3,3) = (GAMMA - 1.0) * AKZT * VM / CM**2 - AKXT
      RI(K,4,3) = BETA * (AKYT * CM - (GAMMA - 1.0) * VM)
      RI(K,5,3) =-BETA * (AKYT * CM + (GAMMA - 1.0) * VM)
      RI(K,1,4) = (GAMMA - 1.0) * AKXT * WM / CM**2 - AKYT
      RI(K,2,4) = (GAMMA - 1.0) * AKYT * WM / CM**2 + AKXT
      RI(K,3,4) = (GAMMA - 1.0) * AKZT * WM / CM**2
      RI(K,4,4) = BETA * (AKZT * CM - (GAMMA - 1.0) * WM)
      RI(K,5,4) =-BETA * (AKZT * CM + (GAMMA - 1.0) * WM)
      RI(K,1,5) =-(GAMMA - 1.0) * AKXT / CM**2
      RI(K,2,5) =-(GAMMA - 1.0) * AKYT / CM**2
      RI(K,3,5) =-(GAMMA - 1.0) * AKZT / CM**2
      RI(K,4,5) = BETA * (GAMMA - 1.0)
      RI(K,5,5) = BETA * (GAMMA - 1.0)
      EIGM(K,1) = THI
      EIGM(K,2) = THI
      EIGM(K,3) = THI
      EIGM(K,4) = THI + CM * TIL
      EIGM(K,5) = THI - CM * TIL
      DO L = 6, LE
        EIGM(K,L) = THI
      ENDDO
      DO L = LS, LE
        DELTA(K,L) = MAX( &
        &              0.0, &
        &              EIGM(K,L) - EIG(K,L), EIG(K+1,L) - EIGM(K,L) &
        &            ) + DEL * CM * TIL
      ENDDO
    ENDIF
    ENDDO
    ! Delta u
    DO L = LS, LE
    DO K = KS, KE - 1
    IF(QH(I,J,K,1) .GT. 0.0 .AND. QH(I,J,K+1,1) .GT. 0.0) THEN
      DU(K,L) = - QH(I,J,K  ,L) * AJA(I,J,K  ) &
      &         + QH(I,J,K+1,L) * AJA(I,J,K+1)
      DU(K,L) = DU(K,L) * 2.0 / (AJA(I,J,K) + AJA(I,J,K+1))
    ENDIF
    ENDDO
    ENDDO
    ! R^-1 Delta u
    DO L = LS, LE
    DO K = KS, KE - 1
    IF(QH(I,J,K,1) .GT. 0.0 .AND. QH(I,J,K+1,1) .GT. 0.0) THEN
      IF(L .LE. 5) THEN
        DUR(K,L) = RI(K,L,1) * DU(K,1) + RI(K,L,2) * DU(K,2) &
        &        + RI(K,L,3) * DU(K,3) + RI(K,L,4) * DU(K,4) &
        &        + RI(K,L,5) * DU(K,5)
      ELSE
        DUR(K,L) = DU(K,L)
      ENDIF
    ENDIF
    ENDDO
    ENDDO
    ! �񎟐��xTVD�X�L�[�� ++++++++++++++++++++++++++++++++++++++++++++++
    IF(Order .EQ. 2) THEN
      ! g
      DO L = LS, LE
      K = KS
      IF(QH(I,J,K,1) .GT. 0.0 .AND. QH(I,J,K+1,1) .GT. 0.0) THEN
        GG(K,L) = DUR(K,L)
      ENDIF
      DO K = KS + 1, KE - 1
      IF(QH(I,J,K,1) .LE. 0.0) CYCLE
      IF(QH(I,J,K-1,1) .GT. 0.0 .AND. QH(I,J,K+1,1) .GT. 0.0) THEN
        GG(K,L) = minmod2(DUR(K,L), DUR(K-1,L))
      ELSEIF(QH(I,J,K-1,1) .GT. 0.0) THEN
        GG(K,L) = DUR(K-1,L)
      ELSEIF(QH(I,J,K+1,1) .GT. 0.0) THEN
        GG(K,L) = DUR(K,L)
      ENDIF
      ENDDO
      K = KE
      IF(QH(I,J,K-1,1) .GT. 0.0 .AND. QH(I,J,K,1) .GT. 0.0) THEN
        GG(K,L) = DUR(K-1,L)
      ENDIF
      ENDDO
      ! phi
      DO L = LS, LE
      DO K = KS, KE - 1
      IF(QH(I,J,K,1) .GT. 0.0 .AND. QH(I,J,K+1,1) .GT. 0.0) THEN
        FSIGMA = Func_sigma(Func_psi(EIGM(K,L), DELTA(K,L)))
        FGAMMA = Func_gamma(FSIGMA, GG(K,L), GG(K+1,L), DUR(K,L))
        PHIM(K,L) = FSIGMA * (GG(K,L) + GG(K+1,L)) &
        &         - Func_psi(EIGM(K,L) + FGAMMA, DELTA(K,L)) * DUR(K,L)
      ENDIF
      ENDDO
      ENDDO
      ! ���l����
      DO L = LS, LE
      DO K = KS, KE - 1
      IF(QH(I,J,K,1) .GT. 0.0 .AND. QH(I,J,K+1,1) .GT. 0.0) THEN
        IF(L .LE. 5) THEN
          GT(I,J,K,L) = GT(I,J,K,L) + 0.5 * ( RR(K,L,1) * PHIM(K,1) &
          &                                 + RR(K,L,2) * PHIM(K,2) &
          &                                 + RR(K,L,3) * PHIM(K,3) &
          &                                 + RR(K,L,4) * PHIM(K,4) &
          &                                 + RR(K,L,5) * PHIM(K,5) )
        ELSE
          GT(I,J,K,L) = GT(I,J,K,L) + 0.5 * PHIM(K,L)
        ENDIF
      ENDIF
      ENDDO
      ENDDO
      CYCLE
    ENDIF
    ! �ꎟ���x���㍷�� +++++++++++++++++++++++++++++++++++++++++++++++++
    ! Delta f^+-
    DO L = LS, LE
    DO K = KS, KE - 1
    IF(QH(I,J,K,1) .GT. 0.0 .AND. QH(I,J,K+1,1) .GT. 0.0) THEN
      ABSA  = Func_psi(EIGM(K,L), DELTA(K,L))
      AP    = 0.5 * (EIGM(K,L) + ABSA)
      AM    = 0.5 * (EIGM(K,L) - ABSA)
      DFP(K,L) = AP * DUR(K,L)
      DFM(K,L) = AM * DUR(K,L)
    ENDIF
    ENDDO
    ENDDO
    ! ���l����
    DO L = LS, LE
    DO K = KS, KE - 1
    IF(QH(I,J,K,1) .GT. 0.0 .AND. QH(I,J,K+1,1) .GT. 0.0) THEN
      IF(L .LE. 5) THEN
        GT(I,J,K,L) = GT(I,J,K,L) - 0.5 * ( RR(K,L,1) * DFP(K,1) &
        &                                 + RR(K,L,2) * DFP(K,2) &
        &                                 + RR(K,L,3) * DFP(K,3) &
        &                                 + RR(K,L,4) * DFP(K,4) &
        &                                 + RR(K,L,5) * DFP(K,5) &
        &                                 - RR(K,L,1) * DFM(K,1) &
        &                                 - RR(K,L,2) * DFM(K,2) &
        &                                 - RR(K,L,3) * DFM(K,3) &
        &                                 - RR(K,L,4) * DFM(K,4) &
        &                                 - RR(K,L,5) * DFM(K,5) )
      ELSE
        GT(I,J,K,L) = GT(I,J,K,L) - 0.5 * (DFP(K,L) - DFM(K,L))
      ENDIF
    ENDIF
    ENDDO
    ENDDO
    IF(Order .EQ. 1) CYCLE
    ! �O��&�l�����xTVD�X�L�[�� +++++++++++++++++++++++++++++++++++++++++
    IF(Order .EQ. 4) THEN
      ! Delta^3 bar(f)^+-
      DO L = LS, LE
      DO K = KS + 1, KE - 2
      IF( QH(I,J,K-1,1) .GT. 0.0 .AND. QH(I,J,K  ,1) .GT. 0.0 .AND. &
      &   QH(I,J,K+1,1) .GT. 0.0 .AND. QH(I,J,K+2,1) .GT. 0.0 ) THEN
        D3FP1 = minmod3(DFP(K-1,L), b2 * DFP(K  ,L), b2 * DFP(K+1,L))
        D3FP2 = minmod3(DFP(K  ,L), b2 * DFP(K+1,L), b2 * DFP(K-1,L))
        D3FP3 = minmod3(DFP(K+1,L), b2 * DFP(K-1,L), b2 * DFP(K  ,L))
        D3FM1 = minmod3(DFM(K-1,L), b2 * DFM(K  ,L), b2 * DFM(K+1,L))
        D3FM2 = minmod3(DFM(K  ,L), b2 * DFM(K+1,L), b2 * DFM(K-1,L))
        D3FM3 = minmod3(DFM(K+1,L), b2 * DFM(K-1,L), b2 * DFM(K  ,L))
        D3FP(K,L) = D3FP1 - 2.0 * D3FP2 + D3FP3
        D3FM(K,L) = D3FM1 - 2.0 * D3FM2 + D3FM3
      ENDIF
      ENDDO
      ENDDO
      ! Delta^asterisk f^+-
      DO L = LS, LE
      DO K = KS + 1, KE - 2
      IF( QH(I,J,K-1,1) .GT. 0.0 .AND. QH(I,J,K  ,1) .GT. 0.0 .AND. &
      &   QH(I,J,K+1,1) .GT. 0.0 .AND. QH(I,J,K+2,1) .GT. 0.0 ) THEN
        DFP(K,L) = DFP(K,L) - D3FP(K,L) / 6.0
        DFM(K,L) = DFM(K,L) - D3FM(K,L) / 6.0
      ENDIF
      ENDDO
      ENDDO
    ENDIF
    ! Delta bar(f)^+-, Delta tilde(f)^+-
    DO L = LS, LE
    DO K = KS + 1, KE - 2
    IF( QH(I,J,K-1,1) .GT. 0.0 .AND. QH(I,J,K  ,1) .GT. 0.0 .AND. &
    &   QH(I,J,K+1,1) .GT. 0.0 .AND. QH(I,J,K+2,1) .GT. 0.0 ) THEN
      DFBP(K-1,L) = minmod2(DFP(K-1,L), b1 * DFP(K  ,L))
      DFBM(K  ,L) = minmod2(DFM(K  ,L), b1 * DFM(K+1,L))
      DFTP(K  ,L) = minmod2(DFP(K  ,L), b1 * DFP(K-1,L))
      DFTM(K+1,L) = minmod2(DFM(K+1,L), b1 * DFM(K  ,L))
    ENDIF
    ENDDO
    ENDDO
    ! ���l����
    DO L = LS, LE
    DO K = KS + 1, KE - 2
    IF( QH(I,J,K-1,1) .GT. 0.0 .AND. QH(I,J,K  ,1) .GT. 0.0 .AND. &
    &   QH(I,J,K+1,1) .GT. 0.0 .AND. QH(I,J,K+2,1) .GT. 0.0 ) THEN
      IF(L .LE. 5) THEN
        GT(I,J,K,L) = GT(I,J,K,L) &
        &           + ( 1.0 * RR(K-1,L,1) * DFBP(K-1,1) &
        &             + 1.0 * RR(K-1,L,2) * DFBP(K-1,2) &
        &             + 1.0 * RR(K-1,L,3) * DFBP(K-1,3) &
        &             + 1.0 * RR(K-1,L,4) * DFBP(K-1,4) &
        &             + 1.0 * RR(K-1,L,5) * DFBP(K-1,5) &
        &             + 2.0 * RR(K  ,L,1) * DFTP(K  ,1) &
        &             + 2.0 * RR(K  ,L,2) * DFTP(K  ,2) &
        &             + 2.0 * RR(K  ,L,3) * DFTP(K  ,3) &
        &             + 2.0 * RR(K  ,L,4) * DFTP(K  ,4) &
        &             + 2.0 * RR(K  ,L,5) * DFTP(K  ,5) &
        &             - 2.0 * RR(K  ,L,1) * DFBM(K  ,1) &
        &             - 2.0 * RR(K  ,L,2) * DFBM(K  ,2) &
        &             - 2.0 * RR(K  ,L,3) * DFBM(K  ,3) &
        &             - 2.0 * RR(K  ,L,4) * DFBM(K  ,4) &
        &             - 2.0 * RR(K  ,L,5) * DFBM(K  ,5) &
        &             - 1.0 * RR(K+1,L,1) * DFTM(K+1,1) &
        &             - 1.0 * RR(K+1,L,2) * DFTM(K+1,2) &
        &             - 1.0 * RR(K+1,L,3) * DFTM(K+1,3) &
        &             - 1.0 * RR(K+1,L,4) * DFTM(K+1,4) &
        &             - 1.0 * RR(K+1,L,5) * DFTM(K+1,5) &
        &           ) / 6.0
      ELSE
        GT(I,J,K,L) = GT(I,J,K,L) &
        &           + ( 1.0 * DFBP(K-1,L) + 2.0 * DFTP(K  ,L) &
        &             - 2.0 * DFBM(K  ,L) - 1.0 * DFTM(K+1,L) ) / 6.0
      ENDIF
    ENDIF
    ENDDO
    ENDDO
  ENDDO
  ENDDO
  !$OMP END DO
  !$OMP END PARALLEL
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE TVDZE
! ��`�I�� *************************************************************
END SUBROUTINE Convection3D
!***********************************************************************
!**** �֐�psi(�G���g���s�[�C��)                                     ****
!***********************************************************************
REAL FUNCTION Func_psi(x, delta)
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, INTENT(IN) :: x, delta
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL :: absx
  ! �����J�n ***********************************************************
  absx = ABS(x)
  IF(absx .GE. delta) THEN
    Func_psi = absx
  ELSE
    Func_psi = (x**2 + delta**2) / (2.0 * delta)
  ENDIF
  ! �����I�� ***********************************************************
  RETURN
! ��`�I�� *************************************************************
END FUNCTION Func_psi
!***********************************************************************
!**** �֐�sigma                                                     ****
!***********************************************************************
REAL FUNCTION Func_sigma(c)
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, INTENT(IN) :: c
  ! �����J�n ***********************************************************
  Func_sigma = 0.5 * c
  ! �����I�� ***********************************************************
  RETURN
! ��`�I�� *************************************************************
END FUNCTION Func_sigma
!***********************************************************************
!**** �֐�gamma                                                     ****
!***********************************************************************
REAL FUNCTION Func_gamma(sigma, gl, gr, Deltau)
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, INTENT(IN) :: sigma, gl, gr, Deltau
  ! �����J�n ***********************************************************
  IF(Deltau .NE. 0.0) THEN
    Func_gamma = sigma * (gr - gl) / Deltau
  ELSE
    Func_gamma = 0.0
  ENDIF
  ! �����I�� ***********************************************************
  RETURN
! ��`�I�� *************************************************************
END FUNCTION Func_gamma
!***********************************************************************
!**** ��ϐ�minmod�֐��̒�`                                        ****
!***********************************************************************
REAL FUNCTION minmod2(x, y)
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, INTENT(IN) :: x, y
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL :: s
  ! �����J�n ***********************************************************
  s = SIGN(1.0, x)
  minmod2 = s * MAX(0.0, MIN(ABS(x), s * y))
  ! �����I�� ***********************************************************
  RETURN
END FUNCTION minmod2
!***********************************************************************
!**** �O�ϐ�minmod�֐��̒�`                                        ****
!***********************************************************************
REAL FUNCTION minmod3(x, y, z)
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, INTENT(IN) :: x, y, z
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL :: s
  ! �����J�n ***********************************************************
  s = SIGN(1.0, x)
  minmod3 = s * MAX(0.0, MIN(ABS(x), s * y, s * z))
  ! �����I�� ***********************************************************
  RETURN
END FUNCTION minmod3
!***********************************************************************
!**** ��]���W�n�̌������̗͂��v�Z(�񎟌�)                          ****
!***********************************************************************
SUBROUTINE RotationForce2D( &
&            OmegaZ, &
&            IS, IE, JS, JE, LS, LE, &
&            X, Y, AJA, RHO, U, V, &
&            DQR &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: OmegaZ
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE
  INTEGER, INTENT(IN)  :: LS, LE
  REAL,    INTENT(IN)  :: X(IS: IE, JS: JE), Y(IS: IE, JS: JE)
  REAL,    INTENT(IN)  :: AJA(IS: IE, JS: JE)
  REAL,    INTENT(IN)  :: RHO(IS: IE, JS: JE)
  REAL,    INTENT(IN)  :: U(IS: IE, JS: JE), V(IS: IE, JS: JE)
  REAL,    INTENT(OUT) :: DQR(IS: IE, JS: JE, LS: LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: QH1
  REAL    :: CoriolisX, CoriolisY
  REAL    :: CentrifugalX, CentrifugalY
  ! �����J�n ***********************************************************
  DQR = 0.0
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, QH1, CoriolisX, CoriolisY, CentrifugalX, CentrifugalY &
!$OMP& )
  DO J = JS, JE
  DO I = IS, IE
  IF(RHO(I,J) .GT. 0.0) THEN
    QH1          = RHO(I,J) / AJA(I,J)
    CoriolisX    =-2.0 * OmegaZ * V(I,J)
    CoriolisY    = 2.0 * OmegaZ * U(I,J)
    CentrifugalX =-OmegaZ**2 * X(I,J)
    CentrifugalY =-OmegaZ**2 * Y(I,J)
    DQR(I,J,2) =-QH1 * (CoriolisX + CentrifugalX)
    DQR(I,J,3) =-QH1 * (CoriolisY + CentrifugalY)
    DQR(I,J,4) =-QH1 * (CentrifugalX * U(I,J) + CentrifugalY * V(I,J))
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE RotationForce2D
!***********************************************************************
!**** ��]���W�n�̌������̗͂��v�Z(�O����)                          ****
!***********************************************************************
SUBROUTINE RotationForce3D( &
&            OmegaX, OmegaY, OmegaZ, &
&            IS, IE, JS, JE, KS, KE, LS, LE, &
&            X, Y, Z, AJA, RHO, U, V, W, &
&            DQR &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: OmegaX, OmegaY, OmegaZ
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE, KS, KE
  INTEGER, INTENT(IN)  :: LS, LE
  REAL,    INTENT(IN)  :: X(IS: IE, JS: JE, KS: KE), &
  &                       Y(IS: IE, JS: JE, KS: KE), &
  &                       Z(IS: IE, JS: JE, KS: KE)
  REAL,    INTENT(IN)  :: AJA(IS: IE, JS: JE, KS: KE)
  REAL,    INTENT(IN)  :: RHO(IS: IE, JS: JE, KS: KE)
  REAL,    INTENT(IN)  :: U(IS: IE, JS: JE, KS: KE), &
  &                       V(IS: IE, JS: JE, KS: KE), &
  &                       W(IS: IE, JS: JE, KS: KE)
  REAL,    INTENT(OUT) :: DQR(IS: IE, JS: JE, KS: KE, LS: LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: QH1
  REAL    :: CoriolisX, CoriolisY, CoriolisZ
  REAL    :: CentrifugalX, CentrifugalY, CentrifugalZ
  ! �����J�n ***********************************************************
  DQR = 0.0
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, QH1, &
!$OMP& CoriolisX, CoriolisY, CoriolisZ, &
!$OMP& CentrifugalX, CentrifugalY, CentrifugalZ &
!$OMP& )
  DO K = KS, KE
  DO J = JS, JE
  DO I = IS, IE
  IF(RHO(I,J,K) .GT. 0.0) THEN
    QH1          = RHO(I,J,K) / AJA(I,J,K)
    CoriolisX    = 2.0 * (OmegaY * W(I,J,K) - OmegaZ * V(I,J,K))
    CoriolisY    = 2.0 * (OmegaZ * U(I,J,K) - OmegaX * W(I,J,K))
    CoriolisZ    = 2.0 * (OmegaX * V(I,J,K) - OmegaY * U(I,J,K))
    CentrifugalX = OmegaY * (OmegaX * Y(I,J,K) - OmegaY * X(I,J,K)) &
    &            - OmegaZ * (OmegaZ * X(I,J,K) - OmegaX * Z(I,J,K))
    CentrifugalY = OmegaZ * (OmegaY * Z(I,J,K) - OmegaZ * Y(I,J,K)) &
    &            - OmegaX * (OmegaX * Y(I,J,K) - OmegaY * X(I,J,K))
    CentrifugalZ = OmegaX * (OmegaZ * X(I,J,K) - OmegaX * Z(I,J,K)) &
    &            - OmegaY * (OmegaY * Z(I,J,K) - OmegaZ * Y(I,J,K))
    DQR(I,J,K,2) =-QH1 * (CoriolisX + CentrifugalX)
    DQR(I,J,K,3) =-QH1 * (CoriolisY + CentrifugalY)
    DQR(I,J,K,4) =-QH1 * (CoriolisZ + CentrifugalZ)
    DQR(I,J,K,5) =-QH1 * ( CentrifugalX * U(I,J,K) &
    &                    + CentrifugalY * V(I,J,K) &
    &                    + CentrifugalZ * W(I,J,K) )
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE RotationForce3D
!***********************************************************************
!**** �g�U��(�S����)�̌v�Z(�X�^�K�[�h�i�q��̓_���g�p)              ****
!**** �v�Z�Ώ� : �P��, �񎟌�, ���k��, �w��                         ****
!**** �v�Z�X�L�[�� : �񎟐��x���S����                               ****
!***********************************************************************
SUBROUTINE Viscosity2D( &
&            RG, GAMMA, PR, &
&            IS, IE, JS, JE, LS, LE, &
&            XIX, XIY, ETX, ETY, AJA, &
&            QH, U, V, T, AMU, &
&            DQD &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: RG, GAMMA, PR
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE
  INTEGER, INTENT(IN)  :: LS, LE
  REAL,    INTENT(IN)  :: XIX(IS:IE, JS:JE), XIY(IS:IE, JS:JE), &
  &                       ETX(IS:IE, JS:JE), ETY(IS:IE, JS:JE), &
  &                       AJA(IS:IE, JS:JE)
  REAL,    INTENT(IN)  :: QH(IS:IE, JS:JE, LS:LE)
  REAL,    INTENT(IN)  :: U(IS:IE, JS:JE), &
  &                       V(IS:IE, JS:JE), &
  &                       T(IS:IE, JS:JE)
  REAL,    INTENT(IN)  :: AMU(IS:IE, JS:JE)
  REAL,    INTENT(OUT) :: DQD(IS:IE, JS:JE, LS:LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, L
  REAL, ALLOCATABLE :: RH(:, :, :), SH(:, :, :)
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 4) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �������m�� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ALLOCATE(RH(IS:IE, JS:JE, LS:LE))
  ALLOCATE(SH(IS:IE, JS:JE, LS:LE))
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  RH (:,:,:) = 0.0
  SH (:,:,:) = 0.0
  DQD(:,:,:) = 0.0
  ! �e�����̋�ԍ��� +++++++++++++++++++++++++++++++++++++++++++++++++++
  CALL VISXI
  CALL VISET
  ! �g�U���x�N�g���̋�ԍ��� +++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE(I, J, L)
  DO L = LS, LE
  !$OMP DO
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( (QH(I  ,J  ,1) .GT. 0.0) .AND. &
  &   (QH(I-1,J  ,1) .GT. 0.0) .AND. (QH(I+1,J  ,1) .GT. 0.0) .AND. &
  &   (QH(I  ,J-1,1) .GT. 0.0) .AND. (QH(I  ,J+1,1) .GT. 0.0) &
  & ) THEN
    DQD(I,J,L) = (-RH(I-1,J  ,L) + RH(I,J,L)) &
    &          + (-SH(I  ,J-1,L) + SH(I,J,L))
  ENDIF
  ENDDO
  ENDDO
  !$OMP END DO
  ENDDO
  !$OMP END PARALLEL
  ! �����I�� ***********************************************************
  RETURN
! �����葱�� ***********************************************************
CONTAINS
!***********************************************************************
!**** �g�U��(�S����)�̌v�Z(XI����)                                  ****
!***********************************************************************
SUBROUTINE VISXI
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL :: XIXM, XIYM, ETXM, ETYM, AJAM
  REAL :: UM, VM, TM
  REAL :: UXIM, VXIM, TXIM, &
  &       UETM, VETM, TETM
  REAL :: UXM, VXM, TXM, &
  &       UYM, VYM, TYM
  REAL :: AMUM
  REAL :: DELVM, TAUXX, TAUYY, TAUXY
  REAL :: QX, QY
  REAL :: R4, S4
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, &
!$OMP& XIXM, XIYM, ETXM, ETYM, AJAM, UM, VM, TM, &
!$OMP& UXIM, VXIM, TXIM, UETM, VETM, TETM, &
!$OMP& UXM, VXM, TXM, UYM, VYM, TYM, &
!$OMP& AMUM, DELVM, TAUXX, TAUYY, TAUXY, QX, QY, R4, S4 &
!$OMP& )
  DO J = JS + 1, JE - 1
  DO I = IS    , IE - 1
    IF(QH(I,J,1) .GT. 0.0 .AND. QH(I+1,J,1) .GT. 0.0) THEN
      ! XI�����̕��ϗʂ̌v�Z -------------------------------------------
      XIXM  = 0.5 * (XIX(I,J) + XIX(I+1,J))
      XIYM  = 0.5 * (XIY(I,J) + XIY(I+1,J))
      ETXM  = 0.5 * (ETX(I,J) + ETX(I+1,J))
      ETYM  = 0.5 * (ETY(I,J) + ETY(I+1,J))
      AJAM  = 0.5 * (AJA(I,J) + AJA(I+1,J))
      UM    = 0.5 * (  U(I,J) +   U(I+1,J))
      VM    = 0.5 * (  V(I,J) +   V(I+1,J))
      TM    = 0.5 * (  T(I,J) +   T(I+1,J))
      ! x,y�����̌v�Z(XI�����̕��ϗ�) ----------------------------------
      UXIM = (-U(I,J) + U(I+1,J))
      VXIM = (-V(I,J) + V(I+1,J))
      TXIM = (-T(I,J) + T(I+1,J))
      UETM = 0.5 * ( - 0.5 * (U(I,J-1) + U(I+1,J-1)) &
      &              + 0.5 * (U(I,J+1) + U(I+1,J+1)) )
      VETM = 0.5 * ( - 0.5 * (V(I,J-1) + V(I+1,J-1)) &
      &              + 0.5 * (V(I,J+1) + V(I+1,J+1)) )
      TETM = 0.5 * ( - 0.5 * (T(I,J-1) + T(I+1,J-1)) &
      &              + 0.5 * (T(I,J+1) + T(I+1,J+1)) )
      UXM  = XIXM * UXIM + ETXM * UETM
      UYM  = XIYM * UXIM + ETYM * UETM
      VXM  = XIXM * VXIM + ETXM * VETM
      VYM  = XIYM * VXIM + ETYM * VETM
      TXM  = XIXM * TXIM + ETXM * TETM
      TYM  = XIYM * TXIM + ETYM * TETM
      ! �S���W����XI�����̕��ϗ� ---------------------------------------
      AMUM = 0.5 * (AMU(I,J) + AMU(I+1,J))
      ! �g�U���x�N�g���̌v�Z -------------------------------------------
      DELVM = UXM + VYM
      TAUXX = AMUM * (2.0 * UXM - 2.0 / 3.0 * DELVM)
      TAUYY = AMUM * (2.0 * VYM - 2.0 / 3.0 * DELVM)
      TAUXY = AMUM * (UYM + VXM)
      QX    =-(AMUM / PR) / (GAMMA - 1.0) * GAMMA * RG * TXM
      QY    =-(AMUM / PR) / (GAMMA - 1.0) * GAMMA * RG * TYM
      R4    = TAUXX * UM + TAUXY * VM - QX
      S4    = TAUXY * UM + TAUYY * VM - QY
      RH(I,J,1) = 0.0
      RH(I,J,2) = (XIXM * TAUXX + XIYM * TAUXY) / AJAM
      RH(I,J,3) = (XIXM * TAUXY + XIYM * TAUYY) / AJAM
      RH(I,J,4) = (XIXM * R4    + XIYM * S4   ) / AJAM
    ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE VISXI
!***********************************************************************
!**** �g�U��(�S����)�̌v�Z(ET����)                                  ****
!***********************************************************************
SUBROUTINE VISET
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL :: XIXM, XIYM, ETXM, ETYM, AJAM
  REAL :: UM, VM, TM
  REAL :: UXIM, VXIM, TXIM, &
  &       UETM, VETM, TETM
  REAL :: UXM, VXM, TXM, &
  &       UYM, VYM, TYM
  REAL :: AMUM
  REAL :: DELVM, TAUXX, TAUYY, TAUXY
  REAL :: QX, QY
  REAL :: R4, S4
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, &
!$OMP& XIXM, XIYM, ETXM, ETYM, AJAM, UM, VM, TM, &
!$OMP& UXIM, VXIM, TXIM, UETM, VETM, TETM, &
!$OMP& UXM, VXM, TXM, UYM, VYM, TYM, &
!$OMP& AMUM, DELVM, TAUXX, TAUYY, TAUXY, QX, QY, R4, S4 &
!$OMP& )
  DO J = JS    , JE - 1
  DO I = IS + 1, IE - 1
    IF(QH(I,J,1) .GT. 0.0 .AND. QH(I,J+1,1) .GT. 0.0) THEN
      ! ET�����̕��ϗʂ̌v�Z -------------------------------------------
      XIXM  = 0.5 * (XIX(I,J) + XIX(I,J+1))
      XIYM  = 0.5 * (XIY(I,J) + XIY(I,J+1))
      ETXM  = 0.5 * (ETX(I,J) + ETX(I,J+1))
      ETYM  = 0.5 * (ETY(I,J) + ETY(I,J+1))
      AJAM  = 0.5 * (AJA(I,J) + AJA(I,J+1))
      UM    = 0.5 * (  U(I,J) +   U(I,J+1))
      VM    = 0.5 * (  V(I,J) +   V(I,J+1))
      TM    = 0.5 * (  T(I,J) +   T(I,J+1))
      ! x,y�����̌v�Z(ET�����̕��ϗ�) ----------------------------------
      UXIM = 0.5 * ( - 0.5 * (U(I-1,J) + U(I-1,J+1)) &
      &              + 0.5 * (U(I+1,J) + U(I+1,J+1)) )
      VXIM = 0.5 * ( - 0.5 * (V(I-1,J) + V(I-1,J+1)) &
      &              + 0.5 * (V(I+1,J) + V(I+1,J+1)) )
      TXIM = 0.5 * ( - 0.5 * (T(I-1,J) + T(I-1,J+1)) &
      &              + 0.5 * (T(I+1,J) + T(I+1,J+1)) )
      UETM = (-U(I,J) + U(I,J+1))
      VETM = (-V(I,J) + V(I,J+1))
      TETM = (-T(I,J) + T(I,J+1))
      UXM  = XIXM * UXIM + ETXM * UETM
      UYM  = XIYM * UXIM + ETYM * UETM
      VXM  = XIXM * VXIM + ETXM * VETM
      VYM  = XIYM * VXIM + ETYM * VETM
      TXM  = XIXM * TXIM + ETXM * TETM
      TYM  = XIYM * TXIM + ETYM * TETM
      ! �S���W����ET�����̕��ϗ� ---------------------------------------
      AMUM = 0.5 * (AMU(I,J) + AMU(I,J+1))
      ! �g�U���x�N�g���̌v�Z -------------------------------------------
      DELVM = UXM + VYM
      TAUXX = AMUM * (2.0 * UXM - 2.0 / 3.0 * DELVM)
      TAUYY = AMUM * (2.0 * VYM - 2.0 / 3.0 * DELVM)
      TAUXY = AMUM * (UYM + VXM)
      QX    =-(AMUM / PR) / (GAMMA-1.0) * GAMMA * RG * TXM
      QY    =-(AMUM / PR) / (GAMMA-1.0) * GAMMA * RG * TYM
      R4    = TAUXX * UM + TAUXY * VM - QX
      S4    = TAUXY * UM + TAUYY * VM - QY
      SH(I,J,1) = 0.0
      SH(I,J,2) = (ETXM * TAUXX + ETYM * TAUXY) / AJAM
      SH(I,J,3) = (ETXM * TAUXY + ETYM * TAUYY) / AJAM
      SH(I,J,4) = (ETXM * R4    + ETYM * S4   ) / AJAM
    ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE VISET
! ��`�I�� *************************************************************
END SUBROUTINE Viscosity2D
!***********************************************************************
!**** �g�U��(�S����)�̌v�Z(�X�^�K�[�h�i�q��̓_���g�p)              ****
!**** �v�Z�Ώ� : �P��, �O����, ���k��, �w��                         ****
!**** �v�Z�X�L�[�� : �񎟐��x���S����                               ****
!***********************************************************************
SUBROUTINE Viscosity3D( &
&            RG, GAMMA, PR, &
&            IS, IE, JS, JE, KS, KE, LS, LE, &
&            XIX, XIY, XIZ, ETX, ETY, ETZ, ZEX, ZEY, ZEZ, AJA, &
&            QH, U, V, W, T, AMU, &
&            DQD &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: RG, GAMMA, PR
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE, KS, KE
  INTEGER, INTENT(IN)  :: LS, LE
  REAL,    INTENT(IN)  :: XIX(IS:IE, JS:JE, KS:KE), &
  &                       XIY(IS:IE, JS:JE, KS:KE), &
  &                       XIZ(IS:IE, JS:JE, KS:KE), &
  &                       ETX(IS:IE, JS:JE, KS:KE), &
  &                       ETY(IS:IE, JS:JE, KS:KE), &
  &                       ETZ(IS:IE, JS:JE, KS:KE), &
  &                       ZEX(IS:IE, JS:JE, KS:KE), &
  &                       ZEY(IS:IE, JS:JE, KS:KE), &
  &                       ZEZ(IS:IE, JS:JE, KS:KE), &
  &                       AJA(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)  :: QH(IS:IE, JS:JE, KS:KE, LS:LE)
  REAL,    INTENT(IN)  :: U(IS:IE, JS:JE, KS:KE), &
  &                       V(IS:IE, JS:JE, KS:KE), &
  &                       W(IS:IE, JS:JE, KS:KE), &
  &                       T(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)  :: AMU(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(OUT) :: DQD(IS:IE, JS:JE, KS:KE, LS:LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K, L
  REAL, ALLOCATABLE :: RH(:, :, :, :), SH(:, :, :, :), TH(:, :, :, :)
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 5) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �������m�� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ALLOCATE(RH(IS:IE, JS:JE, KS:KE, LS:LE))
  ALLOCATE(SH(IS:IE, JS:JE, KS:KE, LS:LE))
  ALLOCATE(TH(IS:IE, JS:JE, KS:KE, LS:LE))
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  RH (:,:,:,:) = 0.0
  SH (:,:,:,:) = 0.0
  TH (:,:,:,:) = 0.0
  DQD(:,:,:,:) = 0.0
  ! �e�����̋�ԍ��� +++++++++++++++++++++++++++++++++++++++++++++++++++
  CALL VISXI
  CALL VISET
  CALL VISZE
  ! �g�U���x�N�g���̋�ԍ��� +++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE(I, J, K, L)
  DO L = LS, LE
  !$OMP DO
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( ( QH(I  ,J  ,K  ,1) .GT. 0.0 ) .AND. &
  &   ( QH(I-1,J  ,K  ,1) .GT. 0.0 ) .AND. &
  &   ( QH(I+1,J  ,K  ,1) .GT. 0.0 ) .AND. &
  &   ( QH(I  ,J-1,K  ,1) .GT. 0.0 ) .AND. &
  &   ( QH(I  ,J+1,K  ,1) .GT. 0.0 ) .AND. &
  &   ( QH(I  ,J  ,K-1,1) .GT. 0.0 ) .AND. &
  &   ( QH(I  ,J  ,K+1,1) .GT. 0.0 ) &
  & ) THEN
    DQD(I,J,K,L) = ( -RH(I-1,J  ,K  ,L) + RH(I,J,K,L) ) &
    &            + ( -SH(I  ,J-1,K  ,L) + SH(I,J,K,L) ) &
    &            + ( -TH(I  ,J  ,K-1,L) + TH(I,J,K,L) )
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END DO
  ENDDO
  !$OMP END PARALLEL
  ! �����I�� ***********************************************************
  RETURN
! �����葱�� ***********************************************************
CONTAINS
!***********************************************************************
!**** �g�U��(�S����)�̌v�Z(XI����)                                  ****
!***********************************************************************
SUBROUTINE VISXI
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM
  REAL :: UM, VM, WM, TM
  REAL :: UXIM, VXIM, WXIM, TXIM, &
  &       UETM, VETM, WETM, TETM, &
  &       UZEM, VZEM, WZEM, TZEM
  REAL :: UXM, VXM, WXM, TXM, &
  &       UYM, VYM, WYM, TYM, &
  &       UZM, VZM, WZM, TZM
  REAL :: AMUM
  REAL :: DELVM, TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX
  REAL :: QX, QY, QZ
  REAL :: R5, S5, T5
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM, &
!$OMP& UM, VM, WM, TM, &
!$OMP& UXIM, VXIM, WXIM, TXIM, &
!$OMP& UETM, VETM, WETM, TETM, &
!$OMP& UZEM, VZEM, WZEM, TZEM, &
!$OMP& UXM, VXM, WXM, TXM, &
!$OMP& UYM, VYM, WYM, TYM, &
!$OMP& UZM, VZM, WZM, TZM, &
!$OMP& AMUM, DELVM, TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX, &
!$OMP& QX, QY, QZ, R5, S5, T5 &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS    , IE - 1
    IF( QH(I,J,K,1) .GT. 0.0 .AND. QH(I+1,J,K,1) .GT. 0.0 ) THEN
      ! XI�����̕��ϗʂ̌v�Z -------------------------------------------
      XIXM  = 0.5 * ( XIX(I,J,K) + XIX(I+1,J,K) )
      XIYM  = 0.5 * ( XIY(I,J,K) + XIY(I+1,J,K) )
      XIZM  = 0.5 * ( XIZ(I,J,K) + XIZ(I+1,J,K) )
      ETXM  = 0.5 * ( ETX(I,J,K) + ETX(I+1,J,K) )
      ETYM  = 0.5 * ( ETY(I,J,K) + ETY(I+1,J,K) )
      ETZM  = 0.5 * ( ETZ(I,J,K) + ETZ(I+1,J,K) )
      ZEXM  = 0.5 * ( ZEX(I,J,K) + ZEX(I+1,J,K) )
      ZEYM  = 0.5 * ( ZEY(I,J,K) + ZEY(I+1,J,K) )
      ZEZM  = 0.5 * ( ZEZ(I,J,K) + ZEZ(I+1,J,K) )
      AJAM  = 0.5 * ( AJA(I,J,K) + AJA(I+1,J,K) )
      UM    = 0.5 * (   U(I,J,K) +   U(I+1,J,K) )
      VM    = 0.5 * (   V(I,J,K) +   V(I+1,J,K) )
      WM    = 0.5 * (   W(I,J,K) +   W(I+1,J,K) )
      TM    = 0.5 * (   T(I,J,K) +   T(I+1,J,K) )
      ! x,y,z�����̌v�Z(XI�����̕��ϗ�) --------------------------------
      UXIM   = ( -  U(I,J,K) +  U(I+1,J,K) )
      VXIM   = ( -  V(I,J,K) +  V(I+1,J,K) )
      WXIM   = ( -  W(I,J,K) +  W(I+1,J,K) )
      TXIM   = ( -  T(I,J,K) +  T(I+1,J,K) )
      UETM   = 0.5 * ( - 0.5*(   U(I,J-1,K) +   U(I+1,J-1,K) ) &
      &                + 0.5*(   U(I,J+1,K) +   U(I+1,J+1,K) )  )
      VETM   = 0.5 * ( - 0.5*(   V(I,J-1,K) +   V(I+1,J-1,K) ) &
      &                + 0.5*(   V(I,J+1,K) +   V(I+1,J+1,K) )  )
      WETM   = 0.5 * ( - 0.5*(   W(I,J-1,K) +   W(I+1,J-1,K) ) &
      &                + 0.5*(   W(I,J+1,K) +   W(I+1,J+1,K) )  )
      TETM   = 0.5 * ( - 0.5*(   T(I,J-1,K) +   T(I+1,J-1,K) ) &
      &                + 0.5*(   T(I,J+1,K) +   T(I+1,J+1,K) )  )
      UZEM   = 0.5 * ( - 0.5*(   U(I,J,K-1) +   U(I+1,J,K-1) ) &
      &                + 0.5*(   U(I,J,K+1) +   U(I+1,J,K+1) )  )
      VZEM   = 0.5 * ( - 0.5*(   V(I,J,K-1) +   V(I+1,J,K-1) ) &
      &                + 0.5*(   V(I,J,K+1) +   V(I+1,J,K+1) )  )
      WZEM   = 0.5 * ( - 0.5*(   W(I,J,K-1) +   W(I+1,J,K-1) ) &
      &                + 0.5*(   W(I,J,K+1) +   W(I+1,J,K+1) )  )
      TZEM   = 0.5 * ( - 0.5*(   T(I,J,K-1) +   T(I+1,J,K-1) ) &
      &                + 0.5*(   T(I,J,K+1) +   T(I+1,J,K+1) )  )
      UXM   = XIXM *  UXIM + ETXM *  UETM + ZEXM *  UZEM
      UYM   = XIYM *  UXIM + ETYM *  UETM + ZEYM *  UZEM
      UZM   = XIZM *  UXIM + ETZM *  UETM + ZEZM *  UZEM
      VXM   = XIXM *  VXIM + ETXM *  VETM + ZEXM *  VZEM
      VYM   = XIYM *  VXIM + ETYM *  VETM + ZEYM *  VZEM
      VZM   = XIZM *  VXIM + ETZM *  VETM + ZEZM *  VZEM
      WXM   = XIXM *  WXIM + ETXM *  WETM + ZEXM *  WZEM
      WYM   = XIYM *  WXIM + ETYM *  WETM + ZEYM *  WZEM
      WZM   = XIZM *  WXIM + ETZM *  WETM + ZEZM *  WZEM
      TXM   = XIXM *  TXIM + ETXM *  TETM + ZEXM *  TZEM
      TYM   = XIYM *  TXIM + ETYM *  TETM + ZEYM *  TZEM
      TZM   = XIZM *  TXIM + ETZM *  TETM + ZEZM *  TZEM
      ! �S���W����XI�����̕��ϗ� ---------------------------------------
      AMUM  = 0.5 * (AMU(I,J,K) + AMU(I+1,J,K))
      ! �g�U���x�N�g���̌v�Z -------------------------------------------
      DELVM = UXM+VYM+WZM
      TAUXX = AMUM*(2.0*UXM-2.0/3.0*DELVM)
      TAUYY = AMUM*(2.0*VYM-2.0/3.0*DELVM)
      TAUZZ = AMUM*(2.0*WZM-2.0/3.0*DELVM)
      TAUXY = AMUM*(UYM+VXM)
      TAUYZ = AMUM*(VZM+WYM)
      TAUZX = AMUM*(WXM+UZM)
      QX    =-(AMUM/PR)/(GAMMA-1.0)*GAMMA*RG*TXM
      QY    =-(AMUM/PR)/(GAMMA-1.0)*GAMMA*RG*TYM
      QZ    =-(AMUM/PR)/(GAMMA-1.0)*GAMMA*RG*TZM
      R5    = TAUXX*UM + TAUXY*VM + TAUZX*WM-QX
      S5    = TAUXY*UM + TAUYY*VM + TAUYZ*WM-QY
      T5    = TAUZX*UM + TAUYZ*VM + TAUZZ*WM-QZ
      RH(I,J,K,1) = 0.0
      RH(I,J,K,2) = (XIXM*TAUXX + XIYM*TAUXY + XIZM*TAUZX)/AJAM
      RH(I,J,K,3) = (XIXM*TAUXY + XIYM*TAUYY + XIZM*TAUYZ)/AJAM
      RH(I,J,K,4) = (XIXM*TAUZX + XIYM*TAUYZ + XIZM*TAUZZ)/AJAM
      RH(I,J,K,5) = (XIXM*R5    + XIYM*S5    + XIZM*T5   )/AJAM
    ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE VISXI
!***********************************************************************
!**** �g�U��(�S����)�̌v�Z(ET����)                                  ****
!***********************************************************************
SUBROUTINE VISET
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM
  REAL :: UM, VM, WM, TM
  REAL :: UXIM, VXIM, WXIM, TXIM, &
  &       UETM, VETM, WETM, TETM, &
  &       UZEM, VZEM, WZEM, TZEM
  REAL :: UXM, VXM, WXM, TXM, &
  &       UYM, VYM, WYM, TYM, &
  &       UZM, VZM, WZM, TZM
  REAL :: AMUM
  REAL :: DELVM, TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX
  REAL :: QX, QY, QZ
  REAL :: R5, S5, T5
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM, &
!$OMP& UM, VM, WM, TM, &
!$OMP& UXIM, VXIM, WXIM, TXIM, &
!$OMP& UETM, VETM, WETM, TETM, &
!$OMP& UZEM, VZEM, WZEM, TZEM, &
!$OMP& UXM, VXM, WXM, TXM, &
!$OMP& UYM, VYM, WYM, TYM, &
!$OMP& UZM, VZM, WZM, TZM, &
!$OMP& AMUM, DELVM, TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX, &
!$OMP& QX, QY, QZ, R5, S5, T5 &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS    , JE - 1
  DO I = IS + 1, IE - 1
    IF( QH(I,J,K,1) .GT. 0.0 .AND. QH(I,J+1,K,1) .GT. 0.0 ) THEN
      ! ET�����̕��ϗʂ̌v�Z -------------------------------------------
      XIXM  = 0.5 * ( XIX(I,J,K) + XIX(I,J+1,K) )
      XIYM  = 0.5 * ( XIY(I,J,K) + XIY(I,J+1,K) )
      XIZM  = 0.5 * ( XIZ(I,J,K) + XIZ(I,J+1,K) )
      ETXM  = 0.5 * ( ETX(I,J,K) + ETX(I,J+1,K) )
      ETYM  = 0.5 * ( ETY(I,J,K) + ETY(I,J+1,K) )
      ETZM  = 0.5 * ( ETZ(I,J,K) + ETZ(I,J+1,K) )
      ZEXM  = 0.5 * ( ZEX(I,J,K) + ZEX(I,J+1,K) )
      ZEYM  = 0.5 * ( ZEY(I,J,K) + ZEY(I,J+1,K) )
      ZEZM  = 0.5 * ( ZEZ(I,J,K) + ZEZ(I,J+1,K) )
      AJAM  = 0.5 * ( AJA(I,J,K) + AJA(I,J+1,K) )
      UM    = 0.5 * (   U(I,J,K) +   U(I,J+1,K) )
      VM    = 0.5 * (   V(I,J,K) +   V(I,J+1,K) )
      WM    = 0.5 * (   W(I,J,K) +   W(I,J+1,K) )
      TM    = 0.5 * (   T(I,J,K) +   T(I,J+1,K) )
      ! x,y,z�����̌v�Z(ET�����̕��ϗ�) --------------------------------
      UXIM   = 0.5 * ( - 0.5*(   U(I-1,J,K) +   U(I-1,J+1,K) ) &
      &                + 0.5*(   U(I+1,J,K) +   U(I+1,J+1,K) )  )
      VXIM   = 0.5 * ( - 0.5*(   V(I-1,J,K) +   V(I-1,J+1,K) ) &
      &                + 0.5*(   V(I+1,J,K) +   V(I+1,J+1,K) )  )
      WXIM   = 0.5 * ( - 0.5*(   W(I-1,J,K) +   W(I-1,J+1,K) ) &
      &                + 0.5*(   W(I+1,J,K) +   W(I+1,J+1,K) )  )
      TXIM   = 0.5 * ( - 0.5*(   T(I-1,J,K) +   T(I-1,J+1,K) ) &
      &                + 0.5*(   T(I+1,J,K) +   T(I+1,J+1,K) )  )
      UETM   = ( -  U(I,J,K) +  U(I,J+1,K) )
      VETM   = ( -  V(I,J,K) +  V(I,J+1,K) )
      WETM   = ( -  W(I,J,K) +  W(I,J+1,K) )
      TETM   = ( -  T(I,J,K) +  T(I,J+1,K) )
      UZEM   = 0.5 * ( - 0.5*(   U(I,J,K-1) +   U(I,J+1,K-1) ) &
      &                + 0.5*(   U(I,J,K+1) +   U(I,J+1,K+1) )  )
      VZEM   = 0.5 * ( - 0.5*(   V(I,J,K-1) +   V(I,J+1,K-1) ) &
      &                + 0.5*(   V(I,J,K+1) +   V(I,J+1,K+1) )  )
      WZEM   = 0.5 * ( - 0.5*(   W(I,J,K-1) +   W(I,J+1,K-1) ) &
      &                + 0.5*(   W(I,J,K+1) +   W(I,J+1,K+1) )  )
      TZEM   = 0.5 * ( - 0.5*(   T(I,J,K-1) +   T(I,J+1,K-1) ) &
      &                + 0.5*(   T(I,J,K+1) +   T(I,J+1,K+1) )  )
      UXM   = XIXM *  UXIM + ETXM *  UETM + ZEXM *  UZEM
      UYM   = XIYM *  UXIM + ETYM *  UETM + ZEYM *  UZEM
      UZM   = XIZM *  UXIM + ETZM *  UETM + ZEZM *  UZEM
      VXM   = XIXM *  VXIM + ETXM *  VETM + ZEXM *  VZEM
      VYM   = XIYM *  VXIM + ETYM *  VETM + ZEYM *  VZEM
      VZM   = XIZM *  VXIM + ETZM *  VETM + ZEZM *  VZEM
      WXM   = XIXM *  WXIM + ETXM *  WETM + ZEXM *  WZEM
      WYM   = XIYM *  WXIM + ETYM *  WETM + ZEYM *  WZEM
      WZM   = XIZM *  WXIM + ETZM *  WETM + ZEZM *  WZEM
      TXM   = XIXM *  TXIM + ETXM *  TETM + ZEXM *  TZEM
      TYM   = XIYM *  TXIM + ETYM *  TETM + ZEYM *  TZEM
      TZM   = XIZM *  TXIM + ETZM *  TETM + ZEZM *  TZEM
      ! �S���W����ET�����̕��ϗ� ---------------------------------------
      AMUM  = 0.5 * (AMU(I,J,K) + AMU(I,J+1,K))
      ! �g�U���x�N�g���̌v�Z -------------------------------------------
      DELVM = UXM+VYM+WZM
      TAUXX = AMUM*(2.0*UXM-2.0/3.0*DELVM)
      TAUYY = AMUM*(2.0*VYM-2.0/3.0*DELVM)
      TAUZZ = AMUM*(2.0*WZM-2.0/3.0*DELVM)
      TAUXY = AMUM*(UYM+VXM)
      TAUYZ = AMUM*(VZM+WYM)
      TAUZX = AMUM*(WXM+UZM)
      QX    =-(AMUM/PR)/(GAMMA-1.0)*GAMMA*RG*TXM
      QY    =-(AMUM/PR)/(GAMMA-1.0)*GAMMA*RG*TYM
      QZ    =-(AMUM/PR)/(GAMMA-1.0)*GAMMA*RG*TZM
      R5    = TAUXX*UM + TAUXY*VM + TAUZX*WM-QX
      S5    = TAUXY*UM + TAUYY*VM + TAUYZ*WM-QY
      T5    = TAUZX*UM + TAUYZ*VM + TAUZZ*WM-QZ
      SH(I,J,K,1) = 0.0
      SH(I,J,K,2) = (ETXM*TAUXX + ETYM*TAUXY + ETZM*TAUZX)/AJAM
      SH(I,J,K,3) = (ETXM*TAUXY + ETYM*TAUYY + ETZM*TAUYZ)/AJAM
      SH(I,J,K,4) = (ETXM*TAUZX + ETYM*TAUYZ + ETZM*TAUZZ)/AJAM
      SH(I,J,K,5) = (ETXM*R5    + ETYM*S5    + ETZM*T5   )/AJAM
    ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE VISET
!***********************************************************************
!**** �g�U��(�S����)�̌v�Z(ZE����)                                  ****
!***********************************************************************
SUBROUTINE VISZE
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM
  REAL :: UM, VM, WM, TM
  REAL :: UXIM, VXIM, WXIM, TXIM, &
  &       UETM, VETM, WETM, TETM, &
  &       UZEM, VZEM, WZEM, TZEM
  REAL :: UXM, VXM, WXM, TXM, &
  &       UYM, VYM, WYM, TYM, &
  &       UZM, VZM, WZM, TZM
  REAL :: AMUM
  REAL :: DELVM, TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX
  REAL :: QX, QY, QZ
  REAL :: R5, S5, T5
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM, &
!$OMP& UM, VM, WM, TM, &
!$OMP& UXIM, VXIM, WXIM, TXIM, &
!$OMP& UETM, VETM, WETM, TETM, &
!$OMP& UZEM, VZEM, WZEM, TZEM, &
!$OMP& UXM, VXM, WXM, TXM, &
!$OMP& UYM, VYM, WYM, TYM, &
!$OMP& UZM, VZM, WZM, TZM, &
!$OMP& AMUM, DELVM, TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX, &
!$OMP& QX, QY, QZ, R5, S5, T5 &
!$OMP& )
  DO K = KS    , KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
    IF( QH(I,J,K,1) .GT. 0.0 .AND. QH(I,J,K+1,1) .GT. 0.0 ) THEN
      ! ZE�����̕��ϗʂ̌v�Z -------------------------------------------
      XIXM  = 0.5 * ( XIX(I,J,K) + XIX(I,J,K+1) )
      XIYM  = 0.5 * ( XIY(I,J,K) + XIY(I,J,K+1) )
      XIZM  = 0.5 * ( XIZ(I,J,K) + XIZ(I,J,K+1) )
      ETXM  = 0.5 * ( ETX(I,J,K) + ETX(I,J,K+1) )
      ETYM  = 0.5 * ( ETY(I,J,K) + ETY(I,J,K+1) )
      ETZM  = 0.5 * ( ETZ(I,J,K) + ETZ(I,J,K+1) )
      ZEXM  = 0.5 * ( ZEX(I,J,K) + ZEX(I,J,K+1) )
      ZEYM  = 0.5 * ( ZEY(I,J,K) + ZEY(I,J,K+1) )
      ZEZM  = 0.5 * ( ZEZ(I,J,K) + ZEZ(I,J,K+1) )
      AJAM  = 0.5 * ( AJA(I,J,K) + AJA(I,J,K+1) )
      UM    = 0.5 * (   U(I,J,K) +   U(I,J,K+1) )
      VM    = 0.5 * (   V(I,J,K) +   V(I,J,K+1) )
      WM    = 0.5 * (   W(I,J,K) +   W(I,J,K+1) )
      TM    = 0.5 * (   T(I,J,K) +   T(I,J,K+1) )
      ! x,y,z�����̌v�Z(ZE�����̕��ϗ�) --------------------------------
      UXIM   = 0.5 * ( - 0.5*(   U(I-1,J,K) +   U(I-1,J,K+1) ) &
      &                + 0.5*(   U(I+1,J,K) +   U(I+1,J,K+1) )  )
      VXIM   = 0.5 * ( - 0.5*(   V(I-1,J,K) +   V(I-1,J,K+1) ) &
      &                + 0.5*(   V(I+1,J,K) +   V(I+1,J,K+1) )  )
      WXIM   = 0.5 * ( - 0.5*(   W(I-1,J,K) +   W(I-1,J,K+1) ) &
      &                + 0.5*(   W(I+1,J,K) +   W(I+1,J,K+1) )  )
      TXIM   = 0.5 * ( - 0.5*(   T(I-1,J,K) +   T(I-1,J,K+1) ) &
      &                + 0.5*(   T(I+1,J,K) +   T(I+1,J,K+1) )  )
      UETM   = 0.5 * ( - 0.5*(   U(I,J-1,K) +   U(I,J-1,K+1) ) &
      &                + 0.5*(   U(I,J+1,K) +   U(I,J+1,K+1) )  )
      VETM   = 0.5 * ( - 0.5*(   V(I,J-1,K) +   V(I,J-1,K+1) ) &
      &                + 0.5*(   V(I,J+1,K) +   V(I,J+1,K+1) )  )
      WETM   = 0.5 * ( - 0.5*(   W(I,J-1,K) +   W(I,J-1,K+1) ) &
      &                + 0.5*(   W(I,J+1,K) +   W(I,J+1,K+1) )  )
      TETM   = 0.5 * ( - 0.5*(   T(I,J-1,K) +   T(I,J-1,K+1) ) &
      &                + 0.5*(   T(I,J+1,K) +   T(I,J+1,K+1) )  )
      UZEM   = ( -  U(I,J,K) +  U(I,J,K+1) )
      VZEM   = ( -  V(I,J,K) +  V(I,J,K+1) )
      WZEM   = ( -  W(I,J,K) +  W(I,J,K+1) )
      TZEM   = ( -  T(I,J,K) +  T(I,J,K+1) )
      UXM   = XIXM *  UXIM + ETXM *  UETM + ZEXM *  UZEM
      UYM   = XIYM *  UXIM + ETYM *  UETM + ZEYM *  UZEM
      UZM   = XIZM *  UXIM + ETZM *  UETM + ZEZM *  UZEM
      VXM   = XIXM *  VXIM + ETXM *  VETM + ZEXM *  VZEM
      VYM   = XIYM *  VXIM + ETYM *  VETM + ZEYM *  VZEM
      VZM   = XIZM *  VXIM + ETZM *  VETM + ZEZM *  VZEM
      WXM   = XIXM *  WXIM + ETXM *  WETM + ZEXM *  WZEM
      WYM   = XIYM *  WXIM + ETYM *  WETM + ZEYM *  WZEM
      WZM   = XIZM *  WXIM + ETZM *  WETM + ZEZM *  WZEM
      TXM   = XIXM *  TXIM + ETXM *  TETM + ZEXM *  TZEM
      TYM   = XIYM *  TXIM + ETYM *  TETM + ZEYM *  TZEM
      TZM   = XIZM *  TXIM + ETZM *  TETM + ZEZM *  TZEM
      ! �S���W����ZE�����̕��ϗ� ---------------------------------------
      AMUM  = 0.5 * (AMU(I,J,K) + AMU(I,J,K+1))
      ! �g�U���x�N�g���̌v�Z -------------------------------------------
      DELVM = UXM+VYM+WZM
      TAUXX = AMUM*(2.0*UXM-2.0/3.0*DELVM)
      TAUYY = AMUM*(2.0*VYM-2.0/3.0*DELVM)
      TAUZZ = AMUM*(2.0*WZM-2.0/3.0*DELVM)
      TAUXY = AMUM*(UYM+VXM)
      TAUYZ = AMUM*(VZM+WYM)
      TAUZX = AMUM*(WXM+UZM)
      QX    =-(AMUM/PR)/(GAMMA-1.0)*GAMMA*RG*TXM
      QY    =-(AMUM/PR)/(GAMMA-1.0)*GAMMA*RG*TYM
      QZ    =-(AMUM/PR)/(GAMMA-1.0)*GAMMA*RG*TZM
      R5    = TAUXX*UM + TAUXY*VM + TAUZX*WM-QX
      S5    = TAUXY*UM + TAUYY*VM + TAUYZ*WM-QY
      T5    = TAUZX*UM + TAUYZ*VM + TAUZZ*WM-QZ
      TH(I,J,K,1) = 0.0
      TH(I,J,K,2) = (ZEXM*TAUXX + ZEYM*TAUXY + ZEZM*TAUZX)/AJAM
      TH(I,J,K,3) = (ZEXM*TAUXY + ZEYM*TAUYY + ZEZM*TAUYZ)/AJAM
      TH(I,J,K,4) = (ZEXM*TAUZX + ZEYM*TAUYZ + ZEZM*TAUZZ)/AJAM
      TH(I,J,K,5) = (ZEXM*R5    + ZEYM*S5    + ZEZM*T5   )/AJAM
    ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE VISZE
! ��`�I�� *************************************************************
END SUBROUTINE Viscosity3D
!***********************************************************************
!**** �������f�� : RANS, EVM, Standard k-e Model (1974)             ****
!**** �v�Z�Ώ� : �P��, �񎟌�, ���k��                               ****
!**** �v�Z�X�L�[�� : �񎟐��x���S����(�X�^�K�[�h�i�q��̓_���g�p)   ****
!***********************************************************************
SUBROUTINE Turbulence2DEvmStd( &
&            PELIM, RG, GAMMA, PR, PRT, &
&            IS, IE, JS, JE, LS, LE, &
&            XIX, XIY, ETX, ETY, AJA, &
&            QH, U, V, T, AK, EPS, AMU, &
&            AMUT, DQD, DQP &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, PARAMETER :: CMU = 0.09
  REAL, PARAMETER :: CE1 = 1.44, CE2 = 1.92
  REAL, PARAMETER :: SIGK = 1.0, SIGE = 1.3
  REAL, PARAMETER :: ZERO = 1.0E-20
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: PELIM
  REAL,    INTENT(IN)  :: RG, GAMMA, PR, PRT
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE
  INTEGER, INTENT(IN)  :: LS, LE
  REAL,    INTENT(IN)  :: XIX(IS: IE, JS: JE), XIY(IS: IE, JS: JE), &
  &                       ETX(IS: IE, JS: JE), ETY(IS: IE, JS: JE), &
  &                       AJA(IS: IE, JS: JE)
  REAL,    INTENT(IN)  :: QH(IS: IE, JS: JE, LS: LE)
  REAL,    INTENT(IN)  :: U(IS: IE, JS: JE), V(IS: IE, JS: JE), &
  &                       T(IS: IE, JS: JE), &
  &                       AK(IS: IE, JS: JE), EPS(IS: IE, JS: JE)
  REAL,    INTENT(IN)  :: AMU(IS: IE, JS: JE)
  REAL,    INTENT(OUT) :: AMUT(IS: IE, JS: JE)
  REAL,    INTENT(OUT) :: DQD(IS: IE, JS: JE, LS: LE)
  REAL,    INTENT(OUT) :: DQP(IS: IE, JS: JE, LS: LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, ALLOCATABLE :: RH(:, :, :), SH(:, :, :)
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 6) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �������m�� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ALLOCATE(RH(IS: IE, JS: JE, LS: LE), SH(IS: IE, JS: JE, LS: LE))
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  AMUT = 0.0
  DQD  = 0.0
  DQP  = 0.0
  ! �����葱���̌Ăяo�� +++++++++++++++++++++++++++++++++++++++++++++++
  CALL NonDiffTerm
  CALL DiffTerm
  ! �����I�� ***********************************************************
  RETURN
! �����葱�� ***********************************************************
CONTAINS
!***********************************************************************
!**** ��g�U���̌v�Z                                                ****
!***********************************************************************
SUBROUTINE NonDiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: UXI, VXI, UET, VET
  REAL    :: UX, VX, UY, VY
  REAL    :: DELV, SS2, PRO, EPSPK
  ! �����J�n ***********************************************************
  ! �Q�S���W���̌v�Z +++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I, J)
  DO J = JS, JE
  DO I = IS, IE
  IF(QH(I,J,1) .GT. 0.0 .AND. QH(I,J,6) .GT. ZERO) THEN
    AMUT(I,J) = CMU * QH(I,J,5)**2 / QH(I,J,6) * AJA(I,J)
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �������ƎU�퍀�̌v�Z +++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, UXI, VXI, UET, VET, UX, VX, UY, VY, DELV, SS2, PRO, EPSPK &
!$OMP& )
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( (QH(I,J-1,1) .GT. 0.0) .AND. (QH(I-1,J,1) .GT. 0.0) .AND. &
  &   (QH(I,J,1)   .GT. 0.0) .AND. &
  &   (QH(I+1,J,1) .GT. 0.0) .AND. (QH(I,J+1,1) .GT. 0.0) &
  & ) THEN
    ! �Ђ��ݑ��x�e���\���̌v�Z -----------------------------------------
    UXI = (-U(I-1,J  ) + U(I+1,J  )) * 0.5
    VXI = (-V(I-1,J  ) + V(I+1,J  )) * 0.5
    UET = (-U(I  ,J-1) + U(I  ,J+1)) * 0.5
    VET = (-V(I  ,J-1) + V(I  ,J+1)) * 0.5
    UX  = XIX(I,J) * UXI + ETX(I,J) * UET
    UY  = XIY(I,J) * UXI + ETY(I,J) * UET
    VX  = XIX(I,J) * VXI + ETX(I,J) * VET
    VY  = XIY(I,J) * VXI + ETY(I,J) * VET
    ! �������̌v�Z -----------------------------------------------------
    DELV = UX + VY
    SS2  = 2.0 * (UX**2 + VY**2) + (UY + VX)**2 - 2.0 / 3.0 * DELV**2
    PRO  = AMUT(I,J) * SS2 &
    &    - 2.0 / 3.0 * QH(I,J,5) * AJA(I,J) * DELV
    ! �Ǐ����t����(�����ƎU��̃o�����X)�ɂ�郊�~�b�^�[
    IF(PELIM .GT. 0.0) THEN
      PRO = MAX(0.0, MIN(QH(I,J,6) * AJA(I,J) / PELIM, PRO))
    ENDIF
    ! ���Y�ƎU��̘a ---------------------------------------------------
    EPSPK = MIN( &
    &       MAX( &
    &         SQRT(SS2), SQRT(QH(I,J,6) * AJA(I,J) / AMU(I,J)) &
    &       ), &
    &       QH(I,J,6) / MAX(ZERO, QH(I,J,5)) &
    &     )
    DQP(I,J,5) = PRO / AJA(I,J) - QH(I,J,6)
    DQP(I,J,6) = (CE1 * PRO / AJA(I,J) - CE2 * QH(I,J,6)) * EPSPK
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE NonDiffTerm
!***********************************************************************
!**** �g�U���̌v�Z                                                  ****
!***********************************************************************
SUBROUTINE DiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, L
  ! �����J�n ***********************************************************
  ! �g�U���̗v�f���v�Z +++++++++++++++++++++++++++++++++++++++++++++++++
  CALL VISXI
  CALL VISET
  ! �g�U���̍��� +++++++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE(I, J, L)
  DO L = LS, LE
  !$OMP DO
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( (QH(I,J-1,1) .GT. 0.0) .AND. (QH(I-1,J,1) .GT. 0.0) .AND. &
  &   (QH(I,J,1)   .GT. 0.0) .AND. &
  &   (QH(I+1,J,1) .GT. 0.0) .AND. (QH(I,J+1,1) .GT. 0.0) &
  & ) THEN
    DQD(I,J,L) = (-RH(I-1,J  ,L) + RH(I,J,L)) &
    &          + (-SH(I  ,J-1,L) + SH(I,J,L))
  ENDIF
  ENDDO
  ENDDO
  !$OMP END DO
  ENDDO
  !$OMP END PARALLEL
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DiffTerm
!***********************************************************************
!**** �g�U��(�S����)�̌v�Z(XI����)                                  ****
!***********************************************************************
SUBROUTINE VISXI
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: XIXM, XIYM, ETXM, ETYM, AJAM
  REAL    :: UM, VM, TM, RHOKM
  REAL    :: UXIM, VXIM, TXIM, AKXIM, EPSXIM, &
  &          UETM, VETM, TETM, AKETM, EPSETM
  REAL    :: UXM, VXM, TXM, AKXM, EPSXM, &
  &          UYM, VYM, TYM, AKYM, EPSYM
  REAL    :: AMUM, AMUTM, AMUKM, AMUEM
  REAL    :: DELVM, TAUXX, TAUYY, TAUXY
  REAL    :: QX, QY
  REAL    :: R4, S4
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, XIXM, XIYM, ETXM, ETYM, AJAM, UM, VM, TM, RHOKM, &
!$OMP& UXIM, VXIM, TXIM, AKXIM, EPSXIM, &
!$OMP& UETM, VETM, TETM, AKETM, EPSETM, &
!$OMP& UXM, VXM, TXM, AKXM, EPSXM, &
!$OMP& UYM, VYM, TYM, AKYM, EPSYM, &
!$OMP& AMUM, AMUTM, AMUKM, AMUEM, &
!$OMP& DELVM, TAUXX, TAUYY, TAUXY, QX, QY, R4, S4 &
!$OMP& )
  DO J = JS + 1, JE - 1
  DO I = IS    , IE - 1
  IF(QH(I,J,1) .GT. 0.0 .AND. QH(I+1,J,1) .GT. 0.0) THEN
    ! XI�����̕��ϗʂ̌v�Z ---------------------------------------------
    XIXM  = 0.5 * (XIX(I,J) + XIX(I+1,J))
    XIYM  = 0.5 * (XIY(I,J) + XIY(I+1,J))
    ETXM  = 0.5 * (ETX(I,J) + ETX(I+1,J))
    ETYM  = 0.5 * (ETY(I,J) + ETY(I+1,J))
    AJAM  = 0.5 * (AJA(I,J) + AJA(I+1,J))
    UM    = 0.5 * (  U(I,J) +   U(I+1,J))
    VM    = 0.5 * (  V(I,J) +   V(I+1,J))
    TM    = 0.5 * (  T(I,J) +   T(I+1,J))
    RHOKM = 0.5 * (QH(I,J,5) * AJA(I,J) + QH(I+1,J,5) * AJA(I+1,J))
    ! x,y�����̌v�Z(XI�����̕��ϗ�) ------------------------------------
    UXIM   = (-  U(I,J) +   U(I+1,J))
    VXIM   = (-  V(I,J) +   V(I+1,J))
    TXIM   = (-  T(I,J) +   T(I+1,J))
    AKXIM  = (- AK(I,J) +  AK(I+1,J))
    EPSXIM = (-EPS(I,J) + EPS(I+1,J))
    UETM   = 0.5 * ( - 0.5 * (  U(I,J-1) +   U(I+1,J-1)) &
    &                + 0.5 * (  U(I,J+1) +   U(I+1,J+1)) )
    VETM   = 0.5 * ( - 0.5 * (  V(I,J-1) +   V(I+1,J-1)) &
    &                + 0.5 * (  V(I,J+1) +   V(I+1,J+1)) )
    TETM   = 0.5 * ( - 0.5 * (  T(I,J-1) +   T(I+1,J-1)) &
    &                + 0.5 * (  T(I,J+1) +   T(I+1,J+1)) )
    AKETM  = 0.5 * ( - 0.5 * ( AK(I,J-1) +  AK(I+1,J-1)) &
    &                + 0.5 * ( AK(I,J+1) +  AK(I+1,J+1)) )
    EPSETM = 0.5 * ( - 0.5 * (EPS(I,J-1) + EPS(I+1,J-1)) &
    &                + 0.5 * (EPS(I,J+1) + EPS(I+1,J+1)) )
    UXM   = XIXM *   UXIM + ETXM *   UETM
    UYM   = XIYM *   UXIM + ETYM *   UETM
    VXM   = XIXM *   VXIM + ETXM *   VETM
    VYM   = XIYM *   VXIM + ETYM *   VETM
    TXM   = XIXM *   TXIM + ETXM *   TETM
    TYM   = XIYM *   TXIM + ETYM *   TETM
    AKXM  = XIXM *  AKXIM + ETXM *  AKETM
    AKYM  = XIYM *  AKXIM + ETYM *  AKETM
    EPSXM = XIXM * EPSXIM + ETXM * EPSETM
    EPSYM = XIYM * EPSXIM + ETYM * EPSETM
    ! �S���W����XI�����̕��ϗ� -----------------------------------------
    AMUM  = 0.5 * ( AMU(I,J) +  AMU(I+1,J))
    AMUTM = 0.5 * (AMUT(I,J) + AMUT(I+1,J))
    AMUKM = AMUM + AMUTM / SIGK
    AMUEM = AMUM + AMUTM / SIGE
    ! �g�U���x�N�g���̌v�Z ---------------------------------------------
    DELVM = UXM + VYM
    TAUXX = (AMUM + AMUTM) * (2.0 * UXM - 2.0 / 3.0 * DELVM) &
    &     - 2.0 / 3.0 * RHOKM
    TAUYY = (AMUM + AMUTM) * (2.0 * VYM - 2.0 / 3.0 * DELVM) &
    &     - 2.0 / 3.0 * RHOKM
    TAUXY = (AMUM + AMUTM) * (UYM + VXM)
    QX    =-(AMUM / PR + AMUTM / PRT) &
    &     / (GAMMA - 1.0) * GAMMA * RG * TXM
    QY    =-(AMUM / PR + AMUTM / PRT) &
    &     / (GAMMA - 1.0) * GAMMA * RG * TYM
    R4    = TAUXX * UM + TAUXY * VM - QX
    S4    = TAUXY * UM + TAUYY * VM - QY
    RH(I,J,1) = 0.0
    RH(I,J,2) = (XIXM * TAUXX + XIYM * TAUXY) / AJAM
    RH(I,J,3) = (XIXM * TAUXY + XIYM * TAUYY) / AJAM
    RH(I,J,4) = (XIXM * R4    + XIYM * S4   ) / AJAM
    RH(I,J,5) = AMUKM * (XIXM *  AKXM + XIYM *  AKYM) / AJAM
    RH(I,J,6) = AMUEM * (XIXM * EPSXM + XIYM * EPSYM) / AJAM
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE VISXI
!***********************************************************************
!**** �g�U��(�S����)�̌v�Z(ET����)                                  ****
!***********************************************************************
SUBROUTINE VISET
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: XIXM, XIYM, ETXM, ETYM, AJAM
  REAL    :: UM, VM, TM, RHOKM
  REAL    :: UXIM, VXIM, TXIM, AKXIM, EPSXIM, &
  &          UETM, VETM, TETM, AKETM, EPSETM
  REAL    :: UXM, VXM, TXM, AKXM, EPSXM, &
  &          UYM, VYM, TYM, AKYM, EPSYM
  REAL    :: AMUM, AMUTM, AMUKM, AMUEM
  REAL    :: DELVM, TAUXX, TAUYY, TAUXY
  REAL    :: QX, QY
  REAL    :: R4, S4
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, XIXM, XIYM, ETXM, ETYM, AJAM, UM, VM, TM, RHOKM, &
!$OMP& UXIM, VXIM, TXIM, AKXIM, EPSXIM, &
!$OMP& UETM, VETM, TETM, AKETM, EPSETM, &
!$OMP& UXM, VXM, TXM, AKXM, EPSXM, &
!$OMP& UYM, VYM, TYM, AKYM, EPSYM, &
!$OMP& AMUM, AMUTM, AMUKM, AMUEM, &
!$OMP& DELVM, TAUXX, TAUYY, TAUXY, QX, QY, R4, S4 &
!$OMP& )
  DO J = JS    , JE - 1
  DO I = IS + 1, IE - 1
  IF(QH(I,J,1) .GT. 0.0 .AND. QH(I,J+1,1) .GT. 0.0) THEN
    ! ET�����̕��ϗʂ̌v�Z ---------------------------------------------
    XIXM  = 0.5 * (XIX(I,J) + XIX(I,J+1))
    XIYM  = 0.5 * (XIY(I,J) + XIY(I,J+1))
    ETXM  = 0.5 * (ETX(I,J) + ETX(I,J+1))
    ETYM  = 0.5 * (ETY(I,J) + ETY(I,J+1))
    AJAM  = 0.5 * (AJA(I,J) + AJA(I,J+1))
    UM    = 0.5 * (  U(I,J) +   U(I,J+1))
    VM    = 0.5 * (  V(I,J) +   V(I,J+1))
    TM    = 0.5 * (  T(I,J) +   T(I,J+1))
    RHOKM = 0.5 * (QH(I,J,5) * AJA(I,J) + QH(I,J+1,5) * AJA(I,J+1))
    ! x,y�����̌v�Z(ET�����̕��ϗ�) ------------------------------------
    UXIM   = 0.5 * ( - 0.5*(  U(I-1,J) +   U(I-1,J+1)) &
    &                + 0.5*(  U(I+1,J) +   U(I+1,J+1)) )
    VXIM   = 0.5 * ( - 0.5*(  V(I-1,J) +   V(I-1,J+1)) &
    &                + 0.5*(  V(I+1,J) +   V(I+1,J+1)) )
    TXIM   = 0.5 * ( - 0.5*(  T(I-1,J) +   T(I-1,J+1)) &
    &                + 0.5*(  T(I+1,J) +   T(I+1,J+1)) )
    AKXIM  = 0.5 * ( - 0.5*( AK(I-1,J) +  AK(I-1,J+1)) &
    &                + 0.5*( AK(I+1,J) +  AK(I+1,J+1)) )
    EPSXIM = 0.5 * ( - 0.5*(EPS(I-1,J) + EPS(I-1,J+1)) &
    &                + 0.5*(EPS(I+1,J) + EPS(I+1,J+1)) )
    UETM   = (-  U(I,J) +   U(I,J+1))
    VETM   = (-  V(I,J) +   V(I,J+1))
    TETM   = (-  T(I,J) +   T(I,J+1))
    AKETM  = (- AK(I,J) +  AK(I,J+1))
    EPSETM = (-EPS(I,J) + EPS(I,J+1))
    UXM   = XIXM *   UXIM + ETXM *   UETM
    UYM   = XIYM *   UXIM + ETYM *   UETM
    VXM   = XIXM *   VXIM + ETXM *   VETM
    VYM   = XIYM *   VXIM + ETYM *   VETM
    TXM   = XIXM *   TXIM + ETXM *   TETM
    TYM   = XIYM *   TXIM + ETYM *   TETM
    AKXM  = XIXM *  AKXIM + ETXM *  AKETM
    AKYM  = XIYM *  AKXIM + ETYM *  AKETM
    EPSXM = XIXM * EPSXIM + ETXM * EPSETM
    EPSYM = XIYM * EPSXIM + ETYM * EPSETM
    ! �S���W����ET�����̕��ϗ� -----------------------------------------
    AMUM  = 0.5 * ( AMU(I,J) +  AMU(I,J+1))
    AMUTM = 0.5 * (AMUT(I,J) + AMUT(I,J+1))
    AMUKM = AMUM + AMUTM / SIGK
    AMUEM = AMUM + AMUTM / SIGE
    ! �g�U���x�N�g���̌v�Z ---------------------------------------------
    DELVM = UXM + VYM
    TAUXX = (AMUM + AMUTM) * (2.0 * UXM - 2.0 / 3.0 * DELVM) &
    &     - 2.0 / 3.0 * RHOKM
    TAUYY = (AMUM + AMUTM) * (2.0 * VYM - 2.0 / 3.0 * DELVM) &
    &     - 2.0 / 3.0 * RHOKM
    TAUXY = (AMUM + AMUTM) * (UYM + VXM)
    QX    =-(AMUM / PR + AMUTM / PRT) &
    &     / (GAMMA - 1.0) * GAMMA * RG * TXM
    QY    =-(AMUM / PR + AMUTM / PRT) &
    &     / (GAMMA - 1.0) * GAMMA * RG * TYM
    R4    = TAUXX * UM + TAUXY * VM - QX
    S4    = TAUXY * UM + TAUYY * VM - QY
    SH(I,J,1) = 0.0
    SH(I,J,2) = (ETXM * TAUXX + ETYM * TAUXY) / AJAM
    SH(I,J,3) = (ETXM * TAUXY + ETYM * TAUYY) / AJAM
    SH(I,J,4) = (ETXM * R4    + ETYM * S4   ) / AJAM
    SH(I,J,5) = AMUKM * (ETXM *  AKXM + ETYM *  AKYM) / AJAM
    SH(I,J,6) = AMUEM * (ETXM * EPSXM + ETYM * EPSYM) / AJAM
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE VISET
! ��`�I�� *************************************************************
END SUBROUTINE Turbulence2DEvmStd
!***********************************************************************
!**** �������f�� : RANS, EVM, Standard k-e Model (1974)             ****
!****                         with Kato-Launder Modification (1993) ****
!**** �v�Z�Ώ� : �P��, �񎟌�, ���k��                               ****
!**** �v�Z�X�L�[�� : �񎟐��x���S����(�X�^�K�[�h�i�q��̓_���g�p)   ****
!***********************************************************************
SUBROUTINE Turbulence2DEvmStdKL( &
&            PELIM, RG, GAMMA, PR, PRT, &
&            IS, IE, JS, JE, LS, LE, &
&            XIX, XIY, ETX, ETY, AJA, &
&            QH, U, V, T, AK, EPS, AMU, &
&            AMUT, DQD, DQP &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, PARAMETER :: CMU = 0.09
  REAL, PARAMETER :: CE1 = 1.44, CE2 = 1.92
  REAL, PARAMETER :: SIGK = 1.0, SIGE = 1.3
  REAL, PARAMETER :: ZERO = 1.0E-20
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: PELIM
  REAL,    INTENT(IN)  :: RG, GAMMA, PR, PRT
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE
  INTEGER, INTENT(IN)  :: LS, LE
  REAL,    INTENT(IN)  :: XIX(IS: IE, JS: JE), XIY(IS: IE, JS: JE), &
  &                       ETX(IS: IE, JS: JE), ETY(IS: IE, JS: JE), &
  &                       AJA(IS: IE, JS: JE)
  REAL,    INTENT(IN)  :: QH(IS: IE, JS: JE, LS: LE)
  REAL,    INTENT(IN)  :: U(IS: IE, JS: JE), V(IS: IE, JS: JE), &
  &                       T(IS: IE, JS: JE), &
  &                       AK(IS: IE, JS: JE), EPS(IS: IE, JS: JE)
  REAL,    INTENT(IN)  :: AMU(IS: IE, JS: JE)
  REAL,    INTENT(OUT) :: AMUT(IS: IE, JS: JE)
  REAL,    INTENT(OUT) :: DQD(IS: IE, JS: JE, LS: LE)
  REAL,    INTENT(OUT) :: DQP(IS: IE, JS: JE, LS: LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, ALLOCATABLE :: RH(:, :, :), SH(:, :, :)
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 6) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �������m�� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ALLOCATE(RH(IS: IE, JS: JE, LS: LE), SH(IS: IE, JS: JE, LS: LE))
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  AMUT = 0.0
  DQD  = 0.0
  DQP  = 0.0
  ! �����葱���̌Ăяo�� +++++++++++++++++++++++++++++++++++++++++++++++
  CALL NonDiffTerm
  CALL DiffTerm
  ! �����I�� ***********************************************************
  RETURN
! �����葱�� ***********************************************************
CONTAINS
!***********************************************************************
!**** ��g�U���̌v�Z                                                ****
!***********************************************************************
SUBROUTINE NonDiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: UXI, VXI, UET, VET
  REAL    :: UX, VX, UY, VY
  REAL    :: DELV, SS2, SC, OMG, OS, PRO, EPSPK
  ! �����J�n ***********************************************************
  ! �Q�S���W���̌v�Z +++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I, J)
  DO J = JS, JE
  DO I = IS, IE
  IF(QH(I,J,1) .GT. 0.0 .AND. QH(I,J,6) .GT. ZERO) THEN
    AMUT(I,J) = CMU * QH(I,J,5)**2 / QH(I,J,6) * AJA(I,J)
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �������ƎU�퍀�̌v�Z +++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, &
!$OMP& UXI, VXI, UET, VET, UX, UY, VX, VY, &
!$OMP& DELV, SS2, SC, OMG, OS, PRO, EPSPK &
!$OMP& )
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( (QH(I,J-1,1) .GT. 0.0) .AND. (QH(I-1,J,1) .GT. 0.0) .AND. &
  &   (QH(I,J,1)   .GT. 0.0) .AND. &
  &   (QH(I+1,J,1) .GT. 0.0) .AND. (QH(I,J+1,1) .GT. 0.0) &
  & ) THEN
    ! �Ђ��ݑ��x�e���\���̌v�Z -----------------------------------------
    UXI = (-U(I-1,J  ) + U(I+1,J  )) * 0.5
    VXI = (-V(I-1,J  ) + V(I+1,J  )) * 0.5
    UET = (-U(I  ,J-1) + U(I  ,J+1)) * 0.5
    VET = (-V(I  ,J-1) + V(I  ,J+1)) * 0.5
    UX  = XIX(I,J) * UXI + ETX(I,J) * UET
    UY  = XIY(I,J) * UXI + ETY(I,J) * UET
    VX  = XIX(I,J) * VXI + ETX(I,J) * VET
    VY  = XIY(I,J) * VXI + ETY(I,J) * VET
    ! �������̌v�Z -----------------------------------------------------
    DELV = UX + VY
    SS2  = 2.0 * (UX**2 + VY**2) + (UY + VX)**2 - 2.0 / 3.0 * DELV**2
    SC  = SQRT(SS2)
    OMG = SQRT((UY - VX)**2)
    ! OMG / SC > 1 �̏ꍇ�AKato-Launder�̏C����K�p���Ȃ�
    IF(SC .GT. ZERO) THEN
      OS = MIN(OMG / SC, 1.0)
    ELSE
      OS = 1.0
    ENDIF
    PRO = OS * ( &
    &     AMUT(I,J) * SS2 &
    &   - 2.0 / 3.0 * DELV * QH(I,J,5) * AJA(I,J) &
    &   )
    ! �Ǐ����t����(�����ƎU��̃o�����X)�ɂ�郊�~�b�^�[
    IF(PELIM .GT. 0.0) THEN
      PRO = MAX(0.0, MIN(QH(I,J,6) * AJA(I,J) / PELIM, PRO))
    ENDIF
    ! ���Y�ƎU��̘a ---------------------------------------------------
    EPSPK = MIN( &
    &       MAX(SC, SQRT(QH(I,J,6) * AJA(I,J) / AMU(I,J))), &
    &       QH(I,J,6) / MAX(ZERO, QH(I,J,5)) &
    &     )
    DQP(I,J,5) = PRO / AJA(I,J) - QH(I,J,6)
    DQP(I,J,6) = (CE1 * PRO / AJA(I,J) - CE2 * QH(I,J,6)) * EPSPK
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE NonDiffTerm
!***********************************************************************
!**** �g�U���̌v�Z                                                  ****
!***********************************************************************
SUBROUTINE DiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, L
  ! �����J�n ***********************************************************
  ! �g�U���̗v�f���v�Z +++++++++++++++++++++++++++++++++++++++++++++++++
  CALL VISXI
  CALL VISET
  ! �g�U���̍��� +++++++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE(I, J, L)
  DO L = LS, LE
  !$OMP DO
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( (QH(I,J-1,1) .GT. 0.0) .AND. (QH(I-1,J,1) .GT. 0.0) .AND. &
  &   (QH(I,J,1)   .GT. 0.0) .AND. &
  &   (QH(I+1,J,1) .GT. 0.0) .AND. (QH(I,J+1,1) .GT. 0.0) &
  & ) THEN
    DQD(I,J,L) = (-RH(I-1,J  ,L) + RH(I,J,L)) &
    &          + (-SH(I  ,J-1,L) + SH(I,J,L))
  ENDIF
  ENDDO
  ENDDO
  !$OMP END DO
  ENDDO
  !$OMP END PARALLEL
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DiffTerm
!***********************************************************************
!**** �g�U��(�S����)�̌v�Z(XI����)                                  ****
!***********************************************************************
SUBROUTINE VISXI
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: XIXM, XIYM, ETXM, ETYM, AJAM
  REAL    :: UM, VM, TM, RHOKM
  REAL    :: UXIM, VXIM, TXIM, AKXIM, EPSXIM, &
  &          UETM, VETM, TETM, AKETM, EPSETM
  REAL    :: UXM, VXM, TXM, AKXM, EPSXM, &
  &          UYM, VYM, TYM, AKYM, EPSYM
  REAL    :: AMUM, AMUTM, AMUKM, AMUEM
  REAL    :: DELVM, TAUXX, TAUYY, TAUXY
  REAL    :: QX, QY
  REAL    :: R4, S4
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, XIXM, XIYM, ETXM, ETYM, AJAM, UM, VM, TM, RHOKM, &
!$OMP& UXIM, VXIM, TXIM, AKXIM, EPSXIM, &
!$OMP& UETM, VETM, TETM, AKETM, EPSETM, &
!$OMP& UXM, VXM, TXM, AKXM, EPSXM, &
!$OMP& UYM, VYM, TYM, AKYM, EPSYM, &
!$OMP& AMUM, AMUTM, AMUKM, AMUEM, &
!$OMP& DELVM, TAUXX, TAUYY, TAUXY, QX, QY, R4, S4 &
!$OMP& )
  DO J = JS + 1, JE - 1
  DO I = IS    , IE - 1
  IF(QH(I,J,1) .GT. 0.0 .AND. QH(I+1,J,1) .GT. 0.0) THEN
    ! XI�����̕��ϗʂ̌v�Z ---------------------------------------------
    XIXM  = 0.5 * (XIX(I,J) + XIX(I+1,J))
    XIYM  = 0.5 * (XIY(I,J) + XIY(I+1,J))
    ETXM  = 0.5 * (ETX(I,J) + ETX(I+1,J))
    ETYM  = 0.5 * (ETY(I,J) + ETY(I+1,J))
    AJAM  = 0.5 * (AJA(I,J) + AJA(I+1,J))
    UM    = 0.5 * (  U(I,J) +   U(I+1,J))
    VM    = 0.5 * (  V(I,J) +   V(I+1,J))
    TM    = 0.5 * (  T(I,J) +   T(I+1,J))
    RHOKM = 0.5 * (QH(I,J,5) * AJA(I,J) + QH(I+1,J,5) * AJA(I+1,J))
    ! x,y�����̌v�Z(XI�����̕��ϗ�) ------------------------------------
    UXIM   = (-  U(I,J) +   U(I+1,J))
    VXIM   = (-  V(I,J) +   V(I+1,J))
    TXIM   = (-  T(I,J) +   T(I+1,J))
    AKXIM  = (- AK(I,J) +  AK(I+1,J))
    EPSXIM = (-EPS(I,J) + EPS(I+1,J))
    UETM   = 0.5 * ( - 0.5 * (  U(I,J-1) +   U(I+1,J-1)) &
    &                + 0.5 * (  U(I,J+1) +   U(I+1,J+1)) )
    VETM   = 0.5 * ( - 0.5 * (  V(I,J-1) +   V(I+1,J-1)) &
    &                + 0.5 * (  V(I,J+1) +   V(I+1,J+1)) )
    TETM   = 0.5 * ( - 0.5 * (  T(I,J-1) +   T(I+1,J-1)) &
    &                + 0.5 * (  T(I,J+1) +   T(I+1,J+1)) )
    AKETM  = 0.5 * ( - 0.5 * ( AK(I,J-1) +  AK(I+1,J-1)) &
    &                + 0.5 * ( AK(I,J+1) +  AK(I+1,J+1)) )
    EPSETM = 0.5 * ( - 0.5 * (EPS(I,J-1) + EPS(I+1,J-1)) &
    &                + 0.5 * (EPS(I,J+1) + EPS(I+1,J+1)) )
    UXM   = XIXM *   UXIM + ETXM *   UETM
    UYM   = XIYM *   UXIM + ETYM *   UETM
    VXM   = XIXM *   VXIM + ETXM *   VETM
    VYM   = XIYM *   VXIM + ETYM *   VETM
    TXM   = XIXM *   TXIM + ETXM *   TETM
    TYM   = XIYM *   TXIM + ETYM *   TETM
    AKXM  = XIXM *  AKXIM + ETXM *  AKETM
    AKYM  = XIYM *  AKXIM + ETYM *  AKETM
    EPSXM = XIXM * EPSXIM + ETXM * EPSETM
    EPSYM = XIYM * EPSXIM + ETYM * EPSETM
    ! �S���W����XI�����̕��ϗ� -----------------------------------------
    AMUM  = 0.5 * ( AMU(I,J) +  AMU(I+1,J))
    AMUTM = 0.5 * (AMUT(I,J) + AMUT(I+1,J))
    AMUKM = AMUM + AMUTM / SIGK
    AMUEM = AMUM + AMUTM / SIGE
    ! �g�U���x�N�g���̌v�Z ---------------------------------------------
    DELVM = UXM + VYM
    TAUXX = (AMUM + AMUTM) * (2.0 * UXM - 2.0 / 3.0 * DELVM) &
    &     - 2.0 / 3.0 * RHOKM
    TAUYY = (AMUM + AMUTM) * (2.0 * VYM - 2.0 / 3.0 * DELVM) &
    &     - 2.0 / 3.0 * RHOKM
    TAUXY = (AMUM + AMUTM) * (UYM + VXM)
    QX    =-(AMUM / PR + AMUTM / PRT) &
    &     / (GAMMA - 1.0) * GAMMA * RG * TXM
    QY    =-(AMUM / PR + AMUTM / PRT) &
    &     / (GAMMA - 1.0) * GAMMA * RG * TYM
    R4    = TAUXX * UM + TAUXY * VM - QX
    S4    = TAUXY * UM + TAUYY * VM - QY
    RH(I,J,1) = 0.0
    RH(I,J,2) = (XIXM * TAUXX + XIYM * TAUXY) / AJAM
    RH(I,J,3) = (XIXM * TAUXY + XIYM * TAUYY) / AJAM
    RH(I,J,4) = (XIXM * R4    + XIYM * S4   ) / AJAM
    RH(I,J,5) = AMUKM * (XIXM *  AKXM + XIYM *  AKYM) / AJAM
    RH(I,J,6) = AMUEM * (XIXM * EPSXM + XIYM * EPSYM) / AJAM
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE VISXI
!***********************************************************************
!**** �g�U��(�S����)�̌v�Z(ET����)                                  ****
!***********************************************************************
SUBROUTINE VISET
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: XIXM, XIYM, ETXM, ETYM, AJAM
  REAL    :: UM, VM, TM, RHOKM
  REAL    :: UXIM, VXIM, TXIM, AKXIM, EPSXIM, &
  &          UETM, VETM, TETM, AKETM, EPSETM
  REAL    :: UXM, VXM, TXM, AKXM, EPSXM, &
  &          UYM, VYM, TYM, AKYM, EPSYM
  REAL    :: AMUM, AMUTM, AMUKM, AMUEM
  REAL    :: DELVM, TAUXX, TAUYY, TAUXY
  REAL    :: QX, QY
  REAL    :: R4, S4
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, XIXM, XIYM, ETXM, ETYM, AJAM, UM, VM, TM, RHOKM, &
!$OMP& UXIM, VXIM, TXIM, AKXIM, EPSXIM, &
!$OMP& UETM, VETM, TETM, AKETM, EPSETM, &
!$OMP& UXM, VXM, TXM, AKXM, EPSXM, &
!$OMP& UYM, VYM, TYM, AKYM, EPSYM, &
!$OMP& AMUM, AMUTM, AMUKM, AMUEM, &
!$OMP& DELVM, TAUXX, TAUYY, TAUXY, QX, QY, R4, S4 &
!$OMP& )
  DO J = JS    , JE - 1
  DO I = IS + 1, IE - 1
  IF(QH(I,J,1) .GT. 0.0 .AND. QH(I,J+1,1) .GT. 0.0) THEN
    ! ET�����̕��ϗʂ̌v�Z ---------------------------------------------
    XIXM  = 0.5 * (XIX(I,J) + XIX(I,J+1))
    XIYM  = 0.5 * (XIY(I,J) + XIY(I,J+1))
    ETXM  = 0.5 * (ETX(I,J) + ETX(I,J+1))
    ETYM  = 0.5 * (ETY(I,J) + ETY(I,J+1))
    AJAM  = 0.5 * (AJA(I,J) + AJA(I,J+1))
    UM    = 0.5 * (  U(I,J) +   U(I,J+1))
    VM    = 0.5 * (  V(I,J) +   V(I,J+1))
    TM    = 0.5 * (  T(I,J) +   T(I,J+1))
    RHOKM = 0.5 * (QH(I,J,5) * AJA(I,J) + QH(I,J+1,5) * AJA(I,J+1))
    ! x,y�����̌v�Z(ET�����̕��ϗ�) ------------------------------------
    UXIM   = 0.5 * ( - 0.5*(  U(I-1,J) +   U(I-1,J+1)) &
    &                + 0.5*(  U(I+1,J) +   U(I+1,J+1)) )
    VXIM   = 0.5 * ( - 0.5*(  V(I-1,J) +   V(I-1,J+1)) &
    &                + 0.5*(  V(I+1,J) +   V(I+1,J+1)) )
    TXIM   = 0.5 * ( - 0.5*(  T(I-1,J) +   T(I-1,J+1)) &
    &                + 0.5*(  T(I+1,J) +   T(I+1,J+1)) )
    AKXIM  = 0.5 * ( - 0.5*( AK(I-1,J) +  AK(I-1,J+1)) &
    &                + 0.5*( AK(I+1,J) +  AK(I+1,J+1)) )
    EPSXIM = 0.5 * ( - 0.5*(EPS(I-1,J) + EPS(I-1,J+1)) &
    &                + 0.5*(EPS(I+1,J) + EPS(I+1,J+1)) )
    UETM   = (-  U(I,J) +   U(I,J+1))
    VETM   = (-  V(I,J) +   V(I,J+1))
    TETM   = (-  T(I,J) +   T(I,J+1))
    AKETM  = (- AK(I,J) +  AK(I,J+1))
    EPSETM = (-EPS(I,J) + EPS(I,J+1))
    UXM   = XIXM *   UXIM + ETXM *   UETM
    UYM   = XIYM *   UXIM + ETYM *   UETM
    VXM   = XIXM *   VXIM + ETXM *   VETM
    VYM   = XIYM *   VXIM + ETYM *   VETM
    TXM   = XIXM *   TXIM + ETXM *   TETM
    TYM   = XIYM *   TXIM + ETYM *   TETM
    AKXM  = XIXM *  AKXIM + ETXM *  AKETM
    AKYM  = XIYM *  AKXIM + ETYM *  AKETM
    EPSXM = XIXM * EPSXIM + ETXM * EPSETM
    EPSYM = XIYM * EPSXIM + ETYM * EPSETM
    ! �S���W����ET�����̕��ϗ� -----------------------------------------
    AMUM  = 0.5 * ( AMU(I,J) +  AMU(I,J+1))
    AMUTM = 0.5 * (AMUT(I,J) + AMUT(I,J+1))
    AMUKM = AMUM + AMUTM / SIGK
    AMUEM = AMUM + AMUTM / SIGE
    ! �g�U���x�N�g���̌v�Z ---------------------------------------------
    DELVM = UXM + VYM
    TAUXX = (AMUM + AMUTM) * (2.0 * UXM - 2.0 / 3.0 * DELVM) &
    &     - 2.0 / 3.0 * RHOKM
    TAUYY = (AMUM + AMUTM) * (2.0 * VYM - 2.0 / 3.0 * DELVM) &
    &     - 2.0 / 3.0 * RHOKM
    TAUXY = (AMUM + AMUTM) * (UYM + VXM)
    QX    =-(AMUM / PR + AMUTM / PRT) &
    &     / (GAMMA - 1.0) * GAMMA * RG * TXM
    QY    =-(AMUM / PR + AMUTM / PRT) &
    &     / (GAMMA - 1.0) * GAMMA * RG * TYM
    R4    = TAUXX * UM + TAUXY * VM - QX
    S4    = TAUXY * UM + TAUYY * VM - QY
    SH(I,J,1) = 0.0
    SH(I,J,2) = (ETXM * TAUXX + ETYM * TAUXY) / AJAM
    SH(I,J,3) = (ETXM * TAUXY + ETYM * TAUYY) / AJAM
    SH(I,J,4) = (ETXM * R4    + ETYM * S4   ) / AJAM
    SH(I,J,5) = AMUKM * (ETXM *  AKXM + ETYM *  AKYM) / AJAM
    SH(I,J,6) = AMUEM * (ETXM * EPSXM + ETYM * EPSYM) / AJAM
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE VISET
! ��`�I�� *************************************************************
END SUBROUTINE Turbulence2DEvmStdKL
!***********************************************************************
!**** �������f�� : RANS, EVM, Standard k-e Model (1974)             ****
!**** �v�Z�Ώ� : �P��, �O����, ���k��                               ****
!**** �v�Z�X�L�[�� : �񎟐��x���S����(�X�^�K�[�h�i�q��̓_���g�p)   ****
!***********************************************************************
SUBROUTINE Turbulence3DEvmStd( &
&            PELIM, RG, GAMMA, PR, PRT, &
&            IS, IE, JS, JE, KS, KE, LS, LE, &
&            XIX, XIY, XIZ, ETX, ETY, ETZ, ZEX, ZEY, ZEZ, AJA, &
&            QH, U, V, W, T, AK, EPS, AMU, &
&            AMUT, DQD, DQP &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, PARAMETER :: CMU = 0.09
  REAL, PARAMETER :: CE1 = 1.44, CE2 = 1.92
  REAL, PARAMETER :: SIGK = 1.0, SIGE = 1.3
  REAL, PARAMETER :: ZERO = 1.0E-20
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: PELIM
  REAL,    INTENT(IN)  :: RG, GAMMA, PR, PRT
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE, KS, KE
  INTEGER, INTENT(IN)  :: LS, LE
  REAL,    INTENT(IN)  :: XIX(IS: IE, JS: JE, KS: KE), &
  &                       XIY(IS: IE, JS: JE, KS: KE), &
  &                       XIZ(IS: IE, JS: JE, KS: KE), &
  &                       ETX(IS: IE, JS: JE, KS: KE), &
  &                       ETY(IS: IE, JS: JE, KS: KE), &
  &                       ETZ(IS: IE, JS: JE, KS: KE), &
  &                       ZEX(IS: IE, JS: JE, KS: KE), &
  &                       ZEY(IS: IE, JS: JE, KS: KE), &
  &                       ZEZ(IS: IE, JS: JE, KS: KE), &
  &                       AJA(IS: IE, JS: JE, KS: KE)
  REAL,    INTENT(IN)  :: QH(IS: IE, JS: JE, KS: KE, LS: LE)
  REAL,    INTENT(IN)  :: U(IS: IE, JS: JE, KS: KE), &
  &                       V(IS: IE, JS: JE, KS: KE), &
  &                       W(IS: IE, JS: JE, KS: KE), &
  &                       T(IS: IE, JS: JE, KS: KE), &
  &                       AK(IS: IE, JS: JE, KS: KE), &
  &                       EPS(IS: IE, JS: JE, KS: KE)
  REAL,    INTENT(IN)  :: AMU(IS: IE, JS: JE, KS: KE)
  REAL,    INTENT(OUT) :: AMUT(IS: IE, JS: JE, KS: KE)
  REAL,    INTENT(OUT) :: DQD(IS: IE, JS: JE, KS: KE, LS: LE)
  REAL,    INTENT(OUT) :: DQP(IS: IE, JS: JE, KS: KE, LS: LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, ALLOCATABLE :: RH(:, :, :, :), SH(:, :, :, :), TH(:, :, :, :)
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 7) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �������m�� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ALLOCATE(RH(IS: IE, JS: JE, KS: KE, LS: LE))
  ALLOCATE(SH(IS: IE, JS: JE, KS: KE, LS: LE))
  ALLOCATE(TH(IS: IE, JS: JE, KS: KE, LS: LE))
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  AMUT = 0.0
  DQD  = 0.0
  DQP  = 0.0
  ! �����葱���̌Ăяo�� +++++++++++++++++++++++++++++++++++++++++++++++
  CALL NonDiffTerm
  CALL DiffTerm
  ! �����I�� ***********************************************************
  RETURN
! �����葱�� ***********************************************************
CONTAINS
!***********************************************************************
!**** ��g�U���̌v�Z                                                ****
!***********************************************************************
SUBROUTINE NonDiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: UXI, VXI, WXI, UET, VET, WET, UZE, VZE, WZE
  REAL    :: UX, VX, WX, UY, VY, WY, UZ, VZ, WZ
  REAL    :: DELV, SS2, PRO, EPSPK
  ! �����J�n ***********************************************************
  ! �Q�S���W���̌v�Z +++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I, J, K)
  DO K = KS, KE
  DO J = JS, JE
  DO I = IS, IE
  IF(QH(I,J,K,1) .GT. 0.0 .AND. QH(I,J,K,7) .GT. ZERO) THEN
    AMUT(I,J,K) = CMU * QH(I,J,K,6)**2 / QH(I,J,K,7) * AJA(I,J,K)
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �������ƎU�퍀�̌v�Z +++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& UXI, VXI, WXI, UET, VET, WET, UZE, VZE, WZE, &
!$OMP& UX, VX, WX, UY, VY, WY, UZ, VZ, WZ, &
!$OMP& DELV, PRO, EPSPK &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( ( QH(I  ,J  ,K  ,1) .GT. 0.0 ) .AND. &
  &   ( QH(I-1,J  ,K  ,1) .GT. 0.0 ) .AND. &
  &   ( QH(I+1,J  ,K  ,1) .GT. 0.0 ) .AND. &
  &   ( QH(I  ,J-1,K  ,1) .GT. 0.0 ) .AND. &
  &   ( QH(I  ,J+1,K  ,1) .GT. 0.0 ) .AND. &
  &   ( QH(I  ,J  ,K-1,1) .GT. 0.0 ) .AND. &
  &   ( QH(I  ,J  ,K+1,1) .GT. 0.0 ) &
  & ) THEN
    ! �Ђ��ݑ��x�e���\���̌v�Z -----------------------------------------
    UXI = ( -  U(I-1,J  ,K  ) +  U(I+1,J  ,K  ) )*0.5
    VXI = ( -  V(I-1,J  ,K  ) +  V(I+1,J  ,K  ) )*0.5
    WXI = ( -  W(I-1,J  ,K  ) +  W(I+1,J  ,K  ) )*0.5
    UET = ( -  U(I  ,J-1,K  ) +  U(I  ,J+1,K  ) )*0.5
    VET = ( -  V(I  ,J-1,K  ) +  V(I  ,J+1,K  ) )*0.5
    WET = ( -  W(I  ,J-1,K  ) +  W(I  ,J+1,K  ) )*0.5
    UZE = ( -  U(I  ,J  ,K-1) +  U(I  ,J  ,K+1) )*0.5
    VZE = ( -  V(I  ,J  ,K-1) +  V(I  ,J  ,K+1) )*0.5
    WZE = ( -  W(I  ,J  ,K-1) +  W(I  ,J  ,K+1) )*0.5
    UX  = XIX(I,J,K)*UXI + ETX(I,J,K)*UET + ZEX(I,J,K)*UZE
    UY  = XIY(I,J,K)*UXI + ETY(I,J,K)*UET + ZEY(I,J,K)*UZE
    UZ  = XIZ(I,J,K)*UXI + ETZ(I,J,K)*UET + ZEZ(I,J,K)*UZE
    VX  = XIX(I,J,K)*VXI + ETX(I,J,K)*VET + ZEX(I,J,K)*VZE
    VY  = XIY(I,J,K)*VXI + ETY(I,J,K)*VET + ZEY(I,J,K)*VZE
    VZ  = XIZ(I,J,K)*VXI + ETZ(I,J,K)*VET + ZEZ(I,J,K)*VZE
    WX  = XIX(I,J,K)*WXI + ETX(I,J,K)*WET + ZEX(I,J,K)*WZE
    WY  = XIY(I,J,K)*WXI + ETY(I,J,K)*WET + ZEY(I,J,K)*WZE
    WZ  = XIZ(I,J,K)*WXI + ETZ(I,J,K)*WET + ZEZ(I,J,K)*WZE
    ! �������̌v�Z -----------------------------------------------------
    DELV = UX+VY+WZ
    SS2  = 2.0*(UX**2 + VY**2 + WZ**2) &
    &    + (UY+VX)**2 + (VZ+WY)**2 + (WX+UZ)**2 &
    &    - 2.0/3.0 * DELV**2
    PRO  = AMUT(I,J,K)*SS2 &
    &    - 2.0/3.0 * QH(I,J,K,6)*AJA(I,J,K) * DELV
    ! �Ǐ����t����(�����ƎU��̃o�����X)�ɂ�郊�~�b�^�[
    IF(PELIM .GT. 0.0) THEN
      PRO = MAX(0.0, MIN(QH(I,J,K,7) * AJA(I,J,K) / PELIM, PRO))
    ENDIF
    ! �����ƎU��̘a ---------------------------------------------------
    EPSPK = MIN( &
    &       MAX( &
    &         SQRT(SS2), &
    &         SQRT(QH(I,J,K,7) * AJA(I,J,K) / AMU(I,J,K)) &
    &       ), &
    &       QH(I,J,K,7) / MAX(ZERO, QH(I,J,K,6)) &
    &     )
    DQP(I,J,K,6) = PRO/AJA(I,J,K) - QH(I,J,K,7)
    DQP(I,J,K,7) = (CE1*PRO/AJA(I,J,K)-CE2*QH(I,J,K,7))*EPSPK
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE NonDiffTerm
!***********************************************************************
!**** �g�U���̌v�Z                                                  ****
!***********************************************************************
SUBROUTINE DiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K, L
  ! �����J�n ***********************************************************
  ! �g�U���̗v�f���v�Z +++++++++++++++++++++++++++++++++++++++++++++++++
  CALL VISXI
  CALL VISET
  CALL VISZE
  ! �g�U���̍��� +++++++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE(I, J, K, L)
  DO L = LS, LE
  !$OMP DO
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( (QH(I,J,K-1,1) .GT. 0.0) .AND. (QH(I,J-1,K,1) .GT. 0.0) .AND. &
  &   (QH(I-1,J,K,1) .GT. 0.0) .AND. (QH(I,J,K,1)   .GT. 0.0) .AND. &
  &   (QH(I+1,J,K,1) .GT. 0.0) .AND. (QH(I,J+1,K,1) .GT. 0.0) .AND. &
  &   (QH(I,J,K+1,1) .GT. 0.0) &
  & ) THEN
    DQD(I,J,K,L) = (-RH(I-1,J  ,K  ,L) + RH(I,J,K,L) ) &
    &            + (-SH(I  ,J-1,K  ,L) + SH(I,J,K,L) ) &
    &            + (-TH(I  ,J  ,K-1,L) + TH(I,J,K,L) )
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END DO
  ENDDO
  !$OMP END PARALLEL
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DiffTerm
!***********************************************************************
!**** �g�U��(�S����)�̌v�Z(XI����)                                  ****
!***********************************************************************
SUBROUTINE VISXI
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM
  REAL    :: UM, VM, WM, TM, RHOKM
  REAL    :: UXIM, VXIM, WXIM, TXIM, AKXIM, EPSXIM, &
  &          UETM, VETM, WETM, TETM, AKETM, EPSETM, &
  &          UZEM, VZEM, WZEM, TZEM, AKZEM, EPSZEM
  REAL    :: UXM, VXM, WXM, TXM, AKXM, EPSXM, &
  &          UYM, VYM, WYM, TYM, AKYM, EPSYM, &
  &          UZM, VZM, WZM, TZM, AKZM, EPSZM
  REAL    :: AMUM, AMUTM, AMUKM, AMUEM
  REAL    :: DELVM, TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX
  REAL    :: QX, QY, QZ
  REAL    :: R5, S5, T5
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM, &
!$OMP& UM, VM, WM, TM, RHOKM, &
!$OMP& UXIM, VXIM, WXIM, TXIM, AKXIM, EPSXIM, &
!$OMP& UETM, VETM, WETM, TETM, AKETM, EPSETM, &
!$OMP& UZEM, VZEM, WZEM, TZEM, AKZEM, EPSZEM, &
!$OMP& UXM, VXM, WXM, TXM, AKXM, EPSXM, &
!$OMP& UYM, VYM, WYM, TYM, AKYM, EPSYM, &
!$OMP& UZM, VZM, WZM, TZM, AKZM, EPSZM, &
!$OMP& AMUM, AMUTM, AMUKM, AMUEM, &
!$OMP& DELVM, TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX, &
!$OMP& QX, QY, QZ, R5, S5, T5 &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS    , IE - 1
  IF( QH(I,J,K,1) .GT. 0.0 .AND. QH(I+1,J,K,1) .GT. 0.0 ) THEN
    ! XI�����̕��ϗʂ̌v�Z ---------------------------------------------
    XIXM  = 0.5 * ( XIX(I,J,K) + XIX(I+1,J,K) )
    XIYM  = 0.5 * ( XIY(I,J,K) + XIY(I+1,J,K) )
    XIZM  = 0.5 * ( XIZ(I,J,K) + XIZ(I+1,J,K) )
    ETXM  = 0.5 * ( ETX(I,J,K) + ETX(I+1,J,K) )
    ETYM  = 0.5 * ( ETY(I,J,K) + ETY(I+1,J,K) )
    ETZM  = 0.5 * ( ETZ(I,J,K) + ETZ(I+1,J,K) )
    ZEXM  = 0.5 * ( ZEX(I,J,K) + ZEX(I+1,J,K) )
    ZEYM  = 0.5 * ( ZEY(I,J,K) + ZEY(I+1,J,K) )
    ZEZM  = 0.5 * ( ZEZ(I,J,K) + ZEZ(I+1,J,K) )
    AJAM  = 0.5 * ( AJA(I,J,K) + AJA(I+1,J,K) )
    UM    = 0.5 * (   U(I,J,K) +   U(I+1,J,K) )
    VM    = 0.5 * (   V(I,J,K) +   V(I+1,J,K) )
    WM    = 0.5 * (   W(I,J,K) +   W(I+1,J,K) )
    TM    = 0.5 * (   T(I,J,K) +   T(I+1,J,K) )
    RHOKM = 0.5 * (  QH(I  ,J,K,6)*AJA(I  ,J,K) &
    &             +  QH(I+1,J,K,6)*AJA(I+1,J,K) )
    ! x,y,z�����̌v�Z(XI�����̕��ϗ�) ----------------------------------
    UXIM   = ( -  U(I,J,K) +  U(I+1,J,K) )
    VXIM   = ( -  V(I,J,K) +  V(I+1,J,K) )
    WXIM   = ( -  W(I,J,K) +  W(I+1,J,K) )
    TXIM   = ( -  T(I,J,K) +  T(I+1,J,K) )
    AKXIM  = ( - AK(I,J,K) + AK(I+1,J,K) )
    EPSXIM = ( -EPS(I,J,K) +EPS(I+1,J,K) )
    UETM   = 0.5 * ( - 0.5*(   U(I,J-1,K) +   U(I+1,J-1,K) ) &
    &                + 0.5*(   U(I,J+1,K) +   U(I+1,J+1,K) )  )
    VETM   = 0.5 * ( - 0.5*(   V(I,J-1,K) +   V(I+1,J-1,K) ) &
    &                + 0.5*(   V(I,J+1,K) +   V(I+1,J+1,K) )  )
    WETM   = 0.5 * ( - 0.5*(   W(I,J-1,K) +   W(I+1,J-1,K) ) &
    &                + 0.5*(   W(I,J+1,K) +   W(I+1,J+1,K) )  )
    TETM   = 0.5 * ( - 0.5*(   T(I,J-1,K) +   T(I+1,J-1,K) ) &
    &                + 0.5*(   T(I,J+1,K) +   T(I+1,J+1,K) )  )
    AKETM  = 0.5 * ( - 0.5*(  AK(I,J-1,K) +  AK(I+1,J-1,K) ) &
    &                + 0.5*(  AK(I,J+1,K) +  AK(I+1,J+1,K) )  )
    EPSETM = 0.5 * ( - 0.5*( EPS(I,J-1,K) + EPS(I+1,J-1,K) ) &
    &                + 0.5*( EPS(I,J+1,K) + EPS(I+1,J+1,K) )  )
    UZEM   = 0.5 * ( - 0.5*(   U(I,J,K-1) +   U(I+1,J,K-1) ) &
    &                + 0.5*(   U(I,J,K+1) +   U(I+1,J,K+1) )  )
    VZEM   = 0.5 * ( - 0.5*(   V(I,J,K-1) +   V(I+1,J,K-1) ) &
    &                + 0.5*(   V(I,J,K+1) +   V(I+1,J,K+1) )  )
    WZEM   = 0.5 * ( - 0.5*(   W(I,J,K-1) +   W(I+1,J,K-1) ) &
    &                + 0.5*(   W(I,J,K+1) +   W(I+1,J,K+1) )  )
    TZEM   = 0.5 * ( - 0.5*(   T(I,J,K-1) +   T(I+1,J,K-1) ) &
    &                + 0.5*(   T(I,J,K+1) +   T(I+1,J,K+1) )  )
    AKZEM  = 0.5 * ( - 0.5*(  AK(I,J,K-1) +  AK(I+1,J,K-1) ) &
    &                + 0.5*(  AK(I,J,K+1) +  AK(I+1,J,K+1) )  )
    EPSZEM = 0.5 * ( - 0.5*( EPS(I,J,K-1) + EPS(I+1,J,K-1) ) &
    &                + 0.5*( EPS(I,J,K+1) + EPS(I+1,J,K+1) )  )
    UXM   = XIXM *  UXIM + ETXM *  UETM + ZEXM *  UZEM
    UYM   = XIYM *  UXIM + ETYM *  UETM + ZEYM *  UZEM
    UZM   = XIZM *  UXIM + ETZM *  UETM + ZEZM *  UZEM
    VXM   = XIXM *  VXIM + ETXM *  VETM + ZEXM *  VZEM
    VYM   = XIYM *  VXIM + ETYM *  VETM + ZEYM *  VZEM
    VZM   = XIZM *  VXIM + ETZM *  VETM + ZEZM *  VZEM
    WXM   = XIXM *  WXIM + ETXM *  WETM + ZEXM *  WZEM
    WYM   = XIYM *  WXIM + ETYM *  WETM + ZEYM *  WZEM
    WZM   = XIZM *  WXIM + ETZM *  WETM + ZEZM *  WZEM
    TXM   = XIXM *  TXIM + ETXM *  TETM + ZEXM *  TZEM
    TYM   = XIYM *  TXIM + ETYM *  TETM + ZEYM *  TZEM
    TZM   = XIZM *  TXIM + ETZM *  TETM + ZEZM *  TZEM
    AKXM  = XIXM * AKXIM + ETXM * AKETM + ZEXM * AKZEM
    AKYM  = XIYM * AKXIM + ETYM * AKETM + ZEYM * AKZEM
    AKZM  = XIZM * AKXIM + ETZM * AKETM + ZEZM * AKZEM
    EPSXM = XIXM *EPSXIM + ETXM *EPSETM + ZEXM *EPSZEM
    EPSYM = XIYM *EPSXIM + ETYM *EPSETM + ZEYM *EPSZEM
    EPSZM = XIZM *EPSXIM + ETZM *EPSETM + ZEZM *EPSZEM
    ! �S���W����XI�����̕��ϗ� -----------------------------------------
    AMUM  = 0.5 * (   AMU(I,J,K) +   AMU(I+1,J,K) )
    AMUTM = 0.5 * (  AMUT(I,J,K) +  AMUT(I+1,J,K) )
    AMUKM = AMUM+AMUTM/SIGK
    AMUEM = AMUM+AMUTM/SIGE
    ! �g�U���x�N�g���̌v�Z ---------------------------------------------
    DELVM = UXM+VYM+WZM
    TAUXX = (AMUM+AMUTM)*(2.0*UXM-2.0/3.0*DELVM) &
    &     - 2.0/3.0*RHOKM
    TAUYY = (AMUM+AMUTM)*(2.0*VYM-2.0/3.0*DELVM) &
    &     - 2.0/3.0*RHOKM
    TAUZZ = (AMUM+AMUTM)*(2.0*WZM-2.0/3.0*DELVM) &
    &     - 2.0/3.0*RHOKM
    TAUXY = (AMUM+AMUTM)*(UYM+VXM)
    TAUYZ = (AMUM+AMUTM)*(VZM+WYM)
    TAUZX = (AMUM+AMUTM)*(WXM+UZM)
    QX    =-(AMUM/PR+AMUTM/PRT)/(GAMMA-1.0)*GAMMA*RG*TXM
    QY    =-(AMUM/PR+AMUTM/PRT)/(GAMMA-1.0)*GAMMA*RG*TYM
    QZ    =-(AMUM/PR+AMUTM/PRT)/(GAMMA-1.0)*GAMMA*RG*TZM
    R5    = TAUXX*UM + TAUXY*VM + TAUZX*WM-QX
    S5    = TAUXY*UM + TAUYY*VM + TAUYZ*WM-QY
    T5    = TAUZX*UM + TAUYZ*VM + TAUZZ*WM-QZ
    RH(I,J,K,1) = 0.0
    RH(I,J,K,2) = (XIXM*TAUXX + XIYM*TAUXY + XIZM*TAUZX)/AJAM
    RH(I,J,K,3) = (XIXM*TAUXY + XIYM*TAUYY + XIZM*TAUYZ)/AJAM
    RH(I,J,K,4) = (XIXM*TAUZX + XIYM*TAUYZ + XIZM*TAUZZ)/AJAM
    RH(I,J,K,5) = (XIXM*R5    + XIYM*S5    + XIZM*T5   )/AJAM
    RH(I,J,K,6) = AMUKM*(XIXM* AKXM +XIYM* AKYM +XIZM* AKZM)/AJAM
    RH(I,J,K,7) = AMUEM*(XIXM*EPSXM +XIYM*EPSYM +XIZM*EPSZM)/AJAM
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE VISXI
!***********************************************************************
!**** �g�U��(�S����)�̌v�Z(ET����)                                  ****
!***********************************************************************
SUBROUTINE VISET
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM
  REAL    :: UM, VM, WM, TM, RHOKM
  REAL    :: UXIM, VXIM, WXIM, TXIM, AKXIM, EPSXIM, &
  &          UETM, VETM, WETM, TETM, AKETM, EPSETM, &
  &          UZEM, VZEM, WZEM, TZEM, AKZEM, EPSZEM
  REAL    :: UXM, VXM, WXM, TXM, AKXM, EPSXM, &
  &          UYM, VYM, WYM, TYM, AKYM, EPSYM, &
  &          UZM, VZM, WZM, TZM, AKZM, EPSZM
  REAL    :: AMUM, AMUTM, AMUKM, AMUEM
  REAL    :: DELVM, TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX
  REAL    :: QX, QY, QZ
  REAL    :: R5, S5, T5
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM, &
!$OMP& UM, VM, WM, TM, RHOKM, &
!$OMP& UXIM, VXIM, WXIM, TXIM, AKXIM, EPSXIM, &
!$OMP& UETM, VETM, WETM, TETM, AKETM, EPSETM, &
!$OMP& UZEM, VZEM, WZEM, TZEM, AKZEM, EPSZEM, &
!$OMP& UXM, VXM, WXM, TXM, AKXM, EPSXM, &
!$OMP& UYM, VYM, WYM, TYM, AKYM, EPSYM, &
!$OMP& UZM, VZM, WZM, TZM, AKZM, EPSZM, &
!$OMP& AMUM, AMUTM, AMUKM, AMUEM, &
!$OMP& DELVM, TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX, &
!$OMP& QX, QY, QZ, R5, S5, T5 &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS    , JE - 1
  DO I = IS + 1, IE - 1
  IF( QH(I,J,K,1) .GT. 0.0 .AND. QH(I,J+1,K,1) .GT. 0.0 ) THEN
    ! ET�����̕��ϗʂ̌v�Z ---------------------------------------------
    XIXM  = 0.5 * ( XIX(I,J,K) + XIX(I,J+1,K) )
    XIYM  = 0.5 * ( XIY(I,J,K) + XIY(I,J+1,K) )
    XIZM  = 0.5 * ( XIZ(I,J,K) + XIZ(I,J+1,K) )
    ETXM  = 0.5 * ( ETX(I,J,K) + ETX(I,J+1,K) )
    ETYM  = 0.5 * ( ETY(I,J,K) + ETY(I,J+1,K) )
    ETZM  = 0.5 * ( ETZ(I,J,K) + ETZ(I,J+1,K) )
    ZEXM  = 0.5 * ( ZEX(I,J,K) + ZEX(I,J+1,K) )
    ZEYM  = 0.5 * ( ZEY(I,J,K) + ZEY(I,J+1,K) )
    ZEZM  = 0.5 * ( ZEZ(I,J,K) + ZEZ(I,J+1,K) )
    AJAM  = 0.5 * ( AJA(I,J,K) + AJA(I,J+1,K) )
    UM    = 0.5 * (   U(I,J,K) +   U(I,J+1,K) )
    VM    = 0.5 * (   V(I,J,K) +   V(I,J+1,K) )
    WM    = 0.5 * (   W(I,J,K) +   W(I,J+1,K) )
    TM    = 0.5 * (   T(I,J,K) +   T(I,J+1,K) )
    RHOKM = 0.5 * (  QH(I,J  ,K,6)*AJA(I,J  ,K) &
    &             +  QH(I,J+1,K,6)*AJA(I,J+1,K) )
    ! x,y,z�����̌v�Z(ET�����̕��ϗ�) ----------------------------------
    UXIM   = 0.5 * ( - 0.5*(   U(I-1,J,K) +   U(I-1,J+1,K) ) &
    &                + 0.5*(   U(I+1,J,K) +   U(I+1,J+1,K) )  )
    VXIM   = 0.5 * ( - 0.5*(   V(I-1,J,K) +   V(I-1,J+1,K) ) &
    &                + 0.5*(   V(I+1,J,K) +   V(I+1,J+1,K) )  )
    WXIM   = 0.5 * ( - 0.5*(   W(I-1,J,K) +   W(I-1,J+1,K) ) &
    &                + 0.5*(   W(I+1,J,K) +   W(I+1,J+1,K) )  )
    TXIM   = 0.5 * ( - 0.5*(   T(I-1,J,K) +   T(I-1,J+1,K) ) &
    &                + 0.5*(   T(I+1,J,K) +   T(I+1,J+1,K) )  )
    AKXIM  = 0.5 * ( - 0.5*(  AK(I-1,J,K) +  AK(I-1,J+1,K) ) &
    &                + 0.5*(  AK(I+1,J,K) +  AK(I+1,J+1,K) )  )
    EPSXIM = 0.5 * ( - 0.5*( EPS(I-1,J,K) + EPS(I-1,J+1,K) ) &
    &                + 0.5*( EPS(I+1,J,K) + EPS(I+1,J+1,K) )  )
    UETM   = ( -  U(I,J,K) +  U(I,J+1,K) )
    VETM   = ( -  V(I,J,K) +  V(I,J+1,K) )
    WETM   = ( -  W(I,J,K) +  W(I,J+1,K) )
    TETM   = ( -  T(I,J,K) +  T(I,J+1,K) )
    AKETM  = ( - AK(I,J,K) + AK(I,J+1,K) )
    EPSETM = ( -EPS(I,J,K) +EPS(I,J+1,K) )
    UZEM   = 0.5 * ( - 0.5*(   U(I,J,K-1) +   U(I,J+1,K-1) ) &
    &                + 0.5*(   U(I,J,K+1) +   U(I,J+1,K+1) )  )
    VZEM   = 0.5 * ( - 0.5*(   V(I,J,K-1) +   V(I,J+1,K-1) ) &
    &                + 0.5*(   V(I,J,K+1) +   V(I,J+1,K+1) )  )
    WZEM   = 0.5 * ( - 0.5*(   W(I,J,K-1) +   W(I,J+1,K-1) ) &
    &                + 0.5*(   W(I,J,K+1) +   W(I,J+1,K+1) )  )
    TZEM   = 0.5 * ( - 0.5*(   T(I,J,K-1) +   T(I,J+1,K-1) ) &
    &                + 0.5*(   T(I,J,K+1) +   T(I,J+1,K+1) )  )
    AKZEM  = 0.5 * ( - 0.5*(  AK(I,J,K-1) +  AK(I,J+1,K-1) ) &
    &                + 0.5*(  AK(I,J,K+1) +  AK(I,J+1,K+1) )  )
    EPSZEM = 0.5 * ( - 0.5*( EPS(I,J,K-1) + EPS(I,J+1,K-1) ) &
    &                + 0.5*( EPS(I,J,K+1) + EPS(I,J+1,K+1) )  )
    UXM   = XIXM *  UXIM + ETXM *  UETM + ZEXM *  UZEM
    UYM   = XIYM *  UXIM + ETYM *  UETM + ZEYM *  UZEM
    UZM   = XIZM *  UXIM + ETZM *  UETM + ZEZM *  UZEM
    VXM   = XIXM *  VXIM + ETXM *  VETM + ZEXM *  VZEM
    VYM   = XIYM *  VXIM + ETYM *  VETM + ZEYM *  VZEM
    VZM   = XIZM *  VXIM + ETZM *  VETM + ZEZM *  VZEM
    WXM   = XIXM *  WXIM + ETXM *  WETM + ZEXM *  WZEM
    WYM   = XIYM *  WXIM + ETYM *  WETM + ZEYM *  WZEM
    WZM   = XIZM *  WXIM + ETZM *  WETM + ZEZM *  WZEM
    TXM   = XIXM *  TXIM + ETXM *  TETM + ZEXM *  TZEM
    TYM   = XIYM *  TXIM + ETYM *  TETM + ZEYM *  TZEM
    TZM   = XIZM *  TXIM + ETZM *  TETM + ZEZM *  TZEM
    AKXM  = XIXM * AKXIM + ETXM * AKETM + ZEXM * AKZEM
    AKYM  = XIYM * AKXIM + ETYM * AKETM + ZEYM * AKZEM
    AKZM  = XIZM * AKXIM + ETZM * AKETM + ZEZM * AKZEM
    EPSXM = XIXM *EPSXIM + ETXM *EPSETM + ZEXM *EPSZEM
    EPSYM = XIYM *EPSXIM + ETYM *EPSETM + ZEYM *EPSZEM
    EPSZM = XIZM *EPSXIM + ETZM *EPSETM + ZEZM *EPSZEM
    ! �S���W����ET�����̕��ϗ� -----------------------------------------
    AMUM  = 0.5 * (   AMU(I,J,K) +   AMU(I,J+1,K) )
    AMUTM = 0.5 * (  AMUT(I,J,K) +  AMUT(I,J+1,K) )
    AMUKM = AMUM+AMUTM/SIGK
    AMUEM = AMUM+AMUTM/SIGE
    ! �g�U���x�N�g���̌v�Z ---------------------------------------------
    DELVM = UXM+VYM+WZM
    TAUXX = (AMUM+AMUTM)*(2.0*UXM-2.0/3.0*DELVM) &
    &     - 2.0/3.0*RHOKM
    TAUYY = (AMUM+AMUTM)*(2.0*VYM-2.0/3.0*DELVM) &
    &     - 2.0/3.0*RHOKM
    TAUZZ = (AMUM+AMUTM)*(2.0*WZM-2.0/3.0*DELVM) &
    &     - 2.0/3.0*RHOKM
    TAUXY = (AMUM+AMUTM)*(UYM+VXM)
    TAUYZ = (AMUM+AMUTM)*(VZM+WYM)
    TAUZX = (AMUM+AMUTM)*(WXM+UZM)
    QX    =-(AMUM/PR+AMUTM/PRT)/(GAMMA-1.0)*GAMMA*RG*TXM
    QY    =-(AMUM/PR+AMUTM/PRT)/(GAMMA-1.0)*GAMMA*RG*TYM
    QZ    =-(AMUM/PR+AMUTM/PRT)/(GAMMA-1.0)*GAMMA*RG*TZM
    R5    = TAUXX*UM + TAUXY*VM + TAUZX*WM-QX
    S5    = TAUXY*UM + TAUYY*VM + TAUYZ*WM-QY
    T5    = TAUZX*UM + TAUYZ*VM + TAUZZ*WM-QZ
    SH(I,J,K,1) = 0.0
    SH(I,J,K,2) = (ETXM*TAUXX + ETYM*TAUXY + ETZM*TAUZX)/AJAM
    SH(I,J,K,3) = (ETXM*TAUXY + ETYM*TAUYY + ETZM*TAUYZ)/AJAM
    SH(I,J,K,4) = (ETXM*TAUZX + ETYM*TAUYZ + ETZM*TAUZZ)/AJAM
    SH(I,J,K,5) = (ETXM*R5    + ETYM*S5    + ETZM*T5   )/AJAM
    SH(I,J,K,6) = AMUKM*(ETXM* AKXM +ETYM* AKYM +ETZM* AKZM)/AJAM
    SH(I,J,K,7) = AMUEM*(ETXM*EPSXM +ETYM*EPSYM +ETZM*EPSZM)/AJAM
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE VISET
!***********************************************************************
!**** �g�U��(�S����)�̌v�Z(ZE����)                                  ****
!***********************************************************************
SUBROUTINE VISZE
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM
  REAL    :: UM, VM, WM, TM, RHOKM
  REAL    :: UXIM, VXIM, WXIM, TXIM, AKXIM, EPSXIM, &
  &          UETM, VETM, WETM, TETM, AKETM, EPSETM, &
  &          UZEM, VZEM, WZEM, TZEM, AKZEM, EPSZEM
  REAL    :: UXM, VXM, WXM, TXM, AKXM, EPSXM, &
  &          UYM, VYM, WYM, TYM, AKYM, EPSYM, &
  &          UZM, VZM, WZM, TZM, AKZM, EPSZM
  REAL    :: AMUM, AMUTM, AMUKM, AMUEM
  REAL    :: DELVM, TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX
  REAL    :: QX, QY, QZ
  REAL    :: R5, S5, T5
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM, &
!$OMP& UM, VM, WM, TM, RHOKM, &
!$OMP& UXIM, VXIM, WXIM, TXIM, AKXIM, EPSXIM, &
!$OMP& UETM, VETM, WETM, TETM, AKETM, EPSETM, &
!$OMP& UZEM, VZEM, WZEM, TZEM, AKZEM, EPSZEM, &
!$OMP& UXM, VXM, WXM, TXM, AKXM, EPSXM, &
!$OMP& UYM, VYM, WYM, TYM, AKYM, EPSYM, &
!$OMP& UZM, VZM, WZM, TZM, AKZM, EPSZM, &
!$OMP& AMUM, AMUTM, AMUKM, AMUEM, &
!$OMP& DELVM, TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX, &
!$OMP& QX, QY, QZ, R5, S5, T5 &
!$OMP& )
  DO K = KS    , KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( QH(I,J,K,1) .GT. 0.0 .AND. QH(I,J,K+1,1) .GT. 0.0 ) THEN
    ! ZE�����̕��ϗʂ̌v�Z ---------------------------------------------
    XIXM  = 0.5 * ( XIX(I,J,K) + XIX(I,J,K+1) )
    XIYM  = 0.5 * ( XIY(I,J,K) + XIY(I,J,K+1) )
    XIZM  = 0.5 * ( XIZ(I,J,K) + XIZ(I,J,K+1) )
    ETXM  = 0.5 * ( ETX(I,J,K) + ETX(I,J,K+1) )
    ETYM  = 0.5 * ( ETY(I,J,K) + ETY(I,J,K+1) )
    ETZM  = 0.5 * ( ETZ(I,J,K) + ETZ(I,J,K+1) )
    ZEXM  = 0.5 * ( ZEX(I,J,K) + ZEX(I,J,K+1) )
    ZEYM  = 0.5 * ( ZEY(I,J,K) + ZEY(I,J,K+1) )
    ZEZM  = 0.5 * ( ZEZ(I,J,K) + ZEZ(I,J,K+1) )
    AJAM  = 0.5 * ( AJA(I,J,K) + AJA(I,J,K+1) )
    UM    = 0.5 * (   U(I,J,K) +   U(I,J,K+1) )
    VM    = 0.5 * (   V(I,J,K) +   V(I,J,K+1) )
    WM    = 0.5 * (   W(I,J,K) +   W(I,J,K+1) )
    TM    = 0.5 * (   T(I,J,K) +   T(I,J,K+1) )
    RHOKM = 0.5 * (  QH(I,J,K  ,6)*AJA(I,J,K  ) &
    &             +  QH(I,J,K+1,6)*AJA(I,J,K+1) )
    ! x,y,z�����̌v�Z(ZE�����̕��ϗ�) ----------------------------------
    UXIM   = 0.5 * ( - 0.5*(   U(I-1,J,K) +   U(I-1,J,K+1) ) &
    &                + 0.5*(   U(I+1,J,K) +   U(I+1,J,K+1) )  )
    VXIM   = 0.5 * ( - 0.5*(   V(I-1,J,K) +   V(I-1,J,K+1) ) &
    &                + 0.5*(   V(I+1,J,K) +   V(I+1,J,K+1) )  )
    WXIM   = 0.5 * ( - 0.5*(   W(I-1,J,K) +   W(I-1,J,K+1) ) &
    &                + 0.5*(   W(I+1,J,K) +   W(I+1,J,K+1) )  )
    TXIM   = 0.5 * ( - 0.5*(   T(I-1,J,K) +   T(I-1,J,K+1) ) &
    &                + 0.5*(   T(I+1,J,K) +   T(I+1,J,K+1) )  )
    AKXIM  = 0.5 * ( - 0.5*(  AK(I-1,J,K) +  AK(I-1,J,K+1) ) &
    &                + 0.5*(  AK(I+1,J,K) +  AK(I+1,J,K+1) )  )
    EPSXIM = 0.5 * ( - 0.5*( EPS(I-1,J,K) + EPS(I-1,J,K+1) ) &
    &                + 0.5*( EPS(I+1,J,K) + EPS(I+1,J,K+1) )  )
    UETM   = 0.5 * ( - 0.5*(   U(I,J-1,K) +   U(I,J-1,K+1) ) &
    &                + 0.5*(   U(I,J+1,K) +   U(I,J+1,K+1) )  )
    VETM   = 0.5 * ( - 0.5*(   V(I,J-1,K) +   V(I,J-1,K+1) ) &
    &                + 0.5*(   V(I,J+1,K) +   V(I,J+1,K+1) )  )
    WETM   = 0.5 * ( - 0.5*(   W(I,J-1,K) +   W(I,J-1,K+1) ) &
    &                + 0.5*(   W(I,J+1,K) +   W(I,J+1,K+1) )  )
    TETM   = 0.5 * ( - 0.5*(   T(I,J-1,K) +   T(I,J-1,K+1) ) &
    &                + 0.5*(   T(I,J+1,K) +   T(I,J+1,K+1) )  )
    AKETM  = 0.5 * ( - 0.5*(  AK(I,J-1,K) +  AK(I,J-1,K+1) ) &
    &                + 0.5*(  AK(I,J+1,K) +  AK(I,J+1,K+1) )  )
    EPSETM = 0.5 * ( - 0.5*( EPS(I,J-1,K) + EPS(I,J-1,K+1) ) &
    &                + 0.5*( EPS(I,J+1,K) + EPS(I,J+1,K+1) )  )
    UZEM   = ( -  U(I,J,K) +  U(I,J,K+1) )
    VZEM   = ( -  V(I,J,K) +  V(I,J,K+1) )
    WZEM   = ( -  W(I,J,K) +  W(I,J,K+1) )
    TZEM   = ( -  T(I,J,K) +  T(I,J,K+1) )
    AKZEM  = ( - AK(I,J,K) + AK(I,J,K+1) )
    EPSZEM = ( -EPS(I,J,K) +EPS(I,J,K+1) )
    UXM   = XIXM *  UXIM + ETXM *  UETM + ZEXM *  UZEM
    UYM   = XIYM *  UXIM + ETYM *  UETM + ZEYM *  UZEM
    UZM   = XIZM *  UXIM + ETZM *  UETM + ZEZM *  UZEM
    VXM   = XIXM *  VXIM + ETXM *  VETM + ZEXM *  VZEM
    VYM   = XIYM *  VXIM + ETYM *  VETM + ZEYM *  VZEM
    VZM   = XIZM *  VXIM + ETZM *  VETM + ZEZM *  VZEM
    WXM   = XIXM *  WXIM + ETXM *  WETM + ZEXM *  WZEM
    WYM   = XIYM *  WXIM + ETYM *  WETM + ZEYM *  WZEM
    WZM   = XIZM *  WXIM + ETZM *  WETM + ZEZM *  WZEM
    TXM   = XIXM *  TXIM + ETXM *  TETM + ZEXM *  TZEM
    TYM   = XIYM *  TXIM + ETYM *  TETM + ZEYM *  TZEM
    TZM   = XIZM *  TXIM + ETZM *  TETM + ZEZM *  TZEM
    AKXM  = XIXM * AKXIM + ETXM * AKETM + ZEXM * AKZEM
    AKYM  = XIYM * AKXIM + ETYM * AKETM + ZEYM * AKZEM
    AKZM  = XIZM * AKXIM + ETZM * AKETM + ZEZM * AKZEM
    EPSXM = XIXM *EPSXIM + ETXM *EPSETM + ZEXM *EPSZEM
    EPSYM = XIYM *EPSXIM + ETYM *EPSETM + ZEYM *EPSZEM
    EPSZM = XIZM *EPSXIM + ETZM *EPSETM + ZEZM *EPSZEM
    ! �S���W����ZE�����̕��ϗ� -----------------------------------------
    AMUM  = 0.5 * (   AMU(I,J,K) +   AMU(I,J,K+1) )
    AMUTM = 0.5 * (  AMUT(I,J,K) +  AMUT(I,J,K+1) )
    AMUKM = AMUM+AMUTM/SIGK
    AMUEM = AMUM+AMUTM/SIGE
    ! �g�U���x�N�g���̌v�Z ---------------------------------------------
    DELVM = UXM+VYM+WZM
    TAUXX = (AMUM+AMUTM)*(2.0*UXM-2.0/3.0*DELVM) &
    &     - 2.0/3.0*RHOKM
    TAUYY = (AMUM+AMUTM)*(2.0*VYM-2.0/3.0*DELVM) &
    &     - 2.0/3.0*RHOKM
    TAUZZ = (AMUM+AMUTM)*(2.0*WZM-2.0/3.0*DELVM) &
    &     - 2.0/3.0*RHOKM
    TAUXY = (AMUM+AMUTM)*(UYM+VXM)
    TAUYZ = (AMUM+AMUTM)*(VZM+WYM)
    TAUZX = (AMUM+AMUTM)*(WXM+UZM)
    QX    =-(AMUM/PR+AMUTM/PRT)/(GAMMA-1.0)*GAMMA*RG*TXM
    QY    =-(AMUM/PR+AMUTM/PRT)/(GAMMA-1.0)*GAMMA*RG*TYM
    QZ    =-(AMUM/PR+AMUTM/PRT)/(GAMMA-1.0)*GAMMA*RG*TZM
    R5    = TAUXX*UM + TAUXY*VM + TAUZX*WM-QX
    S5    = TAUXY*UM + TAUYY*VM + TAUYZ*WM-QY
    T5    = TAUZX*UM + TAUYZ*VM + TAUZZ*WM-QZ
    TH(I,J,K,1) = 0.0
    TH(I,J,K,2) = (ZEXM*TAUXX + ZEYM*TAUXY + ZEZM*TAUZX)/AJAM
    TH(I,J,K,3) = (ZEXM*TAUXY + ZEYM*TAUYY + ZEZM*TAUYZ)/AJAM
    TH(I,J,K,4) = (ZEXM*TAUZX + ZEYM*TAUYZ + ZEZM*TAUZZ)/AJAM
    TH(I,J,K,5) = (ZEXM*R5    + ZEYM*S5    + ZEZM*T5   )/AJAM
    TH(I,J,K,6) = AMUKM*(ZEXM* AKXM +ZEYM* AKYM +ZEZM* AKZM)/AJAM
    TH(I,J,K,7) = AMUEM*(ZEXM*EPSXM +ZEYM*EPSYM +ZEZM*EPSZM)/AJAM
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE VISZE
! ��`�I�� *************************************************************
END SUBROUTINE Turbulence3DEvmStd
!***********************************************************************
!**** �������f�� : RANS, EVM, Standard k-e Model (1974)             ****
!****                         with Kato-Launder Modification (1993) ****
!**** �v�Z�Ώ� : �P��, �O����, ���k��                               ****
!**** �v�Z�X�L�[�� : �񎟐��x���S����(�X�^�K�[�h�i�q��̓_���g�p)   ****
!***********************************************************************
SUBROUTINE Turbulence3DEvmStdKL( &
&            PELIM, RG, GAMMA, PR, PRT, &
&            IS, IE, JS, JE, KS, KE, LS, LE, &
&            XIX, XIY, XIZ, ETX, ETY, ETZ, ZEX, ZEY, ZEZ, AJA, &
&            QH, U, V, W, T, AK, EPS, AMU, &
&            AMUT, DQD, DQP &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, PARAMETER :: CMU = 0.09
  REAL, PARAMETER :: CE1 = 1.44, CE2 = 1.92
  REAL, PARAMETER :: SIGK = 1.0, SIGE = 1.3
  REAL, PARAMETER :: ZERO = 1.0E-20
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: PELIM
  REAL,    INTENT(IN)  :: RG, GAMMA, PR, PRT
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE, KS, KE
  INTEGER, INTENT(IN)  :: LS, LE
  REAL,    INTENT(IN)  :: XIX(IS: IE, JS: JE, KS: KE), &
  &                       XIY(IS: IE, JS: JE, KS: KE), &
  &                       XIZ(IS: IE, JS: JE, KS: KE), &
  &                       ETX(IS: IE, JS: JE, KS: KE), &
  &                       ETY(IS: IE, JS: JE, KS: KE), &
  &                       ETZ(IS: IE, JS: JE, KS: KE), &
  &                       ZEX(IS: IE, JS: JE, KS: KE), &
  &                       ZEY(IS: IE, JS: JE, KS: KE), &
  &                       ZEZ(IS: IE, JS: JE, KS: KE), &
  &                       AJA(IS: IE, JS: JE, KS: KE)
  REAL,    INTENT(IN)  :: QH(IS: IE, JS: JE, KS: KE, LS: LE)
  REAL,    INTENT(IN)  :: U(IS: IE, JS: JE, KS: KE), &
  &                       V(IS: IE, JS: JE, KS: KE), &
  &                       W(IS: IE, JS: JE, KS: KE), &
  &                       T(IS: IE, JS: JE, KS: KE), &
  &                       AK(IS: IE, JS: JE, KS: KE), &
  &                       EPS(IS: IE, JS: JE, KS: KE)
  REAL,    INTENT(IN)  :: AMU(IS: IE, JS: JE, KS: KE)
  REAL,    INTENT(OUT) :: AMUT(IS: IE, JS: JE, KS: KE)
  REAL,    INTENT(OUT) :: DQD(IS: IE, JS: JE, KS: KE, LS: LE)
  REAL,    INTENT(OUT) :: DQP(IS: IE, JS: JE, KS: KE, LS: LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, ALLOCATABLE :: RH(:, :, :, :), SH(:, :, :, :), TH(:, :, :, :)
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 7) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �������m�� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ALLOCATE(RH(IS: IE, JS: JE, KS: KE, LS: LE))
  ALLOCATE(SH(IS: IE, JS: JE, KS: KE, LS: LE))
  ALLOCATE(TH(IS: IE, JS: JE, KS: KE, LS: LE))
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  AMUT = 0.0
  DQD  = 0.0
  DQP  = 0.0
  ! �����葱���̌Ăяo�� +++++++++++++++++++++++++++++++++++++++++++++++
  CALL NonDiffTerm
  CALL DiffTerm
  ! ��������� =========================================================
  DEALLOCATE(RH,SH,TH)
  ! �����I�� ***********************************************************
  RETURN
! �����葱�� ***********************************************************
CONTAINS
!***********************************************************************
!**** ��g�U���̌v�Z                                                ****
!***********************************************************************
SUBROUTINE NonDiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: UXI, VXI, WXI, UET, VET, WET, UZE, VZE, WZE
  REAL    :: UX, VX, WX, UY, VY, WY, UZ, VZ, WZ
  REAL    :: DELV, SS2, SC, OMG, OS, PRO, EPSPK
  ! �����J�n ***********************************************************
  ! �Q�S���W���̌v�Z +++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I, J, K)
  DO K = KS, KE
  DO J = JS, JE
  DO I = IS, IE
  IF(QH(I,J,K,1) .GT. 0.0 .AND. QH(I,J,K,7) .GT. ZERO) THEN
    AMUT(I,J,K) = CMU * QH(I,J,K,6)**2 / QH(I,J,K,7) * AJA(I,J,K)
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �������ƎU�퍀�̌v�Z +++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& UXI, VXI, WXI, UET, VET, WET, UZE, VZE, WZE, &
!$OMP& UX, VX, WX, UY, VY, WY, UZ, VZ, WZ, &
!$OMP& DELV, SS2, SC, OMG, OS, PRO, EPSPK &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( ( QH(I  ,J  ,K  ,1) .GT. 0.0 ) .AND. &
  &   ( QH(I-1,J  ,K  ,1) .GT. 0.0 ) .AND. &
  &   ( QH(I+1,J  ,K  ,1) .GT. 0.0 ) .AND. &
  &   ( QH(I  ,J-1,K  ,1) .GT. 0.0 ) .AND. &
  &   ( QH(I  ,J+1,K  ,1) .GT. 0.0 ) .AND. &
  &   ( QH(I  ,J  ,K-1,1) .GT. 0.0 ) .AND. &
  &   ( QH(I  ,J  ,K+1,1) .GT. 0.0 ) &
  & ) THEN
    ! �Ђ��ݑ��x�e���\���̌v�Z -----------------------------------------
    UXI = ( -  U(I-1,J  ,K  ) +  U(I+1,J  ,K  ) )*0.5
    VXI = ( -  V(I-1,J  ,K  ) +  V(I+1,J  ,K  ) )*0.5
    WXI = ( -  W(I-1,J  ,K  ) +  W(I+1,J  ,K  ) )*0.5
    UET = ( -  U(I  ,J-1,K  ) +  U(I  ,J+1,K  ) )*0.5
    VET = ( -  V(I  ,J-1,K  ) +  V(I  ,J+1,K  ) )*0.5
    WET = ( -  W(I  ,J-1,K  ) +  W(I  ,J+1,K  ) )*0.5
    UZE = ( -  U(I  ,J  ,K-1) +  U(I  ,J  ,K+1) )*0.5
    VZE = ( -  V(I  ,J  ,K-1) +  V(I  ,J  ,K+1) )*0.5
    WZE = ( -  W(I  ,J  ,K-1) +  W(I  ,J  ,K+1) )*0.5
    UX  = XIX(I,J,K)*UXI + ETX(I,J,K)*UET + ZEX(I,J,K)*UZE
    UY  = XIY(I,J,K)*UXI + ETY(I,J,K)*UET + ZEY(I,J,K)*UZE
    UZ  = XIZ(I,J,K)*UXI + ETZ(I,J,K)*UET + ZEZ(I,J,K)*UZE
    VX  = XIX(I,J,K)*VXI + ETX(I,J,K)*VET + ZEX(I,J,K)*VZE
    VY  = XIY(I,J,K)*VXI + ETY(I,J,K)*VET + ZEY(I,J,K)*VZE
    VZ  = XIZ(I,J,K)*VXI + ETZ(I,J,K)*VET + ZEZ(I,J,K)*VZE
    WX  = XIX(I,J,K)*WXI + ETX(I,J,K)*WET + ZEX(I,J,K)*WZE
    WY  = XIY(I,J,K)*WXI + ETY(I,J,K)*WET + ZEY(I,J,K)*WZE
    WZ  = XIZ(I,J,K)*WXI + ETZ(I,J,K)*WET + ZEZ(I,J,K)*WZE
    ! �������̌v�Z -----------------------------------------------------
    DELV = UX + VY + WZ
    SS2 = (UY + VX)**2 + (VZ + WY)**2 + (WX + UZ)**2 &
    &   + 2.0 * (UX**2 + VY**2 + WZ**2) &
    &   - 2.0 / 3.0 * DELV**2
    SC  = SQRT(SS2)
    OMG = SQRT((UY - VX)**2 + (VZ - WY)**2 + (WX - UZ)**2)
    ! OMG / SC > 1 �̏ꍇ�AKato-Launder�̏C����K�p���Ȃ�
    IF(SC .GT. ZERO) THEN
      OS = MIN(OMG / SC, 1.0)
    ELSE
      OS = 1.0
    ENDIF
    PRO = OS * ( &
    &     AMUT(I, J, K) * SS2 &
    &   - 2.0 / 3.0 * DELV * QH(I, J, K, 6)*AJA(I, J, K) &
    &   )
    ! �Ǐ����t����(�����ƎU��̃o�����X)�ɂ�郊�~�b�^�[
    IF(PELIM .GT. 0.0) THEN
      PRO = MAX(0.0, MIN(QH(I,J,K,7) * AJA(I,J,K) / PELIM, PRO))
    ENDIF
    ! �����ƎU��̘a ---------------------------------------------------
    EPSPK = MIN( &
    &       MAX( &
    &         SC, SQRT(QH(I,J,K,7) * AJA(I,J,K) / AMU(I,J,K)) &
    &       ), &
    &       QH(I,J,K,7) / MAX(ZERO, QH(I,J,K,6)) &
    &     )
    DQP(I,J,K,6) = PRO/AJA(I,J,K) - QH(I,J,K,7)
    DQP(I,J,K,7) = (CE1*PRO/AJA(I,J,K)-CE2*QH(I,J,K,7))*EPSPK
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE NonDiffTerm
!***********************************************************************
!**** �g�U���̌v�Z                                                  ****
!***********************************************************************
SUBROUTINE DiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K, L
  ! �����J�n ***********************************************************
  ! �g�U���̗v�f���v�Z +++++++++++++++++++++++++++++++++++++++++++++++++
  CALL VISXI
  CALL VISET
  CALL VISZE
  ! �g�U���̍��� +++++++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE(I, J, K, L)
  DO L = LS, LE
  !$OMP DO
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( (QH(I,J,K-1,1) .GT. 0.0) .AND. (QH(I,J-1,K,1) .GT. 0.0) .AND. &
  &   (QH(I-1,J,K,1) .GT. 0.0) .AND. (QH(I,J,K,1)   .GT. 0.0) .AND. &
  &   (QH(I+1,J,K,1) .GT. 0.0) .AND. (QH(I,J+1,K,1) .GT. 0.0) .AND. &
  &   (QH(I,J,K+1,1) .GT. 0.0) &
  & ) THEN
    DQD(I,J,K,L) = (-RH(I-1,J  ,K  ,L) + RH(I,J,K,L) ) &
    &            + (-SH(I  ,J-1,K  ,L) + SH(I,J,K,L) ) &
    &            + (-TH(I  ,J  ,K-1,L) + TH(I,J,K,L) )
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END DO
  ENDDO
  !$OMP END PARALLEL
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DiffTerm
!***********************************************************************
!**** �g�U��(�S����)�̌v�Z(XI����)                                  ****
!***********************************************************************
SUBROUTINE VISXI
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM
  REAL    :: UM, VM, WM, TM, RHOKM
  REAL    :: UXIM, VXIM, WXIM, TXIM, AKXIM, EPSXIM, &
  &          UETM, VETM, WETM, TETM, AKETM, EPSETM, &
  &          UZEM, VZEM, WZEM, TZEM, AKZEM, EPSZEM
  REAL    :: UXM, VXM, WXM, TXM, AKXM, EPSXM, &
  &          UYM, VYM, WYM, TYM, AKYM, EPSYM, &
  &          UZM, VZM, WZM, TZM, AKZM, EPSZM
  REAL    :: AMUM, AMUTM, AMUKM, AMUEM
  REAL    :: DELVM, TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX
  REAL    :: QX, QY, QZ
  REAL    :: R5, S5, T5
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM, &
!$OMP& UM, VM, WM, TM, RHOKM, &
!$OMP& UXIM, VXIM, WXIM, TXIM, AKXIM, EPSXIM, &
!$OMP& UETM, VETM, WETM, TETM, AKETM, EPSETM, &
!$OMP& UZEM, VZEM, WZEM, TZEM, AKZEM, EPSZEM, &
!$OMP& UXM, VXM, WXM, TXM, AKXM, EPSXM, &
!$OMP& UYM, VYM, WYM, TYM, AKYM, EPSYM, &
!$OMP& UZM, VZM, WZM, TZM, AKZM, EPSZM, &
!$OMP& AMUM, AMUTM, AMUKM, AMUEM, &
!$OMP& DELVM, TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX, &
!$OMP& QX, QY, QZ, R5, S5, T5 &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS    , IE - 1
  IF( QH(I,J,K,1) .GT. 0.0 .AND. QH(I+1,J,K,1) .GT. 0.0 ) THEN
    ! XI�����̕��ϗʂ̌v�Z ---------------------------------------------
    XIXM  = 0.5 * ( XIX(I,J,K) + XIX(I+1,J,K) )
    XIYM  = 0.5 * ( XIY(I,J,K) + XIY(I+1,J,K) )
    XIZM  = 0.5 * ( XIZ(I,J,K) + XIZ(I+1,J,K) )
    ETXM  = 0.5 * ( ETX(I,J,K) + ETX(I+1,J,K) )
    ETYM  = 0.5 * ( ETY(I,J,K) + ETY(I+1,J,K) )
    ETZM  = 0.5 * ( ETZ(I,J,K) + ETZ(I+1,J,K) )
    ZEXM  = 0.5 * ( ZEX(I,J,K) + ZEX(I+1,J,K) )
    ZEYM  = 0.5 * ( ZEY(I,J,K) + ZEY(I+1,J,K) )
    ZEZM  = 0.5 * ( ZEZ(I,J,K) + ZEZ(I+1,J,K) )
    AJAM  = 0.5 * ( AJA(I,J,K) + AJA(I+1,J,K) )
    UM    = 0.5 * (   U(I,J,K) +   U(I+1,J,K) )
    VM    = 0.5 * (   V(I,J,K) +   V(I+1,J,K) )
    WM    = 0.5 * (   W(I,J,K) +   W(I+1,J,K) )
    TM    = 0.5 * (   T(I,J,K) +   T(I+1,J,K) )
    RHOKM = 0.5 * (  QH(I  ,J,K,6)*AJA(I  ,J,K) &
    &             +  QH(I+1,J,K,6)*AJA(I+1,J,K) )
    ! x,y,z�����̌v�Z(XI�����̕��ϗ�) ----------------------------------
    UXIM   = ( -  U(I,J,K) +  U(I+1,J,K) )
    VXIM   = ( -  V(I,J,K) +  V(I+1,J,K) )
    WXIM   = ( -  W(I,J,K) +  W(I+1,J,K) )
    TXIM   = ( -  T(I,J,K) +  T(I+1,J,K) )
    AKXIM  = ( - AK(I,J,K) + AK(I+1,J,K) )
    EPSXIM = ( -EPS(I,J,K) +EPS(I+1,J,K) )
    UETM   = 0.5 * ( - 0.5*(   U(I,J-1,K) +   U(I+1,J-1,K) ) &
    &                + 0.5*(   U(I,J+1,K) +   U(I+1,J+1,K) )  )
    VETM   = 0.5 * ( - 0.5*(   V(I,J-1,K) +   V(I+1,J-1,K) ) &
    &                + 0.5*(   V(I,J+1,K) +   V(I+1,J+1,K) )  )
    WETM   = 0.5 * ( - 0.5*(   W(I,J-1,K) +   W(I+1,J-1,K) ) &
    &                + 0.5*(   W(I,J+1,K) +   W(I+1,J+1,K) )  )
    TETM   = 0.5 * ( - 0.5*(   T(I,J-1,K) +   T(I+1,J-1,K) ) &
    &                + 0.5*(   T(I,J+1,K) +   T(I+1,J+1,K) )  )
    AKETM  = 0.5 * ( - 0.5*(  AK(I,J-1,K) +  AK(I+1,J-1,K) ) &
    &                + 0.5*(  AK(I,J+1,K) +  AK(I+1,J+1,K) )  )
    EPSETM = 0.5 * ( - 0.5*( EPS(I,J-1,K) + EPS(I+1,J-1,K) ) &
    &                + 0.5*( EPS(I,J+1,K) + EPS(I+1,J+1,K) )  )
    UZEM   = 0.5 * ( - 0.5*(   U(I,J,K-1) +   U(I+1,J,K-1) ) &
    &                + 0.5*(   U(I,J,K+1) +   U(I+1,J,K+1) )  )
    VZEM   = 0.5 * ( - 0.5*(   V(I,J,K-1) +   V(I+1,J,K-1) ) &
    &                + 0.5*(   V(I,J,K+1) +   V(I+1,J,K+1) )  )
    WZEM   = 0.5 * ( - 0.5*(   W(I,J,K-1) +   W(I+1,J,K-1) ) &
    &                + 0.5*(   W(I,J,K+1) +   W(I+1,J,K+1) )  )
    TZEM   = 0.5 * ( - 0.5*(   T(I,J,K-1) +   T(I+1,J,K-1) ) &
    &                + 0.5*(   T(I,J,K+1) +   T(I+1,J,K+1) )  )
    AKZEM  = 0.5 * ( - 0.5*(  AK(I,J,K-1) +  AK(I+1,J,K-1) ) &
    &                + 0.5*(  AK(I,J,K+1) +  AK(I+1,J,K+1) )  )
    EPSZEM = 0.5 * ( - 0.5*( EPS(I,J,K-1) + EPS(I+1,J,K-1) ) &
    &                + 0.5*( EPS(I,J,K+1) + EPS(I+1,J,K+1) )  )
    UXM   = XIXM *  UXIM + ETXM *  UETM + ZEXM *  UZEM
    UYM   = XIYM *  UXIM + ETYM *  UETM + ZEYM *  UZEM
    UZM   = XIZM *  UXIM + ETZM *  UETM + ZEZM *  UZEM
    VXM   = XIXM *  VXIM + ETXM *  VETM + ZEXM *  VZEM
    VYM   = XIYM *  VXIM + ETYM *  VETM + ZEYM *  VZEM
    VZM   = XIZM *  VXIM + ETZM *  VETM + ZEZM *  VZEM
    WXM   = XIXM *  WXIM + ETXM *  WETM + ZEXM *  WZEM
    WYM   = XIYM *  WXIM + ETYM *  WETM + ZEYM *  WZEM
    WZM   = XIZM *  WXIM + ETZM *  WETM + ZEZM *  WZEM
    TXM   = XIXM *  TXIM + ETXM *  TETM + ZEXM *  TZEM
    TYM   = XIYM *  TXIM + ETYM *  TETM + ZEYM *  TZEM
    TZM   = XIZM *  TXIM + ETZM *  TETM + ZEZM *  TZEM
    AKXM  = XIXM * AKXIM + ETXM * AKETM + ZEXM * AKZEM
    AKYM  = XIYM * AKXIM + ETYM * AKETM + ZEYM * AKZEM
    AKZM  = XIZM * AKXIM + ETZM * AKETM + ZEZM * AKZEM
    EPSXM = XIXM *EPSXIM + ETXM *EPSETM + ZEXM *EPSZEM
    EPSYM = XIYM *EPSXIM + ETYM *EPSETM + ZEYM *EPSZEM
    EPSZM = XIZM *EPSXIM + ETZM *EPSETM + ZEZM *EPSZEM
    ! �S���W����XI�����̕��ϗ� -----------------------------------------
    AMUM  = 0.5 * (   AMU(I,J,K) +   AMU(I+1,J,K) )
    AMUTM = 0.5 * (  AMUT(I,J,K) +  AMUT(I+1,J,K) )
    AMUKM = AMUM+AMUTM/SIGK
    AMUEM = AMUM+AMUTM/SIGE
    ! �g�U���x�N�g���̌v�Z ---------------------------------------------
    DELVM = UXM+VYM+WZM
    TAUXX = (AMUM+AMUTM)*(2.0*UXM-2.0/3.0*DELVM) &
    &     - 2.0/3.0*RHOKM
    TAUYY = (AMUM+AMUTM)*(2.0*VYM-2.0/3.0*DELVM) &
    &     - 2.0/3.0*RHOKM
    TAUZZ = (AMUM+AMUTM)*(2.0*WZM-2.0/3.0*DELVM) &
    &     - 2.0/3.0*RHOKM
    TAUXY = (AMUM+AMUTM)*(UYM+VXM)
    TAUYZ = (AMUM+AMUTM)*(VZM+WYM)
    TAUZX = (AMUM+AMUTM)*(WXM+UZM)
    QX    =-(AMUM/PR+AMUTM/PRT)/(GAMMA-1.0)*GAMMA*RG*TXM
    QY    =-(AMUM/PR+AMUTM/PRT)/(GAMMA-1.0)*GAMMA*RG*TYM
    QZ    =-(AMUM/PR+AMUTM/PRT)/(GAMMA-1.0)*GAMMA*RG*TZM
    R5    = TAUXX*UM + TAUXY*VM + TAUZX*WM-QX
    S5    = TAUXY*UM + TAUYY*VM + TAUYZ*WM-QY
    T5    = TAUZX*UM + TAUYZ*VM + TAUZZ*WM-QZ
    RH(I,J,K,1) = 0.0
    RH(I,J,K,2) = (XIXM*TAUXX + XIYM*TAUXY + XIZM*TAUZX)/AJAM
    RH(I,J,K,3) = (XIXM*TAUXY + XIYM*TAUYY + XIZM*TAUYZ)/AJAM
    RH(I,J,K,4) = (XIXM*TAUZX + XIYM*TAUYZ + XIZM*TAUZZ)/AJAM
    RH(I,J,K,5) = (XIXM*R5    + XIYM*S5    + XIZM*T5   )/AJAM
    RH(I,J,K,6) = AMUKM*(XIXM* AKXM +XIYM* AKYM +XIZM* AKZM)/AJAM
    RH(I,J,K,7) = AMUEM*(XIXM*EPSXM +XIYM*EPSYM +XIZM*EPSZM)/AJAM
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE VISXI
!***********************************************************************
!**** �g�U��(�S����)�̌v�Z(ET����)                                  ****
!***********************************************************************
SUBROUTINE VISET
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM
  REAL    :: UM, VM, WM, TM, RHOKM
  REAL    :: UXIM, VXIM, WXIM, TXIM, AKXIM, EPSXIM, &
  &          UETM, VETM, WETM, TETM, AKETM, EPSETM, &
  &          UZEM, VZEM, WZEM, TZEM, AKZEM, EPSZEM
  REAL    :: UXM, VXM, WXM, TXM, AKXM, EPSXM, &
  &          UYM, VYM, WYM, TYM, AKYM, EPSYM, &
  &          UZM, VZM, WZM, TZM, AKZM, EPSZM
  REAL    :: AMUM, AMUTM, AMUKM, AMUEM
  REAL    :: DELVM, TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX
  REAL    :: QX, QY, QZ
  REAL    :: R5, S5, T5
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM, &
!$OMP& UM, VM, WM, TM, RHOKM, &
!$OMP& UXIM, VXIM, WXIM, TXIM, AKXIM, EPSXIM, &
!$OMP& UETM, VETM, WETM, TETM, AKETM, EPSETM, &
!$OMP& UZEM, VZEM, WZEM, TZEM, AKZEM, EPSZEM, &
!$OMP& UXM, VXM, WXM, TXM, AKXM, EPSXM, &
!$OMP& UYM, VYM, WYM, TYM, AKYM, EPSYM, &
!$OMP& UZM, VZM, WZM, TZM, AKZM, EPSZM, &
!$OMP& AMUM, AMUTM, AMUKM, AMUEM, &
!$OMP& DELVM, TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX, &
!$OMP& QX, QY, QZ, R5, S5, T5 &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS    , JE - 1
  DO I = IS + 1, IE - 1
  IF( QH(I,J,K,1) .GT. 0.0 .AND. QH(I,J+1,K,1) .GT. 0.0 ) THEN
    ! ET�����̕��ϗʂ̌v�Z ---------------------------------------------
    XIXM  = 0.5 * ( XIX(I,J,K) + XIX(I,J+1,K) )
    XIYM  = 0.5 * ( XIY(I,J,K) + XIY(I,J+1,K) )
    XIZM  = 0.5 * ( XIZ(I,J,K) + XIZ(I,J+1,K) )
    ETXM  = 0.5 * ( ETX(I,J,K) + ETX(I,J+1,K) )
    ETYM  = 0.5 * ( ETY(I,J,K) + ETY(I,J+1,K) )
    ETZM  = 0.5 * ( ETZ(I,J,K) + ETZ(I,J+1,K) )
    ZEXM  = 0.5 * ( ZEX(I,J,K) + ZEX(I,J+1,K) )
    ZEYM  = 0.5 * ( ZEY(I,J,K) + ZEY(I,J+1,K) )
    ZEZM  = 0.5 * ( ZEZ(I,J,K) + ZEZ(I,J+1,K) )
    AJAM  = 0.5 * ( AJA(I,J,K) + AJA(I,J+1,K) )
    UM    = 0.5 * (   U(I,J,K) +   U(I,J+1,K) )
    VM    = 0.5 * (   V(I,J,K) +   V(I,J+1,K) )
    WM    = 0.5 * (   W(I,J,K) +   W(I,J+1,K) )
    TM    = 0.5 * (   T(I,J,K) +   T(I,J+1,K) )
    RHOKM = 0.5 * (  QH(I,J  ,K,6)*AJA(I,J  ,K) &
    &             +  QH(I,J+1,K,6)*AJA(I,J+1,K) )
    ! x,y,z�����̌v�Z(ET�����̕��ϗ�) ----------------------------------
    UXIM   = 0.5 * ( - 0.5*(   U(I-1,J,K) +   U(I-1,J+1,K) ) &
    &                + 0.5*(   U(I+1,J,K) +   U(I+1,J+1,K) )  )
    VXIM   = 0.5 * ( - 0.5*(   V(I-1,J,K) +   V(I-1,J+1,K) ) &
    &                + 0.5*(   V(I+1,J,K) +   V(I+1,J+1,K) )  )
    WXIM   = 0.5 * ( - 0.5*(   W(I-1,J,K) +   W(I-1,J+1,K) ) &
    &                + 0.5*(   W(I+1,J,K) +   W(I+1,J+1,K) )  )
    TXIM   = 0.5 * ( - 0.5*(   T(I-1,J,K) +   T(I-1,J+1,K) ) &
    &                + 0.5*(   T(I+1,J,K) +   T(I+1,J+1,K) )  )
    AKXIM  = 0.5 * ( - 0.5*(  AK(I-1,J,K) +  AK(I-1,J+1,K) ) &
    &                + 0.5*(  AK(I+1,J,K) +  AK(I+1,J+1,K) )  )
    EPSXIM = 0.5 * ( - 0.5*( EPS(I-1,J,K) + EPS(I-1,J+1,K) ) &
    &                + 0.5*( EPS(I+1,J,K) + EPS(I+1,J+1,K) )  )
    UETM   = ( -  U(I,J,K) +  U(I,J+1,K) )
    VETM   = ( -  V(I,J,K) +  V(I,J+1,K) )
    WETM   = ( -  W(I,J,K) +  W(I,J+1,K) )
    TETM   = ( -  T(I,J,K) +  T(I,J+1,K) )
    AKETM  = ( - AK(I,J,K) + AK(I,J+1,K) )
    EPSETM = ( -EPS(I,J,K) +EPS(I,J+1,K) )
    UZEM   = 0.5 * ( - 0.5*(   U(I,J,K-1) +   U(I,J+1,K-1) ) &
    &                + 0.5*(   U(I,J,K+1) +   U(I,J+1,K+1) )  )
    VZEM   = 0.5 * ( - 0.5*(   V(I,J,K-1) +   V(I,J+1,K-1) ) &
    &                + 0.5*(   V(I,J,K+1) +   V(I,J+1,K+1) )  )
    WZEM   = 0.5 * ( - 0.5*(   W(I,J,K-1) +   W(I,J+1,K-1) ) &
    &                + 0.5*(   W(I,J,K+1) +   W(I,J+1,K+1) )  )
    TZEM   = 0.5 * ( - 0.5*(   T(I,J,K-1) +   T(I,J+1,K-1) ) &
    &                + 0.5*(   T(I,J,K+1) +   T(I,J+1,K+1) )  )
    AKZEM  = 0.5 * ( - 0.5*(  AK(I,J,K-1) +  AK(I,J+1,K-1) ) &
    &                + 0.5*(  AK(I,J,K+1) +  AK(I,J+1,K+1) )  )
    EPSZEM = 0.5 * ( - 0.5*( EPS(I,J,K-1) + EPS(I,J+1,K-1) ) &
    &                + 0.5*( EPS(I,J,K+1) + EPS(I,J+1,K+1) )  )
    UXM   = XIXM *  UXIM + ETXM *  UETM + ZEXM *  UZEM
    UYM   = XIYM *  UXIM + ETYM *  UETM + ZEYM *  UZEM
    UZM   = XIZM *  UXIM + ETZM *  UETM + ZEZM *  UZEM
    VXM   = XIXM *  VXIM + ETXM *  VETM + ZEXM *  VZEM
    VYM   = XIYM *  VXIM + ETYM *  VETM + ZEYM *  VZEM
    VZM   = XIZM *  VXIM + ETZM *  VETM + ZEZM *  VZEM
    WXM   = XIXM *  WXIM + ETXM *  WETM + ZEXM *  WZEM
    WYM   = XIYM *  WXIM + ETYM *  WETM + ZEYM *  WZEM
    WZM   = XIZM *  WXIM + ETZM *  WETM + ZEZM *  WZEM
    TXM   = XIXM *  TXIM + ETXM *  TETM + ZEXM *  TZEM
    TYM   = XIYM *  TXIM + ETYM *  TETM + ZEYM *  TZEM
    TZM   = XIZM *  TXIM + ETZM *  TETM + ZEZM *  TZEM
    AKXM  = XIXM * AKXIM + ETXM * AKETM + ZEXM * AKZEM
    AKYM  = XIYM * AKXIM + ETYM * AKETM + ZEYM * AKZEM
    AKZM  = XIZM * AKXIM + ETZM * AKETM + ZEZM * AKZEM
    EPSXM = XIXM *EPSXIM + ETXM *EPSETM + ZEXM *EPSZEM
    EPSYM = XIYM *EPSXIM + ETYM *EPSETM + ZEYM *EPSZEM
    EPSZM = XIZM *EPSXIM + ETZM *EPSETM + ZEZM *EPSZEM
    ! �S���W����ET�����̕��ϗ� -----------------------------------------
    AMUM  = 0.5 * (   AMU(I,J,K) +   AMU(I,J+1,K) )
    AMUTM = 0.5 * (  AMUT(I,J,K) +  AMUT(I,J+1,K) )
    AMUKM = AMUM+AMUTM/SIGK
    AMUEM = AMUM+AMUTM/SIGE
    ! �g�U���x�N�g���̌v�Z ---------------------------------------------
    DELVM = UXM+VYM+WZM
    TAUXX = (AMUM+AMUTM)*(2.0*UXM-2.0/3.0*DELVM) &
    &     - 2.0/3.0*RHOKM
    TAUYY = (AMUM+AMUTM)*(2.0*VYM-2.0/3.0*DELVM) &
    &     - 2.0/3.0*RHOKM
    TAUZZ = (AMUM+AMUTM)*(2.0*WZM-2.0/3.0*DELVM) &
    &     - 2.0/3.0*RHOKM
    TAUXY = (AMUM+AMUTM)*(UYM+VXM)
    TAUYZ = (AMUM+AMUTM)*(VZM+WYM)
    TAUZX = (AMUM+AMUTM)*(WXM+UZM)
    QX    =-(AMUM/PR+AMUTM/PRT)/(GAMMA-1.0)*GAMMA*RG*TXM
    QY    =-(AMUM/PR+AMUTM/PRT)/(GAMMA-1.0)*GAMMA*RG*TYM
    QZ    =-(AMUM/PR+AMUTM/PRT)/(GAMMA-1.0)*GAMMA*RG*TZM
    R5    = TAUXX*UM + TAUXY*VM + TAUZX*WM-QX
    S5    = TAUXY*UM + TAUYY*VM + TAUYZ*WM-QY
    T5    = TAUZX*UM + TAUYZ*VM + TAUZZ*WM-QZ
    SH(I,J,K,1) = 0.0
    SH(I,J,K,2) = (ETXM*TAUXX + ETYM*TAUXY + ETZM*TAUZX)/AJAM
    SH(I,J,K,3) = (ETXM*TAUXY + ETYM*TAUYY + ETZM*TAUYZ)/AJAM
    SH(I,J,K,4) = (ETXM*TAUZX + ETYM*TAUYZ + ETZM*TAUZZ)/AJAM
    SH(I,J,K,5) = (ETXM*R5    + ETYM*S5    + ETZM*T5   )/AJAM
    SH(I,J,K,6) = AMUKM*(ETXM* AKXM +ETYM* AKYM +ETZM* AKZM)/AJAM
    SH(I,J,K,7) = AMUEM*(ETXM*EPSXM +ETYM*EPSYM +ETZM*EPSZM)/AJAM
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE VISET
!***********************************************************************
!**** �g�U��(�S����)�̌v�Z(ZE����)                                  ****
!***********************************************************************
SUBROUTINE VISZE
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM
  REAL    :: UM, VM, WM, TM, RHOKM
  REAL    :: UXIM, VXIM, WXIM, TXIM, AKXIM, EPSXIM, &
  &          UETM, VETM, WETM, TETM, AKETM, EPSETM, &
  &          UZEM, VZEM, WZEM, TZEM, AKZEM, EPSZEM
  REAL    :: UXM, VXM, WXM, TXM, AKXM, EPSXM, &
  &          UYM, VYM, WYM, TYM, AKYM, EPSYM, &
  &          UZM, VZM, WZM, TZM, AKZM, EPSZM
  REAL    :: AMUM, AMUTM, AMUKM, AMUEM
  REAL    :: DELVM, TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX
  REAL    :: QX, QY, QZ
  REAL    :: R5, S5, T5
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM, &
!$OMP& UM, VM, WM, TM, RHOKM, &
!$OMP& UXIM, VXIM, WXIM, TXIM, AKXIM, EPSXIM, &
!$OMP& UETM, VETM, WETM, TETM, AKETM, EPSETM, &
!$OMP& UZEM, VZEM, WZEM, TZEM, AKZEM, EPSZEM, &
!$OMP& UXM, VXM, WXM, TXM, AKXM, EPSXM, &
!$OMP& UYM, VYM, WYM, TYM, AKYM, EPSYM, &
!$OMP& UZM, VZM, WZM, TZM, AKZM, EPSZM, &
!$OMP& AMUM, AMUTM, AMUKM, AMUEM, &
!$OMP& DELVM, TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX, &
!$OMP& QX, QY, QZ, R5, S5, T5 &
!$OMP& )
  DO K = KS    , KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( QH(I,J,K,1) .GT. 0.0 .AND. QH(I,J,K+1,1) .GT. 0.0 ) THEN
    ! ZE�����̕��ϗʂ̌v�Z ---------------------------------------------
    XIXM  = 0.5 * ( XIX(I,J,K) + XIX(I,J,K+1) )
    XIYM  = 0.5 * ( XIY(I,J,K) + XIY(I,J,K+1) )
    XIZM  = 0.5 * ( XIZ(I,J,K) + XIZ(I,J,K+1) )
    ETXM  = 0.5 * ( ETX(I,J,K) + ETX(I,J,K+1) )
    ETYM  = 0.5 * ( ETY(I,J,K) + ETY(I,J,K+1) )
    ETZM  = 0.5 * ( ETZ(I,J,K) + ETZ(I,J,K+1) )
    ZEXM  = 0.5 * ( ZEX(I,J,K) + ZEX(I,J,K+1) )
    ZEYM  = 0.5 * ( ZEY(I,J,K) + ZEY(I,J,K+1) )
    ZEZM  = 0.5 * ( ZEZ(I,J,K) + ZEZ(I,J,K+1) )
    AJAM  = 0.5 * ( AJA(I,J,K) + AJA(I,J,K+1) )
    UM    = 0.5 * (   U(I,J,K) +   U(I,J,K+1) )
    VM    = 0.5 * (   V(I,J,K) +   V(I,J,K+1) )
    WM    = 0.5 * (   W(I,J,K) +   W(I,J,K+1) )
    TM    = 0.5 * (   T(I,J,K) +   T(I,J,K+1) )
    RHOKM = 0.5 * (  QH(I,J,K  ,6)*AJA(I,J,K  ) &
    &             +  QH(I,J,K+1,6)*AJA(I,J,K+1) )
    ! x,y,z�����̌v�Z(ZE�����̕��ϗ�) ----------------------------------
    UXIM   = 0.5 * ( - 0.5*(   U(I-1,J,K) +   U(I-1,J,K+1) ) &
    &                + 0.5*(   U(I+1,J,K) +   U(I+1,J,K+1) )  )
    VXIM   = 0.5 * ( - 0.5*(   V(I-1,J,K) +   V(I-1,J,K+1) ) &
    &                + 0.5*(   V(I+1,J,K) +   V(I+1,J,K+1) )  )
    WXIM   = 0.5 * ( - 0.5*(   W(I-1,J,K) +   W(I-1,J,K+1) ) &
    &                + 0.5*(   W(I+1,J,K) +   W(I+1,J,K+1) )  )
    TXIM   = 0.5 * ( - 0.5*(   T(I-1,J,K) +   T(I-1,J,K+1) ) &
    &                + 0.5*(   T(I+1,J,K) +   T(I+1,J,K+1) )  )
    AKXIM  = 0.5 * ( - 0.5*(  AK(I-1,J,K) +  AK(I-1,J,K+1) ) &
    &                + 0.5*(  AK(I+1,J,K) +  AK(I+1,J,K+1) )  )
    EPSXIM = 0.5 * ( - 0.5*( EPS(I-1,J,K) + EPS(I-1,J,K+1) ) &
    &                + 0.5*( EPS(I+1,J,K) + EPS(I+1,J,K+1) )  )
    UETM   = 0.5 * ( - 0.5*(   U(I,J-1,K) +   U(I,J-1,K+1) ) &
    &                + 0.5*(   U(I,J+1,K) +   U(I,J+1,K+1) )  )
    VETM   = 0.5 * ( - 0.5*(   V(I,J-1,K) +   V(I,J-1,K+1) ) &
    &                + 0.5*(   V(I,J+1,K) +   V(I,J+1,K+1) )  )
    WETM   = 0.5 * ( - 0.5*(   W(I,J-1,K) +   W(I,J-1,K+1) ) &
    &                + 0.5*(   W(I,J+1,K) +   W(I,J+1,K+1) )  )
    TETM   = 0.5 * ( - 0.5*(   T(I,J-1,K) +   T(I,J-1,K+1) ) &
    &                + 0.5*(   T(I,J+1,K) +   T(I,J+1,K+1) )  )
    AKETM  = 0.5 * ( - 0.5*(  AK(I,J-1,K) +  AK(I,J-1,K+1) ) &
    &                + 0.5*(  AK(I,J+1,K) +  AK(I,J+1,K+1) )  )
    EPSETM = 0.5 * ( - 0.5*( EPS(I,J-1,K) + EPS(I,J-1,K+1) ) &
    &                + 0.5*( EPS(I,J+1,K) + EPS(I,J+1,K+1) )  )
    UZEM   = ( -  U(I,J,K) +  U(I,J,K+1) )
    VZEM   = ( -  V(I,J,K) +  V(I,J,K+1) )
    WZEM   = ( -  W(I,J,K) +  W(I,J,K+1) )
    TZEM   = ( -  T(I,J,K) +  T(I,J,K+1) )
    AKZEM  = ( - AK(I,J,K) + AK(I,J,K+1) )
    EPSZEM = ( -EPS(I,J,K) +EPS(I,J,K+1) )
    UXM   = XIXM *  UXIM + ETXM *  UETM + ZEXM *  UZEM
    UYM   = XIYM *  UXIM + ETYM *  UETM + ZEYM *  UZEM
    UZM   = XIZM *  UXIM + ETZM *  UETM + ZEZM *  UZEM
    VXM   = XIXM *  VXIM + ETXM *  VETM + ZEXM *  VZEM
    VYM   = XIYM *  VXIM + ETYM *  VETM + ZEYM *  VZEM
    VZM   = XIZM *  VXIM + ETZM *  VETM + ZEZM *  VZEM
    WXM   = XIXM *  WXIM + ETXM *  WETM + ZEXM *  WZEM
    WYM   = XIYM *  WXIM + ETYM *  WETM + ZEYM *  WZEM
    WZM   = XIZM *  WXIM + ETZM *  WETM + ZEZM *  WZEM
    TXM   = XIXM *  TXIM + ETXM *  TETM + ZEXM *  TZEM
    TYM   = XIYM *  TXIM + ETYM *  TETM + ZEYM *  TZEM
    TZM   = XIZM *  TXIM + ETZM *  TETM + ZEZM *  TZEM
    AKXM  = XIXM * AKXIM + ETXM * AKETM + ZEXM * AKZEM
    AKYM  = XIYM * AKXIM + ETYM * AKETM + ZEYM * AKZEM
    AKZM  = XIZM * AKXIM + ETZM * AKETM + ZEZM * AKZEM
    EPSXM = XIXM *EPSXIM + ETXM *EPSETM + ZEXM *EPSZEM
    EPSYM = XIYM *EPSXIM + ETYM *EPSETM + ZEYM *EPSZEM
    EPSZM = XIZM *EPSXIM + ETZM *EPSETM + ZEZM *EPSZEM
    ! �S���W����ZE�����̕��ϗ� -----------------------------------------
    AMUM  = 0.5 * (   AMU(I,J,K) +   AMU(I,J,K+1) )
    AMUTM = 0.5 * (  AMUT(I,J,K) +  AMUT(I,J,K+1) )
    AMUKM = AMUM+AMUTM/SIGK
    AMUEM = AMUM+AMUTM/SIGE
    ! �g�U���x�N�g���̌v�Z ---------------------------------------------
    DELVM = UXM+VYM+WZM
    TAUXX = (AMUM+AMUTM)*(2.0*UXM-2.0/3.0*DELVM) &
    &     - 2.0/3.0*RHOKM
    TAUYY = (AMUM+AMUTM)*(2.0*VYM-2.0/3.0*DELVM) &
    &     - 2.0/3.0*RHOKM
    TAUZZ = (AMUM+AMUTM)*(2.0*WZM-2.0/3.0*DELVM) &
    &     - 2.0/3.0*RHOKM
    TAUXY = (AMUM+AMUTM)*(UYM+VXM)
    TAUYZ = (AMUM+AMUTM)*(VZM+WYM)
    TAUZX = (AMUM+AMUTM)*(WXM+UZM)
    QX    =-(AMUM/PR+AMUTM/PRT)/(GAMMA-1.0)*GAMMA*RG*TXM
    QY    =-(AMUM/PR+AMUTM/PRT)/(GAMMA-1.0)*GAMMA*RG*TYM
    QZ    =-(AMUM/PR+AMUTM/PRT)/(GAMMA-1.0)*GAMMA*RG*TZM
    R5    = TAUXX*UM + TAUXY*VM + TAUZX*WM-QX
    S5    = TAUXY*UM + TAUYY*VM + TAUYZ*WM-QY
    T5    = TAUZX*UM + TAUYZ*VM + TAUZZ*WM-QZ
    TH(I,J,K,1) = 0.0
    TH(I,J,K,2) = (ZEXM*TAUXX + ZEYM*TAUXY + ZEZM*TAUZX)/AJAM
    TH(I,J,K,3) = (ZEXM*TAUXY + ZEYM*TAUYY + ZEZM*TAUYZ)/AJAM
    TH(I,J,K,4) = (ZEXM*TAUZX + ZEYM*TAUYZ + ZEZM*TAUZZ)/AJAM
    TH(I,J,K,5) = (ZEXM*R5    + ZEYM*S5    + ZEZM*T5   )/AJAM
    TH(I,J,K,6) = AMUKM*(ZEXM* AKXM +ZEYM* AKYM +ZEZM* AKZM)/AJAM
    TH(I,J,K,7) = AMUEM*(ZEXM*EPSXM +ZEYM*EPSYM +ZEZM*EPSZM)/AJAM
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE VISZE
! ��`�I�� *************************************************************
END SUBROUTINE Turbulence3DEvmStdKL
!***********************************************************************
!**** �������f�� : RANS, EVM, Launder-Sharma Model (1974)           ****
!**** �v�Z�Ώ� : �P��, �񎟌�, ���k��                               ****
!**** �v�Z�X�L�[�� : �񎟐��x���S����(�X�^�K�[�h�i�q��̓_���g�p)   ****
!***********************************************************************
SUBROUTINE Turbulence2DEvmLS( &
&            PELIM, RG, GAMMA, PR, PRT, &
&            IS, IE, JS, JE, LS, LE, &
&            XIX, XIY, ETX, ETY, AJA, &
&            RHO, U, V, T, AK, EPST, AMU, &
&            AMUT, DQD, DQP &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, PARAMETER :: CMU = 0.09
  REAL, PARAMETER :: CE1 = 1.44, CE2 = 1.92
  REAL, PARAMETER :: SIGK = 1.0, SIGE = 1.3
  REAL, PARAMETER :: ZERO = 1.0E-20
  REAL, PARAMETER :: TwoThird = 0.66666667
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: PELIM
  REAL,    INTENT(IN)  :: RG, GAMMA, PR, PRT
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE
  INTEGER, INTENT(IN)  :: LS, LE
  REAL,    INTENT(IN)  :: XIX(IS:IE, JS:JE), XIY(IS:IE, JS:JE), &
  &                       ETX(IS:IE, JS:JE), ETY(IS:IE, JS:JE), &
  &                       AJA(IS:IE, JS:JE)
  REAL,    INTENT(IN)  :: RHO(IS:IE, JS:JE), &
  &                       U(IS:IE, JS:JE), V(IS:IE, JS:JE), &
  &                       T(IS:IE, JS:JE), &
  &                       AK(IS:IE, JS:JE), EPST(IS:IE, JS:JE)
  REAL,    INTENT(IN)  :: AMU(IS:IE, JS:JE)
  REAL,    INTENT(OUT) :: AMUT(IS:IE, JS:JE)
  REAL,    INTENT(OUT) :: DQD(IS:IE, JS:JE, LS:LE)
  REAL,    INTENT(OUT) :: DQP(IS:IE, JS:JE, LS:LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, ALLOCATABLE :: RH(:, :, :), SH(:, :, :)
  REAL, ALLOCATABLE :: UXXI(:, :), UYXI(:, :), VXXI(:, :), VYXI(:, :)
  REAL, ALLOCATABLE :: UXET(:, :), UYET(:, :), VXET(:, :), VYET(:, :)
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 6) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �������m�� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ALLOCATE(RH(IS: IE, JS: JE, LS: LE), SH(IS: IE, JS: JE, LS: LE))
  ALLOCATE(UXXI(IS: IE, JS: JE), UYXI(IS: IE, JS: JE))
  ALLOCATE(VXXI(IS: IE, JS: JE), VYXI(IS: IE, JS: JE))
  ALLOCATE(UXET(IS: IE, JS: JE), UYET(IS: IE, JS: JE))
  ALLOCATE(VXET(IS: IE, JS: JE), VYET(IS: IE, JS: JE))
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  AMUT = 0.0
  DQD  = 0.0
  DQP  = 0.0
  ! �����葱���̌Ăяo�� +++++++++++++++++++++++++++++++++++++++++++++++
  CALL PreVel2ndDiff
  CALL NonDiffTerm
  CALL DiffTerm
  ! �����I�� ***********************************************************
  RETURN
! �����葱�� ***********************************************************
CONTAINS
!***********************************************************************
!**** ��K�����v�Z�p�̑O����                                        ****
!***********************************************************************
SUBROUTINE PreVel2ndDiff
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����J�n ***********************************************************
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  UXXI = 0.0
  UYXI = 0.0
  VXXI = 0.0
  VYXI = 0.0
  UXET = 0.0
  UYET = 0.0
  VXET = 0.0
  VYET = 0.0
  ! ���x�̓�K�����̑O���� +++++++++++++++++++++++++++++++++++++++++++++
  CALL PreVel2ndDiffXI
  CALL PreVel2ndDiffET
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE PreVel2ndDiff
!***********************************************************************
!**** ��K�����v�Z�p�̑O����(XI����)                                ****
!***********************************************************************
SUBROUTINE PreVel2ndDiffXI
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: XIXM, XIYM, ETXM, ETYM
  REAL    :: UXI, VXI, UET, VET
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, XIXM, XIYM, ETXM, ETYM, UXI, VXI, UET, VET &
!$OMP& )
  DO J = JS + 1, JE - 1
  DO I = IS    , IE - 1
  IF(RHO(I,J) .GT. 0.0 .AND. RHO(I+1,J) .GT. 0.0) THEN
    ! XI�����̒��Ԓl ---------------------------------------------------
    XIXM = 0.5 * (XIX(I,J) + XIX(I+1,J))
    XIYM = 0.5 * (XIY(I,J) + XIY(I+1,J))
    ETXM = 0.5 * (ETX(I,J) + ETX(I+1,J))
    ETYM = 0.5 * (ETY(I,J) + ETY(I+1,J))
    ! �v�Z��Ԉ�K���� -------------------------------------------------
    UXI = - U(I,J) + U(I+1,J)
    UET = - 0.25 * (U(I,J-1) + U(I+1,J-1) - U(I,J+1) - U(I+1,J+1))
    VXI = - V(I,J) + V(I+1,J)
    VET = - 0.25 * (V(I,J-1) + V(I+1,J-1) - V(I,J+1) - V(I+1,J+1))
    ! ������Ԉ�K���� -------------------------------------------------
    UXXI(I,J) = UXI * XIXM + UET * ETXM
    UYXI(I,J) = UXI * XIYM + UET * ETYM
    VXXI(I,J) = VXI * XIXM + VET * ETXM
    VYXI(I,J) = VXI * XIYM + VET * ETYM
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE PreVel2ndDiffXI
!***********************************************************************
!**** ��K�����v�Z�p�̑O����(ET����)                                ****
!***********************************************************************
SUBROUTINE PreVel2ndDiffET
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: XIXM, XIYM, ETXM, ETYM
  REAL    :: UXI, VXI, UET, VET
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, XIXM, XIYM, ETXM, ETYM, UXI, VXI, UET, VET &
!$OMP& )
  DO J = JS    , JE - 1
  DO I = IS + 1, IE - 1
  IF(RHO(I,J) .GT. 0.0 .AND. RHO(I,J+1) .GT. 0.0) THEN
    ! ET�����̒��Ԓl ---------------------------------------------------
    XIXM = 0.5 * (XIX(I,J) + XIX(I,J+1))
    XIYM = 0.5 * (XIY(I,J) + XIY(I,J+1))
    ETXM = 0.5 * (ETX(I,J) + ETX(I,J+1))
    ETYM = 0.5 * (ETY(I,J) + ETY(I,J+1))
    ! �v�Z��Ԉ�K���� -------------------------------------------------
    UXI = - 0.25 * ( U(I-1,J) - U(I+1,J) + U(I-1,J+1) - U(I+1,J+1) )
    UET = - U(I,J) + U(I,J+1)
    VXI = - 0.25 * ( V(I-1,J) - V(I+1,J) + V(I-1,J+1) - V(I+1,J+1) )
    VET = - V(I,J) + V(I,J+1)
    ! ������Ԉ�K���� -------------------------------------------------
    UXET(I,J) = UXI * XIXM + UET * ETXM
    UYET(I,J) = UXI * XIYM + UET * ETYM
    VXET(I,J) = VXI * XIXM + VET * ETXM
    VYET(I,J) = VXI * XIYM + VET * ETYM
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE PreVel2ndDiffET
!***********************************************************************
!**** ��g�U���̌v�Z                                                ****
!***********************************************************************
SUBROUTINE NonDiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: UXI, VXI, UET, VET
  REAL    :: UX, VX, UY, VY, DELV
  REAL    :: KRXI, KRET, KRX, KRY
  REAL    :: UXX, UXY, UYX, UYY, VXX, VXY, VYX, VYY
  REAL    :: Rtt, f_mu, f_2
  REAL    :: nu, nu_t
  REAL    :: SS2, PP_k, D, E
  REAL    :: QH1, AEAK
  ! �����J�n ***********************************************************
  ! �Q�S���W���̌v�Z +++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, nu, Rtt, f_mu, nu_t &
!$OMP& )
  DO J = JS, JE
  DO I = IS, IE
  IF(RHO(I,J) .GT. 0.0) THEN
    IF(EPST(I,J) .GT. ZERO) THEN
      nu        = AMU(I,J) / RHO(I,J)
      Rtt       = AK(I,J)**2 / (nu * EPST(I,J))
      f_mu      = EXP(-3.4 / (1.0 + Rtt / 50.0)**2)
      nu_t      = CMU * f_mu * AK(I,J)**2 / EPST(I,J)
      AMUT(I,J) = RHO(I,J) * nu_t
    ELSE
      AMUT(I,J) = 0.0
    ENDIF
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! ��g�U���̌v�Z +++++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, &
!$OMP& UXI, VXI, UET, VET, &
!$OMP& UX, VX, UY, VY, DELV, &
!$OMP& KRXI, KRET, KRX, KRY, &
!$OMP& UXX, UXY, UYX, UYY, VXX, VXY, VYX, VYY, &
!$OMP& Rtt, f_2, nu, nu_t, SS2, PP_k, D, E, QH1, AEAK &
!$OMP& )
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( (RHO(I,J-1) .GT. 0.0) .AND. (RHO(I-1,J) .GT. 0.0) .AND. &
  &   (RHO(I,J)   .GT. 0.0) .AND. &
  &   (RHO(I+1,J) .GT. 0.0) .AND. (RHO(I,J+1) .GT. 0.0) &
  & ) THEN
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = 0.5 * (U(I+1,J) - U(I-1,J))
    VXI = 0.5 * (V(I+1,J) - V(I-1,J))
    UET = 0.5 * (U(I,J+1) - U(I,J-1))
    VET = 0.5 * (V(I,J+1) - V(I,J-1))
    ! ������ԕ�����K����
    UX = UXI * XIX(I,J) + UET * ETX(I,J)
    UY = UXI * XIY(I,J) + UET * ETY(I,J)
    VX = VXI * XIX(I,J) + VET * ETX(I,J)
    VY = VXI * XIY(I,J) + VET * ETY(I,J)
    ! ����̑��x�X�P�[�� sqrt(k) �̈�K�����̌v�Z ----------------------
    ! �v�Z��ԕ�����K����
    KRXI = 0.5 * (SQRT(AK(I+1,J)) - SQRT(AK(I-1,J)))
    KRET = 0.5 * (SQRT(AK(I,J+1)) - SQRT(AK(I,J-1)))
    ! ������ԕ�����K����
    KRX = KRXI * XIX(I,J) + KRET * ETX(I,J)
    KRY = KRXI * XIY(I,J) + KRET * ETY(I,J)
    ! ���x�̓�K�����̌v�Z ---------------------------------------------
    UXX = - (UXXI(I-1,J) - UXXI(I,J)) * XIX(I,J) &
    &     - (UXET(I,J-1) - UXET(I,J)) * ETX(I,J)
    UXY = - (UXXI(I-1,J) - UXXI(I,J)) * XIY(I,J) &
    &     - (UXET(I,J-1) - UXET(I,J)) * ETY(I,J)
    UYX = - (UYXI(I-1,J) - UYXI(I,J)) * XIX(I,J) &
    &     - (UYET(I,J-1) - UYET(I,J)) * ETX(I,J)
    UYY = - (UYXI(I-1,J) - UYXI(I,J)) * XIY(I,J) &
    &     - (UYET(I,J-1) - UYET(I,J)) * ETY(I,J)
    VXX = - (VXXI(I-1,J) - VXXI(I,J)) * XIX(I,J) &
    &     - (VXET(I,J-1) - VXET(I,J)) * ETX(I,J)
    VXY = - (VXXI(I-1,J) - VXXI(I,J)) * XIY(I,J) &
    &     - (VXET(I,J-1) - VXET(I,J)) * ETY(I,J)
    VYX = - (VYXI(I-1,J) - VYXI(I,J)) * XIX(I,J) &
    &     - (VYET(I,J-1) - VYET(I,J)) * ETX(I,J)
    VYY = - (VYXI(I-1,J) - VYXI(I,J)) * XIY(I,J) &
    &     - (VYET(I,J-1) - VYET(I,J)) * ETY(I,J)
    ! ���f���֐��̌v�Z -------------------------------------------------
    nu   =  AMU(I,J) / RHO(I,J)
    nu_t = AMUT(I,J) / RHO(I,J)
    IF(EPST(I,J) .GT. ZERO) THEN
      Rtt = AK(I,J)**2 / (nu * EPST(I,J))
    ELSE
      Rtt = 0.0
    ENDIF
    f_2  = 1.0 - 0.3 * EXP(-Rtt**2)
    ! �␳�� D, E �̌v�Z -----------------------------------------------
    D = 2.0 * nu * (KRX**2 + KRY**2)
    E = 2.0 * nu * nu_t * ( &
    &     UXX**2 + VXX**2 + UYY**2 + VYY**2 &
    &   + UXY**2 + VXY**2 + UYX**2 + VYX**2 &
    & )
    ! ���C�m���Y���͂̐���(���Ϙc�ݑ�����) -----------------------------
    DELV = UX + VY
    SS2  = 2.0 * (UX**2 + VY**2) + (UY + VX)**2 - TwoThird * DELV**2
    PP_k = nu_t * SS2 - TwoThird * AK(I,J) * DELV
    ! �Ǐ����t����(�����ƎU��̃o�����X)�ɂ�郊�~�b�^�[
    IF(PELIM .GT. 0.0) THEN
      PP_k = MAX(0.0, MIN((EPST(I,J) + D) / PELIM, PP_k))
    ENDIF
    ! �����A�U��̘a ---------------------------------------------------
    QH1 = RHO(I,J) / AJA(I,J)
    AEAK = MIN( &
    &      MAX(SQRT(SS2), SQRT((EPST(I,J) + D) / nu)), &
    &      EPST(I,J) / MAX(ZERO, AK(I,J)) &
    &    )
    DQP(I,J,5) = QH1 * (PP_k - (EPST(I,J) + D))
    DQP(I,J,6) = QH1 * (AEAK * (CE1 * PP_k - CE2 * f_2 * EPST(I,J)) + E)
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE NonDiffTerm
!***********************************************************************
!**** �g�U���̌v�Z                                                  ****
!***********************************************************************
SUBROUTINE DiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, L
  ! �����J�n ***********************************************************
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  RH = 0.0
  SH = 0.0
  ! �g�U���̗v�f���v�Z +++++++++++++++++++++++++++++++++++++++++++++++++
  CALL DIFFXI
  CALL DIFFET
  ! �g�U���̍��� +++++++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE(I, J, L)
  DO L = LS, LE
  !$OMP DO
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( (RHO(I,J-1) .GT. 0.0) .AND. (RHO(I-1,J) .GT. 0.0) .AND. &
  &   (RHO(I,J)   .GT. 0.0) .AND. &
  &   (RHO(I+1,J) .GT. 0.0) .AND. (RHO(I,J+1) .GT. 0.0) &
  & ) THEN
    DQD(I,J,L) = (-RH(I-1,J  ,L) + RH(I,J,L)) &
    &          + (-SH(I  ,J-1,L) + SH(I,J,L))
  ENDIF
  ENDDO
  ENDDO
  !$OMP END DO
  ENDDO
  !$OMP END PARALLEL
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DiffTerm
!***********************************************************************
!**** �g�U���̌v�Z(xi���������p)                                    ****
!***********************************************************************
SUBROUTINE DIFFXI
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: XIXM, XIYM, ETXM, ETYM, AJAM
  REAL    :: RHOM, UM, VM, TM, AKM, EPSTM, AMUM, AMUTM
  REAL    :: UXI, UET, UX, UY
  REAL    :: VXI, VET, VX, VY
  REAL    :: TXI, TET, TX, TY
  REAL    :: AKXI, AKET, AKX, AKY
  REAL    :: AEXI, AEET, AEX, AEY
  REAL    :: nu, nu_t
  REAL    :: c_u, c_t, c_k, c_e
  REAL    :: TAUXX, TAUYY, TAUXY, DELV
  REAL    :: R4, S4
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, &
!$OMP& XIXM, XIYM, ETXM, ETYM, AJAM, &
!$OMP& RHOM, UM, VM, TM, AKM, EPSTM, AMUM, AMUTM, &
!$OMP& UXI, UET, UX, UY, &
!$OMP& VXI, VET, VX, VY, &
!$OMP& TXI, TET, TX, TY, &
!$OMP& AKXI, AKET, AKX, AKY, &
!$OMP& AEXI, AEET, AEX, AEY, &
!$OMP& nu, nu_t, c_u, c_t, c_k, c_e, &
!$OMP& TAUXX, TAUYY, TAUXY, DELV, R4, S4, QH1 &
!$OMP& )
  DO J = JS + 1, JE - 1
  DO I = IS    , IE - 1
  IF( (RHO(I,J-1) .GT. 0.0) .AND. (RHO(I,J)   .GT. 0.0) .AND. &
  &   (RHO(I+1,J) .GT. 0.0) .AND. (RHO(I,J+1) .GT. 0.0)  &
  & ) THEN
    ! XI�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J) + XIX(I+1,J))
    XIYM = 0.5 * (XIY(I,J) + XIY(I+1,J))
    ETXM = 0.5 * (ETX(I,J) + ETX(I+1,J))
    ETYM = 0.5 * (ETY(I,J) + ETY(I+1,J))
    AJAM = 0.5 * (AJA(I,J) + AJA(I+1,J))
    ! ������
    RHOM  = 0.5 * ( RHO(I,J) +  RHO(I+1,J))
    UM    = 0.5 * (   U(I,J) +    U(I+1,J))
    VM    = 0.5 * (   V(I,J) +    V(I+1,J))
    TM    = 0.5 * (   T(I,J) +    T(I+1,J))
    AKM   = 0.5 * (  AK(I,J) +   AK(I+1,J))
    EPSTM = 0.5 * (EPST(I,J) + EPST(I+1,J))
    AMUM  = 0.5 * ( AMU(I,J) +  AMU(I+1,J))
    AMUTM = 0.5 * (AMUT(I,J) + AMUT(I+1,J))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = - U(I,J) + U(I+1,J)
    VXI = - V(I,J) + V(I+1,J)
    UET = 0.25 * (- U(I,J-1) - U(I+1,J-1) + U(I,J+1) + U(I+1,J+1))
    VET = 0.25 * (- V(I,J-1) - V(I+1,J-1) + V(I,J+1) + V(I+1,J+1))
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM
    UY = UXI * XIYM + UET * ETYM
    VX = VXI * XIXM + VET * ETXM
    VY = VXI * XIYM + VET * ETYM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = - T(I,J) + T(I+1,J)
    TET = 0.25 * (- T(I,J-1) - T(I+1,J-1) + T(I,J+1) + T(I+1,J+1))
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM
    TY = TXI * XIYM + TET * ETYM
    ! k �̈�K�����̌v�Z -----------------------------------------------
    ! �v�Z��ԕ�����K����
    AKXI = - AK(I,J) + AK(I+1,J)
    AKET = 0.25 * (- AK(I,J-1) - AK(I+1,J-1) + AK(I,J+1) + AK(I+1,J+1))
    ! ������ԕ�����K����
    AKX = AKXI * XIXM + AKET * ETXM
    AKY = AKXI * XIYM + AKET * ETYM
    ! epsilon tilde �̈�K�����̌v�Z -----------------------------------
    ! �v�Z��ԕ�����K����
    AEXI = - EPST(I,J) + EPST(I+1,J)
    AEET = 0.25 * (-EPST(I,J-1)-EPST(I+1,J-1)+EPST(I,J+1)+EPST(I+1,J+1))
    ! ������ԕ�����K����
    AEX = AEXI * XIXM + AEET * ETXM
    AEY = AEXI * XIYM + AEET * ETYM
    ! �W���v�Z ---------------------------------------------------------
    nu   = AMUM  / RHOM
    nu_t = AMUTM / RHOM
    c_u  = nu + nu_t
    c_t  = (nu / PR + nu_t / PRT) / (GAMMA - 1.0) * GAMMA * RG
    c_k  = nu + nu_t / SIGK
    c_e  = nu + nu_t / SIGE
    ! �S�����͂ƃ��C�m���Y���̘͂a -------------------------------------
    DELV  = UX + VY
    TAUXX = c_u * (2.0 * UX - TwoThird * DELV) - TwoThird * AKM
    TAUYY = c_u * (2.0 * VY - TwoThird * DELV) - TwoThird * AKM
    TAUXY = c_u * (UY + VX)
    ! �G�l���M�[�̊g�U -------------------------------------------------
    R4 = TAUXX * UM + TAUXY * VM + c_t * TX
    S4 = TAUXY * UM + TAUYY * VM + c_t * TY
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    RH(I,J,1) = 0.0
    RH(I,J,2) = QH1 * (TAUXX * XIXM + TAUXY * XIYM)
    RH(I,J,3) = QH1 * (TAUXY * XIXM + TAUYY * XIYM)
    RH(I,J,4) = QH1 * (R4 * XIXM + S4 * XIYM)
    RH(I,J,5) = QH1 * c_k * (AKX * XIXM + AKY * XIYM)
    RH(I,J,6) = QH1 * c_e * (AEX * XIXM + AEY * XIYM)
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFXI
!***********************************************************************
!**** �g�U���̌v�Z(eta���������p)                                   ****
!***********************************************************************
SUBROUTINE DIFFET
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: XIXM, XIYM, ETXM, ETYM, AJAM
  REAL    :: RHOM, UM, VM, TM, AKM, EPSTM, AMUM, AMUTM
  REAL    :: UXI, UET, UX, UY
  REAL    :: VXI, VET, VX, VY
  REAL    :: TXI, TET, TX, TY
  REAL    :: AKXI, AKET, AKX, AKY
  REAL    :: AEXI, AEET, AEX, AEY
  REAL    :: nu, nu_t
  REAL    :: c_u, c_t, c_k, c_e
  REAL    :: TAUXX, TAUYY, TAUXY, DELV
  REAL    :: R4, S4
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, &
!$OMP& XIXM, XIYM, ETXM, ETYM, AJAM, &
!$OMP& RHOM, UM, VM, TM, AKM, EPSTM, AMUM, AMUTM, &
!$OMP& UXI, UET, UX, UY, &
!$OMP& VXI, VET, VX, VY, &
!$OMP& TXI, TET, TX, TY, &
!$OMP& AKXI, AKET, AKX, AKY, &
!$OMP& AEXI, AEET, AEX, AEY, &
!$OMP& nu, nu_t, c_u, c_t, c_k, c_e, &
!$OMP& TAUXX, TAUYY, TAUXY, DELV, R4, S4, QH1 &
!$OMP& )
  DO J = JS    , JE - 1
  DO I = IS + 1, IE - 1
  IF( (RHO(I-1,J) .GT. 0.0) .AND. (RHO(I,J)   .GT. 0.0) .AND. &
  &   (RHO(I+1,J) .GT. 0.0) .AND. (RHO(I,J+1) .GT. 0.0) &
  & ) THEN
    ! ET�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J) + XIX(I,J+1))
    XIYM = 0.5 * (XIY(I,J) + XIY(I,J+1))
    ETXM = 0.5 * (ETX(I,J) + ETX(I,J+1))
    ETYM = 0.5 * (ETY(I,J) + ETY(I,J+1))
    AJAM = 0.5 * (AJA(I,J) + AJA(I,J+1))
    ! ������
    RHOM  = 0.5 * ( RHO(I,J) +  RHO(I,J+1))
    UM    = 0.5 * (   U(I,J) +    U(I,J+1))
    VM    = 0.5 * (   V(I,J) +    V(I,J+1))
    TM    = 0.5 * (   T(I,J) +    T(I,J+1))
    AKM   = 0.5 * (  AK(I,J) +   AK(I,J+1))
    EPSTM = 0.5 * (EPST(I,J) + EPST(I,J+1))
    AMUM  = 0.5 * ( AMU(I,J) +  AMU(I,J+1))
    AMUTM = 0.5 * (AMUT(I,J) + AMUT(I,J+1))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = 0.25 * (- U(I-1,J) - U(I-1,J+1) + U(I+1,J) + U(I+1,J+1))
    VXI = 0.25 * (- V(I-1,J) - V(I-1,J+1) + V(I+1,J) + V(I+1,J+1))
    UET = - U(I,J) + U(I,J+1)
    VET = - V(I,J) + V(I,J+1)
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM
    UY = UXI * XIYM + UET * ETYM
    VX = VXI * XIXM + VET * ETXM
    VY = VXI * XIYM + VET * ETYM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = 0.25 * (- T(I-1,J) - T(I-1,J+1) + T(I+1,J) + T(I+1,J+1))
    TET = - T(I,J) + T(I,J+1)
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM
    TY = TXI * XIYM + TET * ETYM
    ! k �̈�K�����̌v�Z -----------------------------------------------
    ! �v�Z��ԕ�����K����
    AKXI = 0.25 * (- AK(I-1,J) - AK(I-1,J+1) + AK(I+1,J) + AK(I+1,J+1))
    AKET = - AK(I,J) + AK(I,J+1)
    ! ������ԕ�����K����
    AKX = AKXI * XIXM + AKET * ETXM
    AKY = AKXI * XIYM + AKET * ETYM
    ! epsilon tilde �̈�K�����̌v�Z -----------------------------------
    ! �v�Z��ԕ�����K����
    AEXI = 0.25 * (-EPST(I-1,J)-EPST(I-1,J+1)+EPST(I+1,J)+EPST(I+1,J+1))
    AEET = - EPST(I,J) + EPST(I,J+1)
    ! ������ԕ�����K����
    AEX = AEXI * XIXM + AEET * ETXM
    AEY = AEXI * XIYM + AEET * ETYM
    ! �W���v�Z ---------------------------------------------------------
    nu   = AMUM  / RHOM
    nu_t = AMUTM / RHOM
    c_u  = nu + nu_t
    c_t  = (nu / PR + nu_t / PRT) / (GAMMA - 1.0) * GAMMA * RG
    c_k  = nu + nu_t / SIGK
    c_e  = nu + nu_t / SIGE
    ! �S�����͂ƃ��C�m���Y���̘͂a -------------------------------------
    DELV  = UX + VY
    TAUXX = c_u * (2.0 * UX - TwoThird * DELV) - TwoThird * AKM
    TAUYY = c_u * (2.0 * VY - TwoThird * DELV) - TwoThird * AKM
    TAUXY = c_u * (UY + VX)
    ! �G�l���M�[�̊g�U -------------------------------------------------
    R4 = TAUXX * UM + TAUXY * VM + c_t * TX
    S4 = TAUXY * UM + TAUYY * VM + c_t * TY
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    SH(I,J,1) = 0.0
    SH(I,J,2) = QH1 * (TAUXX * ETXM + TAUXY * ETYM)
    SH(I,J,3) = QH1 * (TAUXY * ETXM + TAUYY * ETYM)
    SH(I,J,4) = QH1 * (R4 * ETXM + S4 * ETYM)
    SH(I,J,5) = QH1 * c_k * (AKX * ETXM + AKY * ETYM)
    SH(I,J,6) = QH1 * c_e * (AEX * ETXM + AEY * ETYM)
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFET
! ��`�I�� *************************************************************
END SUBROUTINE Turbulence2DEvmLS
!***********************************************************************
!**** �������f�� : RANS, EVM, Launder-Sharma Model (1974)           ****
!**** �v�Z�Ώ� : �P��, �O����, ���k��                               ****
!**** �v�Z�X�L�[�� : �񎟐��x���S����(�X�^�K�[�h�i�q��̓_���g�p)   ****
!***********************************************************************
SUBROUTINE Turbulence3DEvmLS( &
&            PELIM, RG, GAMMA, PR, PRT, &
&            IS, IE, JS, JE, KS, KE, LS, LE, &
&            XIX, XIY, XIZ, ETX, ETY, ETZ, ZEX, ZEY, ZEZ, AJA, &
&            RHO, U, V, W, T, AK, EPST, AMU, &
&            AMUT, DQD, DQP &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, PARAMETER :: CMU = 0.09
  REAL, PARAMETER :: CE1 = 1.44, CE2 = 1.92
  REAL, PARAMETER :: SIGK = 1.0, SIGE = 1.3
  REAL, PARAMETER :: ZERO = 1.0E-20
  REAL, PARAMETER :: TwoThird = 0.66666667
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: PELIM
  REAL,    INTENT(IN)  :: RG, GAMMA, PR, PRT
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE, KS, KE
  INTEGER, INTENT(IN)  :: LS, LE
  REAL,    INTENT(IN)  :: XIX(IS:IE, JS:JE, KS:KE), &
  &                       XIY(IS:IE, JS:JE, KS:KE), &
  &                       XIZ(IS:IE, JS:JE, KS:KE), &
  &                       ETX(IS:IE, JS:JE, KS:KE), &
  &                       ETY(IS:IE, JS:JE, KS:KE), &
  &                       ETZ(IS:IE, JS:JE, KS:KE), &
  &                       ZEX(IS:IE, JS:JE, KS:KE), &
  &                       ZEY(IS:IE, JS:JE, KS:KE), &
  &                       ZEZ(IS:IE, JS:JE, KS:KE), &
  &                       AJA(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)  :: RHO(IS:IE, JS:JE, KS:KE), &
  &                       U(IS:IE, JS:JE, KS:KE), &
  &                       V(IS:IE, JS:JE, KS:KE), &
  &                       W(IS:IE, JS:JE, KS:KE), &
  &                       T(IS:IE, JS:JE, KS:KE), &
  &                       AK(IS:IE, JS:JE, KS:KE), &
  &                       EPST(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)  :: AMU(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(OUT) :: AMUT(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(OUT) :: DQD(IS:IE, JS:JE, KS:KE, LS:LE)
  REAL,    INTENT(OUT) :: DQP(IS:IE, JS:JE, KS:KE, LS:LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, ALLOCATABLE :: RH(:, :, :, :), SH(:, :, :, :), TH(:, :, :, :)
  REAL, ALLOCATABLE :: UXXI(:, :, :), UYXI(:, :, :), UZXI(:, :, :), &
  &                    VXXI(:, :, :), VYXI(:, :, :), VZXI(:, :, :), &
  &                    WXXI(:, :, :), WYXI(:, :, :), WZXI(:, :, :)
  REAL, ALLOCATABLE :: UXET(:, :, :), UYET(:, :, :), UZET(:, :, :), &
  &                    VXET(:, :, :), VYET(:, :, :), VZET(:, :, :), &
  &                    WXET(:, :, :), WYET(:, :, :), WZET(:, :, :)
  REAL, ALLOCATABLE :: UXZE(:, :, :), UYZE(:, :, :), UZZE(:, :, :), &
  &                    VXZE(:, :, :), VYZE(:, :, :), VZZE(:, :, :), &
  &                    WXZE(:, :, :), WYZE(:, :, :), WZZE(:, :, :)
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 7) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �������m�� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ALLOCATE(RH(IS: IE, JS: JE, KS: KE, LS: LE))
  ALLOCATE(SH(IS: IE, JS: JE, KS: KE, LS: LE))
  ALLOCATE(TH(IS: IE, JS: JE, KS: KE, LS: LE))
  ALLOCATE(UXXI(IS: IE, JS: JE, KS: KE), UYXI(IS: IE, JS: JE, KS: KE))
  ALLOCATE(UZXI(IS: IE, JS: JE, KS: KE), VXXI(IS: IE, JS: JE, KS: KE))
  ALLOCATE(VYXI(IS: IE, JS: JE, KS: KE), VZXI(IS: IE, JS: JE, KS: KE))
  ALLOCATE(WXXI(IS: IE, JS: JE, KS: KE), WYXI(IS: IE, JS: JE, KS: KE))
  ALLOCATE(WZXI(IS: IE, JS: JE, KS: KE))
  ALLOCATE(UXET(IS: IE, JS: JE, KS: KE), UYET(IS: IE, JS: JE, KS: KE))
  ALLOCATE(UZET(IS: IE, JS: JE, KS: KE), VXET(IS: IE, JS: JE, KS: KE))
  ALLOCATE(VYET(IS: IE, JS: JE, KS: KE), VZET(IS: IE, JS: JE, KS: KE))
  ALLOCATE(WXET(IS: IE, JS: JE, KS: KE), WYET(IS: IE, JS: JE, KS: KE))
  ALLOCATE(WZET(IS: IE, JS: JE, KS: KE))
  ALLOCATE(UXZE(IS: IE, JS: JE, KS: KE), UYZE(IS: IE, JS: JE, KS: KE))
  ALLOCATE(UZZE(IS: IE, JS: JE, KS: KE), VXZE(IS: IE, JS: JE, KS: KE))
  ALLOCATE(VYZE(IS: IE, JS: JE, KS: KE), VZZE(IS: IE, JS: JE, KS: KE))
  ALLOCATE(WXZE(IS: IE, JS: JE, KS: KE), WYZE(IS: IE, JS: JE, KS: KE))
  ALLOCATE(WZZE(IS: IE, JS: JE, KS: KE))
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  AMUT = 0.0
  DQD  = 0.0
  DQP  = 0.0
  ! �����葱���̌Ăяo�� +++++++++++++++++++++++++++++++++++++++++++++++
  CALL PreVel2ndDiff
  CALL NonDiffTerm
  CALL DiffTerm
  ! �����I�� ***********************************************************
  RETURN
! �����葱�� ***********************************************************
CONTAINS
!***********************************************************************
!**** ��K�����v�Z�p�̑O����                                        ****
!***********************************************************************
SUBROUTINE PreVel2ndDiff
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����J�n ***********************************************************
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  UXXI = 0.0
  UYXI = 0.0
  UZXI = 0.0
  VXXI = 0.0
  VYXI = 0.0
  VZXI = 0.0
  WXXI = 0.0
  WYXI = 0.0
  WZXI = 0.0
  UXET = 0.0
  UYET = 0.0
  UZET = 0.0
  VXET = 0.0
  VYET = 0.0
  VZET = 0.0
  WXET = 0.0
  WYET = 0.0
  WZET = 0.0
  UXZE = 0.0
  UYZE = 0.0
  UZZE = 0.0
  VXZE = 0.0
  VYZE = 0.0
  VZZE = 0.0
  WXZE = 0.0
  WYZE = 0.0
  WZZE = 0.0
  ! ���x�̓�K�����̑O���� +++++++++++++++++++++++++++++++++++++++++++++
  CALL PreVel2ndDiffXI
  CALL PreVel2ndDiffET
  CALL PreVel2ndDiffZE
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE PreVel2ndDiff
!***********************************************************************
!**** ��K�����v�Z�p�̑O����(XI����)                                ****
!***********************************************************************
SUBROUTINE PreVel2ndDiffXI
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM
  REAL    :: UXI, VXI, WXI, UET, VET, WET, UZE, VZE, WZE
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, &
!$OMP& UXI, VXI, WXI, UET, VET, WET, UZE, VZE, WZE &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS    , IE - 1
  IF(RHO(I,J,K) .GT. 0.0 .AND. RHO(I+1,J,K) .GT. 0.0) THEN
    ! XI�����̒��Ԓl ---------------------------------------------------
    XIXM = 0.5 * (XIX(I,J,K) + XIX(I+1,J,K))
    XIYM = 0.5 * (XIY(I,J,K) + XIY(I+1,J,K))
    XIZM = 0.5 * (XIZ(I,J,K) + XIZ(I+1,J,K))
    ETXM = 0.5 * (ETX(I,J,K) + ETX(I+1,J,K))
    ETYM = 0.5 * (ETY(I,J,K) + ETY(I+1,J,K))
    ETZM = 0.5 * (ETZ(I,J,K) + ETZ(I+1,J,K))
    ZEXM = 0.5 * (ZEX(I,J,K) + ZEX(I+1,J,K))
    ZEYM = 0.5 * (ZEY(I,J,K) + ZEY(I+1,J,K))
    ZEZM = 0.5 * (ZEZ(I,J,K) + ZEZ(I+1,J,K))
    ! �v�Z��Ԉ�K���� -------------------------------------------------
    UXI = - U(I,J,K) + U(I+1,J,K)
    UET = - 0.25 * ( U(I,J-1,K) + U(I+1,J-1,K) &
    &              - U(I,J+1,K) - U(I+1,J+1,K) )
    UZE = - 0.25 * ( U(I,J,K-1) + U(I+1,J,K-1) &
    &              - U(I,J,K+1) - U(I+1,J,K+1) )
    VXI = - V(I,J,K) + V(I+1,J,K)
    VET = - 0.25 * ( V(I,J-1,K) + V(I+1,J-1,K) &
    &              - V(I,J+1,K) - V(I+1,J+1,K) )
    VZE = - 0.25 * ( V(I,J,K-1) + V(I+1,J,K-1) &
    &              - V(I,J,K+1) - V(I+1,J,K+1) )
    WXI = - W(I,J,K) + W(I+1,J,K)
    WET = - 0.25 * ( W(I,J-1,K) + W(I+1,J-1,K) &
    &              - W(I,J+1,K) - W(I+1,J+1,K) )
    WZE = - 0.25 * ( W(I,J,K-1) + W(I+1,J,K-1) &
    &              - W(I,J,K+1) - W(I+1,J,K+1) )
    ! ������Ԉ�K���� -------------------------------------------------
    UXXI(I,J,K) = UXI * XIXM + UET * ETXM + UZE * ZEXM
    UYXI(I,J,K) = UXI * XIYM + UET * ETYM + UZE * ZEYM
    UZXI(I,J,K) = UXI * XIZM + UET * ETZM + UZE * ZEZM
    VXXI(I,J,K) = VXI * XIXM + VET * ETXM + VZE * ZEXM
    VYXI(I,J,K) = VXI * XIYM + VET * ETYM + VZE * ZEYM
    VZXI(I,J,K) = VXI * XIZM + VET * ETZM + VZE * ZEZM
    WXXI(I,J,K) = WXI * XIXM + WET * ETXM + WZE * ZEXM
    WYXI(I,J,K) = WXI * XIYM + WET * ETYM + WZE * ZEYM
    WZXI(I,J,K) = WXI * XIZM + WET * ETZM + WZE * ZEZM
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE PreVel2ndDiffXI
!***********************************************************************
!**** ��K�����v�Z�p�̑O����(ET����)                                ****
!***********************************************************************
SUBROUTINE PreVel2ndDiffET
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM
  REAL    :: UXI, VXI, WXI, UET, VET, WET, UZE, VZE, WZE
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, &
!$OMP& UXI, VXI, WXI, UET, VET, WET, UZE, VZE, WZE &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS    , JE - 1
  DO I = IS + 1, IE - 1
  IF(RHO(I,J,K) .GT. 0.0 .AND. RHO(I,J+1,K) .GT. 0.0) THEN
    ! ET�����̒��Ԓl ---------------------------------------------------
    XIXM = 0.5 * (XIX(I,J,K) + XIX(I,J+1,K))
    XIYM = 0.5 * (XIY(I,J,K) + XIY(I,J+1,K))
    XIZM = 0.5 * (XIZ(I,J,K) + XIZ(I,J+1,K))
    ETXM = 0.5 * (ETX(I,J,K) + ETX(I,J+1,K))
    ETYM = 0.5 * (ETY(I,J,K) + ETY(I,J+1,K))
    ETZM = 0.5 * (ETZ(I,J,K) + ETZ(I,J+1,K))
    ZEXM = 0.5 * (ZEX(I,J,K) + ZEX(I,J+1,K))
    ZEYM = 0.5 * (ZEY(I,J,K) + ZEY(I,J+1,K))
    ZEZM = 0.5 * (ZEZ(I,J,K) + ZEZ(I,J+1,K))
    ! �v�Z��Ԉ�K���� -------------------------------------------------
    UXI = - 0.25 * ( U(I-1,J  ,K) - U(I+1,J  ,K) &
    &              + U(I-1,J+1,K) - U(I+1,J+1,K) )
    UET = - U(I,J,K) + U(I,J+1,K)
    UZE = - 0.25 * ( U(I,J,K-1) + U(I,J+1,K-1) &
    &              - U(I,J,K+1) - U(I,J+1,K+1) )
    VXI = - 0.25 * ( V(I-1,J  ,K) - V(I+1,J  ,K) &
    &              + V(I-1,J+1,K) - V(I+1,J+1,K) )
    VET = - V(I,J,K) + V(I,J+1,K)
    VZE = - 0.25 * ( V(I,J,K-1) + V(I,J+1,K-1) &
    &              - V(I,J,K+1) - V(I,J+1,K+1) )
    WXI = - 0.25 * ( W(I-1,J  ,K) - W(I+1,J  ,K) &
    &              + W(I-1,J+1,K) - W(I+1,J+1,K) )
    WET = - W(I,J,K) + W(I,J+1,K)
    WZE = - 0.25 * ( W(I,J,K-1) + W(I,J+1,K-1) &
    &              - W(I,J,K+1) - W(I,J+1,K+1) )
    ! ������Ԉ�K���� -------------------------------------------------
    UXET(I,J,K) = UXI * XIXM + UET * ETXM + UZE * ZEXM
    UYET(I,J,K) = UXI * XIYM + UET * ETYM + UZE * ZEYM
    UZET(I,J,K) = UXI * XIZM + UET * ETZM + UZE * ZEZM
    VXET(I,J,K) = VXI * XIXM + VET * ETXM + VZE * ZEXM
    VYET(I,J,K) = VXI * XIYM + VET * ETYM + VZE * ZEYM
    VZET(I,J,K) = VXI * XIZM + VET * ETZM + VZE * ZEZM
    WXET(I,J,K) = WXI * XIXM + WET * ETXM + WZE * ZEXM
    WYET(I,J,K) = WXI * XIYM + WET * ETYM + WZE * ZEYM
    WZET(I,J,K) = WXI * XIZM + WET * ETZM + WZE * ZEZM
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE PreVel2ndDiffET
!***********************************************************************
!**** ��K�����v�Z�p�̑O����(ZE����)                                ****
!***********************************************************************
SUBROUTINE PreVel2ndDiffZE
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM
  REAL    :: UXI, VXI, WXI, UET, VET, WET, UZE, VZE, WZE
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, &
!$OMP& UXI, VXI, WXI, UET, VET, WET, UZE, VZE, WZE &
!$OMP& )
  DO K = KS    , KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF(RHO(I,J,K) .GT. 0.0 .AND. RHO(I,J,K+1) .GT. 0.0) THEN
    ! ZE�����̒��Ԓl ---------------------------------------------------
    XIXM = 0.5 * (XIX(I,J,K) + XIX(I,J,K+1))
    XIYM = 0.5 * (XIY(I,J,K) + XIY(I,J,K+1))
    XIZM = 0.5 * (XIZ(I,J,K) + XIZ(I,J,K+1))
    ETXM = 0.5 * (ETX(I,J,K) + ETX(I,J,K+1))
    ETYM = 0.5 * (ETY(I,J,K) + ETY(I,J,K+1))
    ETZM = 0.5 * (ETZ(I,J,K) + ETZ(I,J,K+1))
    ZEXM = 0.5 * (ZEX(I,J,K) + ZEX(I,J,K+1))
    ZEYM = 0.5 * (ZEY(I,J,K) + ZEY(I,J,K+1))
    ZEZM = 0.5 * (ZEZ(I,J,K) + ZEZ(I,J,K+1))
    ! �v�Z��Ԉ�K���� -------------------------------------------------
    UXI = - 0.25 * ( U(I-1,J,K  ) - U(I+1,J,K  ) &
    &              + U(I-1,J,K+1) - U(I+1,J,K+1) )
    UET = - 0.25 * ( U(I,J-1,K  ) - U(I,J+1,K  ) &
    &              + U(I,J-1,K+1) - U(I,J+1,K+1) )
    UZE = - U(I,J,K) + U(I,J,K+1)
    VXI = - 0.25 * ( V(I-1,J,K  ) - V(I+1,J,K  ) &
    &              + V(I-1,J,K+1) - V(I+1,J,K+1) )
    VET = - 0.25 * ( V(I,J-1,K  ) - V(I,J+1,K  ) &
    &              + V(I,J-1,K+1) - V(I,J+1,K+1) )
    VZE = - V(I,J,K) + V(I,J,K+1)
    WXI = - 0.25 * ( W(I-1,J,K  ) - W(I+1,J,K  ) &
    &              + W(I-1,J,K+1) - W(I+1,J,K+1) )
    WET = - 0.25 * ( W(I,J-1,K  ) - W(I,J+1,K  ) &
    &              + W(I,J-1,K+1) - W(I,J+1,K+1) )
    WZE = - W(I,J,K) + W(I,J,K+1)
    ! ������Ԉ�K���� -------------------------------------------------
    UXZE(I,J,K) = UXI * XIXM + UET * ETXM + UZE * ZEXM
    UYZE(I,J,K) = UXI * XIYM + UET * ETYM + UZE * ZEYM
    UZZE(I,J,K) = UXI * XIZM + UET * ETZM + UZE * ZEZM
    VXZE(I,J,K) = VXI * XIXM + VET * ETXM + VZE * ZEXM
    VYZE(I,J,K) = VXI * XIYM + VET * ETYM + VZE * ZEYM
    VZZE(I,J,K) = VXI * XIZM + VET * ETZM + VZE * ZEZM
    WXZE(I,J,K) = WXI * XIXM + WET * ETXM + WZE * ZEXM
    WYZE(I,J,K) = WXI * XIYM + WET * ETYM + WZE * ZEYM
    WZZE(I,J,K) = WXI * XIZM + WET * ETZM + WZE * ZEZM
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE PreVel2ndDiffZE
!***********************************************************************
!**** ��g�U���̌v�Z                                                ****
!***********************************************************************
SUBROUTINE NonDiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: UXI, VXI, WXI, UET, VET, WET, UZE, VZE, WZE
  REAL    :: UX, VX, WX, UY, VY, WY, UZ, VZ, WZ, DELV
  REAL    :: KRXI, KRET, KRZE, KRX, KRY, KRZ
  REAL    :: UXX, UXY, UXZ, UYX, UYY, UYZ, UZX, UZY, UZZ, &
  &          VXX, VXY, VXZ, VYX, VYY, VYZ, VZX, VZY, VZZ, &
  &          WXX, WXY, WXZ, WYX, WYY, WYZ, WZX, WZY, WZZ
  REAL    :: Rtt, f_mu, f_2
  REAL    :: nu, nu_t
  REAL    :: SS2, PP_k, D, E
  REAL    :: QH1, AEAK
  ! �����J�n ***********************************************************
  ! �Q�S���W���̌v�Z +++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, nu, Rtt, f_mu, nu_t &
!$OMP& )
  DO K = KS, KE
  DO J = JS, JE
  DO I = IS, IE
  IF(RHO(I,J,K) .GT. 0.0) THEN
    IF(EPST(I,J,K) .GT. ZERO) THEN
      nu          = AMU(I,J,K) / RHO(I,J,K)
      Rtt         = AK(I,J,K)**2 / (nu * EPST(I,J,K))
      f_mu        = EXP(-3.4 / (1.0 + Rtt / 50.0)**2)
      nu_t        = CMU * f_mu * AK(I,J,K)**2 / EPST(I,J,K)
      AMUT(I,J,K) = RHO(I,J,K) * nu_t
    ELSE
      AMUT(I,J,K) = 0.0
    ENDIF
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! ��g�U���̌v�Z +++++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& UXI, VXI, WXI, UET, VET, WET, UZE, VZE, WZE, &
!$OMP& UX, VX, WX, UY, VY, WY, UZ, VZ, WZ, DELV, &
!$OMP& KRXI, KRET, KRZE, KRX, KRY, KRZ, &
!$OMP& UXX, UXY, UXZ, UYX, UYY, UYZ, UZX, UZY, UZZ, &
!$OMP& VXX, VXY, VXZ, VYX, VYY, VYZ, VZX, VZY, VZZ, &
!$OMP& WXX, WXY, WXZ, WYX, WYY, WYZ, WZX, WZY, WZZ, &
!$OMP& Rtt, f_2, nu, nu_t, SS2, PP_k, D, E, QH1, AEAK &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( (RHO(I,J,K-1) .GT. 0.0) .AND. (RHO(I,J-1,K) .GT. 0.0) .AND. &
  &   (RHO(I-1,J,K) .GT. 0.0) .AND. (RHO(I,J,K)   .GT. 0.0) .AND. &
  &   (RHO(I+1,J,K) .GT. 0.0) .AND. (RHO(I,J+1,K) .GT. 0.0) .AND. &
  &   (RHO(I,J,K+1) .GT. 0.0) &
  & ) THEN
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = 0.5 * (U(I+1,J,K) - U(I-1,J,K))
    VXI = 0.5 * (V(I+1,J,K) - V(I-1,J,K))
    WXI = 0.5 * (W(I+1,J,K) - W(I-1,J,K))
    UET = 0.5 * (U(I,J+1,K) - U(I,J-1,K))
    VET = 0.5 * (V(I,J+1,K) - V(I,J-1,K))
    WET = 0.5 * (W(I,J+1,K) - W(I,J-1,K))
    UZE = 0.5 * (U(I,J,K+1) - U(I,J,K-1))
    VZE = 0.5 * (V(I,J,K+1) - V(I,J,K-1))
    WZE = 0.5 * (W(I,J,K+1) - W(I,J,K-1))
    ! ������ԕ�����K����
    UX = UXI * XIX(I,J,K) + UET * ETX(I,J,K) + UZE * ZEX(I,J,K)
    UY = UXI * XIY(I,J,K) + UET * ETY(I,J,K) + UZE * ZEY(I,J,K)
    UZ = UXI * XIZ(I,J,K) + UET * ETZ(I,J,K) + UZE * ZEZ(I,J,K)
    VX = VXI * XIX(I,J,K) + VET * ETX(I,J,K) + VZE * ZEX(I,J,K)
    VY = VXI * XIY(I,J,K) + VET * ETY(I,J,K) + VZE * ZEY(I,J,K)
    VZ = VXI * XIZ(I,J,K) + VET * ETZ(I,J,K) + VZE * ZEZ(I,J,K)
    WX = WXI * XIX(I,J,K) + WET * ETX(I,J,K) + WZE * ZEX(I,J,K)
    WY = WXI * XIY(I,J,K) + WET * ETY(I,J,K) + WZE * ZEY(I,J,K)
    WZ = WXI * XIZ(I,J,K) + WET * ETZ(I,J,K) + WZE * ZEZ(I,J,K)
    ! ����̑��x�X�P�[�� sqrt(k) �̈�K�����̌v�Z ----------------------
    ! �v�Z��ԕ�����K����
    KRXI = 0.5 * (SQRT(AK(I+1,J,K)) - SQRT(AK(I-1,J,K)))
    KRET = 0.5 * (SQRT(AK(I,J+1,K)) - SQRT(AK(I,J-1,K)))
    KRZE = 0.5 * (SQRT(AK(I,J,K+1)) - SQRT(AK(I,J,K-1)))
    ! ������ԕ�����K����
    KRX = KRXI * XIX(I,J,K) + KRET * ETX(I,J,K) + KRZE * ZEX(I,J,K)
    KRY = KRXI * XIY(I,J,K) + KRET * ETY(I,J,K) + KRZE * ZEY(I,J,K)
    KRZ = KRXI * XIZ(I,J,K) + KRET * ETZ(I,J,K) + KRZE * ZEZ(I,J,K)
    ! ���x�̓�K�����̌v�Z ---------------------------------------------
    UXX = - (UXXI(I-1,J,K) - UXXI(I,J,K)) * XIX(I,J,K) &
    &     - (UXET(I,J-1,K) - UXET(I,J,K)) * ETX(I,J,K) &
    &     - (UXZE(I,J,K-1) - UXZE(I,J,K)) * ZEX(I,J,K)
    UXY = - (UXXI(I-1,J,K) - UXXI(I,J,K)) * XIY(I,J,K) &
    &     - (UXET(I,J-1,K) - UXET(I,J,K)) * ETY(I,J,K) &
    &     - (UXZE(I,J,K-1) - UXZE(I,J,K)) * ZEY(I,J,K)
    UXZ = - (UXXI(I-1,J,K) - UXXI(I,J,K)) * XIZ(I,J,K) &
    &     - (UXET(I,J-1,K) - UXET(I,J,K)) * ETZ(I,J,K) &
    &     - (UXZE(I,J,K-1) - UXZE(I,J,K)) * ZEZ(I,J,K)
    UYX = - (UYXI(I-1,J,K) - UYXI(I,J,K)) * XIX(I,J,K) &
    &     - (UYET(I,J-1,K) - UYET(I,J,K)) * ETX(I,J,K) &
    &     - (UYZE(I,J,K-1) - UYZE(I,J,K)) * ZEX(I,J,K)
    UYY = - (UYXI(I-1,J,K) - UYXI(I,J,K)) * XIY(I,J,K) &
    &     - (UYET(I,J-1,K) - UYET(I,J,K)) * ETY(I,J,K) &
    &     - (UYZE(I,J,K-1) - UYZE(I,J,K)) * ZEY(I,J,K)
    UYZ = - (UYXI(I-1,J,K) - UYXI(I,J,K)) * XIZ(I,J,K) &
    &     - (UYET(I,J-1,K) - UYET(I,J,K)) * ETZ(I,J,K) &
    &     - (UYZE(I,J,K-1) - UYZE(I,J,K)) * ZEZ(I,J,K)
    UZX = - (UZXI(I-1,J,K) - UZXI(I,J,K)) * XIX(I,J,K) &
    &     - (UZET(I,J-1,K) - UZET(I,J,K)) * ETX(I,J,K) &
    &     - (UZZE(I,J,K-1) - UZZE(I,J,K)) * ZEX(I,J,K)
    UZY = - (UZXI(I-1,J,K) - UZXI(I,J,K)) * XIY(I,J,K) &
    &     - (UZET(I,J-1,K) - UZET(I,J,K)) * ETY(I,J,K) &
    &     - (UZZE(I,J,K-1) - UZZE(I,J,K)) * ZEY(I,J,K)
    UZZ = - (UZXI(I-1,J,K) - UZXI(I,J,K)) * XIZ(I,J,K) &
    &     - (UZET(I,J-1,K) - UZET(I,J,K)) * ETZ(I,J,K) &
    &     - (UZZE(I,J,K-1) - UZZE(I,J,K)) * ZEZ(I,J,K)
    VXX = - (VXXI(I-1,J,K) - VXXI(I,J,K)) * XIX(I,J,K) &
    &     - (VXET(I,J-1,K) - VXET(I,J,K)) * ETX(I,J,K) &
    &     - (VXZE(I,J,K-1) - VXZE(I,J,K)) * ZEX(I,J,K)
    VXY = - (VXXI(I-1,J,K) - VXXI(I,J,K)) * XIY(I,J,K) &
    &     - (VXET(I,J-1,K) - VXET(I,J,K)) * ETY(I,J,K) &
    &     - (VXZE(I,J,K-1) - VXZE(I,J,K)) * ZEY(I,J,K)
    VXZ = - (VXXI(I-1,J,K) - VXXI(I,J,K)) * XIZ(I,J,K) &
    &     - (VXET(I,J-1,K) - VXET(I,J,K)) * ETZ(I,J,K) &
    &     - (VXZE(I,J,K-1) - VXZE(I,J,K)) * ZEZ(I,J,K)
    VYX = - (VYXI(I-1,J,K) - VYXI(I,J,K)) * XIX(I,J,K) &
    &     - (VYET(I,J-1,K) - VYET(I,J,K)) * ETX(I,J,K) &
    &     - (VYZE(I,J,K-1) - VYZE(I,J,K)) * ZEX(I,J,K)
    VYY = - (VYXI(I-1,J,K) - VYXI(I,J,K)) * XIY(I,J,K) &
    &     - (VYET(I,J-1,K) - VYET(I,J,K)) * ETY(I,J,K) &
    &     - (VYZE(I,J,K-1) - VYZE(I,J,K)) * ZEY(I,J,K)
    VYZ = - (VYXI(I-1,J,K) - VYXI(I,J,K)) * XIZ(I,J,K) &
    &     - (VYET(I,J-1,K) - VYET(I,J,K)) * ETZ(I,J,K) &
    &     - (VYZE(I,J,K-1) - VYZE(I,J,K)) * ZEZ(I,J,K)
    VZX = - (VZXI(I-1,J,K) - VZXI(I,J,K)) * XIX(I,J,K) &
    &     - (VZET(I,J-1,K) - VZET(I,J,K)) * ETX(I,J,K) &
    &     - (VZZE(I,J,K-1) - VZZE(I,J,K)) * ZEX(I,J,K)
    VZY = - (VZXI(I-1,J,K) - VZXI(I,J,K)) * XIY(I,J,K) &
    &     - (VZET(I,J-1,K) - VZET(I,J,K)) * ETY(I,J,K) &
    &     - (VZZE(I,J,K-1) - VZZE(I,J,K)) * ZEY(I,J,K)
    VZZ = - (VZXI(I-1,J,K) - VZXI(I,J,K)) * XIZ(I,J,K) &
    &     - (VZET(I,J-1,K) - VZET(I,J,K)) * ETZ(I,J,K) &
    &     - (VZZE(I,J,K-1) - VZZE(I,J,K)) * ZEZ(I,J,K)
    WXX = - (WXXI(I-1,J,K) - WXXI(I,J,K)) * XIX(I,J,K) &
    &     - (WXET(I,J-1,K) - WXET(I,J,K)) * ETX(I,J,K) &
    &     - (WXZE(I,J,K-1) - WXZE(I,J,K)) * ZEX(I,J,K)
    WXY = - (WXXI(I-1,J,K) - WXXI(I,J,K)) * XIY(I,J,K) &
    &     - (WXET(I,J-1,K) - WXET(I,J,K)) * ETY(I,J,K) &
    &     - (WXZE(I,J,K-1) - WXZE(I,J,K)) * ZEY(I,J,K)
    WXZ = - (WXXI(I-1,J,K) - WXXI(I,J,K)) * XIZ(I,J,K) &
    &     - (WXET(I,J-1,K) - WXET(I,J,K)) * ETZ(I,J,K) &
    &     - (WXZE(I,J,K-1) - WXZE(I,J,K)) * ZEZ(I,J,K)
    WYX = - (WYXI(I-1,J,K) - WYXI(I,J,K)) * XIX(I,J,K) &
    &     - (WYET(I,J-1,K) - WYET(I,J,K)) * ETX(I,J,K) &
    &     - (WYZE(I,J,K-1) - WYZE(I,J,K)) * ZEX(I,J,K)
    WYY = - (WYXI(I-1,J,K) - WYXI(I,J,K)) * XIY(I,J,K) &
    &     - (WYET(I,J-1,K) - WYET(I,J,K)) * ETY(I,J,K) &
    &     - (WYZE(I,J,K-1) - WYZE(I,J,K)) * ZEY(I,J,K)
    WYZ = - (WYXI(I-1,J,K) - WYXI(I,J,K)) * XIZ(I,J,K) &
    &     - (WYET(I,J-1,K) - WYET(I,J,K)) * ETZ(I,J,K) &
    &     - (WYZE(I,J,K-1) - WYZE(I,J,K)) * ZEZ(I,J,K)
    WZX = - (WZXI(I-1,J,K) - WZXI(I,J,K)) * XIX(I,J,K) &
    &     - (WZET(I,J-1,K) - WZET(I,J,K)) * ETX(I,J,K) &
    &     - (WZZE(I,J,K-1) - WZZE(I,J,K)) * ZEX(I,J,K)
    WZY = - (WZXI(I-1,J,K) - WZXI(I,J,K)) * XIY(I,J,K) &
    &     - (WZET(I,J-1,K) - WZET(I,J,K)) * ETY(I,J,K) &
    &     - (WZZE(I,J,K-1) - WZZE(I,J,K)) * ZEY(I,J,K)
    WZZ = - (WZXI(I-1,J,K) - WZXI(I,J,K)) * XIZ(I,J,K) &
    &     - (WZET(I,J-1,K) - WZET(I,J,K)) * ETZ(I,J,K) &
    &     - (WZZE(I,J,K-1) - WZZE(I,J,K)) * ZEZ(I,J,K)
    ! ���f���֐��̌v�Z -------------------------------------------------
    nu   = AMU(I,J,K)  / RHO(I,J,K)
    nu_t = AMUT(I,J,K) / RHO(I,J,K)
    IF(EPST(I,J,K) .GT. ZERO) THEN
      Rtt = AK(I,J,K)**2 / (nu * EPST(I,J,K))
    ELSE
      Rtt = 0.0
    ENDIF
    f_2  = 1.0 - 0.3 * EXP(-Rtt**2)
    ! �␳�� D, E �̌v�Z -----------------------------------------------
    D = 2.0 * nu * (KRX**2 + KRY**2 + KRZ**2)
    E = 2.0 * nu * nu_t * ( &
    &     UXX**2 + VXX**2 + WXX**2 &
    &   + UYY**2 + VYY**2 + WYY**2 &
    &   + UZZ**2 + VZZ**2 + WZZ**2 &
    &   + UXY**2 + VXY**2 + WXY**2 &
    &   + UYZ**2 + VYZ**2 + WYZ**2 &
    &   + UZX**2 + VZX**2 + WZX**2 &
    &   + UXZ**2 + VXZ**2 + WXZ**2 &
    &   + UYX**2 + VYX**2 + WYX**2 &
    &   + UZY**2 + VZY**2 + WZY**2 &
    & )
    ! ���C�m���Y���͂̐���(���Ϙc�ݑ�����) -----------------------------
    DELV = UX + VY + WZ
    SS2  = 2.0 * (UX**2 + VY**2 + WZ**2) &
    &    + (UY + VX)**2 + (VZ + WY)**2 + (WX + UZ)**2 &
    &    - TwoThird * DELV**2
    PP_k = nu_t * SS2 - TwoThird * AK(I,J,K) * DELV
    ! �Ǐ����t����(�����ƎU��̃o�����X)�ɂ�郊�~�b�^�[
    IF(PELIM .GT. 0.0) THEN
      PP_k = MAX(0.0, MIN((EPST(I,J,K) + D) / PELIM, PP_k))
    ENDIF
    ! �����A�U��̘a ---------------------------------------------------
    QH1 = RHO(I,J,K) / AJA(I,J,K)
    AEAK = MIN( &
    &      MAX(SQRT(SS2), SQRT((EPST(I,J,K) + D) / nu)), &
    &      EPST(I,J,K) / MAX(ZERO, AK(I,J,K)) &
    &    )
    DQP(I,J,K,6) = QH1 * (PP_k - (EPST(I,J,K) + D))
    DQP(I,J,K,7) = QH1 * ( &
    &                AEAK * (CE1 * PP_k - CE2 * f_2 * EPST(I,J,K)) + E &
    &            )
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE NonDiffTerm
!***********************************************************************
!**** �g�U���̌v�Z                                                  ****
!***********************************************************************
SUBROUTINE DiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K, L
  ! �����J�n ***********************************************************
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  RH = 0.0
  SH = 0.0
  TH = 0.0
  ! �g�U���̗v�f���v�Z +++++++++++++++++++++++++++++++++++++++++++++++++
  CALL DIFFXI
  CALL DIFFET
  CALL DIFFZE
  ! �g�U���̍��� +++++++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE(I, J, K, L)
  DO L = LS, LE
  !$OMP DO
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( (RHO(I,J,K-1) .GT. 0.0) .AND. (RHO(I,J-1,K) .GT. 0.0) .AND. &
  &   (RHO(I-1,J,K) .GT. 0.0) .AND. (RHO(I,J,K)   .GT. 0.0) .AND. &
  &   (RHO(I+1,J,K) .GT. 0.0) .AND. (RHO(I,J+1,K) .GT. 0.0) .AND. &
  &   (RHO(I,J,K+1) .GT. 0.0) &
  & ) THEN
    DQD(I,J,K,L) = (-RH(I-1,J  ,K  ,L) + RH(I,J,K,L) ) &
    &            + (-SH(I  ,J-1,K  ,L) + SH(I,J,K,L) ) &
    &            + (-TH(I  ,J  ,K-1,L) + TH(I,J,K,L) )
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END DO
  ENDDO
  !$OMP END PARALLEL
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DiffTerm
!***********************************************************************
!**** �g�U���̌v�Z(xi���������p)                                    ****
!***********************************************************************
SUBROUTINE DIFFXI
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM
  REAL    :: RHOM, UM, VM, WM, TM, AKM, EPSTM, AMUM, AMUTM
  REAL    :: UXI, UET, UZE, UX, UY, UZ
  REAL    :: VXI, VET, VZE, VX, VY, VZ
  REAL    :: WXI, WET, WZE, WX, WY, WZ
  REAL    :: TXI, TET, TZE, TX, TY, TZ
  REAL    :: AKXI, AKET, AKZE, AKX, AKY, AKZ
  REAL    :: AEXI, AEET, AEZE, AEX, AEY, AEZ
  REAL    :: nu, nu_t
  REAL    :: c_u, c_t, c_k, c_e
  REAL    :: TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX, DELV
  REAL    :: R5, S5, T5
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM, &
!$OMP& RHOM, UM, VM, WM, TM, AKM, EPSTM, AMUM, AMUTM, &
!$OMP& UXI, UET, UZE, UX, UY, UZ, &
!$OMP& VXI, VET, VZE, VX, VY, VZ, &
!$OMP& WXI, WET, WZE, WX, WY, WZ, &
!$OMP& TXI, TET, TZE, TX, TY, TZ, &
!$OMP& AKXI, AKET, AKZE, AKX, AKY, AKZ, &
!$OMP& AEXI, AEET, AEZE, AEX, AEY, AEZ, &
!$OMP& nu, nu_t, c_u, c_t, c_k, c_e, &
!$OMP& TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX, DELV, R5, S5, T5, QH1 &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS    , IE - 1
  IF( (RHO(I,J,K-1) .GT. 0.0) .AND. (RHO(I,J-1,K) .GT. 0.0) .AND. &
  &   (RHO(I,J,K)   .GT. 0.0) .AND. (RHO(I+1,J,K) .GT. 0.0) .AND. &
  &   (RHO(I,J+1,K) .GT. 0.0) .AND. (RHO(I,J,K+1) .GT. 0.0) &
  & ) THEN
    ! XI�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J,K) + XIX(I+1,J,K))
    XIYM = 0.5 * (XIY(I,J,K) + XIY(I+1,J,K))
    XIZM = 0.5 * (XIZ(I,J,K) + XIZ(I+1,J,K))
    ETXM = 0.5 * (ETX(I,J,K) + ETX(I+1,J,K))
    ETYM = 0.5 * (ETY(I,J,K) + ETY(I+1,J,K))
    ETZM = 0.5 * (ETZ(I,J,K) + ETZ(I+1,J,K))
    ZEXM = 0.5 * (ZEX(I,J,K) + ZEX(I+1,J,K))
    ZEYM = 0.5 * (ZEY(I,J,K) + ZEY(I+1,J,K))
    ZEZM = 0.5 * (ZEZ(I,J,K) + ZEZ(I+1,J,K))
    AJAM = 0.5 * (AJA(I,J,K) + AJA(I+1,J,K))
    ! ������
    RHOM  = 0.5 * ( RHO(I,J,K) +  RHO(I+1,J,K))
    UM    = 0.5 * (   U(I,J,K) +    U(I+1,J,K))
    VM    = 0.5 * (   V(I,J,K) +    V(I+1,J,K))
    WM    = 0.5 * (   W(I,J,K) +    W(I+1,J,K))
    TM    = 0.5 * (   T(I,J,K) +    T(I+1,J,K))
    AKM   = 0.5 * (  AK(I,J,K) +   AK(I+1,J,K))
    EPSTM = 0.5 * (EPST(I,J,K) + EPST(I+1,J,K))
    AMUM  = 0.5 * ( AMU(I,J,K) +  AMU(I+1,J,K))
    AMUTM = 0.5 * (AMUT(I,J,K) + AMUT(I+1,J,K))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = - U(I,J,K) + U(I+1,J,K)
    VXI = - V(I,J,K) + V(I+1,J,K)
    WXI = - W(I,J,K) + W(I+1,J,K)
    UET = 0.25 * ( - U(I,J-1,K) - U(I+1,J-1,K) &
    &              + U(I,J+1,K) + U(I+1,J+1,K) )
    VET = 0.25 * ( - V(I,J-1,K) - V(I+1,J-1,K) &
    &              + V(I,J+1,K) + V(I+1,J+1,K) )
    WET = 0.25 * ( - W(I,J-1,K) - W(I+1,J-1,K) &
    &              + W(I,J+1,K) + W(I+1,J+1,K) )
    UZE = 0.25 * ( - U(I,J,K-1) - U(I+1,J,K-1) &
    &              + U(I,J,K+1) + U(I+1,J,K+1) )
    VZE = 0.25 * ( - V(I,J,K-1) - V(I+1,J,K-1) &
    &              + V(I,J,K+1) + V(I+1,J,K+1) )
    WZE = 0.25 * ( - W(I,J,K-1) - W(I+1,J,K-1) &
    &              + W(I,J,K+1) + W(I+1,J,K+1) )
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM + UZE * ZEXM
    UY = UXI * XIYM + UET * ETYM + UZE * ZEYM
    UZ = UXI * XIZM + UET * ETZM + UZE * ZEZM
    VX = VXI * XIXM + VET * ETXM + VZE * ZEXM
    VY = VXI * XIYM + VET * ETYM + VZE * ZEYM
    VZ = VXI * XIZM + VET * ETZM + VZE * ZEZM
    WX = WXI * XIXM + WET * ETXM + WZE * ZEXM
    WY = WXI * XIYM + WET * ETYM + WZE * ZEYM
    WZ = WXI * XIZM + WET * ETZM + WZE * ZEZM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = - T(I,J,K) + T(I+1,J,K)
    TET = 0.25 * ( - T(I,J-1,K) - T(I+1,J-1,K) &
    &              + T(I,J+1,K) + T(I+1,J+1,K) )
    TZE = 0.25 * ( - T(I,J,K-1) - T(I+1,J,K-1) &
    &              + T(I,J,K+1) + T(I+1,J,K+1) )
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM + TZE * ZEXM
    TY = TXI * XIYM + TET * ETYM + TZE * ZEYM
    TZ = TXI * XIZM + TET * ETZM + TZE * ZEZM
    ! k �̈�K�����̌v�Z -----------------------------------------------
    ! �v�Z��ԕ�����K����
    AKXI = - AK(I,J,K) + AK(I+1,J,K)
    AKET = 0.25 * ( - AK(I,J-1,K) - AK(I+1,J-1,K) &
    &               + AK(I,J+1,K) + AK(I+1,J+1,K) )
    AKZE = 0.25 * ( - AK(I,J,K-1) - AK(I+1,J,K-1) &
    &               + AK(I,J,K+1) + AK(I+1,J,K+1) )
    ! ������ԕ�����K����
    AKX = AKXI * XIXM + AKET * ETXM + AKZE * ZEXM
    AKY = AKXI * XIYM + AKET * ETYM + AKZE * ZEYM
    AKZ = AKXI * XIZM + AKET * ETZM + AKZE * ZEZM
    ! epsilon tilde �̈�K�����̌v�Z -----------------------------------
    ! �v�Z��ԕ�����K����
    AEXI = - EPST(I,J,K) + EPST(I+1,J,K)
    AEET = 0.25 * ( - EPST(I,J-1,K) - EPST(I+1,J-1,K) &
    &               + EPST(I,J+1,K) + EPST(I+1,J+1,K) )
    AEZE = 0.25 * ( - EPST(I,J,K-1) - EPST(I+1,J,K-1) &
    &               + EPST(I,J,K+1) + EPST(I+1,J,K+1) )
    ! ������ԕ�����K����
    AEX = AEXI * XIXM + AEET * ETXM + AEZE * ZEXM
    AEY = AEXI * XIYM + AEET * ETYM + AEZE * ZEYM
    AEZ = AEXI * XIZM + AEET * ETZM + AEZE * ZEZM
    ! �W���v�Z ---------------------------------------------------------
    nu   = AMUM  / RHOM
    nu_t = AMUTM / RHOM
    c_u  = nu + nu_t
    c_t  = (nu / PR + nu_t / PRT) / (GAMMA - 1.0) * GAMMA * RG
    c_k  = nu + nu_t / SIGK
    c_e  = nu + nu_t / SIGE
    ! �S�����͂ƃ��C�m���Y���̘͂a -------------------------------------
    DELV  = UX + VY + WZ
    TAUXX = c_u * (2.0 * UX - TwoThird * DELV) - TwoThird * AKM
    TAUYY = c_u * (2.0 * VY - TwoThird * DELV) - TwoThird * AKM
    TAUZZ = c_u * (2.0 * WZ - TwoThird * DELV) - TwoThird * AKM
    TAUXY = c_u * (UY + VX)
    TAUYZ = c_u * (VZ + WY)
    TAUZX = c_u * (WX + UZ)
    ! �G�l���M�[�̊g�U -------------------------------------------------
    R5 = TAUXX * UM + TAUXY * VM + TAUZX * WM + c_t * TX
    S5 = TAUXY * UM + TAUYY * VM + TAUYZ * WM + c_t * TY
    T5 = TAUZX * UM + TAUYZ * VM + TAUZZ * WM + c_t * TZ
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    RH(I,J,K,1) = 0.0
    RH(I,J,K,2) = QH1 * (TAUXX * XIXM + TAUXY * XIYM + TAUZX * XIZM)
    RH(I,J,K,3) = QH1 * (TAUXY * XIXM + TAUYY * XIYM + TAUYZ * XIZM)
    RH(I,J,K,4) = QH1 * (TAUZX * XIXM + TAUYZ * XIYM + TAUZZ * XIZM)
    RH(I,J,K,5) = QH1 * (R5 * XIXM + S5 * XIYM + T5 * XIZM)
    RH(I,J,K,6) = QH1 * c_k * (AKX * XIXM + AKY * XIYM + AKZ * XIZM)
    RH(I,J,K,7) = QH1 * c_e * (AEX * XIXM + AEY * XIYM + AEZ * XIZM)
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFXI
!***********************************************************************
!**** �g�U���̌v�Z(eta���������p)                                   ****
!***********************************************************************
SUBROUTINE DIFFET
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM
  REAL    :: RHOM, UM, VM, WM, TM, AKM, EPSTM, AMUM, AMUTM
  REAL    :: UXI, UET, UZE, UX, UY, UZ
  REAL    :: VXI, VET, VZE, VX, VY, VZ
  REAL    :: WXI, WET, WZE, WX, WY, WZ
  REAL    :: TXI, TET, TZE, TX, TY, TZ
  REAL    :: AKXI, AKET, AKZE, AKX, AKY, AKZ
  REAL    :: AEXI, AEET, AEZE, AEX, AEY, AEZ
  REAL    :: nu, nu_t
  REAL    :: c_u, c_t, c_k, c_e
  REAL    :: TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX, DELV
  REAL    :: R5, S5, T5
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM, &
!$OMP& RHOM, UM, VM, WM, TM, AKM, EPSTM, AMUM, AMUTM, &
!$OMP& UXI, UET, UZE, UX, UY, UZ, &
!$OMP& VXI, VET, VZE, VX, VY, VZ, &
!$OMP& WXI, WET, WZE, WX, WY, WZ, &
!$OMP& TXI, TET, TZE, TX, TY, TZ, &
!$OMP& AKXI, AKET, AKZE, AKX, AKY, AKZ, &
!$OMP& AEXI, AEET, AEZE, AEX, AEY, AEZ, &
!$OMP& nu, nu_t, c_u, c_t, c_k, c_e, &
!$OMP& TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX, DELV, R5, S5, T5, QH1 &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS    , JE - 1
  DO I = IS + 1, IE - 1
  IF( (RHO(I,J,K-1) .GT. 0.0) .AND. (RHO(I-1,J,K) .GT. 0.0) .AND. &
  &   (RHO(I,J,K)   .GT. 0.0) .AND. (RHO(I+1,J,K) .GT. 0.0) .AND. &
  &   (RHO(I,J+1,K) .GT. 0.0) .AND. (RHO(I,J,K+1) .GT. 0.0) &
  & ) THEN
    ! ET�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J,K) + XIX(I,J+1,K))
    XIYM = 0.5 * (XIY(I,J,K) + XIY(I,J+1,K))
    XIZM = 0.5 * (XIZ(I,J,K) + XIZ(I,J+1,K))
    ETXM = 0.5 * (ETX(I,J,K) + ETX(I,J+1,K))
    ETYM = 0.5 * (ETY(I,J,K) + ETY(I,J+1,K))
    ETZM = 0.5 * (ETZ(I,J,K) + ETZ(I,J+1,K))
    ZEXM = 0.5 * (ZEX(I,J,K) + ZEX(I,J+1,K))
    ZEYM = 0.5 * (ZEY(I,J,K) + ZEY(I,J+1,K))
    ZEZM = 0.5 * (ZEZ(I,J,K) + ZEZ(I,J+1,K))
    AJAM = 0.5 * (AJA(I,J,K) + AJA(I,J+1,K))
    ! ������
    RHOM  = 0.5 * ( RHO(I,J,K) +  RHO(I,J+1,K))
    UM    = 0.5 * (   U(I,J,K) +    U(I,J+1,K))
    VM    = 0.5 * (   V(I,J,K) +    V(I,J+1,K))
    WM    = 0.5 * (   W(I,J,K) +    W(I,J+1,K))
    TM    = 0.5 * (   T(I,J,K) +    T(I,J+1,K))
    AKM   = 0.5 * (  AK(I,J,K) +   AK(I,J+1,K))
    EPSTM = 0.5 * (EPST(I,J,K) + EPST(I,J+1,K))
    AMUM  = 0.5 * ( AMU(I,J,K) +  AMU(I,J+1,K))
    AMUTM = 0.5 * (AMUT(I,J,K) + AMUT(I,J+1,K))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = 0.25 * ( - U(I-1,J,K) - U(I-1,J+1,K) &
    &            + U(I+1,J,K) + U(I+1,J+1,K) )
    VXI = 0.25 * ( - V(I-1,J,K) - V(I-1,J+1,K) &
    &            + V(I+1,J,K) + V(I+1,J+1,K) )
    WXI = 0.25 * ( - W(I-1,J,K) - W(I-1,J+1,K) &
    &            + W(I+1,J,K) + W(I+1,J+1,K) )
    UET = - U(I,J,K) + U(I,J+1,K)
    VET = - V(I,J,K) + V(I,J+1,K)
    WET = - W(I,J,K) + W(I,J+1,K)
    UZE = 0.25 * ( - U(I,J,K-1) - U(I,J+1,K-1) &
    &              + U(I,J,K+1) + U(I,J+1,K+1) )
    VZE = 0.25 * ( - V(I,J,K-1) - V(I,J+1,K-1) &
    &              + V(I,J,K+1) + V(I,J+1,K+1) )
    WZE = 0.25 * ( - W(I,J,K-1) - W(I,J+1,K-1) &
    &              + W(I,J,K+1) + W(I,J+1,K+1) )
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM + UZE * ZEXM
    UY = UXI * XIYM + UET * ETYM + UZE * ZEYM
    UZ = UXI * XIZM + UET * ETZM + UZE * ZEZM
    VX = VXI * XIXM + VET * ETXM + VZE * ZEXM
    VY = VXI * XIYM + VET * ETYM + VZE * ZEYM
    VZ = VXI * XIZM + VET * ETZM + VZE * ZEZM
    WX = WXI * XIXM + WET * ETXM + WZE * ZEXM
    WY = WXI * XIYM + WET * ETYM + WZE * ZEYM
    WZ = WXI * XIZM + WET * ETZM + WZE * ZEZM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = 0.25 * ( - T(I-1,J,K) - T(I-1,J+1,K) &
    &              + T(I+1,J,K) + T(I+1,J+1,K) )
    TET = - T(I,J,K) + T(I,J+1,K)
    TZE = 0.25 * ( - T(I,J,K-1) - T(I,J+1,K-1) &
    &              + T(I,J,K+1) + T(I,J+1,K+1) )
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM + TZE * ZEXM
    TY = TXI * XIYM + TET * ETYM + TZE * ZEYM
    TZ = TXI * XIZM + TET * ETZM + TZE * ZEZM
    ! k �̈�K�����̌v�Z -----------------------------------------------
    ! �v�Z��ԕ�����K����
    AKXI = 0.25 * ( - AK(I-1,J,K) - AK(I-1,J+1,K) &
    &               + AK(I+1,J,K) + AK(I+1,J+1,K) )
    AKET = - AK(I,J,K) + AK(I,J+1,K)
    AKZE = 0.25 * ( - AK(I,J,K-1) - AK(I,J+1,K-1) &
    &               + AK(I,J,K+1) + AK(I,J+1,K+1) )
    ! ������ԕ�����K����
    AKX = AKXI * XIXM + AKET * ETXM + AKZE * ZEXM
    AKY = AKXI * XIYM + AKET * ETYM + AKZE * ZEYM
    AKZ = AKXI * XIZM + AKET * ETZM + AKZE * ZEZM
    ! epsilon tilde �̈�K�����̌v�Z -----------------------------------
    ! �v�Z��ԕ�����K����
    AEXI = 0.25 * ( - EPST(I-1,J,K) - EPST(I-1,J+1,K) &
    &               + EPST(I+1,J,K) + EPST(I+1,J+1,K) )
    AEET = - EPST(I,J,K) + EPST(I,J+1,K)
    AEZE = 0.25 * ( - EPST(I,J,K-1) - EPST(I,J+1,K-1) &
    &               + EPST(I,J,K+1) + EPST(I,J+1,K+1) )
    ! ������ԕ�����K����
    AEX = AEXI * XIXM + AEET * ETXM + AEZE * ZEXM
    AEY = AEXI * XIYM + AEET * ETYM + AEZE * ZEYM
    AEZ = AEXI * XIZM + AEET * ETZM + AEZE * ZEZM
    ! �W���v�Z ---------------------------------------------------------
    nu   = AMUM  / RHOM
    nu_t = AMUTM / RHOM
    c_u  = nu + nu_t
    c_t  = (nu / PR + nu_t / PRT) / (GAMMA - 1.0) * GAMMA * RG
    c_k  = nu + nu_t / SIGK
    c_e  = nu + nu_t / SIGE
    ! �S�����͂ƃ��C�m���Y���̘͂a -------------------------------------
    DELV  = UX + VY + WZ
    TAUXX = c_u * (2.0 * UX - TwoThird * DELV) - TwoThird * AKM
    TAUYY = c_u * (2.0 * VY - TwoThird * DELV) - TwoThird * AKM
    TAUZZ = c_u * (2.0 * WZ - TwoThird * DELV) - TwoThird * AKM
    TAUXY = c_u * (UY + VX)
    TAUYZ = c_u * (VZ + WY)
    TAUZX = c_u * (WX + UZ)
    ! �G�l���M�[�̊g�U -------------------------------------------------
    R5 = TAUXX * UM + TAUXY * VM + TAUZX * WM + c_t * TX
    S5 = TAUXY * UM + TAUYY * VM + TAUYZ * WM + c_t * TY
    T5 = TAUZX * UM + TAUYZ * VM + TAUZZ * WM + c_t * TZ
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    SH(I,J,K,1) = 0.0
    SH(I,J,K,2) = QH1 * (TAUXX * ETXM + TAUXY * ETYM + TAUZX * ETZM)
    SH(I,J,K,3) = QH1 * (TAUXY * ETXM + TAUYY * ETYM + TAUYZ * ETZM)
    SH(I,J,K,4) = QH1 * (TAUZX * ETXM + TAUYZ * ETYM + TAUZZ * ETZM)
    SH(I,J,K,5) = QH1 * (R5 * ETXM + S5 * ETYM + T5 * ETZM)
    SH(I,J,K,6) = QH1 * c_k * (AKX * ETXM + AKY * ETYM + AKZ * ETZM)
    SH(I,J,K,7) = QH1 * c_e * (AEX * ETXM + AEY * ETYM + AEZ * ETZM)
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFET
!***********************************************************************
!**** �g�U���̌v�Z(zeta���������p)                                  ****
!***********************************************************************
SUBROUTINE DIFFZE
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM
  REAL    :: RHOM, UM, VM, WM, TM, AKM, EPSTM, AMUM, AMUTM
  REAL    :: UXI, UET, UZE, UX, UY, UZ
  REAL    :: VXI, VET, VZE, VX, VY, VZ
  REAL    :: WXI, WET, WZE, WX, WY, WZ
  REAL    :: TXI, TET, TZE, TX, TY, TZ
  REAL    :: AKXI, AKET, AKZE, AKX, AKY, AKZ
  REAL    :: AEXI, AEET, AEZE, AEX, AEY, AEZ
  REAL    :: nu, nu_t
  REAL    :: c_u, c_t, c_k, c_e
  REAL    :: TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX, DELV
  REAL    :: R5, S5, T5
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM, &
!$OMP& RHOM, UM, VM, WM, TM, AKM, EPSTM, AMUM, AMUTM, &
!$OMP& UXI, UET, UZE, UX, UY, UZ, &
!$OMP& VXI, VET, VZE, VX, VY, VZ, &
!$OMP& WXI, WET, WZE, WX, WY, WZ, &
!$OMP& TXI, TET, TZE, TX, TY, TZ, &
!$OMP& AKXI, AKET, AKZE, AKX, AKY, AKZ, &
!$OMP& AEXI, AEET, AEZE, AEX, AEY, AEZ, &
!$OMP& nu, nu_t, c_u, c_t, c_k, c_e, &
!$OMP& TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX, DELV, R5, S5, T5, QH1 &
!$OMP& )
  DO K = KS    , KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( (RHO(I,J-1,K) .GT. 0.0) .AND. (RHO(I-1,J,K) .GT. 0.0) .AND. &
  &   (RHO(I,J,K)   .GT. 0.0) .AND. (RHO(I+1,J,K) .GT. 0.0) .AND. &
  &   (RHO(I,J+1,K) .GT. 0.0) .AND. (RHO(I,J,K+1) .GT. 0.0) &
  & ) THEN
    ! ZE�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J,K) + XIX(I,J,K+1))
    XIYM = 0.5 * (XIY(I,J,K) + XIY(I,J,K+1))
    XIZM = 0.5 * (XIZ(I,J,K) + XIZ(I,J,K+1))
    ETXM = 0.5 * (ETX(I,J,K) + ETX(I,J,K+1))
    ETYM = 0.5 * (ETY(I,J,K) + ETY(I,J,K+1))
    ETZM = 0.5 * (ETZ(I,J,K) + ETZ(I,J,K+1))
    ZEXM = 0.5 * (ZEX(I,J,K) + ZEX(I,J,K+1))
    ZEYM = 0.5 * (ZEY(I,J,K) + ZEY(I,J,K+1))
    ZEZM = 0.5 * (ZEZ(I,J,K) + ZEZ(I,J,K+1))
    AJAM = 0.5 * (AJA(I,J,K) + AJA(I,J,K+1))
    ! ������
    RHOM  = 0.5 * ( RHO(I,J,K) +  RHO(I,J,K+1))
    UM    = 0.5 * (   U(I,J,K) +    U(I,J,K+1))
    VM    = 0.5 * (   V(I,J,K) +    V(I,J,K+1))
    WM    = 0.5 * (   W(I,J,K) +    W(I,J,K+1))
    TM    = 0.5 * (   T(I,J,K) +    T(I,J,K+1))
    AKM   = 0.5 * (  AK(I,J,K) +   AK(I,J,K+1))
    EPSTM = 0.5 * (EPST(I,J,K) + EPST(I,J,K+1))
    AMUM  = 0.5 * ( AMU(I,J,K) +  AMU(I,J,K+1))
    AMUTM = 0.5 * (AMUT(I,J,K) + AMUT(I,J,K+1))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = 0.25 * ( - U(I-1,J,K) - U(I-1,J,K+1) &
    &              + U(I+1,J,K) + U(I+1,J,K+1) )
    VXI = 0.25 * ( - V(I-1,J,K) - V(I-1,J,K+1) &
    &              + V(I+1,J,K) + V(I+1,J,K+1) )
    WXI = 0.25 * ( - W(I-1,J,K) - W(I-1,J,K+1) &
    &              + W(I+1,J,K) + W(I+1,J,K+1) )
    UET = 0.25 * ( - U(I,J-1,K) - U(I,J-1,K+1) &
    &              + U(I,J+1,K) + U(I,J+1,K+1) )
    VET = 0.25 * ( - V(I,J-1,K) - V(I,J-1,K+1) &
    &              + V(I,J+1,K) + V(I,J+1,K+1) )
    WET = 0.25 * ( - W(I,J-1,K) - W(I,J-1,K+1) &
    &              + W(I,J+1,K) + W(I,J+1,K+1) )
    UZE = - U(I,J,K) + U(I,J,K+1)
    VZE = - V(I,J,K) + V(I,J,K+1)
    WZE = - W(I,J,K) + W(I,J,K+1)
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM + UZE * ZEXM
    UY = UXI * XIYM + UET * ETYM + UZE * ZEYM
    UZ = UXI * XIZM + UET * ETZM + UZE * ZEZM
    VX = VXI * XIXM + VET * ETXM + VZE * ZEXM
    VY = VXI * XIYM + VET * ETYM + VZE * ZEYM
    VZ = VXI * XIZM + VET * ETZM + VZE * ZEZM
    WX = WXI * XIXM + WET * ETXM + WZE * ZEXM
    WY = WXI * XIYM + WET * ETYM + WZE * ZEYM
    WZ = WXI * XIZM + WET * ETZM + WZE * ZEZM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = 0.25 * ( - T(I-1,J,K) - T(I-1,J,K+1) &
    &              + T(I+1,J,K) + T(I+1,J,K+1) )
    TET = 0.25 * ( - T(I,J-1,K) - T(I,J-1,K+1) &
    &              + T(I,J+1,K) + T(I,J+1,K+1) )
    TZE = - T(I,J,K) + T(I,J,K+1)
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM + TZE * ZEXM
    TY = TXI * XIYM + TET * ETYM + TZE * ZEYM
    TZ = TXI * XIZM + TET * ETZM + TZE * ZEZM
    ! k �̈�K�����̌v�Z -----------------------------------------------
    ! �v�Z��ԕ�����K����
    AKXI = 0.25 * ( - AK(I-1,J,K) - AK(I-1,J,K+1) &
    &               + AK(I+1,J,K) + AK(I+1,J,K+1) )
    AKET = 0.25 * ( - AK(I,J-1,K) - AK(I,J-1,K+1) &
    &               + AK(I,J+1,K) + AK(I,J+1,K+1) )
    AKZE = - AK(I,J,K) + AK(I,J,K+1)
    ! ������ԕ�����K����
    AKX = AKXI * XIXM + AKET * ETXM + AKZE * ZEXM
    AKY = AKXI * XIYM + AKET * ETYM + AKZE * ZEYM
    AKZ = AKXI * XIZM + AKET * ETZM + AKZE * ZEZM
    ! epsilon tilde �̈�K�����̌v�Z -----------------------------------
    ! �v�Z��ԕ�����K����
    AEXI = 0.25 * ( - EPST(I-1,J,K) - EPST(I-1,J,K+1) &
    &               + EPST(I+1,J,K) + EPST(I+1,J,K+1) )
    AEET = 0.25 * ( - EPST(I,J-1,K) - EPST(I,J-1,K+1) &
    &               + EPST(I,J+1,K) + EPST(I,J+1,K+1) )
    AEZE = - EPST(I,J,K) + EPST(I,J,K+1)
    ! ������ԕ�����K����
    AEX = AEXI * XIXM + AEET * ETXM + AEZE * ZEXM
    AEY = AEXI * XIYM + AEET * ETYM + AEZE * ZEYM
    AEZ = AEXI * XIZM + AEET * ETZM + AEZE * ZEZM
    ! �W���v�Z ---------------------------------------------------------
    nu   = AMUM  / RHOM
    nu_t = AMUTM / RHOM
    c_u  = nu + nu_t
    c_t  = (nu / PR + nu_t / PRT) / (GAMMA - 1.0) * GAMMA * RG
    c_k  = nu + nu_t / SIGK
    c_e  = nu + nu_t / SIGE
    ! �S�����͂ƃ��C�m���Y���̘͂a -------------------------------------
    DELV  = UX + VY + WZ
    TAUXX = c_u * (2.0 * UX - TwoThird * DELV) - TwoThird * AKM
    TAUYY = c_u * (2.0 * VY - TwoThird * DELV) - TwoThird * AKM
    TAUZZ = c_u * (2.0 * WZ - TwoThird * DELV) - TwoThird * AKM
    TAUXY = c_u * (UY + VX)
    TAUYZ = c_u * (VZ + WY)
    TAUZX = c_u * (WX + UZ)
    ! �G�l���M�[�̊g�U -------------------------------------------------
    R5 = TAUXX * UM + TAUXY * VM + TAUZX * WM + c_t * TX
    S5 = TAUXY * UM + TAUYY * VM + TAUYZ * WM + c_t * TY
    T5 = TAUZX * UM + TAUYZ * VM + TAUZZ * WM + c_t * TZ
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    TH(I,J,K,1) = 0.0
    TH(I,J,K,2) = QH1 * (TAUXX * ZEXM + TAUXY * ZEYM + TAUZX * ZEZM)
    TH(I,J,K,3) = QH1 * (TAUXY * ZEXM + TAUYY * ZEYM + TAUYZ * ZEZM)
    TH(I,J,K,4) = QH1 * (TAUZX * ZEXM + TAUYZ * ZEYM + TAUZZ * ZEZM)
    TH(I,J,K,5) = QH1 * (R5 * ZEXM + S5 * ZEYM + T5 * ZEZM)
    TH(I,J,K,6) = QH1 * c_k * (AKX * ZEXM + AKY * ZEYM + AKZ * ZEZM)
    TH(I,J,K,7) = QH1 * c_e * (AEX * ZEXM + AEY * ZEYM + AEZ * ZEZM)
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFZE
! ��`�I�� *************************************************************
END SUBROUTINE Turbulence3DEvmLS
!***********************************************************************
!**** �������f�� : RANS, EVM, Abe-Kondo-Nagano Model (1994)         ****
!**** �v�Z�Ώ� : �P��, �O����, ���k��                               ****
!**** �v�Z�X�L�[�� : �񎟐��x���S����(�X�^�K�[�h�i�q��̓_���g�p)   ****
!***********************************************************************
SUBROUTINE Turbulence3DEvmAKN( &
&            PELIM, RG, GAMMA, PR, PRT, &
&            IS, IE, I1, I3, JS, JE, KS, KE, LS, LE, &
&            X, Y, Z, &
&            XIX, XIY, XIZ, ETX, ETY, ETZ, ZEX, ZEY, ZEZ, AJA, &
&            RHO, U, V, W, T, AK, EPST, AMU, &
&            AMUT, DQD, DQP &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, PARAMETER :: CMU = 0.09
  REAL, PARAMETER :: CE1 = 1.5, CE2 = 1.9
  REAL, PARAMETER :: SIGK = 1.4, SIGE = 1.4
  REAL, PARAMETER :: ZERO = 1.0E-20
  REAL, PARAMETER :: TwoThird = 0.66666667
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: PELIM
  REAL,    INTENT(IN)  :: RG, GAMMA, PR, PRT
  INTEGER, INTENT(IN)  :: IS, IE, I1, I3, JS, JE, KS, KE
  INTEGER, INTENT(IN)  :: LS, LE
  REAL,    INTENT(IN)  :: X(IS:IE, JS:JE, KS:KE), &
  &                       Y(IS:IE, JS:JE, KS:KE), &
  &                       Z(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)  :: XIX(IS:IE, JS:JE, KS:KE), &
  &                       XIY(IS:IE, JS:JE, KS:KE), &
  &                       XIZ(IS:IE, JS:JE, KS:KE), &
  &                       ETX(IS:IE, JS:JE, KS:KE), &
  &                       ETY(IS:IE, JS:JE, KS:KE), &
  &                       ETZ(IS:IE, JS:JE, KS:KE), &
  &                       ZEX(IS:IE, JS:JE, KS:KE), &
  &                       ZEY(IS:IE, JS:JE, KS:KE), &
  &                       ZEZ(IS:IE, JS:JE, KS:KE), &
  &                       AJA(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)  :: RHO(IS:IE, JS:JE, KS:KE), &
  &                       U(IS:IE, JS:JE, KS:KE), &
  &                       V(IS:IE, JS:JE, KS:KE), &
  &                       W(IS:IE, JS:JE, KS:KE), &
  &                       T(IS:IE, JS:JE, KS:KE), &
  &                       AK(IS:IE, JS:JE, KS:KE), &
  &                       EPST(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)  :: AMU(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(OUT) :: AMUT(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(OUT) :: DQD(IS:IE, JS:JE, KS:KE, LS:LE)
  REAL,    INTENT(OUT) :: DQP(IS:IE, JS:JE, KS:KE, LS:LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, ALLOCATABLE :: RH(:, :, :, :), SH(:, :, :, :), TH(:, :, :, :)
  REAL, ALLOCATABLE :: UXXI(:, :, :), UYXI(:, :, :), UZXI(:, :, :), &
  &                    VXXI(:, :, :), VYXI(:, :, :), VZXI(:, :, :), &
  &                    WXXI(:, :, :), WYXI(:, :, :), WZXI(:, :, :)
  REAL, ALLOCATABLE :: UXET(:, :, :), UYET(:, :, :), UZET(:, :, :), &
  &                    VXET(:, :, :), VYET(:, :, :), VZET(:, :, :), &
  &                    WXET(:, :, :), WYET(:, :, :), WZET(:, :, :)
  REAL, ALLOCATABLE :: UXZE(:, :, :), UYZE(:, :, :), UZZE(:, :, :), &
  &                    VXZE(:, :, :), VYZE(:, :, :), VZZE(:, :, :), &
  &                    WXZE(:, :, :), WYZE(:, :, :), WZZE(:, :, :)
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 7) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �������m�� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ALLOCATE(RH(IS: IE, JS: JE, KS: KE, LS: LE))
  ALLOCATE(SH(IS: IE, JS: JE, KS: KE, LS: LE))
  ALLOCATE(TH(IS: IE, JS: JE, KS: KE, LS: LE))
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  AMUT = 0.0
  DQD  = 0.0
  DQP  = 0.0
  ! �����葱���̌Ăяo�� +++++++++++++++++++++++++++++++++++++++++++++++
  CALL NonDiffTerm
  CALL DiffTerm
  ! ��������� =========================================================
  DEALLOCATE(RH,SH,TH)
  ! �����I�� ***********************************************************
  RETURN
! �����葱�� ***********************************************************
CONTAINS
!***********************************************************************
!**** ��g�U���̌v�Z                                                ****
!***********************************************************************
SUBROUTINE NonDiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: UXI, VXI, WXI, UET, VET, WET, UZE, VZE, WZE
  REAL    :: UX, VX, WX, UY, VY, WY, UZ, VZ, WZ, DELV
  DOUBLE PRECISION :: ETA, YST
  REAL    :: f_mu, f_1
  REAL,DIMENSION(IS:IE,JS:JE,KS:KE) :: Rtt, f_2
  REAL    :: nu, nu_t
  REAL    :: SS2, PP_k, D, E
  REAL    :: QH1, AEAK
  ! �����J�n ***********************************************************
  ! �Q�S���W��,�␳���̌v�Z ++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, nu, f_mu, nu_t &
!$OMP& )
  DO K = KS, KE
  DO J = JS, JE
  DO I = IS, IE
  IF(RHO(I,J,K) .GT. 0.0) THEN
    IF(EPST(I,J,K) .GT. ZERO .AND. AK(I,J,K) .GT. ZERO) THEN
      ETA = (DBLE(AMU(I,J,K) / RHO(I,J,K))**3.0 / &
      &     DBLE(EPST(I,J,K)))**0.25
      IF(I .GE. I1 .AND. I .LT. I3) THEN
        YST = DSQRT(DBLE(X(I,J,K) - X(I,JS,K))**2.0 + &
        &           DBLE(Y(I,J,K) - Y(I,JS,K))**2.0 + &
        &           DBLE(Z(I,J,K) - Z(I,JS,K))**2.0)
      ELSE
        YST = DSQRT(DBLE(X(I,J,K) - X(I1,JS,K))**2.0 + &
        &           DBLE(Y(I,J,K) - Y(I1,JS,K))**2.0 + &
        &           DBLE(Z(I,J,K) - Z(I1,JS,K))**2.0)
      END IF
      YST = YST / ETA
      nu          = AMU(I,J,K) / RHO(I,J,K)
      Rtt(I,J,K)  = REAL(DBLE(AK(I,J,K))**2.0 / DBLE(nu * EPST(I,J,K)))
      f_mu        = REAL(1.0D0 - DEXP(-YST / 14.0D0))**2.0 * &
      &             (1.0 + 5.0 / Rtt(I,J,K)**0.75 * EXP(-(Rtt(I,J,K) / 200.0)**2.0))
      f_2(I,J,K)  = REAL(1.0D0 - DEXP(-YST / 3.1D0))**2.0 * &
      &             (1.0 - 0.3 * EXP(-(Rtt(I,J,K) / 6.5)**2.0))
      nu_t        = CMU * f_mu * AK(I,J,K)**2 / EPST(I,J,K)
      AMUT(I,J,K) = RHO(I,J,K) * nu_t
    ELSE
      Rtt(I,J,K)  = 0.0
      f_2(I,J,K)  = 1.0
      AMUT(I,J,K) = 0.0
    ENDIF
    IF(Rtt(I,J,K) .LE. ZERO) then
      Rtt(I,J,K)  = 0.0
      f_2(I,J,K)  = 1.0
      AMUT(I,J,K) = 0.0
    ENDIF
!if(k .eq. ks .and. j .eq. js) write(*,*) i,j,'fmu,f2',f_mu,f_2(I,J,K),Rtt(I,J,K),nu,AMU(I,J,K),RHO(I,J,K)
!if(k .eq. ks .and. j .eq. js+1) write(*,*) i,j,'fmu,f2',f_mu,f_2(I,J,K),Rtt(I,J,K),nu,AMU(I,J,K),RHO(I,J,K)
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! ��g�U���̌v�Z +++++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& UXI, VXI, WXI, UET, VET, WET, UZE, VZE, WZE, &
!$OMP& UX, VX, WX, UY, VY, WY, UZ, VZ, WZ, DELV, &
!$OMP& SS2, PP_k, D, E, f_1, QH1, AEAK &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( (RHO(I,J,K-1) .GT. 0.0) .AND. (RHO(I,J-1,K) .GT. 0.0) .AND. &
  &   (RHO(I-1,J,K) .GT. 0.0) .AND. (RHO(I,J,K)   .GT. 0.0) .AND. &
  &   (RHO(I+1,J,K) .GT. 0.0) .AND. (RHO(I,J+1,K) .GT. 0.0) .AND. &
  &   (RHO(I,J,K+1) .GT. 0.0) &
  & ) THEN
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = 0.5 * (U(I+1,J,K) - U(I-1,J,K))
    VXI = 0.5 * (V(I+1,J,K) - V(I-1,J,K))
    WXI = 0.5 * (W(I+1,J,K) - W(I-1,J,K))
    UET = 0.5 * (U(I,J+1,K) - U(I,J-1,K))
    VET = 0.5 * (V(I,J+1,K) - V(I,J-1,K))
    WET = 0.5 * (W(I,J+1,K) - W(I,J-1,K))
    UZE = 0.5 * (U(I,J,K+1) - U(I,J,K-1))
    VZE = 0.5 * (V(I,J,K+1) - V(I,J,K-1))
    WZE = 0.5 * (W(I,J,K+1) - W(I,J,K-1))
    ! ������ԕ�����K����
    UX = UXI * XIX(I,J,K) + UET * ETX(I,J,K) + UZE * ZEX(I,J,K)
    UY = UXI * XIY(I,J,K) + UET * ETY(I,J,K) + UZE * ZEY(I,J,K)
    UZ = UXI * XIZ(I,J,K) + UET * ETZ(I,J,K) + UZE * ZEZ(I,J,K)
    VX = VXI * XIX(I,J,K) + VET * ETX(I,J,K) + VZE * ZEX(I,J,K)
    VY = VXI * XIY(I,J,K) + VET * ETY(I,J,K) + VZE * ZEY(I,J,K)
    VZ = VXI * XIZ(I,J,K) + VET * ETZ(I,J,K) + VZE * ZEZ(I,J,K)
    WX = WXI * XIX(I,J,K) + WET * ETX(I,J,K) + WZE * ZEX(I,J,K)
    WY = WXI * XIY(I,J,K) + WET * ETY(I,J,K) + WZE * ZEY(I,J,K)
    WZ = WXI * XIZ(I,J,K) + WET * ETZ(I,J,K) + WZE * ZEZ(I,J,K)
    ! �␳�� D, E �̌v�Z -----------------------------------------------
    D = 0.0
    E = 0.0
    ! �␳�� f_1�̌v�Z -------------------------------------------------
    f_1 = 1.0
    ! ���C�m���Y���͂̐���(���Ϙc�ݑ�����) -----------------------------
    DELV = UX + VY + WZ
    SS2  = 2.0 * (UX**2 + VY**2 + WZ**2) &
    &    + (UY + VX)**2 + (VZ + WY)**2 + (WX + UZ)**2 &
    &    - TwoThird * DELV**2
    PP_k = AMUT(I,J,K) / RHO(I,J,K) * SS2 - TwoThird * AK(I,J,K) * DELV
    ! �Ǐ����t����(�����ƎU��̃o�����X)�ɂ�郊�~�b�^�[
    IF(PELIM .GT. 0.0) THEN
      PP_k = MAX(0.0, MIN((EPST(I,J,K) + D) / PELIM, PP_k))
    ENDIF
    ! �����A�U��̘a ---------------------------------------------------
    QH1 = RHO(I,J,K) / AJA(I,J,K)
if(QH1 .ne. QH1) then
 write(*,*) 'QH1 is diverged'
 write(*,*) i,j,k,RHO(I,J,K),AJA(I,J,K)
 stop
end if
    AEAK = MIN( &
    &      MAX(SQRT(SS2), SQRT((EPST(I,J,K) + D) / (AMU(I,J,K) / RHO(I,J,K)))), &
    &      EPST(I,J,K) / MAX(ZERO, AK(I,J,K)) &
    &    )
    DQP(I,J,K,6) = QH1 * (PP_k - (EPST(I,J,K) + D))
    DQP(I,J,K,7) = QH1 * ( &
    &                AEAK * (CE1 * f_1 * PP_k - CE2 * f_2(I,J,K) * EPST(I,J,K)) + E &
    &            )
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE NonDiffTerm
!***********************************************************************
!**** �g�U���̌v�Z                                                  ****
!***********************************************************************
SUBROUTINE DiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K, L
  ! �����J�n ***********************************************************
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  RH = 0.0
  SH = 0.0
  TH = 0.0
  ! �g�U���̗v�f���v�Z +++++++++++++++++++++++++++++++++++++++++++++++++
  CALL DIFFXI
  CALL DIFFET
  CALL DIFFZE
  ! �g�U���̍��� +++++++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE(I, J, K, L)
  DO L = LS, LE
  !$OMP DO
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( (RHO(I,J,K-1) .GT. 0.0) .AND. (RHO(I,J-1,K) .GT. 0.0) .AND. &
  &   (RHO(I-1,J,K) .GT. 0.0) .AND. (RHO(I,J,K)   .GT. 0.0) .AND. &
  &   (RHO(I+1,J,K) .GT. 0.0) .AND. (RHO(I,J+1,K) .GT. 0.0) .AND. &
  &   (RHO(I,J,K+1) .GT. 0.0) &
  & ) THEN
    DQD(I,J,K,L) = (-RH(I-1,J  ,K  ,L) + RH(I,J,K,L) ) &
    &            + (-SH(I  ,J-1,K  ,L) + SH(I,J,K,L) ) &
    &            + (-TH(I  ,J  ,K-1,L) + TH(I,J,K,L) )
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END DO
  ENDDO
  !$OMP END PARALLEL
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DiffTerm
!***********************************************************************
!**** �g�U���̌v�Z(xi���������p)                                    ****
!***********************************************************************
SUBROUTINE DIFFXI
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM
  REAL    :: RHOM, UM, VM, WM, TM, AKM, EPSTM, AMUM, AMUTM
  REAL    :: UXI, UET, UZE, UX, UY, UZ
  REAL    :: VXI, VET, VZE, VX, VY, VZ
  REAL    :: WXI, WET, WZE, WX, WY, WZ
  REAL    :: TXI, TET, TZE, TX, TY, TZ
  REAL    :: AKXI, AKET, AKZE, AKX, AKY, AKZ
  REAL    :: AEXI, AEET, AEZE, AEX, AEY, AEZ
  REAL    :: nu, nu_t
  REAL    :: c_u, c_t, c_k, c_e
  REAL    :: TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX, DELV
  REAL    :: R5, S5, T5
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM, &
!$OMP& RHOM, UM, VM, WM, TM, AKM, EPSTM, AMUM, AMUTM, &
!$OMP& UXI, UET, UZE, UX, UY, UZ, &
!$OMP& VXI, VET, VZE, VX, VY, VZ, &
!$OMP& WXI, WET, WZE, WX, WY, WZ, &
!$OMP& TXI, TET, TZE, TX, TY, TZ, &
!$OMP& AKXI, AKET, AKZE, AKX, AKY, AKZ, &
!$OMP& AEXI, AEET, AEZE, AEX, AEY, AEZ, &
!$OMP& nu, nu_t, c_u, c_t, c_k, c_e, &
!$OMP& TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX, DELV, R5, S5, T5, QH1 &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS    , IE - 1
  IF( (RHO(I,J,K-1) .GT. 0.0) .AND. (RHO(I,J-1,K) .GT. 0.0) .AND. &
  &   (RHO(I,J,K)   .GT. 0.0) .AND. (RHO(I+1,J,K) .GT. 0.0) .AND. &
  &   (RHO(I,J+1,K) .GT. 0.0) .AND. (RHO(I,J,K+1) .GT. 0.0) &
  & ) THEN
    ! XI�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J,K) + XIX(I+1,J,K))
    XIYM = 0.5 * (XIY(I,J,K) + XIY(I+1,J,K))
    XIZM = 0.5 * (XIZ(I,J,K) + XIZ(I+1,J,K))
    ETXM = 0.5 * (ETX(I,J,K) + ETX(I+1,J,K))
    ETYM = 0.5 * (ETY(I,J,K) + ETY(I+1,J,K))
    ETZM = 0.5 * (ETZ(I,J,K) + ETZ(I+1,J,K))
    ZEXM = 0.5 * (ZEX(I,J,K) + ZEX(I+1,J,K))
    ZEYM = 0.5 * (ZEY(I,J,K) + ZEY(I+1,J,K))
    ZEZM = 0.5 * (ZEZ(I,J,K) + ZEZ(I+1,J,K))
    AJAM = 0.5 * (AJA(I,J,K) + AJA(I+1,J,K))
    ! ������
    RHOM  = 0.5 * ( RHO(I,J,K) +  RHO(I+1,J,K))
    UM    = 0.5 * (   U(I,J,K) +    U(I+1,J,K))
    VM    = 0.5 * (   V(I,J,K) +    V(I+1,J,K))
    WM    = 0.5 * (   W(I,J,K) +    W(I+1,J,K))
    TM    = 0.5 * (   T(I,J,K) +    T(I+1,J,K))
    AKM   = 0.5 * (  AK(I,J,K) +   AK(I+1,J,K))
    EPSTM = 0.5 * (EPST(I,J,K) + EPST(I+1,J,K))
    AMUM  = 0.5 * ( AMU(I,J,K) +  AMU(I+1,J,K))
    AMUTM = 0.5 * (AMUT(I,J,K) + AMUT(I+1,J,K))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = - U(I,J,K) + U(I+1,J,K)
    VXI = - V(I,J,K) + V(I+1,J,K)
    WXI = - W(I,J,K) + W(I+1,J,K)
    UET = 0.25 * ( - U(I,J-1,K) - U(I+1,J-1,K) &
    &              + U(I,J+1,K) + U(I+1,J+1,K) )
    VET = 0.25 * ( - V(I,J-1,K) - V(I+1,J-1,K) &
    &              + V(I,J+1,K) + V(I+1,J+1,K) )
    WET = 0.25 * ( - W(I,J-1,K) - W(I+1,J-1,K) &
    &              + W(I,J+1,K) + W(I+1,J+1,K) )
    UZE = 0.25 * ( - U(I,J,K-1) - U(I+1,J,K-1) &
    &              + U(I,J,K+1) + U(I+1,J,K+1) )
    VZE = 0.25 * ( - V(I,J,K-1) - V(I+1,J,K-1) &
    &              + V(I,J,K+1) + V(I+1,J,K+1) )
    WZE = 0.25 * ( - W(I,J,K-1) - W(I+1,J,K-1) &
    &              + W(I,J,K+1) + W(I+1,J,K+1) )
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM + UZE * ZEXM
    UY = UXI * XIYM + UET * ETYM + UZE * ZEYM
    UZ = UXI * XIZM + UET * ETZM + UZE * ZEZM
    VX = VXI * XIXM + VET * ETXM + VZE * ZEXM
    VY = VXI * XIYM + VET * ETYM + VZE * ZEYM
    VZ = VXI * XIZM + VET * ETZM + VZE * ZEZM
    WX = WXI * XIXM + WET * ETXM + WZE * ZEXM
    WY = WXI * XIYM + WET * ETYM + WZE * ZEYM
    WZ = WXI * XIZM + WET * ETZM + WZE * ZEZM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = - T(I,J,K) + T(I+1,J,K)
    TET = 0.25 * ( - T(I,J-1,K) - T(I+1,J-1,K) &
    &              + T(I,J+1,K) + T(I+1,J+1,K) )
    TZE = 0.25 * ( - T(I,J,K-1) - T(I+1,J,K-1) &
    &              + T(I,J,K+1) + T(I+1,J,K+1) )
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM + TZE * ZEXM
    TY = TXI * XIYM + TET * ETYM + TZE * ZEYM
    TZ = TXI * XIZM + TET * ETZM + TZE * ZEZM
    ! k �̈�K�����̌v�Z -----------------------------------------------
    ! �v�Z��ԕ�����K����
    AKXI = - AK(I,J,K) + AK(I+1,J,K)
    AKET = 0.25 * ( - AK(I,J-1,K) - AK(I+1,J-1,K) &
    &               + AK(I,J+1,K) + AK(I+1,J+1,K) )
    AKZE = 0.25 * ( - AK(I,J,K-1) - AK(I+1,J,K-1) &
    &               + AK(I,J,K+1) + AK(I+1,J,K+1) )
    ! ������ԕ�����K����
    AKX = AKXI * XIXM + AKET * ETXM + AKZE * ZEXM
    AKY = AKXI * XIYM + AKET * ETYM + AKZE * ZEYM
    AKZ = AKXI * XIZM + AKET * ETZM + AKZE * ZEZM
    ! epsilon tilde �̈�K�����̌v�Z -----------------------------------
    ! �v�Z��ԕ�����K����
    AEXI = - EPST(I,J,K) + EPST(I+1,J,K)
    AEET = 0.25 * ( - EPST(I,J-1,K) - EPST(I+1,J-1,K) &
    &               + EPST(I,J+1,K) + EPST(I+1,J+1,K) )
    AEZE = 0.25 * ( - EPST(I,J,K-1) - EPST(I+1,J,K-1) &
    &               + EPST(I,J,K+1) + EPST(I+1,J,K+1) )
    ! ������ԕ�����K����
    AEX = AEXI * XIXM + AEET * ETXM + AEZE * ZEXM
    AEY = AEXI * XIYM + AEET * ETYM + AEZE * ZEYM
    AEZ = AEXI * XIZM + AEET * ETZM + AEZE * ZEZM
    ! �W���v�Z ---------------------------------------------------------
    nu   = AMUM  / RHOM
    nu_t = AMUTM / RHOM
    c_u  = nu + nu_t
    c_t  = (nu / PR + nu_t / PRT) / (GAMMA - 1.0) * GAMMA * RG
    c_k  = nu + nu_t / SIGK
    c_e  = nu + nu_t / SIGE
    ! �S�����͂ƃ��C�m���Y���̘͂a -------------------------------------
    DELV  = UX + VY + WZ
    TAUXX = c_u * (2.0 * UX - TwoThird * DELV) - TwoThird * AKM
    TAUYY = c_u * (2.0 * VY - TwoThird * DELV) - TwoThird * AKM
    TAUZZ = c_u * (2.0 * WZ - TwoThird * DELV) - TwoThird * AKM
    TAUXY = c_u * (UY + VX)
    TAUYZ = c_u * (VZ + WY)
    TAUZX = c_u * (WX + UZ)
    ! �G�l���M�[�̊g�U -------------------------------------------------
    R5 = TAUXX * UM + TAUXY * VM + TAUZX * WM + c_t * TX
    S5 = TAUXY * UM + TAUYY * VM + TAUYZ * WM + c_t * TY
    T5 = TAUZX * UM + TAUYZ * VM + TAUZZ * WM + c_t * TZ
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    RH(I,J,K,1) = 0.0
    RH(I,J,K,2) = QH1 * (TAUXX * XIXM + TAUXY * XIYM + TAUZX * XIZM)
    RH(I,J,K,3) = QH1 * (TAUXY * XIXM + TAUYY * XIYM + TAUYZ * XIZM)
    RH(I,J,K,4) = QH1 * (TAUZX * XIXM + TAUYZ * XIYM + TAUZZ * XIZM)
    RH(I,J,K,5) = QH1 * (R5 * XIXM + S5 * XIYM + T5 * XIZM)
    RH(I,J,K,6) = QH1 * c_k * (AKX * XIXM + AKY * XIYM + AKZ * XIZM)
    RH(I,J,K,7) = QH1 * c_e * (AEX * XIXM + AEY * XIYM + AEZ * XIZM)
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFXI
!***********************************************************************
!**** �g�U���̌v�Z(eta���������p)                                   ****
!***********************************************************************
SUBROUTINE DIFFET
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM
  REAL    :: RHOM, UM, VM, WM, TM, AKM, EPSTM, AMUM, AMUTM
  REAL    :: UXI, UET, UZE, UX, UY, UZ
  REAL    :: VXI, VET, VZE, VX, VY, VZ
  REAL    :: WXI, WET, WZE, WX, WY, WZ
  REAL    :: TXI, TET, TZE, TX, TY, TZ
  REAL    :: AKXI, AKET, AKZE, AKX, AKY, AKZ
  REAL    :: AEXI, AEET, AEZE, AEX, AEY, AEZ
  REAL    :: nu, nu_t
  REAL    :: c_u, c_t, c_k, c_e
  REAL    :: TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX, DELV
  REAL    :: R5, S5, T5
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM, &
!$OMP& RHOM, UM, VM, WM, TM, AKM, EPSTM, AMUM, AMUTM, &
!$OMP& UXI, UET, UZE, UX, UY, UZ, &
!$OMP& VXI, VET, VZE, VX, VY, VZ, &
!$OMP& WXI, WET, WZE, WX, WY, WZ, &
!$OMP& TXI, TET, TZE, TX, TY, TZ, &
!$OMP& AKXI, AKET, AKZE, AKX, AKY, AKZ, &
!$OMP& AEXI, AEET, AEZE, AEX, AEY, AEZ, &
!$OMP& nu, nu_t, c_u, c_t, c_k, c_e, &
!$OMP& TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX, DELV, R5, S5, T5, QH1 &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS    , JE - 1
  DO I = IS + 1, IE - 1
  IF( (RHO(I,J,K-1) .GT. 0.0) .AND. (RHO(I-1,J,K) .GT. 0.0) .AND. &
  &   (RHO(I,J,K)   .GT. 0.0) .AND. (RHO(I+1,J,K) .GT. 0.0) .AND. &
  &   (RHO(I,J+1,K) .GT. 0.0) .AND. (RHO(I,J,K+1) .GT. 0.0) &
  & ) THEN
    ! ET�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J,K) + XIX(I,J+1,K))
    XIYM = 0.5 * (XIY(I,J,K) + XIY(I,J+1,K))
    XIZM = 0.5 * (XIZ(I,J,K) + XIZ(I,J+1,K))
    ETXM = 0.5 * (ETX(I,J,K) + ETX(I,J+1,K))
    ETYM = 0.5 * (ETY(I,J,K) + ETY(I,J+1,K))
    ETZM = 0.5 * (ETZ(I,J,K) + ETZ(I,J+1,K))
    ZEXM = 0.5 * (ZEX(I,J,K) + ZEX(I,J+1,K))
    ZEYM = 0.5 * (ZEY(I,J,K) + ZEY(I,J+1,K))
    ZEZM = 0.5 * (ZEZ(I,J,K) + ZEZ(I,J+1,K))
    AJAM = 0.5 * (AJA(I,J,K) + AJA(I,J+1,K))
    ! ������
    RHOM  = 0.5 * ( RHO(I,J,K) +  RHO(I,J+1,K))
    UM    = 0.5 * (   U(I,J,K) +    U(I,J+1,K))
    VM    = 0.5 * (   V(I,J,K) +    V(I,J+1,K))
    WM    = 0.5 * (   W(I,J,K) +    W(I,J+1,K))
    TM    = 0.5 * (   T(I,J,K) +    T(I,J+1,K))
    AKM   = 0.5 * (  AK(I,J,K) +   AK(I,J+1,K))
    EPSTM = 0.5 * (EPST(I,J,K) + EPST(I,J+1,K))
    AMUM  = 0.5 * ( AMU(I,J,K) +  AMU(I,J+1,K))
    AMUTM = 0.5 * (AMUT(I,J,K) + AMUT(I,J+1,K))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = 0.25 * ( - U(I-1,J,K) - U(I-1,J+1,K) &
    &            + U(I+1,J,K) + U(I+1,J+1,K) )
    VXI = 0.25 * ( - V(I-1,J,K) - V(I-1,J+1,K) &
    &            + V(I+1,J,K) + V(I+1,J+1,K) )
    WXI = 0.25 * ( - W(I-1,J,K) - W(I-1,J+1,K) &
    &            + W(I+1,J,K) + W(I+1,J+1,K) )
    UET = - U(I,J,K) + U(I,J+1,K)
    VET = - V(I,J,K) + V(I,J+1,K)
    WET = - W(I,J,K) + W(I,J+1,K)
    UZE = 0.25 * ( - U(I,J,K-1) - U(I,J+1,K-1) &
    &              + U(I,J,K+1) + U(I,J+1,K+1) )
    VZE = 0.25 * ( - V(I,J,K-1) - V(I,J+1,K-1) &
    &              + V(I,J,K+1) + V(I,J+1,K+1) )
    WZE = 0.25 * ( - W(I,J,K-1) - W(I,J+1,K-1) &
    &              + W(I,J,K+1) + W(I,J+1,K+1) )
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM + UZE * ZEXM
    UY = UXI * XIYM + UET * ETYM + UZE * ZEYM
    UZ = UXI * XIZM + UET * ETZM + UZE * ZEZM
    VX = VXI * XIXM + VET * ETXM + VZE * ZEXM
    VY = VXI * XIYM + VET * ETYM + VZE * ZEYM
    VZ = VXI * XIZM + VET * ETZM + VZE * ZEZM
    WX = WXI * XIXM + WET * ETXM + WZE * ZEXM
    WY = WXI * XIYM + WET * ETYM + WZE * ZEYM
    WZ = WXI * XIZM + WET * ETZM + WZE * ZEZM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = 0.25 * ( - T(I-1,J,K) - T(I-1,J+1,K) &
    &              + T(I+1,J,K) + T(I+1,J+1,K) )
    TET = - T(I,J,K) + T(I,J+1,K)
    TZE = 0.25 * ( - T(I,J,K-1) - T(I,J+1,K-1) &
    &              + T(I,J,K+1) + T(I,J+1,K+1) )
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM + TZE * ZEXM
    TY = TXI * XIYM + TET * ETYM + TZE * ZEYM
    TZ = TXI * XIZM + TET * ETZM + TZE * ZEZM
    ! k �̈�K�����̌v�Z -----------------------------------------------
    ! �v�Z��ԕ�����K����
    AKXI = 0.25 * ( - AK(I-1,J,K) - AK(I-1,J+1,K) &
    &               + AK(I+1,J,K) + AK(I+1,J+1,K) )
    AKET = - AK(I,J,K) + AK(I,J+1,K)
    AKZE = 0.25 * ( - AK(I,J,K-1) - AK(I,J+1,K-1) &
    &               + AK(I,J,K+1) + AK(I,J+1,K+1) )
    ! ������ԕ�����K����
    AKX = AKXI * XIXM + AKET * ETXM + AKZE * ZEXM
    AKY = AKXI * XIYM + AKET * ETYM + AKZE * ZEYM
    AKZ = AKXI * XIZM + AKET * ETZM + AKZE * ZEZM
    ! epsilon tilde �̈�K�����̌v�Z -----------------------------------
    ! �v�Z��ԕ�����K����
    AEXI = 0.25 * ( - EPST(I-1,J,K) - EPST(I-1,J+1,K) &
    &               + EPST(I+1,J,K) + EPST(I+1,J+1,K) )
    AEET = - EPST(I,J,K) + EPST(I,J+1,K)
    AEZE = 0.25 * ( - EPST(I,J,K-1) - EPST(I,J+1,K-1) &
    &               + EPST(I,J,K+1) + EPST(I,J+1,K+1) )
    ! ������ԕ�����K����
    AEX = AEXI * XIXM + AEET * ETXM + AEZE * ZEXM
    AEY = AEXI * XIYM + AEET * ETYM + AEZE * ZEYM
    AEZ = AEXI * XIZM + AEET * ETZM + AEZE * ZEZM
    ! �W���v�Z ---------------------------------------------------------
    nu   = AMUM  / RHOM
    nu_t = AMUTM / RHOM
    c_u  = nu + nu_t
    c_t  = (nu / PR + nu_t / PRT) / (GAMMA - 1.0) * GAMMA * RG
    c_k  = nu + nu_t / SIGK
    c_e  = nu + nu_t / SIGE
    ! �S�����͂ƃ��C�m���Y���̘͂a -------------------------------------
    DELV  = UX + VY + WZ
    TAUXX = c_u * (2.0 * UX - TwoThird * DELV) - TwoThird * AKM
    TAUYY = c_u * (2.0 * VY - TwoThird * DELV) - TwoThird * AKM
    TAUZZ = c_u * (2.0 * WZ - TwoThird * DELV) - TwoThird * AKM
    TAUXY = c_u * (UY + VX)
    TAUYZ = c_u * (VZ + WY)
    TAUZX = c_u * (WX + UZ)
    ! �G�l���M�[�̊g�U -------------------------------------------------
    R5 = TAUXX * UM + TAUXY * VM + TAUZX * WM + c_t * TX
    S5 = TAUXY * UM + TAUYY * VM + TAUYZ * WM + c_t * TY
    T5 = TAUZX * UM + TAUYZ * VM + TAUZZ * WM + c_t * TZ
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    SH(I,J,K,1) = 0.0
    SH(I,J,K,2) = QH1 * (TAUXX * ETXM + TAUXY * ETYM + TAUZX * ETZM)
    SH(I,J,K,3) = QH1 * (TAUXY * ETXM + TAUYY * ETYM + TAUYZ * ETZM)
    SH(I,J,K,4) = QH1 * (TAUZX * ETXM + TAUYZ * ETYM + TAUZZ * ETZM)
    SH(I,J,K,5) = QH1 * (R5 * ETXM + S5 * ETYM + T5 * ETZM)
    SH(I,J,K,6) = QH1 * c_k * (AKX * ETXM + AKY * ETYM + AKZ * ETZM)
    SH(I,J,K,7) = QH1 * c_e * (AEX * ETXM + AEY * ETYM + AEZ * ETZM)
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFET
!***********************************************************************
!**** �g�U���̌v�Z(zeta���������p)                                  ****
!***********************************************************************
SUBROUTINE DIFFZE
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM
  REAL    :: RHOM, UM, VM, WM, TM, AKM, EPSTM, AMUM, AMUTM
  REAL    :: UXI, UET, UZE, UX, UY, UZ
  REAL    :: VXI, VET, VZE, VX, VY, VZ
  REAL    :: WXI, WET, WZE, WX, WY, WZ
  REAL    :: TXI, TET, TZE, TX, TY, TZ
  REAL    :: AKXI, AKET, AKZE, AKX, AKY, AKZ
  REAL    :: AEXI, AEET, AEZE, AEX, AEY, AEZ
  REAL    :: nu, nu_t
  REAL    :: c_u, c_t, c_k, c_e
  REAL    :: TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX, DELV
  REAL    :: R5, S5, T5
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM, &
!$OMP& RHOM, UM, VM, WM, TM, AKM, EPSTM, AMUM, AMUTM, &
!$OMP& UXI, UET, UZE, UX, UY, UZ, &
!$OMP& VXI, VET, VZE, VX, VY, VZ, &
!$OMP& WXI, WET, WZE, WX, WY, WZ, &
!$OMP& TXI, TET, TZE, TX, TY, TZ, &
!$OMP& AKXI, AKET, AKZE, AKX, AKY, AKZ, &
!$OMP& AEXI, AEET, AEZE, AEX, AEY, AEZ, &
!$OMP& nu, nu_t, c_u, c_t, c_k, c_e, &
!$OMP& TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX, DELV, R5, S5, T5, QH1 &
!$OMP& )
  DO K = KS    , KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( (RHO(I,J-1,K) .GT. 0.0) .AND. (RHO(I-1,J,K) .GT. 0.0) .AND. &
  &   (RHO(I,J,K)   .GT. 0.0) .AND. (RHO(I+1,J,K) .GT. 0.0) .AND. &
  &   (RHO(I,J+1,K) .GT. 0.0) .AND. (RHO(I,J,K+1) .GT. 0.0) &
  & ) THEN
    ! ZE�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J,K) + XIX(I,J,K+1))
    XIYM = 0.5 * (XIY(I,J,K) + XIY(I,J,K+1))
    XIZM = 0.5 * (XIZ(I,J,K) + XIZ(I,J,K+1))
    ETXM = 0.5 * (ETX(I,J,K) + ETX(I,J,K+1))
    ETYM = 0.5 * (ETY(I,J,K) + ETY(I,J,K+1))
    ETZM = 0.5 * (ETZ(I,J,K) + ETZ(I,J,K+1))
    ZEXM = 0.5 * (ZEX(I,J,K) + ZEX(I,J,K+1))
    ZEYM = 0.5 * (ZEY(I,J,K) + ZEY(I,J,K+1))
    ZEZM = 0.5 * (ZEZ(I,J,K) + ZEZ(I,J,K+1))
    AJAM = 0.5 * (AJA(I,J,K) + AJA(I,J,K+1))
    ! ������
    RHOM  = 0.5 * ( RHO(I,J,K) +  RHO(I,J,K+1))
    UM    = 0.5 * (   U(I,J,K) +    U(I,J,K+1))
    VM    = 0.5 * (   V(I,J,K) +    V(I,J,K+1))
    WM    = 0.5 * (   W(I,J,K) +    W(I,J,K+1))
    TM    = 0.5 * (   T(I,J,K) +    T(I,J,K+1))
    AKM   = 0.5 * (  AK(I,J,K) +   AK(I,J,K+1))
    EPSTM = 0.5 * (EPST(I,J,K) + EPST(I,J,K+1))
    AMUM  = 0.5 * ( AMU(I,J,K) +  AMU(I,J,K+1))
    AMUTM = 0.5 * (AMUT(I,J,K) + AMUT(I,J,K+1))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = 0.25 * ( - U(I-1,J,K) - U(I-1,J,K+1) &
    &              + U(I+1,J,K) + U(I+1,J,K+1) )
    VXI = 0.25 * ( - V(I-1,J,K) - V(I-1,J,K+1) &
    &              + V(I+1,J,K) + V(I+1,J,K+1) )
    WXI = 0.25 * ( - W(I-1,J,K) - W(I-1,J,K+1) &
    &              + W(I+1,J,K) + W(I+1,J,K+1) )
    UET = 0.25 * ( - U(I,J-1,K) - U(I,J-1,K+1) &
    &              + U(I,J+1,K) + U(I,J+1,K+1) )
    VET = 0.25 * ( - V(I,J-1,K) - V(I,J-1,K+1) &
    &              + V(I,J+1,K) + V(I,J+1,K+1) )
    WET = 0.25 * ( - W(I,J-1,K) - W(I,J-1,K+1) &
    &              + W(I,J+1,K) + W(I,J+1,K+1) )
    UZE = - U(I,J,K) + U(I,J,K+1)
    VZE = - V(I,J,K) + V(I,J,K+1)
    WZE = - W(I,J,K) + W(I,J,K+1)
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM + UZE * ZEXM
    UY = UXI * XIYM + UET * ETYM + UZE * ZEYM
    UZ = UXI * XIZM + UET * ETZM + UZE * ZEZM
    VX = VXI * XIXM + VET * ETXM + VZE * ZEXM
    VY = VXI * XIYM + VET * ETYM + VZE * ZEYM
    VZ = VXI * XIZM + VET * ETZM + VZE * ZEZM
    WX = WXI * XIXM + WET * ETXM + WZE * ZEXM
    WY = WXI * XIYM + WET * ETYM + WZE * ZEYM
    WZ = WXI * XIZM + WET * ETZM + WZE * ZEZM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = 0.25 * ( - T(I-1,J,K) - T(I-1,J,K+1) &
    &              + T(I+1,J,K) + T(I+1,J,K+1) )
    TET = 0.25 * ( - T(I,J-1,K) - T(I,J-1,K+1) &
    &              + T(I,J+1,K) + T(I,J+1,K+1) )
    TZE = - T(I,J,K) + T(I,J,K+1)
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM + TZE * ZEXM
    TY = TXI * XIYM + TET * ETYM + TZE * ZEYM
    TZ = TXI * XIZM + TET * ETZM + TZE * ZEZM
    ! k �̈�K�����̌v�Z -----------------------------------------------
    ! �v�Z��ԕ�����K����
    AKXI = 0.25 * ( - AK(I-1,J,K) - AK(I-1,J,K+1) &
    &               + AK(I+1,J,K) + AK(I+1,J,K+1) )
    AKET = 0.25 * ( - AK(I,J-1,K) - AK(I,J-1,K+1) &
    &               + AK(I,J+1,K) + AK(I,J+1,K+1) )
    AKZE = - AK(I,J,K) + AK(I,J,K+1)
    ! ������ԕ�����K����
    AKX = AKXI * XIXM + AKET * ETXM + AKZE * ZEXM
    AKY = AKXI * XIYM + AKET * ETYM + AKZE * ZEYM
    AKZ = AKXI * XIZM + AKET * ETZM + AKZE * ZEZM
    ! epsilon tilde �̈�K�����̌v�Z -----------------------------------
    ! �v�Z��ԕ�����K����
    AEXI = 0.25 * ( - EPST(I-1,J,K) - EPST(I-1,J,K+1) &
    &               + EPST(I+1,J,K) + EPST(I+1,J,K+1) )
    AEET = 0.25 * ( - EPST(I,J-1,K) - EPST(I,J-1,K+1) &
    &               + EPST(I,J+1,K) + EPST(I,J+1,K+1) )
    AEZE = - EPST(I,J,K) + EPST(I,J,K+1)
    ! ������ԕ�����K����
    AEX = AEXI * XIXM + AEET * ETXM + AEZE * ZEXM
    AEY = AEXI * XIYM + AEET * ETYM + AEZE * ZEYM
    AEZ = AEXI * XIZM + AEET * ETZM + AEZE * ZEZM
    ! �W���v�Z ---------------------------------------------------------
    nu   = AMUM  / RHOM
    nu_t = AMUTM / RHOM
    c_u  = nu + nu_t
    c_t  = (nu / PR + nu_t / PRT) / (GAMMA - 1.0) * GAMMA * RG
    c_k  = nu + nu_t / SIGK
    c_e  = nu + nu_t / SIGE
    ! �S�����͂ƃ��C�m���Y���̘͂a -------------------------------------
    DELV  = UX + VY + WZ
    TAUXX = c_u * (2.0 * UX - TwoThird * DELV) - TwoThird * AKM
    TAUYY = c_u * (2.0 * VY - TwoThird * DELV) - TwoThird * AKM
    TAUZZ = c_u * (2.0 * WZ - TwoThird * DELV) - TwoThird * AKM
    TAUXY = c_u * (UY + VX)
    TAUYZ = c_u * (VZ + WY)
    TAUZX = c_u * (WX + UZ)
    ! �G�l���M�[�̊g�U -------------------------------------------------
    R5 = TAUXX * UM + TAUXY * VM + TAUZX * WM + c_t * TX
    S5 = TAUXY * UM + TAUYY * VM + TAUYZ * WM + c_t * TY
    T5 = TAUZX * UM + TAUYZ * VM + TAUZZ * WM + c_t * TZ
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    TH(I,J,K,1) = 0.0
    TH(I,J,K,2) = QH1 * (TAUXX * ZEXM + TAUXY * ZEYM + TAUZX * ZEZM)
    TH(I,J,K,3) = QH1 * (TAUXY * ZEXM + TAUYY * ZEYM + TAUYZ * ZEZM)
    TH(I,J,K,4) = QH1 * (TAUZX * ZEXM + TAUYZ * ZEYM + TAUZZ * ZEZM)
    TH(I,J,K,5) = QH1 * (R5 * ZEXM + S5 * ZEYM + T5 * ZEZM)
    TH(I,J,K,6) = QH1 * c_k * (AKX * ZEXM + AKY * ZEYM + AKZ * ZEZM)
    TH(I,J,K,7) = QH1 * c_e * (AEX * ZEXM + AEY * ZEYM + AEZ * ZEZM)
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFZE
! ��`�I�� *************************************************************
END SUBROUTINE Turbulence3DEvmAKN
!***********************************************************************
!**** �������f�� : RANS, NL-EVM(ke), Craft-Launder-Suga Model(1996) ****
!**** �v�Z�Ώ� : �P��, �񎟌�, ���k��                               ****
!**** �v�Z�X�L�[�� : �񎟐��x���S����(�X�^�K�[�h�i�q��̓_���g�p)   ****
!***********************************************************************
SUBROUTINE Turbulence2DNlEvmkeCLS( &
&            PELIM, RG, GAMMA, PR, PRT, &
&            IS, IE, JS, JE, LS, LE, &
&            XIX, XIY, ETX, ETY, AJA, &
&            RHO, U, V, T, AK, EPST, AMU, &
&            AMUT, DQD, DQP &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, PARAMETER :: c1 = - 0.1, c2 = 0.1, c3 = 0.26
  REAL, PARAMETER :: c_e1 = 1.44
  REAL, PARAMETER :: SIGK = 1.0, SIGE = 1.3
  REAL, PARAMETER :: aiimin = - 0.66666667, aiimax = 1.3333333
  REAL, PARAMETER :: TwoThird = 0.66666667
  REAL, PARAMETER :: ZERO = 1.0E-20
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: PELIM
  REAL,    INTENT(IN)  :: RG, GAMMA, PR, PRT
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE
  INTEGER, INTENT(IN)  :: LS, LE
  REAL,    INTENT(IN)  :: XIX(IS:IE, JS:JE), XIY(IS:IE, JS:JE), &
  &                       ETX(IS:IE, JS:JE), ETY(IS:IE, JS:JE), &
  &                       AJA(IS:IE, JS:JE)
  REAL,    INTENT(IN)  :: RHO(IS:IE, JS:JE), &
  &                       U(IS:IE, JS:JE), V(IS:IE, JS:JE), &
  &                       T(IS:IE, JS:JE), &
  &                       AK(IS:IE, JS:JE), EPST(IS:IE, JS:JE)
  REAL,    INTENT(IN)  :: AMU(IS:IE, JS:JE)
  REAL,    INTENT(OUT) :: AMUT(IS:IE, JS:JE)
  REAL,    INTENT(OUT) :: DQD(IS:IE, JS:JE, LS:LE)
  REAL,    INTENT(OUT) :: DQP(IS:IE, JS:JE, LS:LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, ALLOCATABLE :: RH(:, :, :), SH(:, :, :)
  REAL, ALLOCATABLE :: UXXI(:, :), UYXI(:, :), VXXI(:, :), VYXI(:, :)
  REAL, ALLOCATABLE :: UXET(:, :), UYET(:, :), VXET(:, :), VYET(:, :)
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 6) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �������m�� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ALLOCATE(RH(IS: IE, JS: JE, LS: LE), SH(IS: IE, JS: JE, LS: LE))
  ALLOCATE(UXXI(IS: IE, JS: JE), UYXI(IS: IE, JS: JE))
  ALLOCATE(VXXI(IS: IE, JS: JE), VYXI(IS: IE, JS: JE))
  ALLOCATE(UXET(IS: IE, JS: JE), UYET(IS: IE, JS: JE))
  ALLOCATE(VXET(IS: IE, JS: JE), VYET(IS: IE, JS: JE))
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  AMUT = 0.0
  DQD  = 0.0
  DQP  = 0.0
  ! �����葱���̌Ăяo�� +++++++++++++++++++++++++++++++++++++++++++++++
  CALL PreVel2ndDiff
  CALL NonDiffTerm
  CALL DiffTerm
  ! �����I�� ***********************************************************
  RETURN
! �����葱�� ***********************************************************
CONTAINS
!***********************************************************************
!**** ��K�����v�Z�p�̑O����                                        ****
!***********************************************************************
SUBROUTINE PreVel2ndDiff
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����J�n ***********************************************************
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  UXXI = 0.0
  UYXI = 0.0
  VXXI = 0.0
  VYXI = 0.0
  UXET = 0.0
  UYET = 0.0
  VXET = 0.0
  VYET = 0.0
  ! ���x�̓�K�����̑O���� +++++++++++++++++++++++++++++++++++++++++++++
  CALL PreVel2ndDiffXI
  CALL PreVel2ndDiffET
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE PreVel2ndDiff
!***********************************************************************
!**** ��K�����v�Z�p�̑O����(XI����)                                ****
!***********************************************************************
SUBROUTINE PreVel2ndDiffXI
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: XIXM, XIYM, ETXM, ETYM
  REAL    :: UXI, VXI, UET, VET
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, XIXM, XIYM, ETXM, ETYM, UXI, VXI, UET, VET &
!$OMP& )
  DO J = JS + 1, JE - 1
  DO I = IS    , IE - 1
  IF(RHO(I,J) .GT. 0.0 .AND. RHO(I+1,J) .GT. 0.0) THEN
    ! XI�����̒��Ԓl ---------------------------------------------------
    XIXM = 0.5 * (XIX(I,J) + XIX(I+1,J))
    XIYM = 0.5 * (XIY(I,J) + XIY(I+1,J))
    ETXM = 0.5 * (ETX(I,J) + ETX(I+1,J))
    ETYM = 0.5 * (ETY(I,J) + ETY(I+1,J))
    ! �v�Z��Ԉ�K���� -------------------------------------------------
    UXI = - U(I,J) + U(I+1,J)
    UET = - 0.25 * (U(I,J-1) + U(I+1,J-1) - U(I,J+1) - U(I+1,J+1))
    VXI = - V(I,J) + V(I+1,J)
    VET = - 0.25 * (V(I,J-1) + V(I+1,J-1) - V(I,J+1) - V(I+1,J+1))
    ! ������Ԉ�K���� -------------------------------------------------
    UXXI(I,J) = UXI * XIXM + UET * ETXM
    UYXI(I,J) = UXI * XIYM + UET * ETYM
    VXXI(I,J) = VXI * XIXM + VET * ETXM
    VYXI(I,J) = VXI * XIYM + VET * ETYM
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE PreVel2ndDiffXI
!***********************************************************************
!**** ��K�����v�Z�p�̑O����(ET����)                                ****
!***********************************************************************
SUBROUTINE PreVel2ndDiffET
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: XIXM, XIYM, ETXM, ETYM
  REAL    :: UXI, VXI, UET, VET
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, XIXM, XIYM, ETXM, ETYM, UXI, VXI, UET, VET &
!$OMP& )
  DO J = JS    , JE - 1
  DO I = IS + 1, IE - 1
  IF(RHO(I,J) .GT. 0.0 .AND. RHO(I,J+1) .GT. 0.0) THEN
    ! ET�����̒��Ԓl ---------------------------------------------------
    XIXM = 0.5 * (XIX(I,J) + XIX(I,J+1))
    XIYM = 0.5 * (XIY(I,J) + XIY(I,J+1))
    ETXM = 0.5 * (ETX(I,J) + ETX(I,J+1))
    ETYM = 0.5 * (ETY(I,J) + ETY(I,J+1))
    ! �v�Z��Ԉ�K���� -------------------------------------------------
    UXI = - 0.25 * ( U(I-1,J) - U(I+1,J) + U(I-1,J+1) - U(I+1,J+1) )
    UET = - U(I,J) + U(I,J+1)
    VXI = - 0.25 * ( V(I-1,J) - V(I+1,J) + V(I-1,J+1) - V(I+1,J+1) )
    VET = - V(I,J) + V(I,J+1)
    ! ������Ԉ�K���� -------------------------------------------------
    UXET(I,J) = UXI * XIXM + UET * ETXM
    UYET(I,J) = UXI * XIYM + UET * ETYM
    VXET(I,J) = VXI * XIXM + VET * ETXM
    VYET(I,J) = VXI * XIYM + VET * ETYM
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE PreVel2ndDiffET
!***********************************************************************
!**** ��g�U���̌v�Z                                                ****
!***********************************************************************
SUBROUTINE NonDiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: UXI, UET, UX, UY
  REAL    :: VXI, VET, VX, VY
  REAL    :: UXIXI, UETET, UXIET, VXIXI, VETET, VXIET
  REAL    :: UXX, UXY, UYX, UYY, VXX, VXY, VYX, VYY
  REAL    :: KRXI, KRET, KRX, KRY
  REAL    :: S11, S22, S33, S12, SS2, ST, SS
  REAL    :: O12, OO2, OT
  REAL    :: eta
  REAL    :: nu, nu_t
  REAL    :: Rtt
  REAL    :: c_mu, f_mu, c_e2
  REAL    :: c4, c6, c7
  REAL    :: nu_t1, nu_t2, nu_t3, AKAE, AEAK
  REAL    :: a11, a22, a33, a12
  REAL    :: uu, vv, ww, uv
  REAL    :: PP_k
  REAL    :: D, E
  REAL    :: QH1
  ! �����J�n ***********************************************************
  ! ��g�U���̌v�Z +++++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, UXI, UET, UX, UY, VXI, VET, VX, VY, &
!$OMP& UXIXI, UETET, UXIET, VXIXI, VETET, VXIET, &
!$OMP& UXX, UXY, UYX, UYY, VXX, VXY, VYX, VYY, &
!$OMP& KRXI, KRET, KRX, KRY, &
!$OMP& S11, S22, S33, S12, SS2, ST, SS, O12, OO2, OT, &
!$OMP& eta, nu, nu_t, Rtt, c_mu, f_mu, c_e2, c4, c6, c7, &
!$OMP& nu_t1, nu_t2, nu_t3, AKAE, AEAK, &
!$OMP& a11, a22, a33, a12, uu, vv, ww, uv, PP_k, D, E, QH1 &
!$OMP& )
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF(RHO(I,J) .GT. 0.0) THEN
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = 0.5 * (- U(I-1,J) + U(I+1,J))
    VXI = 0.5 * (- V(I-1,J) + V(I+1,J))
    UET = 0.5 * (- U(I,J-1) + U(I,J+1))
    VET = 0.5 * (- V(I,J-1) + V(I,J+1))
    ! ������ԕ�����K����
    UX  = XIX(I,J) * UXI + ETX(I,J) * UET
    VX  = XIX(I,J) * VXI + ETX(I,J) * VET
    UY  = XIY(I,J) * UXI + ETY(I,J) * UET
    VY  = XIY(I,J) * VXI + ETY(I,J) * VET
    ! ���x�̓�K�����̌v�Z ---------------------------------------------
    UXX = - (UXXI(I-1,J) - UXXI(I,J)) * XIX(I,J) &
    &     - (UXET(I,J-1) - UXET(I,J)) * ETX(I,J)
    UXY = - (UXXI(I-1,J) - UXXI(I,J)) * XIY(I,J) &
    &     - (UXET(I,J-1) - UXET(I,J)) * ETY(I,J)
    UYX = - (UYXI(I-1,J) - UYXI(I,J)) * XIX(I,J) &
    &     - (UYET(I,J-1) - UYET(I,J)) * ETX(I,J)
    UYY = - (UYXI(I-1,J) - UYXI(I,J)) * XIY(I,J) &
    &     - (UYET(I,J-1) - UYET(I,J)) * ETY(I,J)
    VXX = - (VXXI(I-1,J) - VXXI(I,J)) * XIX(I,J) &
    &     - (VXET(I,J-1) - VXET(I,J)) * ETX(I,J)
    VXY = - (VXXI(I-1,J) - VXXI(I,J)) * XIY(I,J) &
    &     - (VXET(I,J-1) - VXET(I,J)) * ETY(I,J)
    VYX = - (VYXI(I-1,J) - VYXI(I,J)) * XIX(I,J) &
    &     - (VYET(I,J-1) - VYET(I,J)) * ETX(I,J)
    VYY = - (VYXI(I-1,J) - VYXI(I,J)) * XIY(I,J) &
    &     - (VYET(I,J-1) - VYET(I,J)) * ETY(I,J)
    ! ����̑��x�X�P�[�� sqrt(k) �̈�K�����̌v�Z ----------------------
    ! �v�Z��ԕ�����K����
    KRXI = 0.5 * (- SQRT(AK(I-1,J)) + SQRT(AK(I+1,J)))
    KRET = 0.5 * (- SQRT(AK(I,J-1)) + SQRT(AK(I,J+1)))
    ! ������ԕ�����K����
    KRX = KRXI * XIX(I,J) + KRET * ETX(I,J)
    KRY = KRXI * XIY(I,J) + KRET * ETY(I,J)
    ! �c�ݑ��x�ƉQ�x ---------------------------------------------------
    SS  = (UX + VY) * TwoThird
    S11 = 2.0 * UX - SS
    S22 = 2.0 * VY - SS
    S33 =          - SS
    S12 = UY + VX
    SS2 = S11 * S11 + S22 * S22 + S33 * S33 + 2.0 * S12 * S12
    O12 = (UY - VX)
    OO2 = 2.0 * O12 * O12
    IF(EPST(I,J) .GT. ZERO) THEN
      AKAE = AK(I,J) / EPST(I,J)
    ELSE
      AKAE = 0.0
    ENDIF
    ST = AKAE * SQRT(0.5 * SS2)
    OT = AKAE * SQRT(0.5 * OO2)
    ! �e���f���W���̌v�Z -----------------------------------------------
    nu = AMU(I,J) / RHO(I,J)
    IF(EPST(I,J) .GT. ZERO) THEN
      Rtt = AK(I,J)**2 / (nu * EPST(I,J))
    ELSE
      Rtt = 0.0
    ENDIF
    eta  = MAX(ST, OT)
    c_mu = 0.3 / (1.0 + 0.35 * eta**1.5) &
    &    * (1.0 - EXP(-0.36 / MAX(ZERO, EXP(-0.75 * eta))))
    f_mu = 1.0 - EXP(-SQRT(Rtt / 90.0) - (Rtt / 400.0)**2)
    c_e2 = 1.92 * (1.0 - 0.3 * EXP(-Rtt**2))
    c4   =-10.0 * c_mu**2
    c6   =- 5.0 * c_mu**2
    c7   =  5.0 * c_mu**2
    IF(EPST(I,J) .GT. ZERO) THEN
      nu_t = c_mu * f_mu * AK(I,J)**2 / EPST(I,J)
    ELSE
      nu_t = 0.0
    ENDIF
    AMUT(I,J) = RHO(I,J) * nu_t
    ! �񓙕����C�m���Y���̓e���\�� a_ij --------------------------------
    IF(AK(I,J) .GT. ZERO .OR. EPST(I,J)**2 .GT. ZERO) THEN
      nu_t1 =-nu_t / AK(I,J)
      nu_t2 = nu_t / EPST(I,J)
      nu_t3 = nu_t * AK(I,J) / EPST(I,J)**2
    ELSE
      nu_t1 = 0.0
      nu_t2 = 0.0
      nu_t3 = 0.0
    ENDIF
    a11 = nu_t1 * S11 &
    &   + nu_t2 * ( &
    &       c1 * (S11 * S11 + S12 * S12 - SS2 / 3.0) &
    &     + c2 * O12 * S12 * 2.0 &
    &     + c3 * (O12 * O12 - OO2 / 3.0) &
    &   ) &
    &   + nu_t3 * ( &
    &     - c4 * (S11 + S22) * S12 * O12 * 2.0 &
    &     + (c6 * SS2 + c7 * OO2) * S11 &
    &   )
    a22 = nu_t1 * S22 &
    &   + nu_t2 * ( &
    &       c1 * (S22 * S22 + S12 * S12 - SS2 / 3.0) &
    &     - c2 * O12 * S12 * 2.0 &
    &     + c3 * (O12 * O12 - OO2 / 3.0) &
    &   ) &
    &   + nu_t3 * ( &
    &       c4 * (S11 + S22) * S12 * O12 * 2.0 &
    &     + (c6 * SS2 + c7 * OO2) * S22 &
    &   )
    a33 = nu_t1 * S33 &
    &   + nu_t2 * ( &
    &       c1 * (S33 * S33 - SS2 / 3.0) - c3 * OO2 / 3.0 &
    &   ) &
    &   + nu_t3 * (c6 * SS2 + c7 * OO2) * S33
    a12 = nu_t1 * S12 &
    &   + nu_t2 * ( &
    &       c1 * (S11 + S22) * S12 - c2 * O12 * (S11 - S22) &
    &   ) &
    &   + nu_t3 * ( &
    &       c4 * (S11 * S11 - S22 * S22) * O12 &
    &     + (c6 * SS2 + c7 * OO2) * S12 &
    &   )
    a11 = MIN(aiimax, MAX(aiimin, a11))
    a22 = MIN(aiimax, MAX(aiimin, a22))
    a33 = MIN(aiimax, MAX(aiimin, a33))
    a12 = MIN(1.0, MAX(-1.0, a12))
    ! ���C�m���Y���� ---------------------------------------------------
    uu = AK(I,J) * (a11 + TwoThird)
    vv = AK(I,J) * (a22 + TwoThird)
    ww = AK(I,J) * (a33 + TwoThird)
    uv = AK(I,J) * a12
    ! �჌�C�m���Y�␳�� D ---------------------------------------------
    D = 2.0 * nu * (KRX**2 + KRY**2)
    ! �჌�C�m���Y�␳�� E ---------------------------------------------
    IF(Rtt .LE. 250.0) THEN
      E = 0.0022 * ST * nu_t * AK(I,J) * AKAE * ( &
      &     UXX**2 + VXX**2 + UYY**2 + VYY**2 &
      &   + UXY**2 + VXY**2 + UYX**2 + VYX**2 &
      & )
    ELSE
      E = 0.0
    ENDIF
    ! ���C�m���Y���͂̐���(���Ϙc�ݑ�����) -----------------------------
    PP_k = - uu * UX - vv * VY - uv * (VX + UY)
    ! �Ǐ����t����(�����ƎU��̃o�����X)�ɂ�郊�~�b�^�[
    IF(PELIM .GT. 0.0) THEN
      PP_k = MAX(0.0, MIN((EPST(I,J) + D) / PELIM, PP_k))
    ENDIF
    ! �\�[�X���̘a -----------------------------------------------------
    QH1 = RHO(I,J) / AJA(I,J)
    AEAK = MIN( &
    &      MAX(SQRT(0.5 * SS2), SQRT((EPST(I,J) + D) / nu)), &
    &      EPST(I,J) / MAX(ZERO, AK(I,J)) &
    &    )
    DQP(I,J,5) = QH1 * (PP_k - (EPST(I,J) + D))
    DQP(I,J,6) = QH1 * ( &
    &            AEAK * (c_e1 * PP_k - c_e2 * EPST(I,J)) &
    &          + E &
    &          )
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE NonDiffTerm
!***********************************************************************
!**** �g�U���̌v�Z                                                  ****
!***********************************************************************
SUBROUTINE DiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, L
  ! �����J�n ***********************************************************
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  RH = 0.0
  SH = 0.0
  ! �g�U���̗v�f���v�Z +++++++++++++++++++++++++++++++++++++++++++++++++
  CALL DIFFXI
  CALL DIFFET
  ! �g�U���̍��� +++++++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE(I, J, L)
  DO L = LS, LE
  !$OMP DO
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( (RHO(I,J-1) .GT. 0.0) .AND. (RHO(I-1,J) .GT. 0.0) .AND. &
  &   (RHO(I,J)   .GT. 0.0) .AND. &
  &   (RHO(I+1,J) .GT. 0.0) .AND. (RHO(I,J+1) .GT. 0.0) &
  & ) THEN
    DQD(I,J,L) = (-RH(I-1,J  ,L) + RH(I,J,L)) &
    &          + (-SH(I  ,J-1,L) + SH(I,J,L))
  ENDIF
  ENDDO
  ENDDO
  !$OMP END DO
  ENDDO
  !$OMP END PARALLEL
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DiffTerm
!***********************************************************************
!**** �g�U���̌v�Z(xi���������p)                                    ****
!***********************************************************************
SUBROUTINE DIFFXI
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: XIXM, XIYM, ETXM, ETYM, AJAM
  REAL    :: RHOM, UM, VM, AKM, EPSTM, AMUM
  REAL    :: UXI, UET, UX, UY
  REAL    :: VXI, VET, VX, VY
  REAL    :: TXI, TET, TX, TY
  REAL    :: AKXI, AKET, AKX, AKY
  REAL    :: AEXI, AEET, AEX, AEY
  REAL    :: S11, S22, S33, S12, SS2, ST, SS
  REAL    :: O12, OO2, OT
  REAL    :: eta
  REAL    :: nu, nu_t
  REAL    :: Rtt, c_mu, f_mu
  REAL    :: c4, c6, c7
  REAL    :: nu_t1, nu_t2, nu_t3, AKAE
  REAL    :: a11, a22, a33, a12
  REAL    :: uu, vv, ww, uv
  REAL    :: c_t, c_k, c_e
  REAL    :: TAUXX, TAUYY, TAUXY
  REAL    :: R4, S4
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, &
!$OMP& XIXM, XIYM, ETXM, ETYM, AJAM, &
!$OMP& RHOM, UM, VM, AKM, EPSTM, AMUM, &
!$OMP& UXI, UET, UX, UY, VXI, VET, VX, VY, TXI, TET, TX, TY, &
!$OMP& AKXI, AKET, AKX, AKY, AEXI, AEET, AEX, AEY, &
!$OMP& S11, S22, S33, S12, SS2, ST, SS, O12, OO2, OT, &
!$OMP& eta, nu, nu_t, Rtt, c_mu, f_mu, c4, c6, c7, &
!$OMP& nu_t1, nu_t2, nu_t3, AKAE, &
!$OMP& a11, a22, a33, a12, uu, vv, ww, uv, &
!$OMP& c_t, c_k, c_e, TAUXX, TAUYY, TAUXY, R4, S4, QH1 &
!$OMP& )
  DO J = JS + 1, JE - 1
  DO I = IS    , IE - 1
  IF((RHO(I,J) .GT. 0.0) .AND. (RHO(I+1,J) .GT. 0.0)) THEN
    ! XI�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J) + XIX(I+1,J))
    XIYM = 0.5 * (XIY(I,J) + XIY(I+1,J))
    ETXM = 0.5 * (ETX(I,J) + ETX(I+1,J))
    ETYM = 0.5 * (ETY(I,J) + ETY(I+1,J))
    AJAM = 0.5 * (AJA(I,J) + AJA(I+1,J))
    ! ������
    RHOM  = 0.5 * ( RHO(I,J) +  RHO(I+1,J))
    UM    = 0.5 * (   U(I,J) +    U(I+1,J))
    VM    = 0.5 * (   V(I,J) +    V(I+1,J))
    AKM   = 0.5 * (  AK(I,J) +   AK(I+1,J))
    EPSTM = 0.5 * (EPST(I,J) + EPST(I+1,J))
    AMUM  = 0.5 * ( AMU(I,J) +  AMU(I+1,J))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = - U(I,J) + U(I+1,J)
    UET = 0.25 * (- U(I,J-1) - U(I+1,J-1) + U(I,J+1) + U(I+1,J+1))
    VXI = - V(I,J) + V(I+1,J)
    VET = 0.25 * (- V(I,J-1) - V(I+1,J-1) + V(I,J+1) + V(I+1,J+1))
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM
    UY = UXI * XIYM + UET * ETYM
    VX = VXI * XIXM + VET * ETXM
    VY = VXI * XIYM + VET * ETYM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = - T(I,J) + T(I+1,J)
    TET = 0.25 * (- T(I,J-1) - T(I+1,J-1) + T(I,J+1) + T(I+1,J+1))
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM
    TY = TXI * XIYM + TET * ETYM
    ! k �̈�K�����̌v�Z -----------------------------------------------
    ! �v�Z��ԕ�����K����
    AKXI = - AK(I,J) + AK(I+1,J)
    AKET = 0.25 * (- AK(I,J-1) - AK(I+1,J-1) + AK(I,J+1) + AK(I+1,J+1))
    ! ������ԕ�����K����
    AKX = AKXI * XIXM + AKET * ETXM
    AKY = AKXI * XIYM + AKET * ETYM
    ! epsilon tilde �̈�K�����̌v�Z -----------------------------------
    ! �v�Z��ԕ�����K����
    AEXI = - EPST(I,J) + EPST(I+1,J)
    AEET = 0.25 * ( - EPST(I,J-1) - EPST(I+1,J-1) &
    &               + EPST(I,J+1) + EPST(I+1,J+1) )
    ! ������ԕ�����K����
    AEX = AEXI * XIXM + AEET * ETXM
    AEY = AEXI * XIYM + AEET * ETYM
    ! �c�ݑ��x�ƉQ�x ---------------------------------------------------
    SS  = (UX + VY) * TwoThird
    S11 = 2.0 * UX - SS
    S22 = 2.0 * VY - SS
    S33 =          - SS
    S12 = UY + VX
    SS2 = S11 * S11 + S22 * S22 + S33 * S33 + 2.0 * S12 * S12
    O12 = (UY - VX)
    OO2 = 2.0 * O12 * O12
    IF(EPSTM .GT. ZERO) THEN
      AKAE = AKM / EPSTM
    ELSE
      AKAE = 0.0
    ENDIF
    ST = AKAE * SQRT(0.5 * SS2)
    OT = AKAE * SQRT(0.5 * OO2)
    ! �񓙕����C�m���Y���̓e���\�� a_ij �̌W���̌v�Z -------------------
    nu = AMUM / RHOM
    IF(EPSTM .GT. ZERO) THEN
      Rtt = AKM**2 / (nu * EPSTM)
    ELSE
      Rtt = 0.0
    ENDIF
    eta  = MAX(ST, OT)
    c_mu = 0.3 / (1.0 + 0.35 * eta**1.5) &
    &    * (1.0 - EXP(-0.36 / MAX(ZERO, EXP(-0.75 * eta))))
    f_mu = 1.0 - EXP(-SQRT(Rtt / 90.0) - (Rtt / 400.0)**2)
    c4   =-10.0 * c_mu**2
    c6   =- 5.0 * c_mu**2
    c7   =  5.0 * c_mu**2
    IF(EPSTM .GT. ZERO) THEN
      nu_t = c_mu * f_mu * AKM**2 / EPSTM
    ELSE
      nu_t = 0.0
    ENDIF
    ! �񓙕����C�m���Y���̓e���\�� a_ij --------------------------------
    IF(AKM .GT. ZERO .OR. EPSTM**2 .GT. ZERO) THEN
      nu_t1 =-nu_t / AKM
      nu_t2 = nu_t / EPSTM
      nu_t3 = nu_t * AKM / EPSTM**2
    ELSE
      nu_t1 = 0.0
      nu_t2 = 0.0
      nu_t3 = 0.0
    ENDIF
    a11 = nu_t1 * S11 &
    &   + nu_t2 * ( &
    &       c1 * (S11 * S11 + S12 * S12 - SS2 / 3.0) &
    &     + c2 * O12 * S12 * 2.0 &
    &     + c3 * (O12 * O12 - OO2 / 3.0) &
    &   ) &
    &   + nu_t3 * ( &
    &     - c4 * (S11 + S22) * S12 * O12 * 2.0 &
    &     + (c6 * SS2 + c7 * OO2) * S11 &
    &   )
    a22 = nu_t1 * S22 &
    &   + nu_t2 * ( &
    &       c1 * (S22 * S22 + S12 * S12 - SS2 / 3.0) &
    &     - c2 * O12 * S12 * 2.0 &
    &     + c3 * (O12 * O12 - OO2 / 3.0) &
    &   ) &
    &   + nu_t3 * ( &
    &       c4 * (S11 + S22) * S12 * O12 * 2.0 &
    &     + (c6 * SS2 + c7 * OO2) * S22 &
    &   )
    a33 = nu_t1 * S33 &
    &   + nu_t2 * ( &
    &       c1 * (S33 * S33 - SS2 / 3.0) - c3 * OO2 / 3.0 &
    &   ) &
    &   + nu_t3 * (c6 * SS2 + c7 * OO2) * S33
    a12 = nu_t1 * S12 &
    &   + nu_t2 * ( &
    &       c1 * (S11 + S22) * S12 - c2 * O12 * (S11 - S22) &
    &   ) &
    &   + nu_t3 * ( &
    &       c4 * (S11 * S11 - S22 * S22) * O12 &
    &     + (c6 * SS2 + c7 * OO2) * S12 &
    &   )
    a11 = MIN(aiimax, MAX(aiimin, a11))
    a22 = MIN(aiimax, MAX(aiimin, a22))
    a33 = MIN(aiimax, MAX(aiimin, a33))
    a12 = MIN(1.0, MAX(-1.0, a12))
    ! ���C�m���Y���� ---------------------------------------------------
    uu = AKM * (a11 + TwoThird)
    vv = AKM * (a22 + TwoThird)
    ww = AKM * (a33 + TwoThird)
    uv = AKM * a12
    ! �g�U�W�� ---------------------------------------------------------
    c_t = (nu / PR + nu_t / PRT) * GAMMA * RG / (GAMMA - 1.0)
    c_k = nu + nu_t / SIGK
    c_e = nu + nu_t / SIGE
    ! �S�����͂ƃ��C�m���Y���̘͂a -------------------------------------
    TAUXX = nu * S11 - uu
    TAUYY = nu * S22 - vv
    TAUXY = nu * S12 - uv
    ! �G�l���M�[�̊g�U -------------------------------------------------
    R4 = TAUXX * UM + TAUXY * VM + c_t * TX
    S4 = TAUXY * UM + TAUYY * VM + c_t * TY
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    RH(I,J,1) = 0.0
    RH(I,J,2) = QH1 * (TAUXX * XIXM + TAUXY * XIYM)
    RH(I,J,3) = QH1 * (TAUXY * XIXM + TAUYY * XIYM)
    RH(I,J,4) = QH1 * (R4 * XIXM + S4 * XIYM)
    RH(I,J,5) = QH1 * c_k * (AKX * XIXM + AKY * XIYM)
    RH(I,J,6) = QH1 * c_e * (AEX * XIXM + AEY * XIYM)
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFXI
!***********************************************************************
!**** �g�U���̌v�Z(eta���������p)                                   ****
!***********************************************************************
SUBROUTINE DIFFET
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: XIXM, XIYM, ETXM, ETYM, AJAM
  REAL    :: RHOM, UM, VM, AKM, EPSTM, AMUM
  REAL    :: UXI, UET, UX, UY
  REAL    :: VXI, VET, VX, VY
  REAL    :: TXI, TET, TX, TY
  REAL    :: AKXI, AKET, AKX, AKY
  REAL    :: AEXI, AEET, AEX, AEY
  REAL    :: S11, S22, S33, S12, SS2, ST, SS
  REAL    :: O12, OO2, OT
  REAL    :: eta
  REAL    :: nu, nu_t
  REAL    :: Rtt, c_mu, f_mu
  REAL    :: c4, c6, c7
  REAL    :: nu_t1, nu_t2, nu_t3, AKAE
  REAL    :: a11, a22, a33, a12
  REAL    :: uu, vv, ww, uv
  REAL    :: c_t, c_k, c_e
  REAL    :: TAUXX, TAUYY, TAUXY
  REAL    :: R4, S4
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, &
!$OMP& XIXM, XIYM, ETXM, ETYM, AJAM, &
!$OMP& RHOM, UM, VM, AKM, EPSTM, AMUM, &
!$OMP& UXI, UET, UX, UY, VXI, VET, VX, VY, TXI, TET, TX, TY, &
!$OMP& AKXI, AKET, AKX, AKY, AEXI, AEET, AEX, AEY, &
!$OMP& S11, S22, S33, S12, SS2, ST, SS, O12, OO2, OT, &
!$OMP& eta, nu, nu_t, Rtt, c_mu, f_mu, c4, c6, c7, &
!$OMP& nu_t1, nu_t2, nu_t3, AKAE, &
!$OMP& a11, a22, a33, a12, uu, vv, ww, uv, &
!$OMP& c_t, c_k, c_e, TAUXX, TAUYY, TAUXY, R4, S4, QH1 &
!$OMP& )
  DO J = JS    , JE - 1
  DO I = IS + 1, IE - 1
  IF((RHO(I,J) .GT. 0.0) .AND. (RHO(I,J+1) .GT. 0.0)) THEN
    ! ET�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J) + XIX(I,J+1))
    XIYM = 0.5 * (XIY(I,J) + XIY(I,J+1))
    ETXM = 0.5 * (ETX(I,J) + ETX(I,J+1))
    ETYM = 0.5 * (ETY(I,J) + ETY(I,J+1))
    AJAM = 0.5 * (AJA(I,J) + AJA(I,J+1))
    ! ������
    RHOM  = 0.5 * ( RHO(I,J) +  RHO(I,J+1))
    UM    = 0.5 * (   U(I,J) +    U(I,J+1))
    VM    = 0.5 * (   V(I,J) +    V(I,J+1))
    AKM   = 0.5 * (  AK(I,J) +   AK(I,J+1))
    EPSTM = 0.5 * (EPST(I,J) + EPST(I,J+1))
    AMUM  = 0.5 * ( AMU(I,J) +  AMU(I,J+1))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = 0.25 * (- U(I-1,J) - U(I-1,J+1) + U(I+1,J) + U(I+1,J+1))
    UET = - U(I,J) + U(I,J+1)
    VXI = 0.25 * (- V(I-1,J) - V(I-1,J+1) + V(I+1,J) + V(I+1,J+1))
    VET = - V(I,J) + V(I,J+1)
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM
    UY = UXI * XIYM + UET * ETYM
    VX = VXI * XIXM + VET * ETXM
    VY = VXI * XIYM + VET * ETYM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = 0.25 * (- T(I-1,J) - T(I-1,J+1) + T(I+1,J) + T(I+1,J+1))
    TET = - T(I,J) + T(I,J+1)
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM
    TY = TXI * XIYM + TET * ETYM
    ! k �̈�K�����̌v�Z -----------------------------------------------
    ! �v�Z��ԕ�����K����
    AKXI = 0.25 * (- AK(I-1,J) - AK(I-1,J+1) + AK(I+1,J) + AK(I+1,J+1))
    AKET = - AK(I,J) + AK(I,J+1)
    ! ������ԕ�����K����
    AKX = AKXI * XIXM + AKET * ETXM
    AKY = AKXI * XIYM + AKET * ETYM
    ! epsilon tilde �̈�K�����̌v�Z -----------------------------------
    ! �v�Z��ԕ�����K����
    AEXI = 0.25 * ( - EPST(I-1,J) - EPST(I-1,J+1) &
    &               + EPST(I+1,J) + EPST(I+1,J+1) )
    AEET = - EPST(I,J) + EPST(I,J+1)
    ! ������ԕ�����K����
    AEX = AEXI * XIXM + AEET * ETXM
    AEY = AEXI * XIYM + AEET * ETYM
    ! �c�ݑ��x�ƉQ�x ---------------------------------------------------
    SS  = (UX + VY) * TwoThird
    S11 = 2.0 * UX - SS
    S22 = 2.0 * VY - SS
    S33 =          - SS
    S12 = UY + VX
    SS2 = S11 * S11 + S22 * S22 + S33 * S33 + 2.0 * S12 * S12
    O12 = (UY - VX)
    OO2 = 2.0 * O12 * O12
    IF(EPSTM .GT. ZERO) THEN
      AKAE = AKM / EPSTM
    ELSE
      AKAE = 0.0
    ENDIF
    ST = AKAE * SQRT(0.5 * SS2)
    OT = AKAE * SQRT(0.5 * OO2)
    ! �񓙕����C�m���Y���̓e���\�� a_ij �̌W���̌v�Z -------------------
    nu = AMUM / RHOM
    IF(EPSTM .GT. ZERO) THEN
      Rtt = AKM**2 / (nu * EPSTM)
    ELSE
      Rtt = 0.0
    ENDIF
    eta  = MAX(ST, OT)
    c_mu = 0.3 / (1.0 + 0.35 * eta**1.5) &
    &    * (1.0 - EXP(-0.36 / MAX(ZERO, EXP(-0.75 * eta))))
    f_mu = 1.0 - EXP(-SQRT(Rtt / 90.0) - (Rtt / 400.0)**2)
    c4   =-10.0 * c_mu**2
    c6   =- 5.0 * c_mu**2
    c7   =  5.0 * c_mu**2
    IF(EPSTM .GT. ZERO) THEN
      nu_t = c_mu * f_mu * AKM**2 / EPSTM
    ELSE
      nu_t = 0.0
    ENDIF
    ! �񓙕����C�m���Y���̓e���\�� a_ij --------------------------------
    IF(AKM .GT. ZERO .OR. EPSTM**2 .GT. ZERO) THEN
      nu_t1 =-nu_t / AKM
      nu_t2 = nu_t / EPSTM
      nu_t3 = nu_t * AKM / EPSTM**2
    ELSE
      nu_t1 = 0.0
      nu_t2 = 0.0
      nu_t3 = 0.0
    ENDIF
    a11 = nu_t1 * S11 &
    &   + nu_t2 * ( &
    &       c1 * (S11 * S11 + S12 * S12 - SS2 / 3.0) &
    &     + c2 * O12 * S12 * 2.0 &
    &     + c3 * (O12 * O12 - OO2 / 3.0) &
    &   ) &
    &   + nu_t3 * ( &
    &     - c4 * (S11 + S22) * S12 * O12 * 2.0 &
    &     + (c6 * SS2 + c7 * OO2) * S11 &
    &   )
    a22 = nu_t1 * S22 &
    &   + nu_t2 * ( &
    &       c1 * (S22 * S22 + S12 * S12 - SS2 / 3.0) &
    &     - c2 * O12 * S12 * 2.0 &
    &     + c3 * (O12 * O12 - OO2 / 3.0) &
    &   ) &
    &   + nu_t3 * ( &
    &       c4 * (S11 + S22) * S12 * O12 * 2.0 &
    &     + (c6 * SS2 + c7 * OO2) * S22 &
    &   )
    a33 = nu_t1 * S33 &
    &   + nu_t2 * ( &
    &       c1 * (S33 * S33 - SS2 / 3.0) - c3 * OO2 / 3.0 &
    &   ) &
    &   + nu_t3 * (c6 * SS2 + c7 * OO2) * S33
    a12 = nu_t1 * S12 &
    &   + nu_t2 * ( &
    &       c1 * (S11 + S22) * S12 - c2 * O12 * (S11 - S22) &
    &   ) &
    &   + nu_t3 * ( &
    &       c4 * (S11 * S11 - S22 * S22) * O12 &
    &     + (c6 * SS2 + c7 * OO2) * S12 &
    &   )
    a11 = MIN(aiimax, MAX(aiimin, a11))
    a22 = MIN(aiimax, MAX(aiimin, a22))
    a33 = MIN(aiimax, MAX(aiimin, a33))
    a12 = MIN(1.0, MAX(-1.0, a12))
    ! ���C�m���Y���� ---------------------------------------------------
    uu = AKM * (a11 + TwoThird)
    vv = AKM * (a22 + TwoThird)
    ww = AKM * (a33 + TwoThird)
    uv = AKM * a12
    ! �g�U�W�� ---------------------------------------------------------
    c_t = (nu / PR + nu_t / PRT) * GAMMA * RG / (GAMMA - 1.0)
    c_k = nu + nu_t / SIGK
    c_e = nu + nu_t / SIGE
    ! �S�����͂ƃ��C�m���Y���̘͂a -------------------------------------
    TAUXX = nu * S11 - uu
    TAUYY = nu * S22 - vv
    TAUXY = nu * S12 - uv
    ! �G�l���M�[�̊g�U -------------------------------------------------
    R4 = TAUXX * UM + TAUXY * VM + c_t * TX
    S4 = TAUXY * UM + TAUYY * VM + c_t * TY
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    SH(I,J,1) = 0.0
    SH(I,J,2) = QH1 * (TAUXX * ETXM + TAUXY * ETYM)
    SH(I,J,3) = QH1 * (TAUXY * ETXM + TAUYY * ETYM)
    SH(I,J,4) = QH1 * (R4 * ETXM + S4 * ETYM)
    SH(I,J,5) = QH1 * c_k * (AKX * ETXM + AKY * ETYM)
    SH(I,J,6) = QH1 * c_e * (AEX * ETXM + AEY * ETYM)
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFET
! ��`�I�� *************************************************************
END SUBROUTINE Turbulence2DNlEvmkeCLS
!***********************************************************************
!**** �������f�� : RANS, NL-EVM(ke), Craft-Launder-Suga Model(1996) ****
!**** �v�Z�Ώ� : �P��, �O����, ���k��                               ****
!**** �v�Z�X�L�[�� : �񎟐��x���S����(�X�^�K�[�h�i�q��̓_���g�p)   ****
!***********************************************************************
SUBROUTINE Turbulence3DNlEvmkeCLS( &
&            PELIM, RG, GAMMA, PR, PRT, &
&            IS, IE, JS, JE, KS, KE, LS, LE, &
&            XIX, XIY, XIZ, ETX, ETY, ETZ, ZEX, ZEY, ZEZ, AJA, &
&            RHO, U, V, W, T, AK, EPST, AMU, &
&            AMUT, DQD, DQP &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, PARAMETER :: c1 = - 0.1, c2 = 0.1, c3 = 0.26
  REAL, PARAMETER :: c_e1 = 1.44
  REAL, PARAMETER :: SIGK = 1.0, SIGE = 1.3
  REAL, PARAMETER :: aiimin = - 0.66666667, aiimax = 1.3333333
  REAL, PARAMETER :: TwoThird = 0.66666667
  REAL, PARAMETER :: ZERO = 1.0E-20
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: PELIM
  REAL,    INTENT(IN)  :: RG, GAMMA, PR, PRT
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE, KS, KE
  INTEGER, INTENT(IN)  :: LS, LE
  REAL,    INTENT(IN)  :: XIX(IS:IE, JS:JE, KS:KE), &
  &                       XIY(IS:IE, JS:JE, KS:KE), &
  &                       XIZ(IS:IE, JS:JE, KS:KE), &
  &                       ETX(IS:IE, JS:JE, KS:KE), &
  &                       ETY(IS:IE, JS:JE, KS:KE), &
  &                       ETZ(IS:IE, JS:JE, KS:KE), &
  &                       ZEX(IS:IE, JS:JE, KS:KE), &
  &                       ZEY(IS:IE, JS:JE, KS:KE), &
  &                       ZEZ(IS:IE, JS:JE, KS:KE), &
  &                       AJA(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)  :: RHO(IS:IE, JS:JE, KS:KE), &
  &                       U(IS:IE, JS:JE, KS:KE), &
  &                       V(IS:IE, JS:JE, KS:KE), &
  &                       W(IS:IE, JS:JE, KS:KE), &
  &                       T(IS:IE, JS:JE, KS:KE), &
  &                       AK(IS:IE, JS:JE, KS:KE), &
  &                       EPST(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)  :: AMU(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(OUT) :: AMUT(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(OUT) :: DQD(IS:IE, JS:JE, KS:KE, LS:LE)
  REAL,    INTENT(OUT) :: DQP(IS:IE, JS:JE, KS:KE, LS:LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, ALLOCATABLE :: RH(:, :, :, :), SH(:, :, :, :), TH(:, :, :, :)
  REAL, ALLOCATABLE :: UXXI(:, :, :), UYXI(:, :, :), UZXI(:, :, :), &
  &                    VXXI(:, :, :), VYXI(:, :, :), VZXI(:, :, :), &
  &                    WXXI(:, :, :), WYXI(:, :, :), WZXI(:, :, :)
  REAL, ALLOCATABLE :: UXET(:, :, :), UYET(:, :, :), UZET(:, :, :), &
  &                    VXET(:, :, :), VYET(:, :, :), VZET(:, :, :), &
  &                    WXET(:, :, :), WYET(:, :, :), WZET(:, :, :)
  REAL, ALLOCATABLE :: UXZE(:, :, :), UYZE(:, :, :), UZZE(:, :, :), &
  &                    VXZE(:, :, :), VYZE(:, :, :), VZZE(:, :, :), &
  &                    WXZE(:, :, :), WYZE(:, :, :), WZZE(:, :, :)
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 7) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �������m�� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ALLOCATE(RH(IS: IE, JS: JE, KS: KE, LS: LE))
  ALLOCATE(SH(IS: IE, JS: JE, KS: KE, LS: LE))
  ALLOCATE(TH(IS: IE, JS: JE, KS: KE, LS: LE))
  ALLOCATE(UXXI(IS: IE, JS: JE, KS: KE), UYXI(IS: IE, JS: JE, KS: KE))
  ALLOCATE(UZXI(IS: IE, JS: JE, KS: KE), VXXI(IS: IE, JS: JE, KS: KE))
  ALLOCATE(VYXI(IS: IE, JS: JE, KS: KE), VZXI(IS: IE, JS: JE, KS: KE))
  ALLOCATE(WXXI(IS: IE, JS: JE, KS: KE), WYXI(IS: IE, JS: JE, KS: KE))
  ALLOCATE(WZXI(IS: IE, JS: JE, KS: KE))
  ALLOCATE(UXET(IS: IE, JS: JE, KS: KE), UYET(IS: IE, JS: JE, KS: KE))
  ALLOCATE(UZET(IS: IE, JS: JE, KS: KE), VXET(IS: IE, JS: JE, KS: KE))
  ALLOCATE(VYET(IS: IE, JS: JE, KS: KE), VZET(IS: IE, JS: JE, KS: KE))
  ALLOCATE(WXET(IS: IE, JS: JE, KS: KE), WYET(IS: IE, JS: JE, KS: KE))
  ALLOCATE(WZET(IS: IE, JS: JE, KS: KE))
  ALLOCATE(UXZE(IS: IE, JS: JE, KS: KE), UYZE(IS: IE, JS: JE, KS: KE))
  ALLOCATE(UZZE(IS: IE, JS: JE, KS: KE), VXZE(IS: IE, JS: JE, KS: KE))
  ALLOCATE(VYZE(IS: IE, JS: JE, KS: KE), VZZE(IS: IE, JS: JE, KS: KE))
  ALLOCATE(WXZE(IS: IE, JS: JE, KS: KE), WYZE(IS: IE, JS: JE, KS: KE))
  ALLOCATE(WZZE(IS: IE, JS: JE, KS: KE))
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  AMUT = 0.0
  DQD  = 0.0
  DQP  = 0.0
  ! �����葱���̌Ăяo�� +++++++++++++++++++++++++++++++++++++++++++++++
  CALL PreVel2ndDiff
  CALL NonDiffTerm
  CALL DiffTerm
  ! �����I�� ***********************************************************
  RETURN
! �����葱�� ***********************************************************
CONTAINS
!***********************************************************************
!**** ��K�����v�Z�p�̑O����                                        ****
!***********************************************************************
SUBROUTINE PreVel2ndDiff
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����J�n ***********************************************************
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  UXXI = 0.0
  UYXI = 0.0
  UZXI = 0.0
  VXXI = 0.0
  VYXI = 0.0
  VZXI = 0.0
  WXXI = 0.0
  WYXI = 0.0
  WZXI = 0.0
  UXET = 0.0
  UYET = 0.0
  UZET = 0.0
  VXET = 0.0
  VYET = 0.0
  VZET = 0.0
  WXET = 0.0
  WYET = 0.0
  WZET = 0.0
  UXZE = 0.0
  UYZE = 0.0
  UZZE = 0.0
  VXZE = 0.0
  VYZE = 0.0
  VZZE = 0.0
  WXZE = 0.0
  WYZE = 0.0
  WZZE = 0.0
  ! ���x�̓�K�����̑O���� +++++++++++++++++++++++++++++++++++++++++++++
  CALL PreVel2ndDiffXI
  CALL PreVel2ndDiffET
  CALL PreVel2ndDiffZE
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE PreVel2ndDiff
!***********************************************************************
!**** ��K�����v�Z�p�̑O����(XI����)                                ****
!***********************************************************************
SUBROUTINE PreVel2ndDiffXI
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM
  REAL    :: UXI, VXI, WXI, UET, VET, WET, UZE, VZE, WZE
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, &
!$OMP& UXI, VXI, WXI, UET, VET, WET, UZE, VZE, WZE &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS    , IE - 1
  IF(RHO(I,J,K) .GT. 0.0 .AND. RHO(I+1,J,K) .GT. 0.0) THEN
    ! XI�����̒��Ԓl ---------------------------------------------------
    XIXM = 0.5 * (XIX(I,J,K) + XIX(I+1,J,K))
    XIYM = 0.5 * (XIY(I,J,K) + XIY(I+1,J,K))
    XIZM = 0.5 * (XIZ(I,J,K) + XIZ(I+1,J,K))
    ETXM = 0.5 * (ETX(I,J,K) + ETX(I+1,J,K))
    ETYM = 0.5 * (ETY(I,J,K) + ETY(I+1,J,K))
    ETZM = 0.5 * (ETZ(I,J,K) + ETZ(I+1,J,K))
    ZEXM = 0.5 * (ZEX(I,J,K) + ZEX(I+1,J,K))
    ZEYM = 0.5 * (ZEY(I,J,K) + ZEY(I+1,J,K))
    ZEZM = 0.5 * (ZEZ(I,J,K) + ZEZ(I+1,J,K))
    ! �v�Z��Ԉ�K���� -------------------------------------------------
    UXI = - U(I,J,K) + U(I+1,J,K)
    UET = - 0.25 * ( U(I,J-1,K) + U(I+1,J-1,K) &
    &              - U(I,J+1,K) - U(I+1,J+1,K) )
    UZE = - 0.25 * ( U(I,J,K-1) + U(I+1,J,K-1) &
    &              - U(I,J,K+1) - U(I+1,J,K+1) )
    VXI = - V(I,J,K) + V(I+1,J,K)
    VET = - 0.25 * ( V(I,J-1,K) + V(I+1,J-1,K) &
    &              - V(I,J+1,K) - V(I+1,J+1,K) )
    VZE = - 0.25 * ( V(I,J,K-1) + V(I+1,J,K-1) &
    &              - V(I,J,K+1) - V(I+1,J,K+1) )
    WXI = - W(I,J,K) + W(I+1,J,K)
    WET = - 0.25 * ( W(I,J-1,K) + W(I+1,J-1,K) &
    &              - W(I,J+1,K) - W(I+1,J+1,K) )
    WZE = - 0.25 * ( W(I,J,K-1) + W(I+1,J,K-1) &
    &              - W(I,J,K+1) - W(I+1,J,K+1) )
    ! ������Ԉ�K���� -------------------------------------------------
    UXXI(I,J,K) = UXI * XIXM + UET * ETXM + UZE * ZEXM
    UYXI(I,J,K) = UXI * XIYM + UET * ETYM + UZE * ZEYM
    UZXI(I,J,K) = UXI * XIZM + UET * ETZM + UZE * ZEZM
    VXXI(I,J,K) = VXI * XIXM + VET * ETXM + VZE * ZEXM
    VYXI(I,J,K) = VXI * XIYM + VET * ETYM + VZE * ZEYM
    VZXI(I,J,K) = VXI * XIZM + VET * ETZM + VZE * ZEZM
    WXXI(I,J,K) = WXI * XIXM + WET * ETXM + WZE * ZEXM
    WYXI(I,J,K) = WXI * XIYM + WET * ETYM + WZE * ZEYM
    WZXI(I,J,K) = WXI * XIZM + WET * ETZM + WZE * ZEZM
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE PreVel2ndDiffXI
!***********************************************************************
!**** ��K�����v�Z�p�̑O����(ET����)                                ****
!***********************************************************************
SUBROUTINE PreVel2ndDiffET
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM
  REAL    :: UXI, VXI, WXI, UET, VET, WET, UZE, VZE, WZE
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, &
!$OMP& UXI, VXI, WXI, UET, VET, WET, UZE, VZE, WZE &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS    , JE - 1
  DO I = IS + 1, IE - 1
  IF(RHO(I,J,K) .GT. 0.0 .AND. RHO(I,J+1,K) .GT. 0.0) THEN
    ! ET�����̒��Ԓl ---------------------------------------------------
    XIXM = 0.5 * (XIX(I,J,K) + XIX(I,J+1,K))
    XIYM = 0.5 * (XIY(I,J,K) + XIY(I,J+1,K))
    XIZM = 0.5 * (XIZ(I,J,K) + XIZ(I,J+1,K))
    ETXM = 0.5 * (ETX(I,J,K) + ETX(I,J+1,K))
    ETYM = 0.5 * (ETY(I,J,K) + ETY(I,J+1,K))
    ETZM = 0.5 * (ETZ(I,J,K) + ETZ(I,J+1,K))
    ZEXM = 0.5 * (ZEX(I,J,K) + ZEX(I,J+1,K))
    ZEYM = 0.5 * (ZEY(I,J,K) + ZEY(I,J+1,K))
    ZEZM = 0.5 * (ZEZ(I,J,K) + ZEZ(I,J+1,K))
    ! �v�Z��Ԉ�K���� -------------------------------------------------
    UXI = - 0.25 * ( U(I-1,J  ,K) - U(I+1,J  ,K) &
    &              + U(I-1,J+1,K) - U(I+1,J+1,K) )
    UET = - U(I,J,K) + U(I,J+1,K)
    UZE = - 0.25 * ( U(I,J,K-1) + U(I,J+1,K-1) &
    &              - U(I,J,K+1) - U(I,J+1,K+1) )
    VXI = - 0.25 * ( V(I-1,J  ,K) - V(I+1,J  ,K) &
    &              + V(I-1,J+1,K) - V(I+1,J+1,K) )
    VET = - V(I,J,K) + V(I,J+1,K)
    VZE = - 0.25 * ( V(I,J,K-1) + V(I,J+1,K-1) &
    &              - V(I,J,K+1) - V(I,J+1,K+1) )
    WXI = - 0.25 * ( W(I-1,J  ,K) - W(I+1,J  ,K) &
    &              + W(I-1,J+1,K) - W(I+1,J+1,K) )
    WET = - W(I,J,K) + W(I,J+1,K)
    WZE = - 0.25 * ( W(I,J,K-1) + W(I,J+1,K-1) &
    &              - W(I,J,K+1) - W(I,J+1,K+1) )
    ! ������Ԉ�K���� -------------------------------------------------
    UXET(I,J,K) = UXI * XIXM + UET * ETXM + UZE * ZEXM
    UYET(I,J,K) = UXI * XIYM + UET * ETYM + UZE * ZEYM
    UZET(I,J,K) = UXI * XIZM + UET * ETZM + UZE * ZEZM
    VXET(I,J,K) = VXI * XIXM + VET * ETXM + VZE * ZEXM
    VYET(I,J,K) = VXI * XIYM + VET * ETYM + VZE * ZEYM
    VZET(I,J,K) = VXI * XIZM + VET * ETZM + VZE * ZEZM
    WXET(I,J,K) = WXI * XIXM + WET * ETXM + WZE * ZEXM
    WYET(I,J,K) = WXI * XIYM + WET * ETYM + WZE * ZEYM
    WZET(I,J,K) = WXI * XIZM + WET * ETZM + WZE * ZEZM
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE PreVel2ndDiffET
!***********************************************************************
!**** ��K�����v�Z�p�̑O����(ZE����)                                ****
!***********************************************************************
SUBROUTINE PreVel2ndDiffZE
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM
  REAL    :: UXI, VXI, WXI, UET, VET, WET, UZE, VZE, WZE
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, &
!$OMP& UXI, VXI, WXI, UET, VET, WET, UZE, VZE, WZE &
!$OMP& )
  DO K = KS    , KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF(RHO(I,J,K) .GT. 0.0 .AND. RHO(I,J,K+1) .GT. 0.0) THEN
    ! ZE�����̒��Ԓl ---------------------------------------------------
    XIXM = 0.5 * (XIX(I,J,K) + XIX(I,J,K+1))
    XIYM = 0.5 * (XIY(I,J,K) + XIY(I,J,K+1))
    XIZM = 0.5 * (XIZ(I,J,K) + XIZ(I,J,K+1))
    ETXM = 0.5 * (ETX(I,J,K) + ETX(I,J,K+1))
    ETYM = 0.5 * (ETY(I,J,K) + ETY(I,J,K+1))
    ETZM = 0.5 * (ETZ(I,J,K) + ETZ(I,J,K+1))
    ZEXM = 0.5 * (ZEX(I,J,K) + ZEX(I,J,K+1))
    ZEYM = 0.5 * (ZEY(I,J,K) + ZEY(I,J,K+1))
    ZEZM = 0.5 * (ZEZ(I,J,K) + ZEZ(I,J,K+1))
    ! �v�Z��Ԉ�K���� -------------------------------------------------
    UXI = - 0.25 * ( U(I-1,J,K  ) - U(I+1,J,K  ) &
    &              + U(I-1,J,K+1) - U(I+1,J,K+1) )
    UET = - 0.25 * ( U(I,J-1,K  ) - U(I,J+1,K  ) &
    &              + U(I,J-1,K+1) - U(I,J+1,K+1) )
    UZE = - U(I,J,K) + U(I,J,K+1)
    VXI = - 0.25 * ( V(I-1,J,K  ) - V(I+1,J,K  ) &
    &              + V(I-1,J,K+1) - V(I+1,J,K+1) )
    VET = - 0.25 * ( V(I,J-1,K  ) - V(I,J+1,K  ) &
    &              + V(I,J-1,K+1) - V(I,J+1,K+1) )
    VZE = - V(I,J,K) + V(I,J,K+1)
    WXI = - 0.25 * ( W(I-1,J,K  ) - W(I+1,J,K  ) &
    &              + W(I-1,J,K+1) - W(I+1,J,K+1) )
    WET = - 0.25 * ( W(I,J-1,K  ) - W(I,J+1,K  ) &
    &              + W(I,J-1,K+1) - W(I,J+1,K+1) )
    WZE = - W(I,J,K) + W(I,J,K+1)
    ! ������Ԉ�K���� -------------------------------------------------
    UXZE(I,J,K) = UXI * XIXM + UET * ETXM + UZE * ZEXM
    UYZE(I,J,K) = UXI * XIYM + UET * ETYM + UZE * ZEYM
    UZZE(I,J,K) = UXI * XIZM + UET * ETZM + UZE * ZEZM
    VXZE(I,J,K) = VXI * XIXM + VET * ETXM + VZE * ZEXM
    VYZE(I,J,K) = VXI * XIYM + VET * ETYM + VZE * ZEYM
    VZZE(I,J,K) = VXI * XIZM + VET * ETZM + VZE * ZEZM
    WXZE(I,J,K) = WXI * XIXM + WET * ETXM + WZE * ZEXM
    WYZE(I,J,K) = WXI * XIYM + WET * ETYM + WZE * ZEYM
    WZZE(I,J,K) = WXI * XIZM + WET * ETZM + WZE * ZEZM
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE PreVel2ndDiffZE
!***********************************************************************
!**** ��g�U���̌v�Z                                                ****
!***********************************************************************
SUBROUTINE NonDiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: UXI, VXI, WXI, UET, VET, WET, UZE, VZE, WZE
  REAL    :: UX, VX, WX, UY, VY, WY, UZ, VZ, WZ
  REAL    :: UXIXI, UETET, UZEZE, UXIET, UETZE, UZEXI, &
  &          VXIXI, VETET, VZEZE, VXIET, VETZE, VZEXI, &
  &          WXIXI, WETET, WZEZE, WXIET, WETZE, WZEXI
  REAL    :: UXX, UXY, UXZ, UYX, UYY, UYZ, UZX, UZY, UZZ, &
  &          VXX, VXY, VXZ, VYX, VYY, VYZ, VZX, VZY, VZZ, &
  &          WXX, WXY, WXZ, WYX, WYY, WYZ, WZX, WZY, WZZ
  REAL    :: KRXI, KRET, KRZE, KRX, KRY, KRZ
  REAL    :: S11, S22, S33, S12, S23, S31, SS2, ST, SS
  REAL    :: O12, O23, O31, OO2, OT
  REAL    :: eta
  REAL    :: nu, nu_t
  REAL    :: Rtt
  REAL    :: c_mu, f_mu, c_e2
  REAL    :: c4, c6, c7
  REAL    :: nu_t1, nu_t2, nu_t3, AKAE, AEAK
  REAL    :: a11, a22, a33, a12, a23, a31
  REAL    :: uu, vv, ww, uv, vw, wu
  REAL    :: PP_k
  REAL    :: D, E
  REAL    :: QH1
  ! �����J�n ***********************************************************
  ! ��g�U���̌v�Z +++++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& UXI, VXI, WXI, UET, VET, WET, UZE, VZE, WZE, &
!$OMP& UX, VX, WX, UY, VY, WY, UZ, VZ, WZ, &
!$OMP& UXIXI, UETET, UZEZE, UXIET, UETZE, UZEXI, &
!$OMP& VXIXI, VETET, VZEZE, VXIET, VETZE, VZEXI, &
!$OMP& WXIXI, WETET, WZEZE, WXIET, WETZE, WZEXI, &
!$OMP& UXX, UXY, UXZ, UYX, UYY, UYZ, UZX, UZY, UZZ, &
!$OMP& VXX, VXY, VXZ, VYX, VYY, VYZ, VZX, VZY, VZZ, &
!$OMP& WXX, WXY, WXZ, WYX, WYY, WYZ, WZX, WZY, WZZ, &
!$OMP& KRXI, KRET, KRZE, KRX, KRY, KRZ, &
!$OMP& S11, S22, S33, S12, S23, S31, SS2, ST, SS, &
!$OMP& O12, O23, O31, OO2, OT, &
!$OMP& eta, nu, nu_t, Rtt, c_mu, f_mu, c_e2, c4, c6, c7, &
!$OMP& nu_t1, nu_t2, nu_t3, AKAE, AEAK, &
!$OMP& a11, a22, a33, a12, a23, a31, uu, vv, ww, uv, vw, wu, &
!$OMP& PP_k, D, E, QH1 &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
    IF(RHO(I,J,K) .GT. 0.0) THEN
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = (-U(I-1,J,K) + U(I+1,J,K)) * 0.5
    UET = (-U(I,J-1,K) + U(I,J+1,K)) * 0.5
    UZE = (-U(I,J,K-1) + U(I,J,K+1)) * 0.5
    VXI = (-V(I-1,J,K) + V(I+1,J,K)) * 0.5
    VET = (-V(I,J-1,K) + V(I,J+1,K)) * 0.5
    VZE = (-V(I,J,K-1) + V(I,J,K+1)) * 0.5
    WXI = (-W(I-1,J,K) + W(I+1,J,K)) * 0.5
    WET = (-W(I,J-1,K) + W(I,J+1,K)) * 0.5
    WZE = (-W(I,J,K-1) + W(I,J,K+1)) * 0.5
    ! ������ԕ�����K����
    UX  = XIX(I,J,K) * UXI + ETX(I,J,K) * UET + ZEX(I,J,K) * UZE
    VX  = XIX(I,J,K) * VXI + ETX(I,J,K) * VET + ZEX(I,J,K) * VZE
    WX  = XIX(I,J,K) * WXI + ETX(I,J,K) * WET + ZEX(I,J,K) * WZE
    UY  = XIY(I,J,K) * UXI + ETY(I,J,K) * UET + ZEY(I,J,K) * UZE
    VY  = XIY(I,J,K) * VXI + ETY(I,J,K) * VET + ZEY(I,J,K) * VZE
    WY  = XIY(I,J,K) * WXI + ETY(I,J,K) * WET + ZEY(I,J,K) * WZE
    UZ  = XIZ(I,J,K) * UXI + ETZ(I,J,K) * UET + ZEZ(I,J,K) * UZE
    VZ  = XIZ(I,J,K) * VXI + ETZ(I,J,K) * VET + ZEZ(I,J,K) * VZE
    WZ  = XIZ(I,J,K) * WXI + ETZ(I,J,K) * WET + ZEZ(I,J,K) * WZE
    ! ���x�̓�K�����̌v�Z ---------------------------------------------
    UXX = - (UXXI(I-1,J,K) - UXXI(I,J,K)) * XIX(I,J,K) &
    &     - (UXET(I,J-1,K) - UXET(I,J,K)) * ETX(I,J,K) &
    &     - (UXZE(I,J,K-1) - UXZE(I,J,K)) * ZEX(I,J,K)
    UXY = - (UXXI(I-1,J,K) - UXXI(I,J,K)) * XIY(I,J,K) &
    &     - (UXET(I,J-1,K) - UXET(I,J,K)) * ETY(I,J,K) &
    &     - (UXZE(I,J,K-1) - UXZE(I,J,K)) * ZEY(I,J,K)
    UXZ = - (UXXI(I-1,J,K) - UXXI(I,J,K)) * XIZ(I,J,K) &
    &     - (UXET(I,J-1,K) - UXET(I,J,K)) * ETZ(I,J,K) &
    &     - (UXZE(I,J,K-1) - UXZE(I,J,K)) * ZEZ(I,J,K)
    UYX = - (UYXI(I-1,J,K) - UYXI(I,J,K)) * XIX(I,J,K) &
    &     - (UYET(I,J-1,K) - UYET(I,J,K)) * ETX(I,J,K) &
    &     - (UYZE(I,J,K-1) - UYZE(I,J,K)) * ZEX(I,J,K)
    UYY = - (UYXI(I-1,J,K) - UYXI(I,J,K)) * XIY(I,J,K) &
    &     - (UYET(I,J-1,K) - UYET(I,J,K)) * ETY(I,J,K) &
    &     - (UYZE(I,J,K-1) - UYZE(I,J,K)) * ZEY(I,J,K)
    UYZ = - (UYXI(I-1,J,K) - UYXI(I,J,K)) * XIZ(I,J,K) &
    &     - (UYET(I,J-1,K) - UYET(I,J,K)) * ETZ(I,J,K) &
    &     - (UYZE(I,J,K-1) - UYZE(I,J,K)) * ZEZ(I,J,K)
    UZX = - (UZXI(I-1,J,K) - UZXI(I,J,K)) * XIX(I,J,K) &
    &     - (UZET(I,J-1,K) - UZET(I,J,K)) * ETX(I,J,K) &
    &     - (UZZE(I,J,K-1) - UZZE(I,J,K)) * ZEX(I,J,K)
    UZY = - (UZXI(I-1,J,K) - UZXI(I,J,K)) * XIY(I,J,K) &
    &     - (UZET(I,J-1,K) - UZET(I,J,K)) * ETY(I,J,K) &
    &     - (UZZE(I,J,K-1) - UZZE(I,J,K)) * ZEY(I,J,K)
    UZZ = - (UZXI(I-1,J,K) - UZXI(I,J,K)) * XIZ(I,J,K) &
    &     - (UZET(I,J-1,K) - UZET(I,J,K)) * ETZ(I,J,K) &
    &     - (UZZE(I,J,K-1) - UZZE(I,J,K)) * ZEZ(I,J,K)
    VXX = - (VXXI(I-1,J,K) - VXXI(I,J,K)) * XIX(I,J,K) &
    &     - (VXET(I,J-1,K) - VXET(I,J,K)) * ETX(I,J,K) &
    &     - (VXZE(I,J,K-1) - VXZE(I,J,K)) * ZEX(I,J,K)
    VXY = - (VXXI(I-1,J,K) - VXXI(I,J,K)) * XIY(I,J,K) &
    &     - (VXET(I,J-1,K) - VXET(I,J,K)) * ETY(I,J,K) &
    &     - (VXZE(I,J,K-1) - VXZE(I,J,K)) * ZEY(I,J,K)
    VXZ = - (VXXI(I-1,J,K) - VXXI(I,J,K)) * XIZ(I,J,K) &
    &     - (VXET(I,J-1,K) - VXET(I,J,K)) * ETZ(I,J,K) &
    &     - (VXZE(I,J,K-1) - VXZE(I,J,K)) * ZEZ(I,J,K)
    VYX = - (VYXI(I-1,J,K) - VYXI(I,J,K)) * XIX(I,J,K) &
    &     - (VYET(I,J-1,K) - VYET(I,J,K)) * ETX(I,J,K) &
    &     - (VYZE(I,J,K-1) - VYZE(I,J,K)) * ZEX(I,J,K)
    VYY = - (VYXI(I-1,J,K) - VYXI(I,J,K)) * XIY(I,J,K) &
    &     - (VYET(I,J-1,K) - VYET(I,J,K)) * ETY(I,J,K) &
    &     - (VYZE(I,J,K-1) - VYZE(I,J,K)) * ZEY(I,J,K)
    VYZ = - (VYXI(I-1,J,K) - VYXI(I,J,K)) * XIZ(I,J,K) &
    &     - (VYET(I,J-1,K) - VYET(I,J,K)) * ETZ(I,J,K) &
    &     - (VYZE(I,J,K-1) - VYZE(I,J,K)) * ZEZ(I,J,K)
    VZX = - (VZXI(I-1,J,K) - VZXI(I,J,K)) * XIX(I,J,K) &
    &     - (VZET(I,J-1,K) - VZET(I,J,K)) * ETX(I,J,K) &
    &     - (VZZE(I,J,K-1) - VZZE(I,J,K)) * ZEX(I,J,K)
    VZY = - (VZXI(I-1,J,K) - VZXI(I,J,K)) * XIY(I,J,K) &
    &     - (VZET(I,J-1,K) - VZET(I,J,K)) * ETY(I,J,K) &
    &     - (VZZE(I,J,K-1) - VZZE(I,J,K)) * ZEY(I,J,K)
    VZZ = - (VZXI(I-1,J,K) - VZXI(I,J,K)) * XIZ(I,J,K) &
    &     - (VZET(I,J-1,K) - VZET(I,J,K)) * ETZ(I,J,K) &
    &     - (VZZE(I,J,K-1) - VZZE(I,J,K)) * ZEZ(I,J,K)
    WXX = - (WXXI(I-1,J,K) - WXXI(I,J,K)) * XIX(I,J,K) &
    &     - (WXET(I,J-1,K) - WXET(I,J,K)) * ETX(I,J,K) &
    &     - (WXZE(I,J,K-1) - WXZE(I,J,K)) * ZEX(I,J,K)
    WXY = - (WXXI(I-1,J,K) - WXXI(I,J,K)) * XIY(I,J,K) &
    &     - (WXET(I,J-1,K) - WXET(I,J,K)) * ETY(I,J,K) &
    &     - (WXZE(I,J,K-1) - WXZE(I,J,K)) * ZEY(I,J,K)
    WXZ = - (WXXI(I-1,J,K) - WXXI(I,J,K)) * XIZ(I,J,K) &
    &     - (WXET(I,J-1,K) - WXET(I,J,K)) * ETZ(I,J,K) &
    &     - (WXZE(I,J,K-1) - WXZE(I,J,K)) * ZEZ(I,J,K)
    WYX = - (WYXI(I-1,J,K) - WYXI(I,J,K)) * XIX(I,J,K) &
    &     - (WYET(I,J-1,K) - WYET(I,J,K)) * ETX(I,J,K) &
    &     - (WYZE(I,J,K-1) - WYZE(I,J,K)) * ZEX(I,J,K)
    WYY = - (WYXI(I-1,J,K) - WYXI(I,J,K)) * XIY(I,J,K) &
    &     - (WYET(I,J-1,K) - WYET(I,J,K)) * ETY(I,J,K) &
    &     - (WYZE(I,J,K-1) - WYZE(I,J,K)) * ZEY(I,J,K)
    WYZ = - (WYXI(I-1,J,K) - WYXI(I,J,K)) * XIZ(I,J,K) &
    &     - (WYET(I,J-1,K) - WYET(I,J,K)) * ETZ(I,J,K) &
    &     - (WYZE(I,J,K-1) - WYZE(I,J,K)) * ZEZ(I,J,K)
    WZX = - (WZXI(I-1,J,K) - WZXI(I,J,K)) * XIX(I,J,K) &
    &     - (WZET(I,J-1,K) - WZET(I,J,K)) * ETX(I,J,K) &
    &     - (WZZE(I,J,K-1) - WZZE(I,J,K)) * ZEX(I,J,K)
    WZY = - (WZXI(I-1,J,K) - WZXI(I,J,K)) * XIY(I,J,K) &
    &     - (WZET(I,J-1,K) - WZET(I,J,K)) * ETY(I,J,K) &
    &     - (WZZE(I,J,K-1) - WZZE(I,J,K)) * ZEY(I,J,K)
    WZZ = - (WZXI(I-1,J,K) - WZXI(I,J,K)) * XIZ(I,J,K) &
    &     - (WZET(I,J-1,K) - WZET(I,J,K)) * ETZ(I,J,K) &
    &     - (WZZE(I,J,K-1) - WZZE(I,J,K)) * ZEZ(I,J,K)
    ! ����̑��x�X�P�[�� sqrt(k) �̈�K�����̌v�Z ----------------------
    ! �v�Z��ԕ�����K����
    KRXI = 0.5 * (- SQRT(AK(I-1,J,K)) + SQRT(AK(I+1,J,K)))
    KRET = 0.5 * (- SQRT(AK(I,J-1,K)) + SQRT(AK(I,J+1,K)))
    KRZE = 0.5 * (- SQRT(AK(I,J,K-1)) + SQRT(AK(I,J,K+1)))
    ! ������ԕ�����K����
    KRX = KRXI * XIX(I,J,K) + KRET * ETX(I,J,K) + KRZE * ZEX(I,J,K)
    KRY = KRXI * XIY(I,J,K) + KRET * ETY(I,J,K) + KRZE * ZEY(I,J,K)
    KRZ = KRXI * XIZ(I,J,K) + KRET * ETZ(I,J,K) + KRZE * ZEZ(I,J,K)
    ! �c�ݑ��x�ƉQ�x ---------------------------------------------------
    SS  = (UX + VY + WZ) * TwoThird
    S11 = 2.0 * UX - SS
    S22 = 2.0 * VY - SS
    S33 = 2.0 * WZ - SS
    S12 = UY + VX
    S23 = VZ + WY
    S31 = WX + UZ
    SS2 = S11 * S11 + S22 * S22 + S33 * S33 &
    &   + 2.0 * (S12 * S12 + S23 * S23 + S31 * S31)
    O12 = UY - VX
    O23 = VZ - WY
    O31 = WX - UZ
    OO2 = 2.0 * (O12 * O12 + O23 * O23 + O31 * O31)
    IF(EPST(I,J,K) .GT. ZERO) THEN
      AKAE = AK(I,J,K) / EPST(I,J,K)
    ELSE
      AKAE = 0.0
    ENDIF
    ST = AKAE * SQRT(0.5 * SS2)
    OT = AKAE * SQRT(0.5 * OO2)
    ! �e���f���W���̌v�Z -----------------------------------------------
    nu = AMU(I,J,K) / RHO(I,J,K)
    IF(EPST(I,J,K) .GT. ZERO) THEN
      Rtt = AK(I,J,K)**2 / (nu * EPST(I,J,K))
    ELSE
      Rtt = 0.0
    ENDIF
    eta  = MAX(ST, OT)
    c_mu = 0.3 / (1.0 + 0.35 * eta**1.5) &
    &    * (1.0 - EXP(-0.36 / MAX(ZERO, EXP(-0.75 * eta))))
    f_mu = 1.0 - EXP(-SQRT(Rtt / 90.0) - (Rtt / 400.0)**2)
    c_e2 = 1.92 * (1.0 - 0.3 * EXP(-Rtt**2))
    c4   =-10.0 * c_mu**2
    c6   =- 5.0 * c_mu**2
    c7   =  5.0 * c_mu**2
    IF(EPST(I,J,K) .GT. ZERO) THEN
      nu_t = c_mu * f_mu * AK(I,J,K)**2 / EPST(I,J,K)
    ELSE
      nu_t = 0.0
    ENDIF
    AMUT(I,J,K) = RHO(I,J,K) * nu_t
    ! �񓙕����C�m���Y���̓e���\�� a_ij --------------------------------
    IF(AK(I,J,K) .GT. ZERO .OR. EPST(I,J,K)**2 .GT. ZERO) THEN
      nu_t1 =-nu_t / AK(I,J,K)
      nu_t2 = nu_t / EPST(I,J,K)
      nu_t3 = nu_t * AK(I,J,K) / EPST(I,J,K)**2
    ELSE
      nu_t1 = 0.0
      nu_t2 = 0.0
      nu_t3 = 0.0
    ENDIF
    a11 = nu_t1 * S11 &
    &   + nu_t2 * ( &
    &       c1 * (S11 * S11 + S31 * S31 + S12 * S12 - SS2 / 3.0) &
    &     + c2 * (O12 * S12 - O31 * S31) * 2.0 &
    &     + c3 * (O12 * O12 + O31 * O31 - OO2 / 3.0) &
    &   ) &
    &   + nu_t3 * ( &
    &       c4 * ( (S12 * S23 + (S33 + S11) * S31) * O31 &
    &            - (S23 * S31 + (S11 + S22) * S12) * O12 ) * 2.0 &
    &     + (c6 * SS2 + c7 * OO2) * S11 &
    &   )
    a22 = nu_t1 * S22 &
    &   + nu_t2 * ( &
    &       c1 * (S22 * S22 + S12 * S12 + S23 * S23 - SS2 / 3.0) &
    &     + c2 * (O23 * S23 - O12 * S12) * 2.0 &
    &     + c3 * (O23 * O23 + O12 * O12 - OO2 / 3.0) &
    &   ) &
    &   + nu_t3 * ( &
    &       c4 * ( (S23 * S31 + (S11 + S22) * S12) * O12 &
    &            - (S31 * S12 + (S22 + S33) * S23) * O23 ) * 2.0 &
    &     + (c6 * SS2 + c7 * OO2) * S22 &
    &   )
    a33 = nu_t1 * S33 &
    &   + nu_t2 * ( &
    &       c1 * (S33 * S33 + S23 * S23 + S31 * S31 - SS2 / 3.0) &
    &     + c2 * (O31 * S31 - O23 * S23) * 2.0 &
    &     + c3 * (O31 * O31 + O23 * O23 - OO2 / 3.0) &
    &   ) &
    &   + nu_t3 * ( &
    &       c4 * ( (S31 * S12 + (S22 + S33) * S23) * O23 &
    &            - (S12 * S23 + (S33 + S11) * S31) * O31) * 2.0 &
    &     + (c6 * SS2 + c7 * OO2) * S33 &
    &   )
    a12 = nu_t1 * S12 &
    &   + nu_t2 * ( &
    &       c1 * ((S11 + S22) * S12 + S23 * S31) &
    &     + c2 * (O23 * S31 - O31 * S23 - O12 * (S11 - S22)) &
    &     - c3 * (O23 * O31) &
    &   ) &
    &   + nu_t3 * ( &
    &       c4 * ( &
    &         (S11 * S11 - S22 * S22 - S23 * S23 + S31 * S31) * O12 &
    &       + ((S22 + S33) * S23 + S31 * S12) * O31 &
    &       - ((S33 + S11) * S31 + S12 * S23) * O23 &
    &     ) &
    &     + (c6 * SS2 + c7 * OO2) * S12 &
    &   )
    a23 = nu_t1 * S23 &
    &   + nu_t2 * ( &
    &       c1 * ((S22 + S33) * S23 + S31 * S12) &
    &     + c2 * (O31 * S12 - O12 * S31 - O23 * (S22 - S33)) &
    &     - c3 * (O31 * O12) &
    &   ) &
    &   + nu_t3 * ( &
    &       c4 * ( &
    &         (S22 * S22 - S33 * S33 - S31 * S31 + S12 * S12) * O23 &
    &       + ((S11 + S33) * S31 + S12 * S23) * O12 &
    &       - ((S11 + S22) * S12 + S23 * S31) * O31 &
    &     ) &
    &     + (c6 * SS2 + c7 * OO2) * S23 &
    &   )
    a31 = nu_t1 * S31 &
    &   + nu_t2 * ( &
    &       c1 * ((S11 + S33) * S31 + S12 * S23) &
    &     + c2 * (O12 * S23 - O23 * S12 - O31 * (S33 - S11)) &
    &     - c3 * (O12 * O23) &
    &   ) &
    &   + nu_t3 * ( &
    &       c4 * ( &
    &         (S33 * S33 - S11 * S11 - S12 * S12 + S23 * S23) * O31 &
    &       + ((S11 + S22) * S12 + S31 * S23) * O23 &
    &       - ((S22 + S33) * S23 + S12 * S31) * O12 &
    &     ) &
    &     + (c6 * SS2 + c7 * OO2) * S31 &
    &   )
    a11 = MIN(aiimax, MAX(aiimin, a11))
    a22 = MIN(aiimax, MAX(aiimin, a22))
    a33 = MIN(aiimax, MAX(aiimin, a33))
    a12 = MIN(1.0, MAX(-1.0, a12))
    a23 = MIN(1.0, MAX(-1.0, a23))
    a31 = MIN(1.0, MAX(-1.0, a31))
    ! ���C�m���Y���� ---------------------------------------------------
    uu = AK(I,J,K) * (a11 + TwoThird)
    vv = AK(I,J,K) * (a22 + TwoThird)
    ww = AK(I,J,K) * (a33 + TwoThird)
    uv = AK(I,J,K) * a12
    vw = AK(I,J,K) * a23
    wu = AK(I,J,K) * a31
    ! �჌�C�m���Y�␳�� D ---------------------------------------------
    D = 2.0 * nu * (KRX**2 + KRY**2 + KRZ**2)
    ! �჌�C�m���Y�␳�� E ---------------------------------------------
    IF(Rtt .LE. 250.0) THEN
      E = 0.0022 * ST * nu_t * AK(I,J,K) * AKAE * ( &
      &     UXX**2 + VXX**2 + WXX**2 &
      &   + UYY**2 + VYY**2 + WYY**2 &
      &   + UZZ**2 + VZZ**2 + WZZ**2 &
      &   + UXY**2 + VXY**2 + WXY**2 &
      &   + UYZ**2 + VYZ**2 + WYZ**2 &
      &   + UZX**2 + VZX**2 + WZX**2 &
      &   + UXZ**2 + VXZ**2 + WXZ**2 &
      &   + UYX**2 + VYX**2 + WYX**2 &
      &   + UZY**2 + VZY**2 + WZY**2 &
      & )
    ELSE
      E = 0.0
    ENDIF
    ! ���C�m���Y���͂̐���(���Ϙc�ݑ�����) -----------------------------
    PP_k = - uu * UX - vv * VY - ww * WZ &
    &      - uv * (VX + UY) - vw * (WY + VZ) - wu * (WX + UZ)
    ! �Ǐ����t����(�����ƎU��̃o�����X)�ɂ�郊�~�b�^�[
    IF(PELIM .GT. 0.0) THEN
      PP_k = MAX(0.0, MIN((EPST(I,J,K) + D) / PELIM, PP_k))
    ENDIF
    ! �\�[�X���̘a -----------------------------------------------------
    QH1 = RHO(I,J,K) / AJA(I,J,K)
    AEAK = MIN( &
    &      MAX(SQRT(0.5 * SS2), SQRT((EPST(I,J,K) + D) / nu)), &
    &      EPST(I,J,K) / MAX(ZERO, AK(I,J,K)) &
    &    )
    DQP(I,J,K,6) = QH1 * (PP_k - (EPST(I,J,K) + D))
    DQP(I,J,K,7) = QH1 * (AEAK * (c_e1 * PP_k - c_e2 * EPST(I,J,K)) + E)
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE NonDiffTerm
!***********************************************************************
!**** �g�U���̌v�Z                                                  ****
!***********************************************************************
SUBROUTINE DiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K, L
  ! �����J�n ***********************************************************
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  RH = 0.0
  SH = 0.0
  TH = 0.0
  ! �g�U���̗v�f���v�Z +++++++++++++++++++++++++++++++++++++++++++++++++
  CALL DIFFXI
  CALL DIFFET
  CALL DIFFZE
  ! �g�U���̍��� +++++++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE(I, J, K, L)
  DO L = LS, LE
  !$OMP DO
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( (RHO(I,J,K-1) .GT. 0.0) .AND. (RHO(I,J-1,K) .GT. 0.0) .AND. &
  &   (RHO(I-1,J,K) .GT. 0.0) .AND. (RHO(I,J,K)   .GT. 0.0) .AND. &
  &   (RHO(I+1,J,K) .GT. 0.0) .AND. (RHO(I,J+1,K) .GT. 0.0) .AND. &
  &   (RHO(I,J,K+1) .GT. 0.0) &
  & ) THEN
    DQD(I,J,K,L) = (-RH(I-1,J  ,K  ,L) + RH(I,J,K,L) ) &
    &            + (-SH(I  ,J-1,K  ,L) + SH(I,J,K,L) ) &
    &            + (-TH(I  ,J  ,K-1,L) + TH(I,J,K,L) )
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END DO
  ENDDO
  !$OMP END PARALLEL
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DiffTerm
!***********************************************************************
!**** �g�U���̌v�Z(xi���������p)                                    ****
!***********************************************************************
SUBROUTINE DIFFXI
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM
  REAL    :: RHOM, UM, VM, WM, AKM, EPSTM, AMUM
  REAL    :: UXI, UET, UZE, UX, UY, UZ
  REAL    :: VXI, VET, VZE, VX, VY, VZ
  REAL    :: WXI, WET, WZE, WX, WY, WZ
  REAL    :: TXI, TET, TZE, TX, TY, TZ
  REAL    :: AKXI, AKET, AKZE, AKX, AKY, AKZ
  REAL    :: AEXI, AEET, AEZE, AEX, AEY, AEZ
  REAL    :: S11, S22, S33, S12, S23, S31, SS2, ST, SS
  REAL    :: O12, O23, O31, OO2, OT
  REAL    :: eta
  REAL    :: nu, nu_t
  REAL    :: Rtt, c_mu, f_mu
  REAL    :: c4, c6, c7
  REAL    :: nu_t1, nu_t2, nu_t3, AKAE
  REAL    :: a11, a22, a33, a12, a23, a31
  REAL    :: uu, vv, ww, uv, vw, wu
  REAL    :: c_t, c_k, c_e
  REAL    :: TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX
  REAL    :: R5, S5, T5
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM, &
!$OMP& RHOM, UM, VM, WM, AKM, EPSTM, AMUM, &
!$OMP& UXI, UET, UZE, UX, UY, UZ, &
!$OMP& VXI, VET, VZE, VX, VY, VZ, &
!$OMP& WXI, WET, WZE, WX, WY, WZ, &
!$OMP& TXI, TET, TZE, TX, TY, TZ, &
!$OMP& AKXI, AKET, AKZE, AKX, AKY, AKZ, &
!$OMP& AEXI, AEET, AEZE, AEX, AEY, AEZ, &
!$OMP& S11, S22, S33, S12, S23, S31, SS2, ST, SS, &
!$OMP& O12, O23, O31, OO2, OT, &
!$OMP& eta, nu, nu_t, Rtt, c_mu, f_mu, c4, c6, c7, &
!$OMP& nu_t1, nu_t2, nu_t3, AKAE, &
!$OMP& a11, a22, a33, a12, a23, a31, uu, vv, ww, uv, vw, wu, &
!$OMP& c_t, c_k, c_e, &
!$OMP& TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX, R5, S5, T5, QH1 &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS    , IE - 1
  IF((RHO(I,J,K) .GT. 0.0) .AND. (RHO(I+1,J,K) .GT. 0.0)) THEN
    ! XI�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J,K) + XIX(I+1,J,K))
    XIYM = 0.5 * (XIY(I,J,K) + XIY(I+1,J,K))
    XIZM = 0.5 * (XIZ(I,J,K) + XIZ(I+1,J,K))
    ETXM = 0.5 * (ETX(I,J,K) + ETX(I+1,J,K))
    ETYM = 0.5 * (ETY(I,J,K) + ETY(I+1,J,K))
    ETZM = 0.5 * (ETZ(I,J,K) + ETZ(I+1,J,K))
    ZEXM = 0.5 * (ZEX(I,J,K) + ZEX(I+1,J,K))
    ZEYM = 0.5 * (ZEY(I,J,K) + ZEY(I+1,J,K))
    ZEZM = 0.5 * (ZEZ(I,J,K) + ZEZ(I+1,J,K))
    AJAM = 0.5 * (AJA(I,J,K) + AJA(I+1,J,K))
    ! ������
    RHOM  = 0.5 * ( RHO(I,J,K) +  RHO(I+1,J,K))
    UM    = 0.5 * (   U(I,J,K) +    U(I+1,J,K))
    VM    = 0.5 * (   V(I,J,K) +    V(I+1,J,K))
    WM    = 0.5 * (   W(I,J,K) +    W(I+1,J,K))
    AKM   = 0.5 * (  AK(I,J,K) +   AK(I+1,J,K))
    EPSTM = 0.5 * (EPST(I,J,K) + EPST(I+1,J,K))
    AMUM  = 0.5 * ( AMU(I,J,K) +  AMU(I+1,J,K))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = - U(I,J,K) + U(I+1,J,K)
    UET = 0.25 * ( - U(I,J-1,K) - U(I+1,J-1,K) &
    &              + U(I,J+1,K) + U(I+1,J+1,K) )
    UZE = 0.25 * ( - U(I,J,K-1) - U(I+1,J,K-1) &
    &              + U(I,J,K+1) + U(I+1,J,K+1) )
    VXI = - V(I,J,K) + V(I+1,J,K)
    VET = 0.25 * ( - V(I,J-1,K) - V(I+1,J-1,K) &
    &              + V(I,J+1,K) + V(I+1,J+1,K) )
    VZE = 0.25 * ( - V(I,J,K-1) - V(I+1,J,K-1) &
    &              + V(I,J,K+1) + V(I+1,J,K+1) )
    WXI = - W(I,J,K) + W(I+1,J,K)
    WET = 0.25 * ( - W(I,J-1,K) - W(I+1,J-1,K) &
    &              + W(I,J+1,K) + W(I+1,J+1,K) )
    WZE = 0.25 * ( - W(I,J,K-1) - W(I+1,J,K-1) &
    &              + W(I,J,K+1) + W(I+1,J,K+1) )
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM + UZE * ZEXM
    UY = UXI * XIYM + UET * ETYM + UZE * ZEYM
    UZ = UXI * XIZM + UET * ETZM + UZE * ZEZM
    VX = VXI * XIXM + VET * ETXM + VZE * ZEXM
    VY = VXI * XIYM + VET * ETYM + VZE * ZEYM
    VZ = VXI * XIZM + VET * ETZM + VZE * ZEZM
    WX = WXI * XIXM + WET * ETXM + WZE * ZEXM
    WY = WXI * XIYM + WET * ETYM + WZE * ZEYM
    WZ = WXI * XIZM + WET * ETZM + WZE * ZEZM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = - T(I,J,K) + T(I+1,J,K)
    TET = 0.25 * ( - T(I,J-1,K) - T(I+1,J-1,K) &
    &              + T(I,J+1,K) + T(I+1,J+1,K) )
    TZE = 0.25 * ( - T(I,J,K-1) - T(I+1,J,K-1) &
    &              + T(I,J,K+1) + T(I+1,J,K+1) )
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM + TZE * ZEXM
    TY = TXI * XIYM + TET * ETYM + TZE * ZEYM
    TZ = TXI * XIZM + TET * ETZM + TZE * ZEZM
    ! k �̈�K�����̌v�Z -----------------------------------------------
    ! �v�Z��ԕ�����K����
    AKXI = - AK(I,J,K) + AK(I+1,J,K)
    AKET = 0.25 * ( - AK(I,J-1,K) - AK(I+1,J-1,K) &
    &               + AK(I,J+1,K) + AK(I+1,J+1,K) )
    AKZE = 0.25 * ( - AK(I,J,K-1) - AK(I+1,J,K-1) &
    &               + AK(I,J,K+1) + AK(I+1,J,K+1) )
    ! ������ԕ�����K����
    AKX = AKXI * XIXM + AKET * ETXM + AKZE * ZEXM
    AKY = AKXI * XIYM + AKET * ETYM + AKZE * ZEYM
    AKZ = AKXI * XIZM + AKET * ETZM + AKZE * ZEZM
    ! epsilon tilde �̈�K�����̌v�Z -----------------------------------
    ! �v�Z��ԕ�����K����
    AEXI = - EPST(I,J,K) + EPST(I+1,J,K)
    AEET = 0.25 * ( - EPST(I,J-1,K) - EPST(I+1,J-1,K) &
    &               + EPST(I,J+1,K) + EPST(I+1,J+1,K) )
    AEZE = 0.25 * ( - EPST(I,J,K-1) - EPST(I+1,J,K-1) &
    &               + EPST(I,J,K+1) + EPST(I+1,J,K+1) )
    ! ������ԕ�����K����
    AEX = AEXI * XIXM + AEET * ETXM + AEZE * ZEXM
    AEY = AEXI * XIYM + AEET * ETYM + AEZE * ZEYM
    AEZ = AEXI * XIZM + AEET * ETZM + AEZE * ZEZM
    ! �c�ݑ��x�ƉQ�x ---------------------------------------------------
    SS  = (UX + VY + WZ) * TwoThird
    S11 = 2.0 * UX - SS
    S22 = 2.0 * VY - SS
    S33 = 2.0 * WZ - SS
    S12 = UY + VX
    S23 = VZ + WY
    S31 = WX + UZ
    SS2 = S11 * S11 + S22 * S22 + S33 * S33 &
    &   + 2.0 * (S12 * S12 + S23 * S23 + S31 * S31)
    O12 = UY - VX
    O23 = VZ - WY
    O31 = WX - UZ
    OO2 = 2.0 * (O12 * O12 + O23 * O23 + O31 * O31)
    IF(EPSTM .GT. ZERO) THEN
      AKAE = AKM / EPSTM
    ELSE
      AKAE = 0.0
    ENDIF
    ST = AKAE * SQRT(0.5 * SS2)
    OT = AKAE * SQRT(0.5 * OO2)
    ! �񓙕����C�m���Y���̓e���\�� a_ij �̌W���̌v�Z -------------------
    nu = AMUM / RHOM
    IF(EPSTM .GT. ZERO) THEN
      Rtt = AKM**2 / (nu * EPSTM)
    ELSE
      Rtt = 0.0
    ENDIF
    eta  = MAX(ST, OT)
    c_mu = 0.3 / (1.0 + 0.35 * eta**1.5) &
    &    * (1.0 - EXP(-0.36 / MAX(ZERO, EXP(-0.75 * eta))))
    f_mu = 1.0 - EXP(-SQRT(Rtt / 90.0) - (Rtt / 400.0)**2)
    c4   =-10.0 * c_mu**2
    c6   =- 5.0 * c_mu**2
    c7   =  5.0 * c_mu**2
    IF(EPSTM .GT. ZERO) THEN
      nu_t = c_mu * f_mu * AKM**2 / EPSTM
    ELSE
      nu_t = 0.0
    ENDIF
    ! �񓙕����C�m���Y���̓e���\�� a_ij --------------------------------
    IF(AKM .GT. ZERO .OR. EPSTM**2 .GT. ZERO) THEN
      nu_t1 =-nu_t / AKM
      nu_t2 = nu_t / EPSTM
      nu_t3 = nu_t * AKM / EPSTM**2
    ELSE
      nu_t1 = 0.0
      nu_t2 = 0.0
      nu_t3 = 0.0
    ENDIF
    a11 = nu_t1 * S11 &
    &   + nu_t2 * ( &
    &       c1 * (S11 * S11 + S31 * S31 + S12 * S12 - SS2 / 3.0) &
    &     + c2 * (O12 * S12 - O31 * S31) * 2.0 &
    &     + c3 * (O12 * O12 + O31 * O31 - OO2 / 3.0) &
    &   ) &
    &   + nu_t3 * ( &
    &       c4 * ( (S12 * S23 + (S33 + S11) * S31) * O31 &
    &            - (S23 * S31 + (S11 + S22) * S12) * O12 ) * 2.0 &
    &     + (c6 * SS2 + c7 * OO2) * S11 &
    &   )
    a22 = nu_t1 * S22 &
    &   + nu_t2 * ( &
    &       c1 * (S22 * S22 + S12 * S12 + S23 * S23 - SS2 / 3.0) &
    &     + c2 * (O23 * S23 - O12 * S12) * 2.0 &
    &     + c3 * (O23 * O23 + O12 * O12 - OO2 / 3.0) &
    &   ) &
    &   + nu_t3 * ( &
    &       c4 * ( (S23 * S31 + (S11 + S22) * S12) * O12 &
    &            - (S31 * S12 + (S22 + S33) * S23) * O23 ) * 2.0 &
    &     + (c6 * SS2 + c7 * OO2) * S22 &
    &   )
    a33 = nu_t1 * S33 &
    &   + nu_t2 * ( &
    &       c1 * (S33 * S33 + S23 * S23 + S31 * S31 - SS2 / 3.0) &
    &     + c2 * (O31 * S31 - O23 * S23) * 2.0 &
    &     + c3 * (O31 * O31 + O23 * O23 - OO2 / 3.0) &
    &   ) &
    &   + nu_t3 * ( &
    &       c4 * ( (S31 * S12 + (S22 + S33) * S23) * O23 &
    &            - (S12 * S23 + (S33 + S11) * S31) * O31) * 2.0 &
    &     + (c6 * SS2 + c7 * OO2) * S33 &
    &   )
    a12 = nu_t1 * S12 &
    &   + nu_t2 * ( &
    &       c1 * ((S11 + S22) * S12 + S23 * S31) &
    &     + c2 * (O23 * S31 - O31 * S23 - O12 * (S11 - S22)) &
    &     - c3 * (O23 * O31) &
    &   ) &
    &   + nu_t3 * ( &
    &       c4 * ( &
    &         (S11 * S11 - S22 * S22 - S23 * S23 + S31 * S31) * O12 &
    &       + ((S22 + S33) * S23 + S31 * S12) * O31 &
    &       - ((S33 + S11) * S31 + S12 * S23) * O23 &
    &     ) &
    &     + (c6 * SS2 + c7 * OO2) * S12 &
    &   )
    a23 = nu_t1 * S23 &
    &   + nu_t2 * ( &
    &       c1 * ((S22 + S33) * S23 + S31 * S12) &
    &     + c2 * (O31 * S12 - O12 * S31 - O23 * (S22 - S33)) &
    &     - c3 * (O31 * O12) &
    &   ) &
    &   + nu_t3 * ( &
    &       c4 * ( &
    &         (S22 * S22 - S33 * S33 - S31 * S31 + S12 * S12) * O23 &
    &       + ((S11 + S33) * S31 + S12 * S23) * O12 &
    &       - ((S11 + S22) * S12 + S23 * S31) * O31 &
    &     ) &
    &     + (c6 * SS2 + c7 * OO2) * S23 &
    &   )
    a31 = nu_t1 * S31 &
    &   + nu_t2 * ( &
    &       c1 * ((S11 + S33) * S31 + S12 * S23) &
    &     + c2 * (O12 * S23 - O23 * S12 - O31 * (S33 - S11)) &
    &     - c3 * (O12 * O23) &
    &   ) &
    &   + nu_t3 * ( &
    &       c4 * ( &
    &         (S33 * S33 - S11 * S11 - S12 * S12 + S23 * S23) * O31 &
    &       + ((S11 + S22) * S12 + S31 * S23) * O23 &
    &       - ((S22 + S33) * S23 + S12 * S31) * O12 &
    &     ) &
    &     + (c6 * SS2 + c7 * OO2) * S31 &
    &   )
    a11 = MIN(aiimax, MAX(aiimin, a11))
    a22 = MIN(aiimax, MAX(aiimin, a22))
    a33 = MIN(aiimax, MAX(aiimin, a33))
    a12 = MIN(1.0, MAX(-1.0, a12))
    a23 = MIN(1.0, MAX(-1.0, a23))
    a31 = MIN(1.0, MAX(-1.0, a31))
    ! ���C�m���Y���� ---------------------------------------------------
    uu = AKM * (a11 + TwoThird)
    vv = AKM * (a22 + TwoThird)
    ww = AKM * (a33 + TwoThird)
    uv = AKM * a12
    vw = AKM * a23
    wu = AKM * a31
    ! �g�U�W�� ---------------------------------------------------------
    c_t  = (nu / PR + nu_t / PRT) / (GAMMA - 1.0) * GAMMA * RG
    c_k  = nu + nu_t / SIGK
    c_e  = nu + nu_t / SIGE
    ! �S�����͂ƃ��C�m���Y���̘͂a -------------------------------------
    TAUXX = nu * S11 - uu
    TAUYY = nu * S22 - vv
    TAUZZ = nu * S33 - ww
    TAUXY = nu * S12 - uv
    TAUYZ = nu * S23 - vw
    TAUZX = nu * S31 - wu
    ! �G�l���M�[�̊g�U -------------------------------------------------
    R5 = TAUXX * UM + TAUXY * VM + TAUZX * WM + c_t * TX
    S5 = TAUXY * UM + TAUYY * VM + TAUYZ * WM + c_t * TY
    T5 = TAUZX * UM + TAUYZ * VM + TAUZZ * WM + c_t * TZ
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    RH(I,J,K,1) = 0.0
    RH(I,J,K,2) = QH1 * (TAUXX * XIXM + TAUXY * XIYM + TAUZX * XIZM)
    RH(I,J,K,3) = QH1 * (TAUXY * XIXM + TAUYY * XIYM + TAUYZ * XIZM)
    RH(I,J,K,4) = QH1 * (TAUZX * XIXM + TAUYZ * XIYM + TAUZZ * XIZM)
    RH(I,J,K,5) = QH1 * (R5 * XIXM + S5 * XIYM + T5 * XIZM)
    RH(I,J,K,6) = QH1 * c_k * (AKX * XIXM + AKY * XIYM + AKZ * XIZM)
    RH(I,J,K,7) = QH1 * c_e * (AEX * XIXM + AEY * XIYM + AEZ * XIZM)
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFXI
!***********************************************************************
!**** �g�U���̌v�Z(eta���������p)                                   ****
!***********************************************************************
SUBROUTINE DIFFET
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM
  REAL    :: RHOM, UM, VM, WM, AKM, EPSTM, AMUM
  REAL    :: UXI, UET, UZE, UX, UY, UZ
  REAL    :: VXI, VET, VZE, VX, VY, VZ
  REAL    :: WXI, WET, WZE, WX, WY, WZ
  REAL    :: TXI, TET, TZE, TX, TY, TZ
  REAL    :: AKXI, AKET, AKZE, AKX, AKY, AKZ
  REAL    :: AEXI, AEET, AEZE, AEX, AEY, AEZ
  REAL    :: S11, S22, S33, S12, S23, S31, SS2, ST, SS
  REAL    :: O12, O23, O31, OO2, OT
  REAL    :: eta
  REAL    :: nu, nu_t
  REAL    :: Rtt, c_mu, f_mu
  REAL    :: c4, c6, c7
  REAL    :: nu_t1, nu_t2, nu_t3, AKAE
  REAL    :: a11, a22, a33, a12, a23, a31
  REAL    :: uu, vv, ww, uv, vw, wu
  REAL    :: c_t, c_k, c_e
  REAL    :: TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX
  REAL    :: R5, S5, T5
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM, &
!$OMP& RHOM, UM, VM, WM, AKM, EPSTM, AMUM, &
!$OMP& UXI, UET, UZE, UX, UY, UZ, &
!$OMP& VXI, VET, VZE, VX, VY, VZ, &
!$OMP& WXI, WET, WZE, WX, WY, WZ, &
!$OMP& TXI, TET, TZE, TX, TY, TZ, &
!$OMP& AKXI, AKET, AKZE, AKX, AKY, AKZ, &
!$OMP& AEXI, AEET, AEZE, AEX, AEY, AEZ, &
!$OMP& S11, S22, S33, S12, S23, S31, SS2, ST, SS, &
!$OMP& O12, O23, O31, OO2, OT, &
!$OMP& eta, nu, nu_t, Rtt, c_mu, f_mu, c4, c6, c7, &
!$OMP& nu_t1, nu_t2, nu_t3, AKAE, &
!$OMP& a11, a22, a33, a12, a23, a31, uu, vv, ww, uv, vw, wu, &
!$OMP& c_t, c_k, c_e, &
!$OMP& TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX, R5, S5, T5, QH1 &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS    , JE - 1
  DO I = IS + 1, IE - 1
  IF((RHO(I,J,K) .GT. 0.0) .AND. (RHO(I,J+1,K) .GT. 0.0)) THEN
    ! ET�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J,K) + XIX(I,J+1,K))
    XIYM = 0.5 * (XIY(I,J,K) + XIY(I,J+1,K))
    XIZM = 0.5 * (XIZ(I,J,K) + XIZ(I,J+1,K))
    ETXM = 0.5 * (ETX(I,J,K) + ETX(I,J+1,K))
    ETYM = 0.5 * (ETY(I,J,K) + ETY(I,J+1,K))
    ETZM = 0.5 * (ETZ(I,J,K) + ETZ(I,J+1,K))
    ZEXM = 0.5 * (ZEX(I,J,K) + ZEX(I,J+1,K))
    ZEYM = 0.5 * (ZEY(I,J,K) + ZEY(I,J+1,K))
    ZEZM = 0.5 * (ZEZ(I,J,K) + ZEZ(I,J+1,K))
    AJAM = 0.5 * (AJA(I,J,K) + AJA(I,J+1,K))
    ! ������
    RHOM  = 0.5 * ( RHO(I,J,K) +  RHO(I,J+1,K))
    UM    = 0.5 * (   U(I,J,K) +    U(I,J+1,K))
    VM    = 0.5 * (   V(I,J,K) +    V(I,J+1,K))
    WM    = 0.5 * (   W(I,J,K) +    W(I,J+1,K))
    AKM   = 0.5 * (  AK(I,J,K) +   AK(I,J+1,K))
    EPSTM = 0.5 * (EPST(I,J,K) + EPST(I,J+1,K))
    AMUM  = 0.5 * ( AMU(I,J,K) +  AMU(I,J+1,K))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = 0.25 * ( - U(I-1,J,K) - U(I-1,J+1,K) &
    &              + U(I+1,J,K) + U(I+1,J+1,K) )
    UET = - U(I,J,K) + U(I,J+1,K)
    UZE = 0.25 * ( - U(I,J,K-1) - U(I,J+1,K-1) &
    &              + U(I,J,K+1) + U(I,J+1,K+1) )
    VXI = 0.25 * ( - V(I-1,J,K) - V(I-1,J+1,K) &
    &              + V(I+1,J,K) + V(I+1,J+1,K) )
    VET = - V(I,J,K) + V(I,J+1,K)
    VZE = 0.25 * ( - V(I,J,K-1) - V(I,J+1,K-1) &
    &              + V(I,J,K+1) + V(I,J+1,K+1) )
    WXI = 0.25 * ( - W(I-1,J,K) - W(I-1,J+1,K) &
    &              + W(I+1,J,K) + W(I+1,J+1,K) )
    WET = - W(I,J,K) + W(I,J+1,K)
    WZE = 0.25 * ( - W(I,J,K-1) - W(I,J+1,K-1) &
    &              + W(I,J,K+1) + W(I,J+1,K+1) )
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM + UZE * ZEXM
    UY = UXI * XIYM + UET * ETYM + UZE * ZEYM
    UZ = UXI * XIZM + UET * ETZM + UZE * ZEZM
    VX = VXI * XIXM + VET * ETXM + VZE * ZEXM
    VY = VXI * XIYM + VET * ETYM + VZE * ZEYM
    VZ = VXI * XIZM + VET * ETZM + VZE * ZEZM
    WX = WXI * XIXM + WET * ETXM + WZE * ZEXM
    WY = WXI * XIYM + WET * ETYM + WZE * ZEYM
    WZ = WXI * XIZM + WET * ETZM + WZE * ZEZM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = 0.25 * ( - T(I-1,J,K) - T(I-1,J+1,K) &
    &              + T(I+1,J,K) + T(I+1,J+1,K) )
    TET = - T(I,J,K) + T(I,J+1,K)
    TZE = 0.25 * ( - T(I,J,K-1) - T(I,J+1,K-1) &
    &              + T(I,J,K+1) + T(I,J+1,K+1) )
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM + TZE * ZEXM
    TY = TXI * XIYM + TET * ETYM + TZE * ZEYM
    TZ = TXI * XIZM + TET * ETZM + TZE * ZEZM
    ! k �̈�K�����̌v�Z -----------------------------------------------
    ! �v�Z��ԕ�����K����
    AKXI = 0.25 * ( - AK(I-1,J,K) - AK(I-1,J+1,K) &
    &               + AK(I+1,J,K) + AK(I+1,J+1,K) )
    AKET = - AK(I,J,K) + AK(I,J+1,K)
    AKZE = 0.25 * ( - AK(I,J,K-1) - AK(I,J+1,K-1) &
    &               + AK(I,J,K+1) + AK(I,J+1,K+1) )
    ! ������ԕ�����K����
    AKX = AKXI * XIXM + AKET * ETXM + AKZE * ZEXM
    AKY = AKXI * XIYM + AKET * ETYM + AKZE * ZEYM
    AKZ = AKXI * XIZM + AKET * ETZM + AKZE * ZEZM
    ! epsilon tilde �̈�K�����̌v�Z -----------------------------------
    ! �v�Z��ԕ�����K����
    AEXI = 0.25 * ( - EPST(I-1,J,K) - EPST(I-1,J+1,K) &
    &               + EPST(I+1,J,K) + EPST(I+1,J+1,K) )
    AEET = - EPST(I,J,K) + EPST(I,J+1,K)
    AEZE = 0.25 * ( - EPST(I,J,K-1) - EPST(I,J+1,K-1) &
    &               + EPST(I,J,K+1) + EPST(I,J+1,K+1) )
    ! ������ԕ�����K����
    AEX = AEXI * XIXM + AEET * ETXM + AEZE * ZEXM
    AEY = AEXI * XIYM + AEET * ETYM + AEZE * ZEYM
    AEZ = AEXI * XIZM + AEET * ETZM + AEZE * ZEZM
    ! �c�ݑ��x�ƉQ�x ---------------------------------------------------
    SS  = (UX + VY + WZ) * TwoThird
    S11 = 2.0 * UX - SS
    S22 = 2.0 * VY - SS
    S33 = 2.0 * WZ - SS
    S12 = UY + VX
    S23 = VZ + WY
    S31 = WX + UZ
    SS2 = S11 * S11 + S22 * S22 + S33 * S33 &
    &   + 2.0 * (S12 * S12 + S23 * S23 + S31 * S31)
    O12 = UY - VX
    O23 = VZ - WY
    O31 = WX - UZ
    OO2 = 2.0 * (O12 * O12 + O23 * O23 + O31 * O31)
    IF(EPSTM .GT. ZERO) THEN
      AKAE = AKM / EPSTM
    ELSE
      AKAE = 0.0
    ENDIF
    ST = AKAE * SQRT(0.5 * SS2)
    OT = AKAE * SQRT(0.5 * OO2)
    ! �񓙕����C�m���Y���̓e���\�� a_ij �̌W���̌v�Z -------------------
    nu = AMUM / RHOM
    IF(EPSTM .GT. ZERO) THEN
      Rtt = AKM**2 / (nu * EPSTM)
    ELSE
      Rtt = 0.0
    ENDIF
    eta  = MAX(ST, OT)
    c_mu = 0.3 / (1.0 + 0.35 * eta**1.5) &
    &    * (1.0 - EXP(-0.36 / MAX(ZERO, EXP(-0.75 * eta))))
    f_mu = 1.0 - EXP(-SQRT(Rtt / 90.0) - (Rtt / 400.0)**2)
    c4   =-10.0 * c_mu**2
    c6   =- 5.0 * c_mu**2
    c7   =  5.0 * c_mu**2
    IF(EPSTM .GT. ZERO) THEN
      nu_t = c_mu * f_mu * AKM**2 / EPSTM
    ELSE
      nu_t = 0.0
    ENDIF
    ! �񓙕����C�m���Y���̓e���\�� a_ij --------------------------------
    IF(AKM .GT. ZERO .OR. EPSTM**2 .GT. ZERO) THEN
      nu_t1 =-nu_t / AKM
      nu_t2 = nu_t / EPSTM
      nu_t3 = nu_t * AKM / EPSTM**2
    ELSE
      nu_t1 = 0.0
      nu_t2 = 0.0
      nu_t3 = 0.0
    ENDIF
    a11 = nu_t1 * S11 &
    &   + nu_t2 * ( &
    &       c1 * (S11 * S11 + S31 * S31 + S12 * S12 - SS2 / 3.0) &
    &     + c2 * (O12 * S12 - O31 * S31) * 2.0 &
    &     + c3 * (O12 * O12 + O31 * O31 - OO2 / 3.0) &
    &   ) &
    &   + nu_t3 * ( &
    &       c4 * ( (S12 * S23 + (S33 + S11) * S31) * O31 &
    &            - (S23 * S31 + (S11 + S22) * S12) * O12 ) * 2.0 &
    &     + (c6 * SS2 + c7 * OO2) * S11 &
    &   )
    a22 = nu_t1 * S22 &
    &   + nu_t2 * ( &
    &       c1 * (S22 * S22 + S12 * S12 + S23 * S23 - SS2 / 3.0) &
    &     + c2 * (O23 * S23 - O12 * S12) * 2.0 &
    &     + c3 * (O23 * O23 + O12 * O12 - OO2 / 3.0) &
    &   ) &
    &   + nu_t3 * ( &
    &       c4 * ( (S23 * S31 + (S11 + S22) * S12) * O12 &
    &            - (S31 * S12 + (S22 + S33) * S23) * O23 ) * 2.0 &
    &     + (c6 * SS2 + c7 * OO2) * S22 &
    &   )
    a33 = nu_t1 * S33 &
    &   + nu_t2 * ( &
    &       c1 * (S33 * S33 + S23 * S23 + S31 * S31 - SS2 / 3.0) &
    &     + c2 * (O31 * S31 - O23 * S23) * 2.0 &
    &     + c3 * (O31 * O31 + O23 * O23 - OO2 / 3.0) &
    &   ) &
    &   + nu_t3 * ( &
    &       c4 * ( (S31 * S12 + (S22 + S33) * S23) * O23 &
    &            - (S12 * S23 + (S33 + S11) * S31) * O31) * 2.0 &
    &     + (c6 * SS2 + c7 * OO2) * S33 &
    &   )
    a12 = nu_t1 * S12 &
    &   + nu_t2 * ( &
    &       c1 * ((S11 + S22) * S12 + S23 * S31) &
    &     + c2 * (O23 * S31 - O31 * S23 - O12 * (S11 - S22)) &
    &     - c3 * (O23 * O31) &
    &   ) &
    &   + nu_t3 * ( &
    &       c4 * ( &
    &         (S11 * S11 - S22 * S22 - S23 * S23 + S31 * S31) * O12 &
    &       + ((S22 + S33) * S23 + S31 * S12) * O31 &
    &       - ((S33 + S11) * S31 + S12 * S23) * O23 &
    &     ) &
    &     + (c6 * SS2 + c7 * OO2) * S12 &
    &   )
    a23 = nu_t1 * S23 &
    &   + nu_t2 * ( &
    &       c1 * ((S22 + S33) * S23 + S31 * S12) &
    &     + c2 * (O31 * S12 - O12 * S31 - O23 * (S22 - S33)) &
    &     - c3 * (O31 * O12) &
    &   ) &
    &   + nu_t3 * ( &
    &       c4 * ( &
    &         (S22 * S22 - S33 * S33 - S31 * S31 + S12 * S12) * O23 &
    &       + ((S11 + S33) * S31 + S12 * S23) * O12 &
    &       - ((S11 + S22) * S12 + S23 * S31) * O31 &
    &     ) &
    &     + (c6 * SS2 + c7 * OO2) * S23 &
    &   )
    a31 = nu_t1 * S31 &
    &   + nu_t2 * ( &
    &       c1 * ((S11 + S33) * S31 + S12 * S23) &
    &     + c2 * (O12 * S23 - O23 * S12 - O31 * (S33 - S11)) &
    &     - c3 * (O12 * O23) &
    &   ) &
    &   + nu_t3 * ( &
    &       c4 * ( &
    &         (S33 * S33 - S11 * S11 - S12 * S12 + S23 * S23) * O31 &
    &       + ((S11 + S22) * S12 + S31 * S23) * O23 &
    &       - ((S22 + S33) * S23 + S12 * S31) * O12 &
    &     ) &
    &     + (c6 * SS2 + c7 * OO2) * S31 &
    &   )
    a11 = MIN(aiimax, MAX(aiimin, a11))
    a22 = MIN(aiimax, MAX(aiimin, a22))
    a33 = MIN(aiimax, MAX(aiimin, a33))
    a12 = MIN(1.0, MAX(-1.0, a12))
    a23 = MIN(1.0, MAX(-1.0, a23))
    a31 = MIN(1.0, MAX(-1.0, a31))
    ! ���C�m���Y���� ---------------------------------------------------
    uu = AKM * (a11 + TwoThird)
    vv = AKM * (a22 + TwoThird)
    ww = AKM * (a33 + TwoThird)
    uv = AKM * a12
    vw = AKM * a23
    wu = AKM * a31
    ! �g�U�W�� ---------------------------------------------------------
    c_t  = (nu / PR + nu_t / PRT) / (GAMMA - 1.0) * GAMMA * RG
    c_k  = nu + nu_t / SIGK
    c_e  = nu + nu_t / SIGE
    ! �S�����͂ƃ��C�m���Y���̘͂a -------------------------------------
    TAUXX = nu * S11 - uu
    TAUYY = nu * S22 - vv
    TAUZZ = nu * S33 - ww
    TAUXY = nu * S12 - uv
    TAUYZ = nu * S23 - vw
    TAUZX = nu * S31 - wu
    ! �G�l���M�[�̊g�U -------------------------------------------------
    R5 = TAUXX * UM + TAUXY * VM + TAUZX * WM + c_t * TX
    S5 = TAUXY * UM + TAUYY * VM + TAUYZ * WM + c_t * TY
    T5 = TAUZX * UM + TAUYZ * VM + TAUZZ * WM + c_t * TZ
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    SH(I,J,K,1) = 0.0
    SH(I,J,K,2) = QH1 * (TAUXX * ETXM + TAUXY * ETYM + TAUZX * ETZM)
    SH(I,J,K,3) = QH1 * (TAUXY * ETXM + TAUYY * ETYM + TAUYZ * ETZM)
    SH(I,J,K,4) = QH1 * (TAUZX * ETXM + TAUYZ * ETYM + TAUZZ * ETZM)
    SH(I,J,K,5) = QH1 * (R5 * ETXM + S5 * ETYM + T5 * ETZM)
    SH(I,J,K,6) = QH1 * c_k * (AKX * ETXM + AKY * ETYM + AKZ * ETZM)
    SH(I,J,K,7) = QH1 * c_e * (AEX * ETXM + AEY * ETYM + AEZ * ETZM)
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFET
!***********************************************************************
!**** �g�U���̌v�Z(zeta���������p)                                  ****
!***********************************************************************
SUBROUTINE DIFFZE
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM
  REAL    :: RHOM, UM, VM, WM, AKM, EPSTM, AMUM
  REAL    :: UXI, UET, UZE, UX, UY, UZ
  REAL    :: VXI, VET, VZE, VX, VY, VZ
  REAL    :: WXI, WET, WZE, WX, WY, WZ
  REAL    :: TXI, TET, TZE, TX, TY, TZ
  REAL    :: AKXI, AKET, AKZE, AKX, AKY, AKZ
  REAL    :: AEXI, AEET, AEZE, AEX, AEY, AEZ
  REAL    :: S11, S22, S33, S12, S23, S31, SS2, ST, SS
  REAL    :: O12, O23, O31, OO2, OT
  REAL    :: eta
  REAL    :: nu, nu_t
  REAL    :: Rtt, c_mu, f_mu
  REAL    :: c4, c6, c7
  REAL    :: nu_t1, nu_t2, nu_t3, AKAE
  REAL    :: a11, a22, a33, a12, a23, a31
  REAL    :: uu, vv, ww, uv, vw, wu
  REAL    :: c_t, c_k, c_e
  REAL    :: TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX
  REAL    :: R5, S5, T5
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM, &
!$OMP& RHOM, UM, VM, WM, AKM, EPSTM, AMUM, &
!$OMP& UXI, UET, UZE, UX, UY, UZ, &
!$OMP& VXI, VET, VZE, VX, VY, VZ, &
!$OMP& WXI, WET, WZE, WX, WY, WZ, &
!$OMP& TXI, TET, TZE, TX, TY, TZ, &
!$OMP& AKXI, AKET, AKZE, AKX, AKY, AKZ, &
!$OMP& AEXI, AEET, AEZE, AEX, AEY, AEZ, &
!$OMP& S11, S22, S33, S12, S23, S31, SS2, ST, SS, &
!$OMP& O12, O23, O31, OO2, OT, &
!$OMP& eta, nu, nu_t, Rtt, c_mu, f_mu, c4, c6, c7, &
!$OMP& nu_t1, nu_t2, nu_t3, AKAE, &
!$OMP& a11, a22, a33, a12, a23, a31, uu, vv, ww, uv, vw, wu, &
!$OMP& c_t, c_k, c_e, &
!$OMP& TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX, R5, S5, T5, QH1 &
!$OMP& )
  DO K = KS    , KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF((RHO(I,J,K) .GT. 0.0) .AND. (RHO(I,J,K+1) .GT. 0.0)) THEN
    ! ZE�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J,K) + XIX(I,J,K+1))
    XIYM = 0.5 * (XIY(I,J,K) + XIY(I,J,K+1))
    XIZM = 0.5 * (XIZ(I,J,K) + XIZ(I,J,K+1))
    ETXM = 0.5 * (ETX(I,J,K) + ETX(I,J,K+1))
    ETYM = 0.5 * (ETY(I,J,K) + ETY(I,J,K+1))
    ETZM = 0.5 * (ETZ(I,J,K) + ETZ(I,J,K+1))
    ZEXM = 0.5 * (ZEX(I,J,K) + ZEX(I,J,K+1))
    ZEYM = 0.5 * (ZEY(I,J,K) + ZEY(I,J,K+1))
    ZEZM = 0.5 * (ZEZ(I,J,K) + ZEZ(I,J,K+1))
    AJAM = 0.5 * (AJA(I,J,K) + AJA(I,J,K+1))
    ! ������
    RHOM  = 0.5 * ( RHO(I,J,K) +  RHO(I,J,K+1))
    UM    = 0.5 * (   U(I,J,K) +    U(I,J,K+1))
    VM    = 0.5 * (   V(I,J,K) +    V(I,J,K+1))
    WM    = 0.5 * (   W(I,J,K) +    W(I,J,K+1))
    AKM   = 0.5 * (  AK(I,J,K) +   AK(I,J,K+1))
    EPSTM = 0.5 * (EPST(I,J,K) + EPST(I,J,K+1))
    AMUM  = 0.5 * ( AMU(I,J,K) +  AMU(I,J,K+1))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = 0.25 * ( - U(I-1,J,K) - U(I-1,J,K+1) &
    &              + U(I+1,J,K) + U(I+1,J,K+1) )
    UET = 0.25 * ( - U(I,J-1,K) - U(I,J-1,K+1) &
    &              + U(I,J+1,K) + U(I,J+1,K+1) )
    UZE = - U(I,J,K) + U(I,J,K+1)
    VXI = 0.25 * ( - V(I-1,J,K) - V(I-1,J,K+1) &
    &              + V(I+1,J,K) + V(I+1,J,K+1) )
    VET = 0.25 * ( - V(I,J-1,K) - V(I,J-1,K+1) &
    &              + V(I,J+1,K) + V(I,J+1,K+1) )
    VZE = - V(I,J,K) + V(I,J,K+1)
    WXI = 0.25 * ( - W(I-1,J,K) - W(I-1,J,K+1) &
    &              + W(I+1,J,K) + W(I+1,J,K+1) )
    WET = 0.25 * ( - W(I,J-1,K) - W(I,J-1,K+1) &
    &              + W(I,J+1,K) + W(I,J+1,K+1) )
    WZE = - W(I,J,K) + W(I,J,K+1)
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM + UZE * ZEXM
    UY = UXI * XIYM + UET * ETYM + UZE * ZEYM
    UZ = UXI * XIZM + UET * ETZM + UZE * ZEZM
    VX = VXI * XIXM + VET * ETXM + VZE * ZEXM
    VY = VXI * XIYM + VET * ETYM + VZE * ZEYM
    VZ = VXI * XIZM + VET * ETZM + VZE * ZEZM
    WX = WXI * XIXM + WET * ETXM + WZE * ZEXM
    WY = WXI * XIYM + WET * ETYM + WZE * ZEYM
    WZ = WXI * XIZM + WET * ETZM + WZE * ZEZM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = 0.25 * ( - T(I-1,J,K) - T(I-1,J,K+1) &
    &              + T(I+1,J,K) + T(I+1,J,K+1) )
    TET = 0.25 * ( - T(I,J-1,K) - T(I,J-1,K+1) &
    &              + T(I,J+1,K) + T(I,J+1,K+1) )
    TZE = - T(I,J,K) + T(I,J,K+1)
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM + TZE * ZEXM
    TY = TXI * XIYM + TET * ETYM + TZE * ZEYM
    TZ = TXI * XIZM + TET * ETZM + TZE * ZEZM
    ! k �̈�K�����̌v�Z -----------------------------------------------
    ! �v�Z��ԕ�����K����
    AKXI = 0.25 * ( - AK(I-1,J,K) - AK(I-1,J,K+1) &
    &               + AK(I+1,J,K) + AK(I+1,J,K+1) )
    AKET = 0.25 * ( - AK(I,J-1,K) - AK(I,J-1,K+1) &
    &               + AK(I,J+1,K) + AK(I,J+1,K+1) )
    AKZE = - AK(I,J,K) + AK(I,J,K+1)
    ! ������ԕ�����K����
    AKX = AKXI * XIXM + AKET * ETXM + AKZE * ZEXM
    AKY = AKXI * XIYM + AKET * ETYM + AKZE * ZEYM
    AKZ = AKXI * XIZM + AKET * ETZM + AKZE * ZEZM
    ! epsilon tilde �̈�K�����̌v�Z -----------------------------------
    ! �v�Z��ԕ�����K����
    AEXI = 0.25 * ( - EPST(I-1,J,K) - EPST(I-1,J,K+1) &
    &               + EPST(I+1,J,K) + EPST(I+1,J,K+1) )
    AEET = 0.25 * ( - EPST(I,J-1,K) - EPST(I,J-1,K+1) &
    &               + EPST(I,J+1,K) + EPST(I,J+1,K+1) )
    AEZE = - EPST(I,J,K) + EPST(I,J,K+1)
    ! ������ԕ�����K����
    AEX = AEXI * XIXM + AEET * ETXM + AEZE * ZEXM
    AEY = AEXI * XIYM + AEET * ETYM + AEZE * ZEYM
    AEZ = AEXI * XIZM + AEET * ETZM + AEZE * ZEZM
    ! �c�ݑ��x�ƉQ�x ---------------------------------------------------
    SS  = (UX + VY + WZ) * TwoThird
    S11 = 2.0 * UX - SS
    S22 = 2.0 * VY - SS
    S33 = 2.0 * WZ - SS
    S12 = UY + VX
    S23 = VZ + WY
    S31 = WX + UZ
    SS2 = S11 * S11 + S22 * S22 + S33 * S33 &
    &   + 2.0 * (S12 * S12 + S23 * S23 + S31 * S31)
    O12 = UY - VX
    O23 = VZ - WY
    O31 = WX - UZ
    OO2 = 2.0 * (O12 * O12 + O23 * O23 + O31 * O31)
    IF(EPSTM .GT. ZERO) THEN
      AKAE = AKM / EPSTM
    ELSE
      AKAE = 0.0
    ENDIF
    ST = AKAE * SQRT(0.5 * SS2)
    OT = AKAE * SQRT(0.5 * OO2)
    ! �񓙕����C�m���Y���̓e���\�� a_ij �̌W���̌v�Z -------------------
    nu = AMUM / RHOM
    IF(EPSTM .GT. ZERO) THEN
      Rtt = AKM**2 / (nu * EPSTM)
    ELSE
      Rtt = 0.0
    ENDIF
    eta  = MAX(ST, OT)
    c_mu = 0.3 / (1.0 + 0.35 * eta**1.5) &
    &    * (1.0 - EXP(-0.36 / MAX(ZERO, EXP(-0.75 * eta))))
    f_mu = 1.0 - EXP(-SQRT(Rtt / 90.0) - (Rtt / 400.0)**2)
    c4   =-10.0 * c_mu**2
    c6   =- 5.0 * c_mu**2
    c7   =  5.0 * c_mu**2
    IF(EPSTM .GT. ZERO) THEN
      nu_t = c_mu * f_mu * AKM**2 / EPSTM
    ELSE
      nu_t = 0.0
    ENDIF
    ! �񓙕����C�m���Y���̓e���\�� a_ij --------------------------------
    IF(AKM .GT. ZERO .OR. EPSTM**2 .GT. ZERO) THEN
      nu_t1 =-nu_t / AKM
      nu_t2 = nu_t / EPSTM
      nu_t3 = nu_t * AKM / EPSTM**2
    ELSE
      nu_t1 = 0.0
      nu_t2 = 0.0
      nu_t3 = 0.0
    ENDIF
    a11 = nu_t1 * S11 &
    &   + nu_t2 * ( &
    &       c1 * (S11 * S11 + S31 * S31 + S12 * S12 - SS2 / 3.0) &
    &     + c2 * (O12 * S12 - O31 * S31) * 2.0 &
    &     + c3 * (O12 * O12 + O31 * O31 - OO2 / 3.0) &
    &   ) &
    &   + nu_t3 * ( &
    &       c4 * ( (S12 * S23 + (S33 + S11) * S31) * O31 &
    &            - (S23 * S31 + (S11 + S22) * S12) * O12 ) * 2.0 &
    &     + (c6 * SS2 + c7 * OO2) * S11 &
    &   )
    a22 = nu_t1 * S22 &
    &   + nu_t2 * ( &
    &       c1 * (S22 * S22 + S12 * S12 + S23 * S23 - SS2 / 3.0) &
    &     + c2 * (O23 * S23 - O12 * S12) * 2.0 &
    &     + c3 * (O23 * O23 + O12 * O12 - OO2 / 3.0) &
    &   ) &
    &   + nu_t3 * ( &
    &       c4 * ( (S23 * S31 + (S11 + S22) * S12) * O12 &
    &            - (S31 * S12 + (S22 + S33) * S23) * O23 ) * 2.0 &
    &     + (c6 * SS2 + c7 * OO2) * S22 &
    &   )
    a33 = nu_t1 * S33 &
    &   + nu_t2 * ( &
    &       c1 * (S33 * S33 + S23 * S23 + S31 * S31 - SS2 / 3.0) &
    &     + c2 * (O31 * S31 - O23 * S23) * 2.0 &
    &     + c3 * (O31 * O31 + O23 * O23 - OO2 / 3.0) &
    &   ) &
    &   + nu_t3 * ( &
    &       c4 * ( (S31 * S12 + (S22 + S33) * S23) * O23 &
    &            - (S12 * S23 + (S33 + S11) * S31) * O31) * 2.0 &
    &     + (c6 * SS2 + c7 * OO2) * S33 &
    &   )
    a12 = nu_t1 * S12 &
    &   + nu_t2 * ( &
    &       c1 * ((S11 + S22) * S12 + S23 * S31) &
    &     + c2 * (O23 * S31 - O31 * S23 - O12 * (S11 - S22)) &
    &     - c3 * (O23 * O31) &
    &   ) &
    &   + nu_t3 * ( &
    &       c4 * ( &
    &         (S11 * S11 - S22 * S22 - S23 * S23 + S31 * S31) * O12 &
    &       + ((S22 + S33) * S23 + S31 * S12) * O31 &
    &       - ((S33 + S11) * S31 + S12 * S23) * O23 &
    &     ) &
    &     + (c6 * SS2 + c7 * OO2) * S12 &
    &   )
    a23 = nu_t1 * S23 &
    &   + nu_t2 * ( &
    &       c1 * ((S22 + S33) * S23 + S31 * S12) &
    &     + c2 * (O31 * S12 - O12 * S31 - O23 * (S22 - S33)) &
    &     - c3 * (O31 * O12) &
    &   ) &
    &   + nu_t3 * ( &
    &       c4 * ( &
    &         (S22 * S22 - S33 * S33 - S31 * S31 + S12 * S12) * O23 &
    &       + ((S11 + S33) * S31 + S12 * S23) * O12 &
    &       - ((S11 + S22) * S12 + S23 * S31) * O31 &
    &     ) &
    &     + (c6 * SS2 + c7 * OO2) * S23 &
    &   )
    a31 = nu_t1 * S31 &
    &   + nu_t2 * ( &
    &       c1 * ((S11 + S33) * S31 + S12 * S23) &
    &     + c2 * (O12 * S23 - O23 * S12 - O31 * (S33 - S11)) &
    &     - c3 * (O12 * O23) &
    &   ) &
    &   + nu_t3 * ( &
    &       c4 * ( &
    &         (S33 * S33 - S11 * S11 - S12 * S12 + S23 * S23) * O31 &
    &       + ((S11 + S22) * S12 + S31 * S23) * O23 &
    &       - ((S22 + S33) * S23 + S12 * S31) * O12 &
    &     ) &
    &     + (c6 * SS2 + c7 * OO2) * S31 &
    &   )
    a11 = MIN(aiimax, MAX(aiimin, a11))
    a22 = MIN(aiimax, MAX(aiimin, a22))
    a33 = MIN(aiimax, MAX(aiimin, a33))
    a12 = MIN(1.0, MAX(-1.0, a12))
    a23 = MIN(1.0, MAX(-1.0, a23))
    a31 = MIN(1.0, MAX(-1.0, a31))
    ! ���C�m���Y���� ---------------------------------------------------
    uu = AKM * (a11 + TwoThird)
    vv = AKM * (a22 + TwoThird)
    ww = AKM * (a33 + TwoThird)
    uv = AKM * a12
    vw = AKM * a23
    wu = AKM * a31
    ! �g�U�W�� ---------------------------------------------------------
    c_t  = (nu / PR + nu_t / PRT) / (GAMMA - 1.0) * GAMMA * RG
    c_k  = nu + nu_t / SIGK
    c_e  = nu + nu_t / SIGE
    ! �S�����͂ƃ��C�m���Y���̘͂a -------------------------------------
    TAUXX = nu * S11 - uu
    TAUYY = nu * S22 - vv
    TAUZZ = nu * S33 - ww
    TAUXY = nu * S12 - uv
    TAUYZ = nu * S23 - vw
    TAUZX = nu * S31 - wu
    ! �G�l���M�[�̊g�U -------------------------------------------------
    R5 = TAUXX * UM + TAUXY * VM + TAUZX * WM + c_t * TX
    S5 = TAUXY * UM + TAUYY * VM + TAUYZ * WM + c_t * TY
    T5 = TAUZX * UM + TAUYZ * VM + TAUZZ * WM + c_t * TZ
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    TH(I,J,K,1) = 0.0
    TH(I,J,K,2) = QH1 * (TAUXX * ZEXM + TAUXY * ZEYM + TAUZX * ZEZM)
    TH(I,J,K,3) = QH1 * (TAUXY * ZEXM + TAUYY * ZEYM + TAUYZ * ZEZM)
    TH(I,J,K,4) = QH1 * (TAUZX * ZEXM + TAUYZ * ZEYM + TAUZZ * ZEZM)
    TH(I,J,K,5) = QH1 * (R5 * ZEXM + S5 * ZEYM + T5 * ZEZM)
    TH(I,J,K,6) = QH1 * c_k * (AKX * ZEXM + AKY * ZEYM + AKZ * ZEZM)
    TH(I,J,K,7) = QH1 * c_e * (AEX * ZEXM + AEY * ZEYM + AEZ * ZEZM)
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFZE
! ��`�I�� *************************************************************
END SUBROUTINE Turbulence3DNlEvmkeCLS
!***********************************************************************
!**** �������f�� : RANS, RSM Gibson-Launder Model (1978)            ****
!****              �����M�`�B�ɂ�Vandromme�̃��f�����g�p            ****
!**** �v�Z�Ώ� : �P��, �񎟌�, ���k��                               ****
!**** �v�Z�X�L�[�� : �񎟐��x���S����(�X�^�K�[�h�i�q��̓_���g�p)   ****
!***********************************************************************
SUBROUTINE Turbulence2DRSMGL( &
&            PELIM, RG, GAMMA, PR, &
&            IS, IE, JS, JE, LS, LE, &
&            XIX, XIY, ETX, ETY, AJA, &
&            RHO, U, V, T, uu, vv, ww, uv, EPS, AMU, &
&            n1, n2, d, &
&            AMUT, DQD, DQP &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, PARAMETER :: C_se = 0.313
  REAL, PARAMETER :: C_s = 0.22, C_e = 0.18
  REAL, PARAMETER :: C_1 = 1.8, C_2 = 0.6
  REAL, PARAMETER :: C_l = 2.5
  REAL, PARAMETER :: C_w1 = 0.5, C_w2 = 0.3
  REAL, PARAMETER :: C_e1 = 1.44, C_e2 = 1.92
  REAL, PARAMETER :: TwoThird = 0.66666667
  REAL, PARAMETER :: ZERO = 1.0E-20
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: PELIM
  REAL,    INTENT(IN)  :: RG, GAMMA, PR
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE
  INTEGER, INTENT(IN)  :: LS, LE
  REAL,    INTENT(IN)  :: XIX(IS:IE, JS:JE), XIY(IS:IE, JS:JE), &
  &                       ETX(IS:IE, JS:JE), ETY(IS:IE, JS:JE), &
  &                       AJA(IS:IE, JS:JE)
  REAL,    INTENT(IN)  :: RHO(IS:IE, JS:JE), &
  &                       U(IS:IE, JS:JE), &
  &                       V(IS:IE, JS:JE), &
  &                       T(IS:IE, JS:JE), &
  &                       uu(IS:IE, JS:JE), &
  &                       vv(IS:IE, JS:JE), &
  &                       ww(IS:IE, JS:JE), &
  &                       uv(IS:IE, JS:JE), &
  &                       EPS(IS:IE, JS:JE)
  REAL,    INTENT(IN)  :: AMU(IS:IE, JS:JE)
  REAL,    INTENT(IN)  :: n1(IS:IE, JS:JE), n2(IS:IE, JS:JE)
  REAL,    INTENT(IN)  :: d(IS:IE, JS:JE)
  REAL,    INTENT(OUT) :: AMUT(IS:IE, JS:JE)
  REAL,    INTENT(OUT) :: DQD(IS:IE, JS:JE, LS:LE)
  REAL,    INTENT(OUT) :: DQP(IS:IE, JS:JE, LS:LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, ALLOCATABLE :: RH(:, :, :), SH(:, :, :)
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 9) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �������m�� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ALLOCATE(RH(IS: IE, JS: JE, LS: LE), SH(IS: IE, JS: JE, LS: LE))
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  AMUT = 0.0
  DQD  = 0.0
  DQP  = 0.0
  ! �����葱���̌Ăяo�� +++++++++++++++++++++++++++++++++++++++++++++++
  CALL NonDiffTerm
  CALL DiffTerm
  ! �����I�� ***********************************************************
  RETURN
! �����葱�� ***********************************************************
CONTAINS
!***********************************************************************
!**** ��g�U���̌v�Z                                                ****
!***********************************************************************
SUBROUTINE NonDiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: TMP, TMP1, TMPw, TMPw1, TMPw2, TMPw1km, TMPw2km
  REAL    :: UXI, VXI, UET, VET, UX, VX, UY, VY
  REAL    :: P11, P22, P33, P12, P_k
  REAL    :: eps11, eps22, eps33, eps12, e_k
  REAL    :: phi1_11, phi1_22, phi1_33, phi1_12
  REAL    :: phi2_11, phi2_22, phi2_33, phi2_12
  REAL    :: phiw1_11, phiw1_22, phiw1_33, phiw1_12
  REAL    :: phiw2_11, phiw2_22, phiw2_33, phiw2_12
  REAL    :: phi11, phi22, phi33, phi12
  REAL    :: AK, SS2, nu, AEAK
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, &
!$OMP& TMP, TMP1, TMPw, TMPw1, TMPw2, TMPw1km, TMPw2km, &
!$OMP& UXI, VXI, UET, VET, UX, VX, UY, VY, &
!$OMP& P11, P22, P33, P12, P_k, &
!$OMP& eps11, eps22, eps33, eps12, e_k, &
!$OMP& phi1_11, phi1_22, phi1_33, phi1_12, &
!$OMP& phi2_11, phi2_22, phi2_33, phi2_12, &
!$OMP& phiw1_11, phiw1_22, phiw1_33, phiw1_12, &
!$OMP& phiw2_11, phiw2_22, phiw2_33, phiw2_12, &
!$OMP& phi11, phi22, phi33, phi12, &
!$OMP& AK, SS2, nu, AEAK, QH1 &
!$OMP& )
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF(RHO(I,J) .GT. 0.0) THEN
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = 0.5 * (U(I+1,J) - U(I-1,J))
    VXI = 0.5 * (V(I+1,J) - V(I-1,J))
    UET = 0.5 * (U(I,J+1) - U(I,J-1))
    VET = 0.5 * (V(I,J+1) - V(I,J-1))
    ! ������ԕ�����K����
    UX = UXI * XIX(I,J) + UET * ETX(I,J)
    UY = UXI * XIY(I,J) + UET * ETY(I,J)
    VX = VXI * XIX(I,J) + VET * ETX(I,J)
    VY = VXI * XIY(I,J) + VET * ETY(I,J)
    ! �������ƎU�퍀 ---------------------------------------------------
    P11 = - 2.0 * (uu(I,J) * UX + uv(I,J) * UY)
    P22 = - 2.0 * (uv(I,J) * VX + vv(I,J) * VY)
    P33 = 0.0
    P12 = - (uu(I,J) * VX + uv(I,J) * (UX + VY) + vv(I,J) * UY)
    P_k = 0.5 * (P11 + P22 + P33)
    e_k = EPS(I,J)
    ! �Ǐ����t����(�����ƎU��̃o�����X)�ɂ�郊�~�b�^�[
    IF(PELIM .GT. 0.0) THEN
      TMP = TwoThird * e_k / PELIM
      P11 = MIN(TMP, MAX(-TMP, P11))
      P22 = MIN(TMP, MAX(-TMP, P22))
      P33 = MIN(TMP, MAX(-TMP, P33))
      P_k = 0.5 * (P11 + P22 + P33)
    ENDIF
    TMP   = TwoThird * e_k
    eps11 = TMP
    eps22 = TMP
    eps33 = TMP
    eps12 = 0.0
    ! e / k (���ԃX�P�[�����~�b�^�[) -----------------------------------
    AK   = 0.5 * (uu(I,J) + vv(I,J) + ww(I,J))
    SS2  = 2.0 * (UX**2 + VY**2) + (UY + VX)**2 &
    &    - TwoThird * (UX + VY)**2
    nu   = AMU(I,J) / RHO(I,J)
    AEAK = MIN(MAX(SQRT(SS2), SQRT(e_k / nu)), e_k / MAX(ZERO, AK))
    ! �ĕ��z�� ---------------------------------------------------------
    TMP1    = - C_1 * AEAK
    phi1_11 = TMP1 * (uu(I,J) - TwoThird * AK)
    phi1_22 = TMP1 * (vv(I,J) - TwoThird * AK)
    phi1_33 = TMP1 * (ww(I,J) - TwoThird * AK)
    phi1_12 = TMP1 * uv(I,J)
    phi2_11 = - C_2 * (P11 - TwoThird * P_k)
    phi2_22 = - C_2 * (P22 - TwoThird * P_k)
    phi2_33 = - C_2 * (P33 - TwoThird * P_k)
    phi2_12 = - C_2 * P12
    IF(C_l * e_k * d(I,J) .GT. ZERO) THEN
      TMPw = AK**1.5 / MAX(ZERO, (C_l * e_k * d(I,J)))
      ! �ǖʔ��ˍ��̃_���s���O�֐��̐���
      ! TMPw = MIN(1.0, MAX(0.0, TMPw))
    ELSE
      TMPw = 0.0
    ENDIF
    TMPw1   = C_w1 * TMPw * AEAK
    TMPw2   = C_w2 * TMPw
    TMPw1km = uu(I,J) * n1(I,J) * n1(I,J) &
    &       + vv(I,J) * n2(I,J) * n2(I,J) &
    &       + 2.0 * uv(I,J) * n1(I,J) * n2(I,J)
    TMPw2km = phi2_11 * n1(I,J) * n1(I,J) &
    &       + phi2_22 * n2(I,J) * n2(I,J) &
    &       + 2.0 * phi2_12 * n1(I,J) * n2(I,J)
    phiw1_11 = TMPw1 * (TMPw1km - 3.0 * n1(I,J) &
    &          * (uu(I,J) * n1(I,J) + uv(I,J) * n2(I,J)) &
    &        )
    phiw1_22 = TMPw1 * (TMPw1km - 3.0 * n2(I,J) &
    &          * (uv(I,J) * n1(I,J) + vv(I,J) * n2(I,J)) &
    &        )
    phiw1_33 = TMPw1 * TMPw1km
    phiw1_12 = - 1.5 * TMPw1 * ( &
    &          n1(I,J) * (uv(I,J) * n1(I,J) + vv(I,J) * n2(I,J)) &
    &        + n2(I,J) * (uu(I,J) * n1(I,J) + uv(I,J) * n2(I,J)) &
    &        )
    phiw2_11 = TMPw2 * (TMPw2km - 3.0 * n1(I,J) &
    &          * (phi2_11 * n1(I,J) + phi2_12 * n2(I,J)) &
    &        )
    phiw2_22 = TMPw2 * (TMPw2km - 3.0 * n2(I,J) &
    &          * (phi2_12 * n1(I,J) + phi2_22 * n2(I,J)) &
    &        )
    phiw2_33 = TMPw2 * TMPw2km
    phiw2_12 = - 1.5 * TMPw2 * ( &
    &          n1(I,J) * (phi2_12 * n1(I,J) + phi2_22 * n2(I,J)) &
    &        + n2(I,J) * (phi2_11 * n1(I,J) + phi2_12 * n2(I,J)) &
    &        )
    phi11 = phi1_11 + phi2_11 + phiw1_11 + phiw2_11
    phi22 = phi1_22 + phi2_22 + phiw1_22 + phiw2_22
    phi33 = phi1_33 + phi2_33 + phiw1_33 + phiw2_33
    phi12 = phi1_12 + phi2_12 + phiw1_12 + phiw2_12
    ! �Q�S���W���̌v�Z -------------------------------------------------
    IF(e_k .GT. ZERO) THEN
      AMUT(I,J) = 0.09 * AK**2 / e_k * RHO(I,J)
    ENDIF
    ! �������A���͍ĕ��z���A�U�퍀�̘a ---------------------------------
    QH1 = RHO(I,J) / AJA(I,J)
    DQP(I,J,5) = QH1 * (P11 - eps11 + phi11)
    DQP(I,J,6) = QH1 * (P22 - eps22 + phi22)
    DQP(I,J,7) = QH1 * (P33 - eps33 + phi33)
    DQP(I,J,8) = QH1 * (P12 - eps12 + phi12)
    DQP(I,J,9) = QH1 * AEAK * (C_e1 * P_k - C_e2 * e_k)
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE NonDiffTerm
!***********************************************************************
!**** �g�U���̌v�Z                                                  ****
!***********************************************************************
SUBROUTINE DiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, L
  ! �����J�n ***********************************************************
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  RH = 0.0
  SH = 0.0
  ! �g�U���̗v�f���v�Z +++++++++++++++++++++++++++++++++++++++++++++++++
  CALL DIFFXI
  CALL DIFFET
  ! �g�U���̍��� +++++++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE(I, J, L)
  DO L = LS, LE
  !$OMP DO
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( (RHO(I,J-1) .GT. 0.0) .AND. (RHO(I-1,J) .GT. 0.0) .AND. &
  &   (RHO(I,J)   .GT. 0.0) .AND. &
  &   (RHO(I+1,J) .GT. 0.0) .AND. (RHO(I,J+1) .GT. 0.0) &
  & ) THEN
    DQD(I,J,L) = (-RH(I-1,J  ,L) + RH(I,J,L)) &
    &          + (-SH(I  ,J-1,L) + SH(I,J,L))
  ENDIF
  ENDDO
  ENDDO
  !$OMP END DO
  ENDDO
  !$OMP END PARALLEL
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DiffTerm
!***********************************************************************
!**** �g�U���̌v�Z(xi���������p)                                    ****
!***********************************************************************
SUBROUTINE DIFFXI
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: XIXM, XIYM, ETXM, ETYM, AJAM
  REAL    :: RHOM, UM, VM, uuM, vvM, wwM, uvM, EPSM, AMUM
  REAL    :: UXI, UET, UX, UY
  REAL    :: VXI, VET, VX, VY
  REAL    :: TXI, TET, TX, TY
  REAL    :: uuXI, uuET, uuX, uuY
  REAL    :: vvXI, vvET, vvX, vvY
  REAL    :: wwXI, wwET, wwX, wwY
  REAL    :: uvXI, uvET, uvX, uvY
  REAL    :: AEXI, AEET, AEX, AEY
  REAL    :: nu
  REAL    :: S11, S22, S12, SS
  REAL    :: C_p, AKAE
  REAL    :: R2M, S2M, R2T, S2T
  REAL    :: R3M, S3M, R3T, S3T
  REAL    :: R4M, S4M, R4T, S4T
  REAL    :: R5M, S5M, R5T, S5T
  REAL    :: R6M, S6M, R6T, S6T
  REAL    :: R7M, S7M, R7T, S7T
  REAL    :: R8M, S8M, R8T, S8T
  REAL    :: R9M, S9M, R9T, S9T
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, &
!$OMP& XIXM, XIYM, ETXM, ETYM, AJAM, &
!$OMP& RHOM, UM, VM, uuM, vvM, wwM, uvM, EPSM, AMUM, &
!$OMP& UXI, UET, UX, UY, VXI, VET, VX, VY, TXI, TET, TX, TY, &
!$OMP& uuXI, uuET, uuX, uuY, vvXI, vvET, vvX, vvY, &
!$OMP& wwXI, wwET, wwX, wwY, uvXI, uvET, uvX, uvY, &
!$OMP& AEXI, AEET, AEX, AEY, &
!$OMP& nu, S11, S22, S12, SS, C_p, AKAE, &
!$OMP& R2M, S2M, R2T, S2T, R3M, S3M, R3T, S3T, R4M, S4M, R4T, S4T, &
!$OMP& R5M, S5M, R5T, S5T, R6M, S6M, R6T, S6T, R7M, S7M, R7T, S7T, &
!$OMP& R8M, S8M, R8T, S8T, R9M, S9M, R9T, S9T, QH1 &
!$OMP& )
  DO J = JS + 1, JE - 1
  DO I = IS    , IE - 1
  IF((RHO(I,J) .GT. 0.0) .AND. (RHO(I+1,J) .GT. 0.0)) THEN
    ! XI�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J) + XIX(I+1,J))
    XIYM = 0.5 * (XIY(I,J) + XIY(I+1,J))
    ETXM = 0.5 * (ETX(I,J) + ETX(I+1,J))
    ETYM = 0.5 * (ETY(I,J) + ETY(I+1,J))
    AJAM = 0.5 * (AJA(I,J) + AJA(I+1,J))
    ! ������
    RHOM = 0.5 * (RHO(I,J) + RHO(I+1,J))
    UM   = 0.5 * (  U(I,J) +   U(I+1,J))
    VM   = 0.5 * (  V(I,J) +   V(I+1,J))
    uuM  = 0.5 * ( uu(I,J) +  uu(I+1,J))
    vvM  = 0.5 * ( vv(I,J) +  vv(I+1,J))
    wwM  = 0.5 * ( ww(I,J) +  ww(I+1,J))
    uvM  = 0.5 * ( uv(I,J) +  uv(I+1,J))
    EPSM = 0.5 * (EPS(I,J) + EPS(I+1,J))
    AMUM = 0.5 * (AMU(I,J) + AMU(I+1,J))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = - U(I,J) + U(I+1,J)
    UET = 0.25 * (- U(I,J-1) - U(I+1,J-1) + U(I,J+1) + U(I+1,J+1))
    VXI = - V(I,J) + V(I+1,J)
    VET = 0.25 * (- V(I,J-1) - V(I+1,J-1) + V(I,J+1) + V(I+1,J+1))
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM
    UY = UXI * XIYM + UET * ETYM
    VX = VXI * XIXM + VET * ETXM
    VY = VXI * XIYM + VET * ETYM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = - T(I,J) + T(I+1,J)
    TET = 0.25 * (- T(I,J-1) - T(I+1,J-1) + T(I,J+1) + T(I+1,J+1))
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM
    TY = TXI * XIYM + TET * ETYM
    ! uu �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    uuXI = - uu(I,J) + uu(I+1,J)
    uuET = 0.25 * ( - uu(I,J-1) - uu(I+1,J-1) &
    &               + uu(I,J+1) + uu(I+1,J+1) )
    ! ������ԕ�����K����
    uuX = uuXI * XIXM + uuET * ETXM
    uuY = uuXI * XIYM + uuET * ETYM
    ! vv �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    vvXI = - vv(I,J) + vv(I+1,J)
    vvET = 0.25 * ( - vv(I,J-1) - vv(I+1,J-1) &
    &               + vv(I,J+1) + vv(I+1,J+1) )
    ! ������ԕ�����K����
    vvX = vvXI * XIXM + vvET * ETXM
    vvY = vvXI * XIYM + vvET * ETYM
    ! ww �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    wwXI = - ww(I,J) + ww(I+1,J)
    wwET = 0.25 * ( - ww(I,J-1) - ww(I+1,J-1) &
    &               + ww(I,J+1) + ww(I+1,J+1) )
    ! ������ԕ�����K����
    wwX = wwXI * XIXM + wwET * ETXM
    wwY = wwXI * XIYM + wwET * ETYM
    ! uv �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    uvXI = - uv(I,J) + uv(I+1,J)
    uvET = 0.25 * ( - uv(I,J-1) - uv(I+1,J-1) &
    &               + uv(I,J+1) + uv(I+1,J+1) )
    ! ������ԕ�����K����
    uvX = uvXI * XIXM + uvET * ETXM
    uvY = uvXI * XIYM + uvET * ETYM
    ! epsilon �̈�K�����̌v�Z -----------------------------------------
    ! �v�Z��ԕ�����K����
    AEXI = - EPS(I,J) + EPS(I+1,J)
    AEET = 0.25 * ( - EPS(I,J-1) - EPS(I+1,J-1) &
    &               + EPS(I,J+1) + EPS(I+1,J+1) )
    ! ������ԕ�����K����
    AEX = AEXI * XIXM + AEET * ETXM
    AEY = AEXI * XIYM + AEET * ETYM
    ! ���S�x -----------------------------------------------------------
    nu = AMUM / RHOM
    ! �c�ݑ��x ---------------------------------------------------------
    SS  = (UX + VY) * TwoThird
    S11 = 2.0 * UX - SS
    S22 = 2.0 * VY - SS
    S12 = UY + VX
    ! U �̊g�U ---------------------------------------------------------
    R2M = nu * S11
    S2M = nu * S12
    R2T =-uuM
    S2T =-uvM
    ! V �̊g�U ---------------------------------------------------------
    R3M = nu * S12
    S3M = nu * S22
    R3T =-uvM
    S3T =-vvM
    ! �G�l���M�[�̊g�U -------------------------------------------------
    C_p  = GAMMA * RG / (GAMMA - 1.0)
    IF(EPSM .GT. ZERO) THEN
      AKAE = 0.5 * (uuM + vvM + wwM) / EPSM
    ELSE
      AKAE = 0.0
    ENDIF
    R4M = C_p * nu / PR * TX + nu * (S11 * UM + S12 * VM)
    S4M = C_p * nu / PR * TY + nu * (S12 * UM + S22 * VM)
    R4T = AKAE * C_se * C_p * (uuM * TX + uvM * TY) &
    &   + AKAE * C_s  * ( &
    &     uuM * (uuX + vvX + wwX) + uvM * (uuY + vvY + wwY) &
    &   ) &
    &   - (uuM * UM + uvM * VM)
    S4T = AKAE * C_se * C_p * (uvM * TX + vvM * TY) &
    &   + AKAE * C_s  * ( &
    &     uvM * (uuX + vvX + wwX) + vvM * (uuY + vvY + wwY) &
    &   ) &
    &   - (uvM * UM + vvM * VM)
    ! uu �̊g�U --------------------------------------------------------
    R5M = nu * uuX
    S5M = nu * uuY
    R5T = C_s * AKAE * (uuM * uuX + uvM * uuY)
    S5T = C_s * AKAE * (uvM * uuX + vvM * uuY)
    ! vv �̊g�U --------------------------------------------------------
    R6M = nu * vvX
    S6M = nu * vvY
    R6T = C_s * AKAE * (uuM * vvX + uvM * vvY)
    S6T = C_s * AKAE * (uvM * vvX + vvM * vvY)
    ! ww �̊g�U --------------------------------------------------------
    R7M = nu * wwX
    S7M = nu * wwY
    R7T = C_s * AKAE * (uuM * wwX + uvM * wwY)
    S7T = C_s * AKAE * (uvM * wwX + vvM * wwY)
    ! uv �̊g�U --------------------------------------------------------
    R8M = nu * uvX
    S8M = nu * uvY
    R8T = C_s * AKAE * (uuM * uvX + uvM * uvY)
    S8T = C_s * AKAE * (uvM * uvX + vvM * uvY)
    ! epsilon �̊g�U ---------------------------------------------------
    R9M = nu * AEX
    S9M = nu * AEY
    R9T = C_e * AKAE * (uuM * AEX + uvM * AEY)
    S9T = C_e * AKAE * (uvM * AEX + vvM * AEY)
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    RH(I,J,1) = 0.0
    RH(I,J,2) = QH1 * ((R2M + R2T) * XIXM + (S2M + S2T) * XIYM)
    RH(I,J,3) = QH1 * ((R3M + R3T) * XIXM + (S3M + S3T) * XIYM)
    RH(I,J,4) = QH1 * ((R4M + R4T) * XIXM + (S4M + S4T) * XIYM)
    RH(I,J,5) = QH1 * ((R5M + R5T) * XIXM + (S5M + S5T) * XIYM)
    RH(I,J,6) = QH1 * ((R6M + R6T) * XIXM + (S6M + S6T) * XIYM)
    RH(I,J,7) = QH1 * ((R7M + R7T) * XIXM + (S7M + S7T) * XIYM)
    RH(I,J,8) = QH1 * ((R8M + R8T) * XIXM + (S8M + S8T) * XIYM)
    RH(I,J,9) = QH1 * ((R9M + R9T) * XIXM + (S9M + S9T) * XIYM)
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFXI
!***********************************************************************
!**** �g�U���̌v�Z(eta���������p)                                   ****
!***********************************************************************
SUBROUTINE DIFFET
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: XIXM, XIYM, ETXM, ETYM, AJAM
  REAL    :: RHOM, UM, VM, uuM, vvM, wwM, uvM, EPSM, AMUM
  REAL    :: UXI, UET, UX, UY
  REAL    :: VXI, VET, VX, VY
  REAL    :: TXI, TET, TX, TY
  REAL    :: uuXI, uuET, uuX, uuY
  REAL    :: vvXI, vvET, vvX, vvY
  REAL    :: wwXI, wwET, wwX, wwY
  REAL    :: uvXI, uvET, uvX, uvY
  REAL    :: AEXI, AEET, AEX, AEY
  REAL    :: nu
  REAL    :: S11, S22, S12, SS
  REAL    :: C_p, AKAE
  REAL    :: R2M, S2M, R2T, S2T
  REAL    :: R3M, S3M, R3T, S3T
  REAL    :: R4M, S4M, R4T, S4T
  REAL    :: R5M, S5M, R5T, S5T
  REAL    :: R6M, S6M, R6T, S6T
  REAL    :: R7M, S7M, R7T, S7T
  REAL    :: R8M, S8M, R8T, S8T
  REAL    :: R9M, S9M, R9T, S9T
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, &
!$OMP& XIXM, XIYM, ETXM, ETYM, AJAM, &
!$OMP& RHOM, UM, VM, uuM, vvM, wwM, uvM, EPSM, AMUM, &
!$OMP& UXI, UET, UX, UY, VXI, VET, VX, VY, TXI, TET, TX, TY, &
!$OMP& uuXI, uuET, uuX, uuY, vvXI, vvET, vvX, vvY, &
!$OMP& wwXI, wwET, wwX, wwY, uvXI, uvET, uvX, uvY, &
!$OMP& AEXI, AEET, AEX, AEY, &
!$OMP& nu, S11, S22, S12, SS, C_p, AKAE, &
!$OMP& R2M, S2M, R2T, S2T, R3M, S3M, R3T, S3T, R4M, S4M, R4T, S4T, &
!$OMP& R5M, S5M, R5T, S5T, R6M, S6M, R6T, S6T, R7M, S7M, R7T, S7T, &
!$OMP& R8M, S8M, R8T, S8T, R9M, S9M, R9T, S9T, QH1 &
!$OMP& )
  DO J = JS    , JE - 1
  DO I = IS + 1, IE - 1
  IF((RHO(I,J) .GT. 0.0) .AND. (RHO(I,J+1) .GT. 0.0)) THEN
    ! ET�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J) + XIX(I,J+1))
    XIYM = 0.5 * (XIY(I,J) + XIY(I,J+1))
    ETXM = 0.5 * (ETX(I,J) + ETX(I,J+1))
    ETYM = 0.5 * (ETY(I,J) + ETY(I,J+1))
    AJAM = 0.5 * (AJA(I,J) + AJA(I,J+1))
    ! ������
    RHOM = 0.5 * (RHO(I,J) + RHO(I,J+1))
    UM   = 0.5 * (  U(I,J) +   U(I,J+1))
    VM   = 0.5 * (  V(I,J) +   V(I,J+1))
    uuM  = 0.5 * ( uu(I,J) +  uu(I,J+1))
    vvM  = 0.5 * ( vv(I,J) +  vv(I,J+1))
    wwM  = 0.5 * ( ww(I,J) +  ww(I,J+1))
    uvM  = 0.5 * ( uv(I,J) +  uv(I,J+1))
    EPSM = 0.5 * (EPS(I,J) + EPS(I,J+1))
    AMUM = 0.5 * (AMU(I,J) + AMU(I,J+1))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = 0.25 * (- U(I-1,J) - U(I-1,J+1) + U(I+1,J) + U(I+1,J+1))
    UET = - U(I,J) + U(I,J+1)
    VXI = 0.25 * (- V(I-1,J) - V(I-1,J+1) + V(I+1,J) + V(I+1,J+1))
    VET = - V(I,J) + V(I,J+1)
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM
    UY = UXI * XIYM + UET * ETYM
    VX = VXI * XIXM + VET * ETXM
    VY = VXI * XIYM + VET * ETYM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = 0.25 * (- T(I-1,J) - T(I-1,J+1) + T(I+1,J) + T(I+1,J+1))
    TET = - T(I,J) + T(I,J+1)
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM
    TY = TXI * XIYM + TET * ETYM
    ! uu �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    uuXI = 0.25 * (- uu(I-1,J) - uu(I-1,J+1) + uu(I+1,J) + uu(I+1,J+1))
    uuET = - uu(I,J) + uu(I,J+1)
    ! ������ԕ�����K����
    uuX = uuXI * XIXM + uuET * ETXM
    uuY = uuXI * XIYM + uuET * ETYM
    ! vv �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    vvXI = 0.25 * (- vv(I-1,J) - vv(I-1,J+1) + vv(I+1,J) + vv(I+1,J+1))
    vvET = - vv(I,J) + vv(I,J+1)
    ! ������ԕ�����K����
    vvX = vvXI * XIXM + vvET * ETXM
    vvY = vvXI * XIYM + vvET * ETYM
    ! ww �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    wwXI = 0.25 * (- ww(I-1,J) - ww(I-1,J+1) + ww(I+1,J) + ww(I+1,J+1))
    wwET = - ww(I,J) + ww(I,J+1)
    ! ������ԕ�����K����
    wwX = wwXI * XIXM + wwET * ETXM
    wwY = wwXI * XIYM + wwET * ETYM
    ! uv �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    uvXI = 0.25 * (- uv(I-1,J) - uv(I-1,J+1) + uv(I+1,J) + uv(I+1,J+1))
    uvET = - uv(I,J) + uv(I,J+1)
    ! ������ԕ�����K����
    uvX = uvXI * XIXM + uvET * ETXM
    uvY = uvXI * XIYM + uvET * ETYM
    ! epsilon �̈�K�����̌v�Z -----------------------------------------
    ! �v�Z��ԕ�����K����
    AEXI = 0.25 * ( - EPS(I-1,J) - EPS(I-1,J+1) &
    &               + EPS(I+1,J) + EPS(I+1,J+1) )
    AEET = - EPS(I,J) + EPS(I,J+1)
    ! ������ԕ�����K����
    AEX = AEXI * XIXM + AEET * ETXM
    AEY = AEXI * XIYM + AEET * ETYM
    ! ���S�x -----------------------------------------------------------
    nu = AMUM / RHOM
    ! �c�ݑ��x ---------------------------------------------------------
    SS  = (UX + VY) * TwoThird
    S11 = 2.0 * UX - SS
    S22 = 2.0 * VY - SS
    S12 = UY + VX
    ! U �̊g�U ---------------------------------------------------------
    R2M = nu * S11
    S2M = nu * S12
    R2T =-uuM
    S2T =-uvM
    ! V �̊g�U ---------------------------------------------------------
    R3M = nu * S12
    S3M = nu * S22
    R3T =-uvM
    S3T =-vvM
    ! �G�l���M�[�̊g�U -------------------------------------------------
    C_p  = GAMMA * RG / (GAMMA - 1.0)
    IF(EPSM .GT. ZERO) THEN
      AKAE = 0.5 * (uuM + vvM + wwM) / EPSM
    ELSE
      AKAE = 0.0
    ENDIF
    R4M = C_p * nu / PR * TX + nu * (S11 * UM + S12 * VM)
    S4M = C_p * nu / PR * TY + nu * (S12 * UM + S22 * VM)
    R4T = AKAE * C_se * C_p * (uuM * TX + uvM * TY) &
    &   + AKAE * C_s  * ( &
    &     uuM * (uuX + vvX + wwX) + uvM * (uuY + vvY + wwY) &
    &   ) &
    &   - (uuM * UM + uvM * VM)
    S4T = AKAE * C_se * C_p * (uvM * TX + vvM * TY) &
    &   + AKAE * C_s  * ( &
    &     uvM * (uuX + vvX + wwX) + vvM * (uuY + vvY + wwY) &
    &   ) &
    &   - (uvM * UM + vvM * VM)
    ! uu �̊g�U --------------------------------------------------------
    R5M = nu * uuX
    S5M = nu * uuY
    R5T = C_s * AKAE * (uuM * uuX + uvM * uuY)
    S5T = C_s * AKAE * (uvM * uuX + vvM * uuY)
    ! vv �̊g�U --------------------------------------------------------
    R6M = nu * vvX
    S6M = nu * vvY
    R6T = C_s * AKAE * (uuM * vvX + uvM * vvY)
    S6T = C_s * AKAE * (uvM * vvX + vvM * vvY)
    ! ww �̊g�U --------------------------------------------------------
    R7M = nu * wwX
    S7M = nu * wwY
    R7T = C_s * AKAE * (uuM * wwX + uvM * wwY)
    S7T = C_s * AKAE * (uvM * wwX + vvM * wwY)
    ! uv �̊g�U --------------------------------------------------------
    R8M = nu * uvX
    S8M = nu * uvY
    R8T = C_s * AKAE * (uuM * uvX + uvM * uvY)
    S8T = C_s * AKAE * (uvM * uvX + vvM * uvY)
    ! epsilon �̊g�U ---------------------------------------------------
    R9M = nu * AEX
    S9M = nu * AEY
    R9T = C_e * AKAE * (uuM * AEX + uvM * AEY)
    S9T = C_e * AKAE * (uvM * AEX + vvM * AEY)
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    SH(I,J,1) = 0.0
    SH(I,J,2) = QH1 * ((R2M + R2T) * ETXM + (S2M + S2T) * ETYM)
    SH(I,J,3) = QH1 * ((R3M + R3T) * ETXM + (S3M + S3T) * ETYM)
    SH(I,J,4) = QH1 * ((R4M + R4T) * ETXM + (S4M + S4T) * ETYM)
    SH(I,J,5) = QH1 * ((R5M + R5T) * ETXM + (S5M + S5T) * ETYM)
    SH(I,J,6) = QH1 * ((R6M + R6T) * ETXM + (S6M + S6T) * ETYM)
    SH(I,J,7) = QH1 * ((R7M + R7T) * ETXM + (S7M + S7T) * ETYM)
    SH(I,J,8) = QH1 * ((R8M + R8T) * ETXM + (S8M + S8T) * ETYM)
    SH(I,J,9) = QH1 * ((R9M + R9T) * ETXM + (S9M + S9T) * ETYM)
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFET
! ��`�I�� *************************************************************
END SUBROUTINE Turbulence2DRSMGL
!***********************************************************************
!**** �������f�� : RANS, RSM Gibson-Launder Model (1978)            ****
!****              �����M�`�B�ɂ�Vandromme�̃��f�����g�p            ****
!**** �v�Z�Ώ� : �P��, �O����, ���k��                               ****
!**** �v�Z�X�L�[�� : �񎟐��x���S����(�X�^�K�[�h�i�q��̓_���g�p)   ****
!***********************************************************************
SUBROUTINE Turbulence3DRSMGL( &
&            PELIM, RG, GAMMA, PR, &
&            IS, IE, JS, JE, KS, KE, LS, LE, &
&            XIX, XIY, XIZ, ETX, ETY, ETZ, ZEX, ZEY, ZEZ, AJA, &
&            RHO, U, V, W, T, uu, vv, ww, uv, vw, wu, EPS, AMU, &
&            n1, n2, n3, d, &
&            AMUT, DQD, DQP &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, PARAMETER :: C_se = 0.313
  REAL, PARAMETER :: C_s = 0.22, C_e = 0.18
  REAL, PARAMETER :: C_1 = 1.8, C_2 = 0.6
  REAL, PARAMETER :: C_l = 2.5
  REAL, PARAMETER :: C_w1 = 0.5, C_w2 = 0.3
  REAL, PARAMETER :: C_e1 = 1.44, C_e2 = 1.92
  REAL, PARAMETER :: TwoThird = 0.66666667
  REAL, PARAMETER :: ZERO = 1.0E-20
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: PELIM
  REAL,    INTENT(IN)  :: RG, GAMMA, PR
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE, KS, KE
  INTEGER, INTENT(IN)  :: LS, LE
  REAL,    INTENT(IN)  :: XIX(IS:IE, JS:JE, KS:KE), &
  &                       XIY(IS:IE, JS:JE, KS:KE), &
  &                       XIZ(IS:IE, JS:JE, KS:KE), &
  &                       ETX(IS:IE, JS:JE, KS:KE), &
  &                       ETY(IS:IE, JS:JE, KS:KE), &
  &                       ETZ(IS:IE, JS:JE, KS:KE), &
  &                       ZEX(IS:IE, JS:JE, KS:KE), &
  &                       ZEY(IS:IE, JS:JE, KS:KE), &
  &                       ZEZ(IS:IE, JS:JE, KS:KE), &
  &                       AJA(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)  :: RHO(IS:IE, JS:JE, KS:KE), &
  &                       U(IS:IE, JS:JE, KS:KE), &
  &                       V(IS:IE, JS:JE, KS:KE), &
  &                       W(IS:IE, JS:JE, KS:KE), &
  &                       T(IS:IE, JS:JE, KS:KE), &
  &                       uu(IS:IE, JS:JE, KS:KE), &
  &                       vv(IS:IE, JS:JE, KS:KE), &
  &                       ww(IS:IE, JS:JE, KS:KE), &
  &                       uv(IS:IE, JS:JE, KS:KE), &
  &                       vw(IS:IE, JS:JE, KS:KE), &
  &                       wu(IS:IE, JS:JE, KS:KE), &
  &                       EPS(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)  :: AMU(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)  :: n1(IS:IE, JS:JE, KS:KE), &
  &                       n2(IS:IE, JS:JE, KS:KE), &
  &                       n3(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)  :: d(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(OUT) :: AMUT(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(OUT) :: DQD(IS:IE, JS:JE, KS:KE, LS:LE)
  REAL,    INTENT(OUT) :: DQP(IS:IE, JS:JE, KS:KE, LS:LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, ALLOCATABLE :: RH(:, :, :, :), SH(:, :, :, :), TH(:, :, :, :)
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 12) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �������m�� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ALLOCATE(RH(IS: IE, JS: JE, KS: KE, LS: LE))
  ALLOCATE(SH(IS: IE, JS: JE, KS: KE, LS: LE))
  ALLOCATE(TH(IS: IE, JS: JE, KS: KE, LS: LE))
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  AMUT = 0.0
  DQD  = 0.0
  DQP  = 0.0
  ! �����葱���̌Ăяo�� +++++++++++++++++++++++++++++++++++++++++++++++
  CALL NonDiffTerm
  CALL DiffTerm
  ! �����I�� ***********************************************************
  RETURN
! �����葱�� ***********************************************************
CONTAINS
!***********************************************************************
!**** ��g�U���̌v�Z                                                ****
!***********************************************************************
SUBROUTINE NonDiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: TMP, TMP1, TMPw, TMPw1, TMPw2, TMPw1km, TMPw2km
  REAL    :: UXI, VXI, WXI, UET, VET, WET, UZE, VZE, WZE
  REAL    :: UX, VX, WX, UY, VY, WY, UZ, VZ, WZ
  REAL    :: P11, P22, P33, P12, P23, P31, P_k
  REAL    :: eps11, eps22, eps33, eps12, eps23, eps31, e_k
  REAL    :: phi1_11, phi1_22, phi1_33, phi1_12, phi1_23, phi1_31
  REAL    :: phi2_11, phi2_22, phi2_33, phi2_12, phi2_23, phi2_31
  REAL    :: phiw1_11, phiw1_22, phiw1_33, phiw1_12, phiw1_23, phiw1_31
  REAL    :: phiw2_11, phiw2_22, phiw2_33, phiw2_12, phiw2_23, phiw2_31
  REAL    :: phi11, phi22, phi33, phi12, phi23, phi31
  REAL    :: AK, SS2, nu, AEAK
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& TMP, TMP1, TMPw, TMPw1, TMPw2, TMPw1km, TMPw2km, &
!$OMP& UXI, VXI, WXI, UET, VET, WET, UZE, VZE, WZE, &
!$OMP& UX, VX, WX, UY, VY, WY, UZ, VZ, WZ, &
!$OMP& P11, P22, P33, P12, P23, P31, P_k, &
!$OMP& eps11, eps22, eps33, eps12, eps23, eps31, e_k, &
!$OMP& phi1_11, phi1_22, phi1_33, phi1_12, phi1_23, phi1_31, &
!$OMP& phi2_11, phi2_22, phi2_33, phi2_12, phi2_23, phi2_31, &
!$OMP& phiw1_11, phiw1_22, phiw1_33, phiw1_12, phiw1_23, phiw1_31, &
!$OMP& phiw2_11, phiw2_22, phiw2_33, phiw2_12, phiw2_23, phiw2_31, &
!$OMP& phi11, phi22, phi33, phi12, phi23, phi31, AK, SS2, nu, AEAK, QH1 &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF(RHO(I,J,K) .GT. 0.0) THEN
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = 0.5 * (U(I+1,J,K) - U(I-1,J,K))
    UET = 0.5 * (U(I,J+1,K) - U(I,J-1,K))
    UZE = 0.5 * (U(I,J,K+1) - U(I,J,K-1))
    VXI = 0.5 * (V(I+1,J,K) - V(I-1,J,K))
    VET = 0.5 * (V(I,J+1,K) - V(I,J-1,K))
    VZE = 0.5 * (V(I,J,K+1) - V(I,J,K-1))
    WXI = 0.5 * (W(I+1,J,K) - W(I-1,J,K))
    WET = 0.5 * (W(I,J+1,K) - W(I,J-1,K))
    WZE = 0.5 * (W(I,J,K+1) - W(I,J,K-1))
    ! ������ԕ�����K����
    UX = UXI * XIX(I,J,K) + UET * ETX(I,J,K) + UZE * ZEX(I,J,K)
    UY = UXI * XIY(I,J,K) + UET * ETY(I,J,K) + UZE * ZEY(I,J,K)
    UZ = UXI * XIZ(I,J,K) + UET * ETZ(I,J,K) + UZE * ZEZ(I,J,K)
    VX = VXI * XIX(I,J,K) + VET * ETX(I,J,K) + VZE * ZEX(I,J,K)
    VY = VXI * XIY(I,J,K) + VET * ETY(I,J,K) + VZE * ZEY(I,J,K)
    VZ = VXI * XIZ(I,J,K) + VET * ETZ(I,J,K) + VZE * ZEZ(I,J,K)
    WX = WXI * XIX(I,J,K) + WET * ETX(I,J,K) + WZE * ZEX(I,J,K)
    WY = WXI * XIY(I,J,K) + WET * ETY(I,J,K) + WZE * ZEY(I,J,K)
    WZ = WXI * XIZ(I,J,K) + WET * ETZ(I,J,K) + WZE * ZEZ(I,J,K)
    ! �������ƎU�퍀 ---------------------------------------------------
    P11 = - 2.0 * (uu(I,J,K) * UX + uv(I,J,K) * UY + wu(I,J,K) * UZ)
    P22 = - 2.0 * (uv(I,J,K) * VX + vv(I,J,K) * VY + vw(I,J,K) * VZ)
    P33 = - 2.0 * (wu(I,J,K) * WX + vw(I,J,K) * WY + ww(I,J,K) * WZ)
    P12 = - (uv(I,J,K) * UX + uu(I,J,K) * VX) &
    &     - (vv(I,J,K) * UY + uv(I,J,K) * VY) &
    &     - (vw(I,J,K) * UZ + wu(I,J,K) * VZ)
    P23 = - (wu(I,J,K) * VX + uv(I,J,K) * WX) &
    &     - (vw(I,J,K) * VY + vv(I,J,K) * WY) &
    &     - (ww(I,J,K) * VZ + vw(I,J,K) * WZ)
    P31 = - (uu(I,J,K) * WX + wu(I,J,K) * UX) &
    &     - (uv(I,J,K) * WY + vw(I,J,K) * UY) &
    &     - (wu(I,J,K) * WZ + ww(I,J,K) * UZ)
    P_k = 0.5 * (P11 + P22 + P33)
    e_k = EPS(I,J,K)
    ! �Ǐ����t����(�����ƎU��̃o�����X)�ɂ�郊�~�b�^�[
    IF(PELIM .GT. 0.0) THEN
      TMP = TwoThird * e_k / PELIM
      P11 = MIN(TMP, MAX(-TMP, P11))
      P22 = MIN(TMP, MAX(-TMP, P22))
      P33 = MIN(TMP, MAX(-TMP, P33))
      P_k = 0.5 * (P11 + P22 + P33)
    ENDIF
    TMP   = TwoThird * e_k
    eps11 = TMP
    eps22 = TMP
    eps33 = TMP
    eps12 = 0.0
    eps23 = 0.0
    eps31 = 0.0
    ! e / k (���ԃX�P�[�����~�b�^�[) -----------------------------------
    AK   = 0.5 * (uu(I,J,K) + vv(I,J,K) + ww(I,J,K))
    SS2  = 2.0 * (UX**2 + VY**2 + WZ**2) &
    &    + (UY + VX)**2 + (VZ + WY)**2 + (WX + UZ)**2 &
    &    - TwoThird * (UX + VY + WZ)**2
    nu   = AMU(I,J,K) / RHO(I,J,K)
    AEAK = MIN(MAX(SQRT(SS2), SQRT(e_k / nu)), e_k / MAX(ZERO, AK))
    ! �ĕ��z�� ---------------------------------------------------------
    TMP1    = - C_1 * AEAK
    phi1_11 = TMP1 * (uu(I,J,K) - TwoThird * AK)
    phi1_22 = TMP1 * (vv(I,J,K) - TwoThird * AK)
    phi1_33 = TMP1 * (ww(I,J,K) - TwoThird * AK)
    phi1_12 = TMP1 * uv(I,J,K)
    phi1_23 = TMP1 * vw(I,J,K)
    phi1_31 = TMP1 * wu(I,J,K)
    phi2_11 = - C_2 * (P11 - TwoThird * P_k)
    phi2_22 = - C_2 * (P22 - TwoThird * P_k)
    phi2_33 = - C_2 * (P33 - TwoThird * P_k)
    phi2_12 = - C_2 * P12
    phi2_23 = - C_2 * P23
    phi2_31 = - C_2 * P31
    IF(C_l * e_k * d(I,J,K) .GT. ZERO) THEN
      TMPw = AK**1.5 / MAX(ZERO, (C_l * e_k * d(I,J,K)))
      ! �ǖʔ��ˍ��̃_���s���O�֐��̐���
      ! TMPw = MIN(1.0, MAX(0.0, TMPw))
    ELSE
      TMPw = 0.0
    ENDIF
    TMPw1   = C_w1 * TMPw * AEAK
    TMPw2   = C_w2 * TMPw
    TMPw1km = uu(I,J,K) * n1(I,J,K) * n1(I,J,K) &
    &       + vv(I,J,K) * n2(I,J,K) * n2(I,J,K) &
    &       + ww(I,J,K) * n3(I,J,K) * n3(I,J,K) &
    &       + 2.0 * ( &
    &         uv(I,J,K) * n1(I,J,K) * n2(I,J,K) &
    &       + vw(I,J,K) * n2(I,J,K) * n3(I,J,K) &
    &       + wu(I,J,K) * n3(I,J,K) * n1(I,J,K) &
    &       )
    TMPw2km = phi2_11 * n1(I,J,K) * n1(I,J,K) &
    &       + phi2_22 * n2(I,J,K) * n2(I,J,K) &
    &       + phi2_33 * n3(I,J,K) * n3(I,J,K) &
    &       + 2.0 * ( &
    &         phi2_12 * n1(I,J,K) * n2(I,J,K) &
    &       + phi2_23 * n2(I,J,K) * n3(I,J,K) &
    &       + phi2_31 * n3(I,J,K) * n1(I,J,K) &
    &       )
    phiw1_11 = TMPw1 * (TMPw1km - 3.0 * n1(I,J,K) &
    &          * ( uu(I,J,K) * n1(I,J,K) &
    &            + uv(I,J,K) * n2(I,J,K) &
    &            + wu(I,J,K) * n3(I,J,K) ) &
    &        )
    phiw1_22 = TMPw1 * (TMPw1km - 3.0 * n2(I,J,K) &
    &          * ( uv(I,J,K) * n1(I,J,K) &
    &            + vv(I,J,K) * n2(I,J,K) &
    &            + vw(I,J,K) * n3(I,J,K) ) &
    &        )
    phiw1_33 = TMPw1 * (TMPw1km - 3.0 * n3(I,J,K) &
    &          * ( wu(I,J,K) * n1(I,J,K) &
    &            + vw(I,J,K) * n2(I,J,K) &
    &            + ww(I,J,K) * n3(I,J,K) ) &
    &        )
    phiw1_12 = - 1.5 * TMPw1 * ( &
    &          n1(I,J,K) * ( uv(I,J,K) * n1(I,J,K) &
    &                      + vv(I,J,K) * n2(I,J,K) &
    &                      + vw(I,J,K) * n3(I,J,K) ) &
    &        + n2(I,J,K) * ( uu(I,J,K) * n1(I,J,K) &
    &                      + uv(I,J,K) * n2(I,J,K) &
    &                      + wu(I,J,K) * n3(I,J,K) ) &
    &        )
    phiw1_23 = - 1.5 * TMPw1 * ( &
    &          n2(I,J,K) * ( wu(I,J,K) * n1(I,J,K) &
    &                      + vw(I,J,K) * n2(I,J,K) &
    &                      + ww(I,J,K) * n3(I,J,K) ) &
    &        + n3(I,J,K) * ( uv(I,J,K) * n1(I,J,K) &
    &                      + vv(I,J,K) * n2(I,J,K) &
    &                      + vw(I,J,K) * n3(I,J,K) ) &
    &        )
    phiw1_31 = - 1.5 * TMPw1 * ( &
    &          n3(I,J,K) * ( uu(I,J,K) * n1(I,J,K) &
    &                      + uv(I,J,K) * n2(I,J,K) &
    &                      + wu(I,J,K) * n3(I,J,K) ) &
    &        + n1(I,J,K) * ( wu(I,J,K) * n1(I,J,K) &
    &                      + vw(I,J,K) * n2(I,J,K) &
    &                      + ww(I,J,K) * n3(I,J,K) ) &
    &        )
    phiw2_11 = TMPw2 * (TMPw2km - 3.0 * n1(I,J,K) &
    &          * ( phi2_11 * n1(I,J,K) &
    &            + phi2_12 * n2(I,J,K) &
    &            + phi2_31 * n3(I,J,K) ) &
    &        )
    phiw2_22 = TMPw2 * (TMPw2km - 3.0 * n2(I,J,K) &
    &          * ( phi2_12 * n1(I,J,K) &
    &            + phi2_22 * n2(I,J,K) &
    &            + phi2_23 * n3(I,J,K) ) &
    &        )
    phiw2_33 = TMPw2 * (TMPw2km - 3.0 * n3(I,J,K) &
    &          * ( phi2_31 * n1(I,J,K) &
    &            + phi2_23 * n2(I,J,K) &
    &            + phi2_33 * n3(I,J,K) ) &
    &        )
    phiw2_12 = - 1.5 * TMPw2 * ( &
    &          n1(I,J,K) * ( phi2_12 * n1(I,J,K) &
    &                      + phi2_22 * n2(I,J,K) &
    &                      + phi2_23 * n3(I,J,K) ) &
    &        + n2(I,J,K) * ( phi2_11 * n1(I,J,K) &
    &                      + phi2_12 * n2(I,J,K) &
    &                      + phi2_31 * n3(I,J,K) ) &
    &        )
    phiw2_23 = - 1.5 * TMPw2 * ( &
    &          n2(I,J,K) * ( phi2_31 * n1(I,J,K) &
    &                      + phi2_23 * n2(I,J,K) &
    &                      + phi2_33 * n3(I,J,K) ) &
    &        + n3(I,J,K) * ( phi2_12 * n1(I,J,K) &
    &                      + phi2_22 * n2(I,J,K) &
    &                      + phi2_23 * n3(I,J,K) ) &
    &        )
    phiw2_31 = - 1.5 * TMPw2 * ( &
    &          n3(I,J,K) * ( phi2_11 * n1(I,J,K) &
    &                      + phi2_12 * n2(I,J,K) &
    &                      + phi2_31 * n3(I,J,K) ) &
    &        + n1(I,J,K) * ( phi2_31 * n1(I,J,K) &
    &                      + phi2_23 * n2(I,J,K) &
    &                      + phi2_33 * n3(I,J,K) ) &
    &        )
    phi11 = phi1_11 + phi2_11 + phiw1_11 + phiw2_11
    phi22 = phi1_22 + phi2_22 + phiw1_22 + phiw2_22
    phi33 = phi1_33 + phi2_33 + phiw1_33 + phiw2_33
    phi12 = phi1_12 + phi2_12 + phiw1_12 + phiw2_12
    phi23 = phi1_23 + phi2_23 + phiw1_23 + phiw2_23
    phi31 = phi1_31 + phi2_31 + phiw1_31 + phiw2_31
    ! �Q�S���W���̌v�Z -------------------------------------------------
    IF(e_k .GT. ZERO) THEN
      AMUT(I,J,K) = 0.09 * AK**2 / e_k * RHO(I,J,K)
    ENDIF
    ! �������A���͍ĕ��z���A�U�퍀�̘a ---------------------------------
    QH1 = RHO(I,J,K) / AJA(I,J,K)
    DQP(I,J,K, 6) = QH1 * (P11 - eps11 + phi11)
    DQP(I,J,K, 7) = QH1 * (P22 - eps22 + phi22)
    DQP(I,J,K, 8) = QH1 * (P33 - eps33 + phi33)
    DQP(I,J,K, 9) = QH1 * (P12 - eps12 + phi12)
    DQP(I,J,K,10) = QH1 * (P23 - eps23 + phi23)
    DQP(I,J,K,11) = QH1 * (P31 - eps31 + phi31)
    DQP(I,J,K,12) = QH1 * AEAK * (C_e1 * P_k - C_e2 * e_k)
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE NonDiffTerm
!***********************************************************************
!**** �g�U���̌v�Z                                                  ****
!***********************************************************************
SUBROUTINE DiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K, L
  ! �����J�n ***********************************************************
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  RH = 0.0
  SH = 0.0
  TH = 0.0
  ! �g�U���̗v�f���v�Z +++++++++++++++++++++++++++++++++++++++++++++++++
  CALL DIFFXI
  CALL DIFFET
  CALL DIFFZE
  ! �g�U���̍��� +++++++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE(I, J, K, L)
  DO L = LS, LE
  !$OMP DO
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( (RHO(I,J,K-1) .GT. 0.0) .AND. (RHO(I,J-1,K) .GT. 0.0) .AND. &
  &   (RHO(I-1,J,K) .GT. 0.0) .AND. (RHO(I,J,K)   .GT. 0.0) .AND. &
  &   (RHO(I+1,J,K) .GT. 0.0) .AND. (RHO(I,J+1,K) .GT. 0.0) .AND. &
  &   (RHO(I,J,K+1) .GT. 0.0) &
  & ) THEN
    DQD(I,J,K,L) = (-RH(I-1,J  ,K  ,L) + RH(I,J,K,L) ) &
    &            + (-SH(I  ,J-1,K  ,L) + SH(I,J,K,L) ) &
    &            + (-TH(I  ,J  ,K-1,L) + TH(I,J,K,L) )
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END DO
  ENDDO
  !$OMP END PARALLEL
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DiffTerm
!***********************************************************************
!**** �g�U���̌v�Z(xi���������p)                                    ****
!***********************************************************************
SUBROUTINE DIFFXI
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM
  REAL    :: RHOM, UM, VM, WM, uuM, vvM, wwM, uvM, vwM, wuM, EPSM, AMUM
  REAL    :: UXI, UET, UZE, UX, UY, UZ
  REAL    :: VXI, VET, VZE, VX, VY, VZ
  REAL    :: WXI, WET, WZE, WX, WY, WZ
  REAL    :: TXI, TET, TZE, TX, TY, TZ
  REAL    :: uuXI, uuET, uuZE, uuX, uuY, uuZ
  REAL    :: vvXI, vvET, vvZE, vvX, vvY, vvZ
  REAL    :: wwXI, wwET, wwZE, wwX, wwY, wwZ
  REAL    :: uvXI, uvET, uvZE, uvX, uvY, uvZ
  REAL    :: vwXI, vwET, vwZE, vwX, vwY, vwZ
  REAL    :: wuXI, wuET, wuZE, wuX, wuY, wuZ
  REAL    :: AEXI, AEET, AEZE, AEX, AEY, AEZ
  REAL    :: nu
  REAL    :: S11, S22, S33, S12, S23, S31, SS
  REAL    :: C_p, AKAE
  REAL    :: R02M, S02M, T02M, R02T, S02T, T02T
  REAL    :: R03M, S03M, T03M, R03T, S03T, T03T
  REAL    :: R04M, S04M, T04M, R04T, S04T, T04T
  REAL    :: R05M, S05M, T05M, R05T, S05T, T05T
  REAL    :: R06M, S06M, T06M, R06T, S06T, T06T
  REAL    :: R07M, S07M, T07M, R07T, S07T, T07T
  REAL    :: R08M, S08M, T08M, R08T, S08T, T08T
  REAL    :: R09M, S09M, T09M, R09T, S09T, T09T
  REAL    :: R10M, S10M, T10M, R10T, S10T, T10T
  REAL    :: R11M, S11M, T11M, R11T, S11T, T11T
  REAL    :: R12M, S12M, T12M, R12T, S12T, T12T
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM, &
!$OMP& RHOM, UM, VM, WM, uuM, vvM, wwM, uvM, vwM, wuM, EPSM, AMUM, &
!$OMP& UXI, UET, UZE, UX, UY, UZ, &
!$OMP& VXI, VET, VZE, VX, VY, VZ, &
!$OMP& WXI, WET, WZE, WX, WY, WZ, &
!$OMP& TXI, TET, TZE, TX, TY, TZ, &
!$OMP& uuXI, uuET, uuZE, uuX, uuY, uuZ, &
!$OMP& vvXI, vvET, vvZE, vvX, vvY, vvZ, &
!$OMP& wwXI, wwET, wwZE, wwX, wwY, wwZ, &
!$OMP& uvXI, uvET, uvZE, uvX, uvY, uvZ, &
!$OMP& vwXI, vwET, vwZE, vwX, vwY, vwZ, &
!$OMP& wuXI, wuET, wuZE, wuX, wuY, wuZ, &
!$OMP& AEXI, AEET, AEZE, AEX, AEY, AEZ, &
!$OMP& nu, S11, S22, S33, S12, S23, S31, SS, C_p, AKAE, &
!$OMP& R02M, S02M, T02M, R02T, S02T, T02T, &
!$OMP& R03M, S03M, T03M, R03T, S03T, T03T, &
!$OMP& R04M, S04M, T04M, R04T, S04T, T04T, &
!$OMP& R05M, S05M, T05M, R05T, S05T, T05T, &
!$OMP& R06M, S06M, T06M, R06T, S06T, T06T, &
!$OMP& R07M, S07M, T07M, R07T, S07T, T07T, &
!$OMP& R08M, S08M, T08M, R08T, S08T, T08T, &
!$OMP& R09M, S09M, T09M, R09T, S09T, T09T, &
!$OMP& R10M, S10M, T10M, R10T, S10T, T10T, &
!$OMP& R11M, S11M, T11M, R11T, S11T, T11T, &
!$OMP& R12M, S12M, T12M, R12T, S12T, T12T, &
!$OMP& QH1 &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS    , IE - 1
  IF((RHO(I,J,K) .GT. 0.0) .AND. (RHO(I+1,J,K) .GT. 0.0)) THEN
    ! XI�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J,K) + XIX(I+1,J,K))
    XIYM = 0.5 * (XIY(I,J,K) + XIY(I+1,J,K))
    XIZM = 0.5 * (XIZ(I,J,K) + XIZ(I+1,J,K))
    ETXM = 0.5 * (ETX(I,J,K) + ETX(I+1,J,K))
    ETYM = 0.5 * (ETY(I,J,K) + ETY(I+1,J,K))
    ETZM = 0.5 * (ETZ(I,J,K) + ETZ(I+1,J,K))
    ZEXM = 0.5 * (ZEX(I,J,K) + ZEX(I+1,J,K))
    ZEYM = 0.5 * (ZEY(I,J,K) + ZEY(I+1,J,K))
    ZEZM = 0.5 * (ZEZ(I,J,K) + ZEZ(I+1,J,K))
    AJAM = 0.5 * (AJA(I,J,K) + AJA(I+1,J,K))
    ! ������
    RHOM = 0.5 * (RHO(I,J,K) + RHO(I+1,J,K))
    UM   = 0.5 * (  U(I,J,K) +   U(I+1,J,K))
    VM   = 0.5 * (  V(I,J,K) +   V(I+1,J,K))
    WM   = 0.5 * (  W(I,J,K) +   W(I+1,J,K))
    uuM  = 0.5 * ( uu(I,J,K) +  uu(I+1,J,K))
    vvM  = 0.5 * ( vv(I,J,K) +  vv(I+1,J,K))
    wwM  = 0.5 * ( ww(I,J,K) +  ww(I+1,J,K))
    uvM  = 0.5 * ( uv(I,J,K) +  uv(I+1,J,K))
    vwM  = 0.5 * ( vw(I,J,K) +  vw(I+1,J,K))
    wuM  = 0.5 * ( wu(I,J,K) +  wu(I+1,J,K))
    EPSM = 0.5 * (EPS(I,J,K) + EPS(I+1,J,K))
    AMUM = 0.5 * (AMU(I,J,K) + AMU(I+1,J,K))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = - U(I,J,K) + U(I+1,J,K)
    UET = 0.25 * ( - U(I,J-1,K) - U(I+1,J-1,K) &
    &              + U(I,J+1,K) + U(I+1,J+1,K) )
    UZE = 0.25 * ( - U(I,J,K-1) - U(I+1,J,K-1) &
    &              + U(I,J,K+1) + U(I+1,J,K+1) )
    VXI = - V(I,J,K) + V(I+1,J,K)
    VET = 0.25 * ( - V(I,J-1,K) - V(I+1,J-1,K) &
    &              + V(I,J+1,K) + V(I+1,J+1,K) )
    VZE = 0.25 * ( - V(I,J,K-1) - V(I+1,J,K-1) &
    &              + V(I,J,K+1) + V(I+1,J,K+1) )
    WXI = - W(I,J,K) + W(I+1,J,K)
    WET = 0.25 * ( - W(I,J-1,K) - W(I+1,J-1,K) &
    &              + W(I,J+1,K) + W(I+1,J+1,K) )
    WZE = 0.25 * ( - W(I,J,K-1) - W(I+1,J,K-1) &
    &              + W(I,J,K+1) + W(I+1,J,K+1) )
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM + UZE * ZEXM
    UY = UXI * XIYM + UET * ETYM + UZE * ZEYM
    UZ = UXI * XIZM + UET * ETZM + UZE * ZEZM
    VX = VXI * XIXM + VET * ETXM + VZE * ZEXM
    VY = VXI * XIYM + VET * ETYM + VZE * ZEYM
    VZ = VXI * XIZM + VET * ETZM + VZE * ZEZM
    WX = WXI * XIXM + WET * ETXM + WZE * ZEXM
    WY = WXI * XIYM + WET * ETYM + WZE * ZEYM
    WZ = WXI * XIZM + WET * ETZM + WZE * ZEZM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = - T(I,J,K) + T(I+1,J,K)
    TET = 0.25 * ( - T(I,J-1,K) - T(I+1,J-1,K) &
    &              + T(I,J+1,K) + T(I+1,J+1,K) )
    TZE = 0.25 * ( - T(I,J,K-1) - T(I+1,J,K-1) &
    &              + T(I,J,K+1) + T(I+1,J,K+1) )
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM + TZE * ZEXM
    TY = TXI * XIYM + TET * ETYM + TZE * ZEYM
    TZ = TXI * XIZM + TET * ETZM + TZE * ZEZM
    ! uu �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    uuXI = - uu(I,J,K) + uu(I+1,J,K)
    uuET = 0.25 * ( - uu(I,J-1,K) - uu(I+1,J-1,K) &
    &               + uu(I,J+1,K) + uu(I+1,J+1,K) )
    uuZE = 0.25 * ( - uu(I,J,K-1) - uu(I+1,J,K-1) &
    &               + uu(I,J,K+1) + uu(I+1,J,K+1) )
    ! ������ԕ�����K����
    uuX = uuXI * XIXM + uuET * ETXM + uuZE * ZEXM
    uuY = uuXI * XIYM + uuET * ETYM + uuZE * ZEYM
    uuZ = uuXI * XIZM + uuET * ETZM + uuZE * ZEZM
    ! vv �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    vvXI = - vv(I,J,K) + vv(I+1,J,K)
    vvET = 0.25 * ( - vv(I,J-1,K) - vv(I+1,J-1,K) &
    &               + vv(I,J+1,K) + vv(I+1,J+1,K) )
    vvZE = 0.25 * ( - vv(I,J,K-1) - vv(I+1,J,K-1) &
    &               + vv(I,J,K+1) + vv(I+1,J,K+1) )
    ! ������ԕ�����K����
    vvX = vvXI * XIXM + vvET * ETXM + vvZE * ZEXM
    vvY = vvXI * XIYM + vvET * ETYM + vvZE * ZEYM
    vvZ = vvXI * XIZM + vvET * ETZM + vvZE * ZEZM
    ! ww �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    wwXI = - ww(I,J,K) + ww(I+1,J,K)
    wwET = 0.25 * ( - ww(I,J-1,K) - ww(I+1,J-1,K) &
    &               + ww(I,J+1,K) + ww(I+1,J+1,K) )
    wwZE = 0.25 * ( - ww(I,J,K-1) - ww(I+1,J,K-1) &
    &               + ww(I,J,K+1) + ww(I+1,J,K+1) )
    ! ������ԕ�����K����
    wwX = wwXI * XIXM + wwET * ETXM + wwZE * ZEXM
    wwY = wwXI * XIYM + wwET * ETYM + wwZE * ZEYM
    wwZ = wwXI * XIZM + wwET * ETZM + wwZE * ZEZM
    ! uv �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    uvXI = - uv(I,J,K) + uv(I+1,J,K)
    uvET = 0.25 * ( - uv(I,J-1,K) - uv(I+1,J-1,K) &
    &               + uv(I,J+1,K) + uv(I+1,J+1,K) )
    uvZE = 0.25 * ( - uv(I,J,K-1) - uv(I+1,J,K-1) &
    &               + uv(I,J,K+1) + uv(I+1,J,K+1) )
    ! ������ԕ�����K����
    uvX = uvXI * XIXM + uvET * ETXM + uvZE * ZEXM
    uvY = uvXI * XIYM + uvET * ETYM + uvZE * ZEYM
    uvZ = uvXI * XIZM + uvET * ETZM + uvZE * ZEZM
    ! vw �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    vwXI = - vw(I,J,K) + vw(I+1,J,K)
    vwET = 0.25 * ( - vw(I,J-1,K) - vw(I+1,J-1,K) &
    &               + vw(I,J+1,K) + vw(I+1,J+1,K) )
    vwZE = 0.25 * ( - vw(I,J,K-1) - vw(I+1,J,K-1) &
    &               + vw(I,J,K+1) + vw(I+1,J,K+1) )
    ! ������ԕ�����K����
    vwX = vwXI * XIXM + vwET * ETXM + vwZE * ZEXM
    vwY = vwXI * XIYM + vwET * ETYM + vwZE * ZEYM
    vwZ = vwXI * XIZM + vwET * ETZM + vwZE * ZEZM
    ! wu �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    wuXI = - wu(I,J,K) + wu(I+1,J,K)
    wuET = 0.25 * ( - wu(I,J-1,K) - wu(I+1,J-1,K) &
    &               + wu(I,J+1,K) + wu(I+1,J+1,K) )
    wuZE = 0.25 * ( - wu(I,J,K-1) - wu(I+1,J,K-1) &
    &               + wu(I,J,K+1) + wu(I+1,J,K+1) )
    ! ������ԕ�����K����
    wuX = wuXI * XIXM + wuET * ETXM + wuZE * ZEXM
    wuY = wuXI * XIYM + wuET * ETYM + wuZE * ZEYM
    wuZ = wuXI * XIZM + wuET * ETZM + wuZE * ZEZM
    ! epsilon �̈�K�����̌v�Z -----------------------------------------
    ! �v�Z��ԕ�����K����
    AEXI = - EPS(I,J,K) + EPS(I+1,J,K)
    AEET = 0.25 * ( - EPS(I,J-1,K) - EPS(I+1,J-1,K) &
    &               + EPS(I,J+1,K) + EPS(I+1,J+1,K) )
    AEZE = 0.25 * ( - EPS(I,J,K-1) - EPS(I+1,J,K-1) &
    &               + EPS(I,J,K+1) + EPS(I+1,J,K+1) )
    ! ������ԕ�����K����
    AEX = AEXI * XIXM + AEET * ETXM + AEZE * ZEXM
    AEY = AEXI * XIYM + AEET * ETYM + AEZE * ZEYM
    AEZ = AEXI * XIZM + AEET * ETZM + AEZE * ZEZM
    ! ���S�x -----------------------------------------------------------
    nu = AMUM / RHOM
    ! �c�ݑ��x ---------------------------------------------------------
    SS  = (UX + VY + WZ) * TwoThird
    S11 = 2.0 * UX - SS
    S22 = 2.0 * VY - SS
    S33 = 2.0 * WZ - SS
    S12 = UY + VX
    S23 = VZ + WY
    S31 = WX + UZ
    ! U �̊g�U ---------------------------------------------------------
    R02M = nu * S11
    S02M = nu * S12
    T02M = nu * S31
    R02T =-uuM
    S02T =-uvM
    T02T =-wuM
    ! V �̊g�U ---------------------------------------------------------
    R03M = nu * S12
    S03M = nu * S22
    T03M = nu * S23
    R03T =-uvM
    S03T =-vvM
    T03T =-vwM
    ! W �̊g�U ---------------------------------------------------------
    R04M = nu * S31
    S04M = nu * S23
    T04M = nu * S33
    R04T =-wuM
    S04T =-vwM
    T04T =-wwM
    ! �G�l���M�[�̊g�U -------------------------------------------------
    C_p  = GAMMA * RG / (GAMMA - 1.0)
    IF(EPSM .GT. ZERO) THEN
      AKAE = 0.5 * (uuM + vvM + wwM) / EPSM
    ELSE
      AKAE = 0.0
    ENDIF
    R05M = C_p * nu / PR * TX + nu * (S11 * UM + S12 * VM + S31 * WM)
    S05M = C_p * nu / PR * TY + nu * (S12 * UM + S22 * VM + S23 * WM)
    T05M = C_p * nu / PR * TZ + nu * (S31 * UM + S23 * VM + S33 * WM)
    R05T = AKAE * C_se * C_p * (uuM * TX + uvM * TY + wuM * TZ) &
    &    + AKAE * C_s  * ( &
    &      uuM * (uuX + vvX + wwX) &
    &    + uvM * (uuY + vvY + wwY) &
    &    + wuM * (uuZ + vvZ + wwZ) &
    &    ) &
    &    - (uuM * UM + uvM * VM + wuM * WM)
    S05T = AKAE * C_se * C_p * (uvM * TX + vvM * TY + vwM * TZ) &
    &    + AKAE * C_s  * ( &
    &      uvM * (uuX + vvX + wwX) &
    &    + vvM * (uuY + vvY + wwY) &
    &    + vwM * (uuZ + vvZ + wwZ) &
    &    ) &
    &    - (uvM * UM + vvM * VM + vwM * WM)
    T05T = AKAE * C_se * C_p * (wuM * TX + vwM * TY + wwM * TZ) &
    &    + AKAE * C_s  * ( &
    &      wuM * (uuX + vvX + wwX) &
    &    + vwM * (uuY + vvY + wwY) &
    &    + wwM * (uuZ + vvZ + wwZ) &
    &    ) &
    &    - (wuM * UM + vwM * VM + wwM * WM)
    ! uu �̊g�U --------------------------------------------------------
    R06M = nu * uuX
    S06M = nu * uuY
    T06M = nu * uuZ
    R06T = C_s * AKAE * (uuM * uuX + uvM * uuY + wuM * uuZ)
    S06T = C_s * AKAE * (uvM * uuX + vvM * uuY + vwM * uuZ)
    T06T = C_s * AKAE * (wuM * uuX + vwM * uuY + wwM * uuZ)
    ! vv �̊g�U --------------------------------------------------------
    R07M = nu * vvX
    S07M = nu * vvY
    T07M = nu * vvZ
    R07T = C_s * AKAE * (uuM * vvX + uvM * vvY + wuM * vvZ)
    S07T = C_s * AKAE * (uvM * vvX + vvM * vvY + vwM * vvZ)
    T07T = C_s * AKAE * (wuM * vvX + vwM * vvY + wwM * vvZ)
    ! ww �̊g�U --------------------------------------------------------
    R08M = nu * wwX
    S08M = nu * wwY
    T08M = nu * wwZ
    R08T = C_s * AKAE * (uuM * wwX + uvM * wwY + wuM * wwZ)
    S08T = C_s * AKAE * (uvM * wwX + vvM * wwY + vwM * wwZ)
    T08T = C_s * AKAE * (wuM * wwX + vwM * wwY + wwM * wwZ)
    ! uv �̊g�U --------------------------------------------------------
    R09M = nu * uvX
    S09M = nu * uvY
    T09M = nu * uvZ
    R09T = C_s * AKAE * (uuM * uvX + uvM * uvY + wuM * uvZ)
    S09T = C_s * AKAE * (uvM * uvX + vvM * uvY + vwM * uvZ)
    T09T = C_s * AKAE * (wuM * uvX + vwM * uvY + wwM * uvZ)
    ! vw �̊g�U --------------------------------------------------------
    R10M = nu * vwX
    S10M = nu * vwY
    T10M = nu * vwZ
    R10T = C_s * AKAE * (uuM * vwX + uvM * vwY + wuM * vwZ)
    S10T = C_s * AKAE * (uvM * vwX + vvM * vwY + vwM * vwZ)
    T10T = C_s * AKAE * (wuM * vwX + vwM * vwY + wwM * vwZ)
    ! wu �̊g�U --------------------------------------------------------
    R11M = nu * wuX
    S11M = nu * wuY
    T11M = nu * wuZ
    R11T = C_s * AKAE * (uuM * wuX + uvM * wuY + wuM * wuZ)
    S11T = C_s * AKAE * (uvM * wuX + vvM * wuY + vwM * wuZ)
    T11T = C_s * AKAE * (wuM * wuX + vwM * wuY + wwM * wuZ)
    ! epsilon �̊g�U ---------------------------------------------------
    R12M = nu * AEX
    S12M = nu * AEY
    T12M = nu * AEZ
    R12T = C_e * AKAE * (uuM * AEX + uvM * AEY + wuM * AEZ)
    S12T = C_e * AKAE * (uvM * AEX + vvM * AEY + vwM * AEZ)
    T12T = C_e * AKAE * (wuM * AEX + vwM * AEY + wwM * AEZ)
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    RH(I,J,K, 1) = 0.0
    RH(I,J,K, 2) = QH1 * ( (R02M + R02T) * XIXM &
    &                    + (S02M + S02T) * XIYM &
    &                    + (T02M + T02T) * XIZM )
    RH(I,J,K, 3) = QH1 * ( (R03M + R03T) * XIXM &
    &                    + (S03M + S03T) * XIYM &
    &                    + (T03M + T03T) * XIZM )
    RH(I,J,K, 4) = QH1 * ( (R04M + R04T) * XIXM &
    &                    + (S04M + S04T) * XIYM &
    &                    + (T04M + T04T) * XIZM )
    RH(I,J,K, 5) = QH1 * ( (R05M + R05T) * XIXM &
    &                    + (S05M + S05T) * XIYM &
    &                    + (T05M + T05T) * XIZM )
    RH(I,J,K, 6) = QH1 * ( (R06M + R06T) * XIXM &
    &                    + (S06M + S06T) * XIYM &
    &                    + (T06M + T06T) * XIZM )
    RH(I,J,K, 7) = QH1 * ( (R07M + R07T) * XIXM &
    &                    + (S07M + S07T) * XIYM &
    &                    + (T07M + T07T) * XIZM )
    RH(I,J,K, 8) = QH1 * ( (R08M + R08T) * XIXM &
    &                    + (S08M + S08T) * XIYM &
    &                    + (T08M + T08T) * XIZM )
    RH(I,J,K, 9) = QH1 * ( (R09M + R09T) * XIXM &
    &                    + (S09M + S09T) * XIYM &
    &                    + (T09M + T09T) * XIZM )
    RH(I,J,K,10) = QH1 * ( (R10M + R10T) * XIXM &
    &                    + (S10M + S10T) * XIYM &
    &                    + (T10M + T10T) * XIZM )
    RH(I,J,K,11) = QH1 * ( (R11M + R11T) * XIXM &
    &                    + (S11M + S11T) * XIYM &
    &                    + (T11M + T11T) * XIZM )
    RH(I,J,K,12) = QH1 * ( (R12M + R12T) * XIXM &
    &                    + (S12M + S12T) * XIYM &
    &                    + (T12M + T12T) * XIZM )
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFXI
!***********************************************************************
!**** �g�U���̌v�Z(eta���������p)                                   ****
!***********************************************************************
SUBROUTINE DIFFET
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM
  REAL    :: RHOM, UM, VM, WM, uuM, vvM, wwM, uvM, vwM, wuM, EPSM, AMUM
  REAL    :: UXI, UET, UZE, UX, UY, UZ
  REAL    :: VXI, VET, VZE, VX, VY, VZ
  REAL    :: WXI, WET, WZE, WX, WY, WZ
  REAL    :: TXI, TET, TZE, TX, TY, TZ
  REAL    :: uuXI, uuET, uuZE, uuX, uuY, uuZ
  REAL    :: vvXI, vvET, vvZE, vvX, vvY, vvZ
  REAL    :: wwXI, wwET, wwZE, wwX, wwY, wwZ
  REAL    :: uvXI, uvET, uvZE, uvX, uvY, uvZ
  REAL    :: vwXI, vwET, vwZE, vwX, vwY, vwZ
  REAL    :: wuXI, wuET, wuZE, wuX, wuY, wuZ
  REAL    :: AEXI, AEET, AEZE, AEX, AEY, AEZ
  REAL    :: nu
  REAL    :: S11, S22, S33, S12, S23, S31, SS
  REAL    :: C_p, AKAE
  REAL    :: R02M, S02M, T02M, R02T, S02T, T02T
  REAL    :: R03M, S03M, T03M, R03T, S03T, T03T
  REAL    :: R04M, S04M, T04M, R04T, S04T, T04T
  REAL    :: R05M, S05M, T05M, R05T, S05T, T05T
  REAL    :: R06M, S06M, T06M, R06T, S06T, T06T
  REAL    :: R07M, S07M, T07M, R07T, S07T, T07T
  REAL    :: R08M, S08M, T08M, R08T, S08T, T08T
  REAL    :: R09M, S09M, T09M, R09T, S09T, T09T
  REAL    :: R10M, S10M, T10M, R10T, S10T, T10T
  REAL    :: R11M, S11M, T11M, R11T, S11T, T11T
  REAL    :: R12M, S12M, T12M, R12T, S12T, T12T
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM, &
!$OMP& RHOM, UM, VM, WM, uuM, vvM, wwM, uvM, vwM, wuM, EPSM, AMUM, &
!$OMP& UXI, UET, UZE, UX, UY, UZ, &
!$OMP& VXI, VET, VZE, VX, VY, VZ, &
!$OMP& WXI, WET, WZE, WX, WY, WZ, &
!$OMP& TXI, TET, TZE, TX, TY, TZ, &
!$OMP& uuXI, uuET, uuZE, uuX, uuY, uuZ, &
!$OMP& vvXI, vvET, vvZE, vvX, vvY, vvZ, &
!$OMP& wwXI, wwET, wwZE, wwX, wwY, wwZ, &
!$OMP& uvXI, uvET, uvZE, uvX, uvY, uvZ, &
!$OMP& vwXI, vwET, vwZE, vwX, vwY, vwZ, &
!$OMP& wuXI, wuET, wuZE, wuX, wuY, wuZ, &
!$OMP& AEXI, AEET, AEZE, AEX, AEY, AEZ, &
!$OMP& nu, S11, S22, S33, S12, S23, S31, SS, C_p, AKAE, &
!$OMP& R02M, S02M, T02M, R02T, S02T, T02T, &
!$OMP& R03M, S03M, T03M, R03T, S03T, T03T, &
!$OMP& R04M, S04M, T04M, R04T, S04T, T04T, &
!$OMP& R05M, S05M, T05M, R05T, S05T, T05T, &
!$OMP& R06M, S06M, T06M, R06T, S06T, T06T, &
!$OMP& R07M, S07M, T07M, R07T, S07T, T07T, &
!$OMP& R08M, S08M, T08M, R08T, S08T, T08T, &
!$OMP& R09M, S09M, T09M, R09T, S09T, T09T, &
!$OMP& R10M, S10M, T10M, R10T, S10T, T10T, &
!$OMP& R11M, S11M, T11M, R11T, S11T, T11T, &
!$OMP& R12M, S12M, T12M, R12T, S12T, T12T, &
!$OMP& QH1 &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS    , JE - 1
  DO I = IS + 1, IE - 1
  IF((RHO(I,J,K) .GT. 0.0) .AND. (RHO(I,J+1,K) .GT. 0.0)) THEN
    ! XI�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J,K) + XIX(I,J+1,K))
    XIYM = 0.5 * (XIY(I,J,K) + XIY(I,J+1,K))
    XIZM = 0.5 * (XIZ(I,J,K) + XIZ(I,J+1,K))
    ETXM = 0.5 * (ETX(I,J,K) + ETX(I,J+1,K))
    ETYM = 0.5 * (ETY(I,J,K) + ETY(I,J+1,K))
    ETZM = 0.5 * (ETZ(I,J,K) + ETZ(I,J+1,K))
    ZEXM = 0.5 * (ZEX(I,J,K) + ZEX(I,J+1,K))
    ZEYM = 0.5 * (ZEY(I,J,K) + ZEY(I,J+1,K))
    ZEZM = 0.5 * (ZEZ(I,J,K) + ZEZ(I,J+1,K))
    AJAM = 0.5 * (AJA(I,J,K) + AJA(I,J+1,K))
    ! ������
    RHOM = 0.5 * (RHO(I,J,K) + RHO(I,J+1,K))
    UM   = 0.5 * (  U(I,J,K) +   U(I,J+1,K))
    VM   = 0.5 * (  V(I,J,K) +   V(I,J+1,K))
    WM   = 0.5 * (  W(I,J,K) +   W(I,J+1,K))
    uuM  = 0.5 * ( uu(I,J,K) +  uu(I,J+1,K))
    vvM  = 0.5 * ( vv(I,J,K) +  vv(I,J+1,K))
    wwM  = 0.5 * ( ww(I,J,K) +  ww(I,J+1,K))
    uvM  = 0.5 * ( uv(I,J,K) +  uv(I,J+1,K))
    vwM  = 0.5 * ( vw(I,J,K) +  vw(I,J+1,K))
    wuM  = 0.5 * ( wu(I,J,K) +  wu(I,J+1,K))
    EPSM = 0.5 * (EPS(I,J,K) + EPS(I,J+1,K))
    AMUM = 0.5 * (AMU(I,J,K) + AMU(I,J+1,K))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = 0.25 * ( - U(I-1,J,K) - U(I-1,J+1,K) &
    &              + U(I+1,J,K) + U(I+1,J+1,K) )
    UET = - U(I,J,K) + U(I,J+1,K)
    UZE = 0.25 * ( - U(I,J,K-1) - U(I,J+1,K-1) &
    &              + U(I,J,K+1) + U(I,J+1,K+1) )
    VXI = 0.25 * ( - V(I-1,J,K) - V(I-1,J+1,K) &
    &              + V(I+1,J,K) + V(I+1,J+1,K) )
    VET = - V(I,J,K) + V(I,J+1,K)
    VZE = 0.25 * ( - V(I,J,K-1) - V(I,J+1,K-1) &
    &              + V(I,J,K+1) + V(I,J+1,K+1) )
    WXI = 0.25 * ( - W(I-1,J,K) - W(I-1,J+1,K) &
    &              + W(I+1,J,K) + W(I+1,J+1,K) )
    WET = - W(I,J,K) + W(I,J+1,K)
    WZE = 0.25 * ( - W(I,J,K-1) - W(I,J+1,K-1) &
    &              + W(I,J,K+1) + W(I,J+1,K+1) )
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM + UZE * ZEXM
    UY = UXI * XIYM + UET * ETYM + UZE * ZEYM
    UZ = UXI * XIZM + UET * ETZM + UZE * ZEZM
    VX = VXI * XIXM + VET * ETXM + VZE * ZEXM
    VY = VXI * XIYM + VET * ETYM + VZE * ZEYM
    VZ = VXI * XIZM + VET * ETZM + VZE * ZEZM
    WX = WXI * XIXM + WET * ETXM + WZE * ZEXM
    WY = WXI * XIYM + WET * ETYM + WZE * ZEYM
    WZ = WXI * XIZM + WET * ETZM + WZE * ZEZM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = 0.25 * ( - T(I-1,J,K) - T(I-1,J+1,K) &
    &              + T(I+1,J,K) + T(I+1,J+1,K) )
    TET = - T(I,J,K) + T(I,J+1,K)
    TZE = 0.25 * ( - T(I,J,K-1) - T(I,J+1,K-1) &
    &              + T(I,J,K+1) + T(I,J+1,K+1) )
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM + TZE * ZEXM
    TY = TXI * XIYM + TET * ETYM + TZE * ZEYM
    TZ = TXI * XIZM + TET * ETZM + TZE * ZEZM
    ! uu �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    uuXI = 0.25 * ( - uu(I-1,J,K) - uu(I-1,J+1,K) &
    &               + uu(I+1,J,K) + uu(I+1,J+1,K) )
    uuET = - uu(I,J,K) + uu(I,J+1,K)
    uuZE = 0.25 * ( - uu(I,J,K-1) - uu(I,J+1,K-1) &
    &               + uu(I,J,K+1) + uu(I,J+1,K+1) )
    ! ������ԕ�����K����
    uuX = uuXI * XIXM + uuET * ETXM + uuZE * ZEXM
    uuY = uuXI * XIYM + uuET * ETYM + uuZE * ZEYM
    uuZ = uuXI * XIZM + uuET * ETZM + uuZE * ZEZM
    ! vv �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    vvXI = 0.25 * ( - vv(I-1,J,K) - vv(I-1,J+1,K) &
    &               + vv(I+1,J,K) + vv(I+1,J+1,K) )
    vvET = - vv(I,J,K) + vv(I,J+1,K)
    vvZE = 0.25 * ( - vv(I,J,K-1) - vv(I,J+1,K-1) &
    &               + vv(I,J,K+1) + vv(I,J+1,K+1) )
    ! ������ԕ�����K����
    vvX = vvXI * XIXM + vvET * ETXM + vvZE * ZEXM
    vvY = vvXI * XIYM + vvET * ETYM + vvZE * ZEYM
    vvZ = vvXI * XIZM + vvET * ETZM + vvZE * ZEZM
    ! ww �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    wwXI = 0.25 * ( - ww(I-1,J,K) - ww(I-1,J+1,K) &
    &               + ww(I+1,J,K) + ww(I+1,J+1,K) )
    wwET = - ww(I,J,K) + ww(I,J+1,K)
    wwZE = 0.25 * ( - ww(I,J,K-1) - ww(I,J+1,K-1) &
    &               + ww(I,J,K+1) + ww(I,J+1,K+1) )
    ! ������ԕ�����K����
    wwX = wwXI * XIXM + wwET * ETXM + wwZE * ZEXM
    wwY = wwXI * XIYM + wwET * ETYM + wwZE * ZEYM
    wwZ = wwXI * XIZM + wwET * ETZM + wwZE * ZEZM
    ! uv �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    uvXI = 0.25 * ( - uv(I-1,J,K) - uv(I-1,J+1,K) &
    &               + uv(I+1,J,K) + uv(I+1,J+1,K) )
    uvET = - uv(I,J,K) + uv(I,J+1,K)
    uvZE = 0.25 * ( - uv(I,J,K-1) - uv(I,J+1,K-1) &
    &               + uv(I,J,K+1) + uv(I,J+1,K+1) )
    ! ������ԕ�����K����
    uvX = uvXI * XIXM + uvET * ETXM + uvZE * ZEXM
    uvY = uvXI * XIYM + uvET * ETYM + uvZE * ZEYM
    uvZ = uvXI * XIZM + uvET * ETZM + uvZE * ZEZM
    ! vw �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    vwXI = 0.25 * ( - vw(I-1,J,K) - vw(I-1,J+1,K) &
    &               + vw(I+1,J,K) + vw(I+1,J+1,K) )
    vwET = - vw(I,J,K) + vw(I,J+1,K)
    vwZE = 0.25 * ( - vw(I,J,K-1) - vw(I,J+1,K-1) &
    &               + vw(I,J,K+1) + vw(I,J+1,K+1) )
    ! ������ԕ�����K����
    vwX = vwXI * XIXM + vwET * ETXM + vwZE * ZEXM
    vwY = vwXI * XIYM + vwET * ETYM + vwZE * ZEYM
    vwZ = vwXI * XIZM + vwET * ETZM + vwZE * ZEZM
    ! wu �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    wuXI = 0.25 * ( - wu(I-1,J,K) - wu(I-1,J+1,K) &
    &               + wu(I+1,J,K) + wu(I+1,J+1,K) )
    wuET = - wu(I,J,K) + wu(I,J+1,K)
    wuZE = 0.25 * ( - wu(I,J,K-1) - wu(I,J+1,K-1) &
    &               + wu(I,J,K+1) + wu(I,J+1,K+1) )
    ! ������ԕ�����K����
    wuX = wuXI * XIXM + wuET * ETXM + wuZE * ZEXM
    wuY = wuXI * XIYM + wuET * ETYM + wuZE * ZEYM
    wuZ = wuXI * XIZM + wuET * ETZM + wuZE * ZEZM
    ! epsilon �̈�K�����̌v�Z -----------------------------------------
    ! �v�Z��ԕ�����K����
    AEXI = 0.25 * ( - EPS(I-1,J,K) - EPS(I-1,J+1,K) &
    &               + EPS(I+1,J,K) + EPS(I+1,J+1,K) )
    AEET = - EPS(I,J,K) + EPS(I,J+1,K)
    AEZE = 0.25 * ( - EPS(I,J,K-1) - EPS(I,J+1,K-1) &
    &               + EPS(I,J,K+1) + EPS(I,J+1,K+1) )
    ! ������ԕ�����K����
    AEX = AEXI * XIXM + AEET * ETXM + AEZE * ZEXM
    AEY = AEXI * XIYM + AEET * ETYM + AEZE * ZEYM
    AEZ = AEXI * XIZM + AEET * ETZM + AEZE * ZEZM
    ! ���S�x -----------------------------------------------------------
    nu = AMUM / RHOM
    ! �c�ݑ��x ---------------------------------------------------------
    SS  = (UX + VY + WZ) * TwoThird
    S11 = 2.0 * UX - SS
    S22 = 2.0 * VY - SS
    S33 = 2.0 * WZ - SS
    S12 = UY + VX
    S23 = VZ + WY
    S31 = WX + UZ
    ! U �̊g�U ---------------------------------------------------------
    R02M = nu * S11
    S02M = nu * S12
    T02M = nu * S31
    R02T =-uuM
    S02T =-uvM
    T02T =-wuM
    ! V �̊g�U ---------------------------------------------------------
    R03M = nu * S12
    S03M = nu * S22
    T03M = nu * S23
    R03T =-uvM
    S03T =-vvM
    T03T =-vwM
    ! W �̊g�U ---------------------------------------------------------
    R04M = nu * S31
    S04M = nu * S23
    T04M = nu * S33
    R04T =-wuM
    S04T =-vwM
    T04T =-wwM
    ! �G�l���M�[�̊g�U -------------------------------------------------
    C_p  = GAMMA * RG / (GAMMA - 1.0)
    IF(EPSM .GT. ZERO) THEN
      AKAE = 0.5 * (uuM + vvM + wwM) / EPSM
    ELSE
      AKAE = 0.0
    ENDIF
    R05M = C_p * nu / PR * TX + nu * (S11 * UM + S12 * VM + S31 * WM)
    S05M = C_p * nu / PR * TY + nu * (S12 * UM + S22 * VM + S23 * WM)
    T05M = C_p * nu / PR * TZ + nu * (S31 * UM + S23 * VM + S33 * WM)
    R05T = AKAE * C_se * C_p * (uuM * TX + uvM * TY + wuM * TZ) &
    &    + AKAE * C_s  * ( &
    &      uuM * (uuX + vvX + wwX) &
    &    + uvM * (uuY + vvY + wwY) &
    &    + wuM * (uuZ + vvZ + wwZ) &
    &    ) &
    &    - (uuM * UM + uvM * VM + wuM * WM)
    S05T = AKAE * C_se * C_p * (uvM * TX + vvM * TY + vwM * TZ) &
    &    + AKAE * C_s  * ( &
    &      uvM * (uuX + vvX + wwX) &
    &    + vvM * (uuY + vvY + wwY) &
    &    + vwM * (uuZ + vvZ + wwZ) &
    &    ) &
    &    - (uvM * UM + vvM * VM + vwM * WM)
    T05T = AKAE * C_se * C_p * (wuM * TX + vwM * TY + wwM * TZ) &
    &    + AKAE * C_s  * ( &
    &      wuM * (uuX + vvX + wwX) &
    &    + vwM * (uuY + vvY + wwY) &
    &    + wwM * (uuZ + vvZ + wwZ) &
    &    ) &
    &    - (wuM * UM + vwM * VM + wwM * WM)
    ! uu �̊g�U --------------------------------------------------------
    R06M = nu * uuX
    S06M = nu * uuY
    T06M = nu * uuZ
    R06T = C_s * AKAE * (uuM * uuX + uvM * uuY + wuM * uuZ)
    S06T = C_s * AKAE * (uvM * uuX + vvM * uuY + vwM * uuZ)
    T06T = C_s * AKAE * (wuM * uuX + vwM * uuY + wwM * uuZ)
    ! vv �̊g�U --------------------------------------------------------
    R07M = nu * vvX
    S07M = nu * vvY
    T07M = nu * vvZ
    R07T = C_s * AKAE * (uuM * vvX + uvM * vvY + wuM * vvZ)
    S07T = C_s * AKAE * (uvM * vvX + vvM * vvY + vwM * vvZ)
    T07T = C_s * AKAE * (wuM * vvX + vwM * vvY + wwM * vvZ)
    ! ww �̊g�U --------------------------------------------------------
    R08M = nu * wwX
    S08M = nu * wwY
    T08M = nu * wwZ
    R08T = C_s * AKAE * (uuM * wwX + uvM * wwY + wuM * wwZ)
    S08T = C_s * AKAE * (uvM * wwX + vvM * wwY + vwM * wwZ)
    T08T = C_s * AKAE * (wuM * wwX + vwM * wwY + wwM * wwZ)
    ! uv �̊g�U --------------------------------------------------------
    R09M = nu * uvX
    S09M = nu * uvY
    T09M = nu * uvZ
    R09T = C_s * AKAE * (uuM * uvX + uvM * uvY + wuM * uvZ)
    S09T = C_s * AKAE * (uvM * uvX + vvM * uvY + vwM * uvZ)
    T09T = C_s * AKAE * (wuM * uvX + vwM * uvY + wwM * uvZ)
    ! vw �̊g�U --------------------------------------------------------
    R10M = nu * vwX
    S10M = nu * vwY
    T10M = nu * vwZ
    R10T = C_s * AKAE * (uuM * vwX + uvM * vwY + wuM * vwZ)
    S10T = C_s * AKAE * (uvM * vwX + vvM * vwY + vwM * vwZ)
    T10T = C_s * AKAE * (wuM * vwX + vwM * vwY + wwM * vwZ)
    ! wu �̊g�U --------------------------------------------------------
    R11M = nu * wuX
    S11M = nu * wuY
    T11M = nu * wuZ
    R11T = C_s * AKAE * (uuM * wuX + uvM * wuY + wuM * wuZ)
    S11T = C_s * AKAE * (uvM * wuX + vvM * wuY + vwM * wuZ)
    T11T = C_s * AKAE * (wuM * wuX + vwM * wuY + wwM * wuZ)
    ! epsilon �̊g�U ---------------------------------------------------
    R12M = nu * AEX
    S12M = nu * AEY
    T12M = nu * AEZ
    R12T = C_e * AKAE * (uuM * AEX + uvM * AEY + wuM * AEZ)
    S12T = C_e * AKAE * (uvM * AEX + vvM * AEY + vwM * AEZ)
    T12T = C_e * AKAE * (wuM * AEX + vwM * AEY + wwM * AEZ)
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    SH(I,J,K, 1) = 0.0
    SH(I,J,K, 2) = QH1 * ( (R02M + R02T) * ETXM &
    &                    + (S02M + S02T) * ETYM &
    &                    + (T02M + T02T) * ETZM )
    SH(I,J,K, 3) = QH1 * ( (R03M + R03T) * ETXM &
    &                    + (S03M + S03T) * ETYM &
    &                    + (T03M + T03T) * ETZM )
    SH(I,J,K, 4) = QH1 * ( (R04M + R04T) * ETXM &
    &                    + (S04M + S04T) * ETYM &
    &                    + (T04M + T04T) * ETZM )
    SH(I,J,K, 5) = QH1 * ( (R05M + R05T) * ETXM &
    &                    + (S05M + S05T) * ETYM &
    &                    + (T05M + T05T) * ETZM )
    SH(I,J,K, 6) = QH1 * ( (R06M + R06T) * ETXM &
    &                    + (S06M + S06T) * ETYM &
    &                    + (T06M + T06T) * ETZM )
    SH(I,J,K, 7) = QH1 * ( (R07M + R07T) * ETXM &
    &                    + (S07M + S07T) * ETYM &
    &                    + (T07M + T07T) * ETZM )
    SH(I,J,K, 8) = QH1 * ( (R08M + R08T) * ETXM &
    &                    + (S08M + S08T) * ETYM &
    &                    + (T08M + T08T) * ETZM )
    SH(I,J,K, 9) = QH1 * ( (R09M + R09T) * ETXM &
    &                    + (S09M + S09T) * ETYM &
    &                    + (T09M + T09T) * ETZM )
    SH(I,J,K,10) = QH1 * ( (R10M + R10T) * ETXM &
    &                    + (S10M + S10T) * ETYM &
    &                    + (T10M + T10T) * ETZM )
    SH(I,J,K,11) = QH1 * ( (R11M + R11T) * ETXM &
    &                    + (S11M + S11T) * ETYM &
    &                    + (T11M + T11T) * ETZM )
    SH(I,J,K,12) = QH1 * ( (R12M + R12T) * ETXM &
    &                    + (S12M + S12T) * ETYM &
    &                    + (T12M + T12T) * ETZM )
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFET
!***********************************************************************
!**** �g�U���̌v�Z(zeta���������p)                                  ****
!***********************************************************************
SUBROUTINE DIFFZE
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM
  REAL    :: RHOM, UM, VM, WM, uuM, vvM, wwM, uvM, vwM, wuM, EPSM, AMUM
  REAL    :: UXI, UET, UZE, UX, UY, UZ
  REAL    :: VXI, VET, VZE, VX, VY, VZ
  REAL    :: WXI, WET, WZE, WX, WY, WZ
  REAL    :: TXI, TET, TZE, TX, TY, TZ
  REAL    :: uuXI, uuET, uuZE, uuX, uuY, uuZ
  REAL    :: vvXI, vvET, vvZE, vvX, vvY, vvZ
  REAL    :: wwXI, wwET, wwZE, wwX, wwY, wwZ
  REAL    :: uvXI, uvET, uvZE, uvX, uvY, uvZ
  REAL    :: vwXI, vwET, vwZE, vwX, vwY, vwZ
  REAL    :: wuXI, wuET, wuZE, wuX, wuY, wuZ
  REAL    :: AEXI, AEET, AEZE, AEX, AEY, AEZ
  REAL    :: nu
  REAL    :: S11, S22, S33, S12, S23, S31, SS
  REAL    :: C_p, AKAE
  REAL    :: R02M, S02M, T02M, R02T, S02T, T02T
  REAL    :: R03M, S03M, T03M, R03T, S03T, T03T
  REAL    :: R04M, S04M, T04M, R04T, S04T, T04T
  REAL    :: R05M, S05M, T05M, R05T, S05T, T05T
  REAL    :: R06M, S06M, T06M, R06T, S06T, T06T
  REAL    :: R07M, S07M, T07M, R07T, S07T, T07T
  REAL    :: R08M, S08M, T08M, R08T, S08T, T08T
  REAL    :: R09M, S09M, T09M, R09T, S09T, T09T
  REAL    :: R10M, S10M, T10M, R10T, S10T, T10T
  REAL    :: R11M, S11M, T11M, R11T, S11T, T11T
  REAL    :: R12M, S12M, T12M, R12T, S12T, T12T
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM, &
!$OMP& RHOM, UM, VM, WM, uuM, vvM, wwM, uvM, vwM, wuM, EPSM, AMUM, &
!$OMP& UXI, UET, UZE, UX, UY, UZ, &
!$OMP& VXI, VET, VZE, VX, VY, VZ, &
!$OMP& WXI, WET, WZE, WX, WY, WZ, &
!$OMP& TXI, TET, TZE, TX, TY, TZ, &
!$OMP& uuXI, uuET, uuZE, uuX, uuY, uuZ, &
!$OMP& vvXI, vvET, vvZE, vvX, vvY, vvZ, &
!$OMP& wwXI, wwET, wwZE, wwX, wwY, wwZ, &
!$OMP& uvXI, uvET, uvZE, uvX, uvY, uvZ, &
!$OMP& vwXI, vwET, vwZE, vwX, vwY, vwZ, &
!$OMP& wuXI, wuET, wuZE, wuX, wuY, wuZ, &
!$OMP& AEXI, AEET, AEZE, AEX, AEY, AEZ, &
!$OMP& nu, S11, S22, S33, S12, S23, S31, SS, C_p, AKAE, &
!$OMP& R02M, S02M, T02M, R02T, S02T, T02T, &
!$OMP& R03M, S03M, T03M, R03T, S03T, T03T, &
!$OMP& R04M, S04M, T04M, R04T, S04T, T04T, &
!$OMP& R05M, S05M, T05M, R05T, S05T, T05T, &
!$OMP& R06M, S06M, T06M, R06T, S06T, T06T, &
!$OMP& R07M, S07M, T07M, R07T, S07T, T07T, &
!$OMP& R08M, S08M, T08M, R08T, S08T, T08T, &
!$OMP& R09M, S09M, T09M, R09T, S09T, T09T, &
!$OMP& R10M, S10M, T10M, R10T, S10T, T10T, &
!$OMP& R11M, S11M, T11M, R11T, S11T, T11T, &
!$OMP& R12M, S12M, T12M, R12T, S12T, T12T, &
!$OMP& QH1 &
!$OMP& )
  DO K = KS    , KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF((RHO(I,J,K) .GT. 0.0) .AND. (RHO(I,J,K+1) .GT. 0.0)) THEN
    ! XI�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J,K) + XIX(I,J,K+1))
    XIYM = 0.5 * (XIY(I,J,K) + XIY(I,J,K+1))
    XIZM = 0.5 * (XIZ(I,J,K) + XIZ(I,J,K+1))
    ETXM = 0.5 * (ETX(I,J,K) + ETX(I,J,K+1))
    ETYM = 0.5 * (ETY(I,J,K) + ETY(I,J,K+1))
    ETZM = 0.5 * (ETZ(I,J,K) + ETZ(I,J,K+1))
    ZEXM = 0.5 * (ZEX(I,J,K) + ZEX(I,J,K+1))
    ZEYM = 0.5 * (ZEY(I,J,K) + ZEY(I,J,K+1))
    ZEZM = 0.5 * (ZEZ(I,J,K) + ZEZ(I,J,K+1))
    AJAM = 0.5 * (AJA(I,J,K) + AJA(I,J,K+1))
    ! ������
    RHOM = 0.5 * (RHO(I,J,K) + RHO(I,J,K+1))
    UM   = 0.5 * (  U(I,J,K) +   U(I,J,K+1))
    VM   = 0.5 * (  V(I,J,K) +   V(I,J,K+1))
    WM   = 0.5 * (  W(I,J,K) +   W(I,J,K+1))
    uuM  = 0.5 * ( uu(I,J,K) +  uu(I,J,K+1))
    vvM  = 0.5 * ( vv(I,J,K) +  vv(I,J,K+1))
    wwM  = 0.5 * ( ww(I,J,K) +  ww(I,J,K+1))
    uvM  = 0.5 * ( uv(I,J,K) +  uv(I,J,K+1))
    vwM  = 0.5 * ( vw(I,J,K) +  vw(I,J,K+1))
    wuM  = 0.5 * ( wu(I,J,K) +  wu(I,J,K+1))
    EPSM = 0.5 * (EPS(I,J,K) + EPS(I,J,K+1))
    AMUM = 0.5 * (AMU(I,J,K) + AMU(I,J,K+1))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = 0.25 * ( - U(I-1,J,K) - U(I-1,J,K+1) &
    &              + U(I+1,J,K) + U(I+1,J,K+1) )
    UET = 0.25 * ( - U(I,J-1,K) - U(I,J-1,K+1) &
    &              + U(I,J+1,K) + U(I,J+1,K+1) )
    UZE = - U(I,J,K) + U(I,J,K+1)
    VXI = 0.25 * ( - V(I-1,J,K) - V(I-1,J,K+1) &
    &              + V(I+1,J,K) + V(I+1,J,K+1) )
    VET = 0.25 * ( - V(I,J-1,K) - V(I,J-1,K+1) &
    &              + V(I,J+1,K) + V(I,J+1,K+1) )
    VZE = - V(I,J,K) + V(I,J,K+1)
    WXI = 0.25 * ( - W(I-1,J,K) - W(I-1,J,K+1) &
    &              + W(I+1,J,K) + W(I+1,J,K+1) )
    WET = 0.25 * ( - W(I,J-1,K) - W(I,J-1,K+1) &
    &              + W(I,J+1,K) + W(I,J+1,K+1) )
    WZE = - W(I,J,K) + W(I,J,K+1)
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM + UZE * ZEXM
    UY = UXI * XIYM + UET * ETYM + UZE * ZEYM
    UZ = UXI * XIZM + UET * ETZM + UZE * ZEZM
    VX = VXI * XIXM + VET * ETXM + VZE * ZEXM
    VY = VXI * XIYM + VET * ETYM + VZE * ZEYM
    VZ = VXI * XIZM + VET * ETZM + VZE * ZEZM
    WX = WXI * XIXM + WET * ETXM + WZE * ZEXM
    WY = WXI * XIYM + WET * ETYM + WZE * ZEYM
    WZ = WXI * XIZM + WET * ETZM + WZE * ZEZM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = 0.25 * ( - T(I-1,J,K) - T(I-1,J,K+1) &
    &              + T(I+1,J,K) + T(I+1,J,K+1) )
    TET = 0.25 * ( - T(I,J-1,K) - T(I,J-1,K+1) &
    &              + T(I,J+1,K) + T(I,J+1,K+1) )
    TZE = - T(I,J,K) + T(I,J,K+1)
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM + TZE * ZEXM
    TY = TXI * XIYM + TET * ETYM + TZE * ZEYM
    TZ = TXI * XIZM + TET * ETZM + TZE * ZEZM
    ! uu �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    uuXI = 0.25 * ( - uu(I-1,J,K) - uu(I-1,J,K+1) &
    &               + uu(I+1,J,K) + uu(I+1,J,K+1) )
    uuET = 0.25 * ( - uu(I,J-1,K) - uu(I,J-1,K+1) &
    &               + uu(I,J+1,K) + uu(I,J+1,K+1) )
    uuZE = - uu(I,J,K) + uu(I,J,K+1)
    ! ������ԕ�����K����
    uuX = uuXI * XIXM + uuET * ETXM + uuZE * ZEXM
    uuY = uuXI * XIYM + uuET * ETYM + uuZE * ZEYM
    uuZ = uuXI * XIZM + uuET * ETZM + uuZE * ZEZM
    ! vv �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    vvXI = 0.25 * ( - vv(I-1,J,K) - vv(I-1,J,K+1) &
    &               + vv(I+1,J,K) + vv(I+1,J,K+1) )
    vvET = 0.25 * ( - vv(I,J-1,K) - vv(I,J-1,K+1) &
    &               + vv(I,J+1,K) + vv(I,J+1,K+1) )
    vvZE = - vv(I,J,K) + vv(I,J,K+1)
    ! ������ԕ�����K����
    vvX = vvXI * XIXM + vvET * ETXM + vvZE * ZEXM
    vvY = vvXI * XIYM + vvET * ETYM + vvZE * ZEYM
    vvZ = vvXI * XIZM + vvET * ETZM + vvZE * ZEZM
    ! ww �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    wwXI = 0.25 * ( - ww(I-1,J,K) - ww(I-1,J,K+1) &
    &               + ww(I+1,J,K) + ww(I+1,J,K+1) )
    wwET = 0.25 * ( - ww(I,J-1,K) - ww(I,J-1,K+1) &
    &               + ww(I,J+1,K) + ww(I,J+1,K+1) )
    wwZE = - ww(I,J,K) + ww(I,J,K+1)
    ! ������ԕ�����K����
    wwX = wwXI * XIXM + wwET * ETXM + wwZE * ZEXM
    wwY = wwXI * XIYM + wwET * ETYM + wwZE * ZEYM
    wwZ = wwXI * XIZM + wwET * ETZM + wwZE * ZEZM
    ! uv �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    uvXI = 0.25 * ( - uv(I-1,J,K) - uv(I-1,J,K+1) &
    &               + uv(I+1,J,K) + uv(I+1,J,K+1) )
    uvET = 0.25 * ( - uv(I,J-1,K) - uv(I,J-1,K+1) &
    &               + uv(I,J+1,K) + uv(I,J+1,K+1) )
    uvZE = - uv(I,J,K) + uv(I,J,K+1)
    ! ������ԕ�����K����
    uvX = uvXI * XIXM + uvET * ETXM + uvZE * ZEXM
    uvY = uvXI * XIYM + uvET * ETYM + uvZE * ZEYM
    uvZ = uvXI * XIZM + uvET * ETZM + uvZE * ZEZM
    ! vw �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    vwXI = 0.25 * ( - vw(I-1,J,K) - vw(I-1,J,K+1) &
    &               + vw(I+1,J,K) + vw(I+1,J,K+1) )
    vwET = 0.25 * ( - vw(I,J-1,K) - vw(I,J-1,K+1) &
    &               + vw(I,J+1,K) + vw(I,J+1,K+1) )
    vwZE = - vw(I,J,K) + vw(I,J,K+1)
    ! ������ԕ�����K����
    vwX = vwXI * XIXM + vwET * ETXM + vwZE * ZEXM
    vwY = vwXI * XIYM + vwET * ETYM + vwZE * ZEYM
    vwZ = vwXI * XIZM + vwET * ETZM + vwZE * ZEZM
    ! wu �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    wuXI = 0.25 * ( - wu(I-1,J,K) - wu(I-1,J,K+1) &
    &               + wu(I+1,J,K) + wu(I+1,J,K+1) )
    wuET = 0.25 * ( - wu(I,J-1,K) - wu(I,J-1,K+1) &
    &               + wu(I,J+1,K) + wu(I,J+1,K+1) )
    wuZE = - wu(I,J,K) + wu(I,J,K+1)
    ! ������ԕ�����K����
    wuX = wuXI * XIXM + wuET * ETXM + wuZE * ZEXM
    wuY = wuXI * XIYM + wuET * ETYM + wuZE * ZEYM
    wuZ = wuXI * XIZM + wuET * ETZM + wuZE * ZEZM
    ! epsilon �̈�K�����̌v�Z -----------------------------------------
    ! �v�Z��ԕ�����K����
    AEXI = 0.25 * ( - EPS(I-1,J,K) - EPS(I-1,J,K+1) &
    &               + EPS(I+1,J,K) + EPS(I+1,J,K+1) )
    AEET = 0.25 * ( - EPS(I,J-1,K) - EPS(I,J-1,K+1) &
    &               + EPS(I,J+1,K) + EPS(I,J+1,K+1) )
    AEZE = - EPS(I,J,K) + EPS(I,J,K+1)
    ! ������ԕ�����K����
    AEX = AEXI * XIXM + AEET * ETXM + AEZE * ZEXM
    AEY = AEXI * XIYM + AEET * ETYM + AEZE * ZEYM
    AEZ = AEXI * XIZM + AEET * ETZM + AEZE * ZEZM
    ! ���S�x -----------------------------------------------------------
    nu = AMUM / RHOM
    ! �c�ݑ��x ---------------------------------------------------------
    SS  = (UX + VY + WZ) * TwoThird
    S11 = 2.0 * UX - SS
    S22 = 2.0 * VY - SS
    S33 = 2.0 * WZ - SS
    S12 = UY + VX
    S23 = VZ + WY
    S31 = WX + UZ
    ! U �̊g�U ---------------------------------------------------------
    R02M = nu * S11
    S02M = nu * S12
    T02M = nu * S31
    R02T =-uuM
    S02T =-uvM
    T02T =-wuM
    ! V �̊g�U ---------------------------------------------------------
    R03M = nu * S12
    S03M = nu * S22
    T03M = nu * S23
    R03T =-uvM
    S03T =-vvM
    T03T =-vwM
    ! W �̊g�U ---------------------------------------------------------
    R04M = nu * S31
    S04M = nu * S23
    T04M = nu * S33
    R04T =-wuM
    S04T =-vwM
    T04T =-wwM
    ! �G�l���M�[�̊g�U -------------------------------------------------
    C_p  = GAMMA * RG / (GAMMA - 1.0)
    IF(EPSM .GT. ZERO) THEN
      AKAE = 0.5 * (uuM + vvM + wwM) / EPSM
    ELSE
      AKAE = 0.0
    ENDIF
    R05M = C_p * nu / PR * TX + nu * (S11 * UM + S12 * VM + S31 * WM)
    S05M = C_p * nu / PR * TY + nu * (S12 * UM + S22 * VM + S23 * WM)
    T05M = C_p * nu / PR * TZ + nu * (S31 * UM + S23 * VM + S33 * WM)
    R05T = AKAE * C_se * C_p * (uuM * TX + uvM * TY + wuM * TZ) &
    &    + AKAE * C_s  * ( &
    &      uuM * (uuX + vvX + wwX) &
    &    + uvM * (uuY + vvY + wwY) &
    &    + wuM * (uuZ + vvZ + wwZ) &
    &    ) &
    &    - (uuM * UM + uvM * VM + wuM * WM)
    S05T = AKAE * C_se * C_p * (uvM * TX + vvM * TY + vwM * TZ) &
    &    + AKAE * C_s  * ( &
    &      uvM * (uuX + vvX + wwX) &
    &    + vvM * (uuY + vvY + wwY) &
    &    + vwM * (uuZ + vvZ + wwZ) &
    &    ) &
    &    - (uvM * UM + vvM * VM + vwM * WM)
    T05T = AKAE * C_se * C_p * (wuM * TX + vwM * TY + wwM * TZ) &
    &    + AKAE * C_s  * ( &
    &      wuM * (uuX + vvX + wwX) &
    &    + vwM * (uuY + vvY + wwY) &
    &    + wwM * (uuZ + vvZ + wwZ) &
    &    ) &
    &    - (wuM * UM + vwM * VM + wwM * WM)
    ! uu �̊g�U --------------------------------------------------------
    R06M = nu * uuX
    S06M = nu * uuY
    T06M = nu * uuZ
    R06T = C_s * AKAE * (uuM * uuX + uvM * uuY + wuM * uuZ)
    S06T = C_s * AKAE * (uvM * uuX + vvM * uuY + vwM * uuZ)
    T06T = C_s * AKAE * (wuM * uuX + vwM * uuY + wwM * uuZ)
    ! vv �̊g�U --------------------------------------------------------
    R07M = nu * vvX
    S07M = nu * vvY
    T07M = nu * vvZ
    R07T = C_s * AKAE * (uuM * vvX + uvM * vvY + wuM * vvZ)
    S07T = C_s * AKAE * (uvM * vvX + vvM * vvY + vwM * vvZ)
    T07T = C_s * AKAE * (wuM * vvX + vwM * vvY + wwM * vvZ)
    ! ww �̊g�U --------------------------------------------------------
    R08M = nu * wwX
    S08M = nu * wwY
    T08M = nu * wwZ
    R08T = C_s * AKAE * (uuM * wwX + uvM * wwY + wuM * wwZ)
    S08T = C_s * AKAE * (uvM * wwX + vvM * wwY + vwM * wwZ)
    T08T = C_s * AKAE * (wuM * wwX + vwM * wwY + wwM * wwZ)
    ! uv �̊g�U --------------------------------------------------------
    R09M = nu * uvX
    S09M = nu * uvY
    T09M = nu * uvZ
    R09T = C_s * AKAE * (uuM * uvX + uvM * uvY + wuM * uvZ)
    S09T = C_s * AKAE * (uvM * uvX + vvM * uvY + vwM * uvZ)
    T09T = C_s * AKAE * (wuM * uvX + vwM * uvY + wwM * uvZ)
    ! vw �̊g�U --------------------------------------------------------
    R10M = nu * vwX
    S10M = nu * vwY
    T10M = nu * vwZ
    R10T = C_s * AKAE * (uuM * vwX + uvM * vwY + wuM * vwZ)
    S10T = C_s * AKAE * (uvM * vwX + vvM * vwY + vwM * vwZ)
    T10T = C_s * AKAE * (wuM * vwX + vwM * vwY + wwM * vwZ)
    ! wu �̊g�U --------------------------------------------------------
    R11M = nu * wuX
    S11M = nu * wuY
    T11M = nu * wuZ
    R11T = C_s * AKAE * (uuM * wuX + uvM * wuY + wuM * wuZ)
    S11T = C_s * AKAE * (uvM * wuX + vvM * wuY + vwM * wuZ)
    T11T = C_s * AKAE * (wuM * wuX + vwM * wuY + wwM * wuZ)
    ! epsilon �̊g�U ---------------------------------------------------
    R12M = nu * AEX
    S12M = nu * AEY
    T12M = nu * AEZ
    R12T = C_e * AKAE * (uuM * AEX + uvM * AEY + wuM * AEZ)
    S12T = C_e * AKAE * (uvM * AEX + vvM * AEY + vwM * AEZ)
    T12T = C_e * AKAE * (wuM * AEX + vwM * AEY + wwM * AEZ)
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    TH(I,J,K, 1) = 0.0
    TH(I,J,K, 2) = QH1 * ( (R02M + R02T) * ZEXM &
    &                    + (S02M + S02T) * ZEYM &
    &                    + (T02M + T02T) * ZEZM )
    TH(I,J,K, 3) = QH1 * ( (R03M + R03T) * ZEXM &
    &                    + (S03M + S03T) * ZEYM &
    &                    + (T03M + T03T) * ZEZM )
    TH(I,J,K, 4) = QH1 * ( (R04M + R04T) * ZEXM &
    &                    + (S04M + S04T) * ZEYM &
    &                    + (T04M + T04T) * ZEZM )
    TH(I,J,K, 5) = QH1 * ( (R05M + R05T) * ZEXM &
    &                    + (S05M + S05T) * ZEYM &
    &                    + (T05M + T05T) * ZEZM )
    TH(I,J,K, 6) = QH1 * ( (R06M + R06T) * ZEXM &
    &                    + (S06M + S06T) * ZEYM &
    &                    + (T06M + T06T) * ZEZM )
    TH(I,J,K, 7) = QH1 * ( (R07M + R07T) * ZEXM &
    &                    + (S07M + S07T) * ZEYM &
    &                    + (T07M + T07T) * ZEZM )
    TH(I,J,K, 8) = QH1 * ( (R08M + R08T) * ZEXM &
    &                    + (S08M + S08T) * ZEYM &
    &                    + (T08M + T08T) * ZEZM )
    TH(I,J,K, 9) = QH1 * ( (R09M + R09T) * ZEXM &
    &                    + (S09M + S09T) * ZEYM &
    &                    + (T09M + T09T) * ZEZM )
    TH(I,J,K,10) = QH1 * ( (R10M + R10T) * ZEXM &
    &                    + (S10M + S10T) * ZEYM &
    &                    + (T10M + T10T) * ZEZM )
    TH(I,J,K,11) = QH1 * ( (R11M + R11T) * ZEXM &
    &                    + (S11M + S11T) * ZEYM &
    &                    + (T11M + T11T) * ZEZM )
    TH(I,J,K,12) = QH1 * ( (R12M + R12T) * ZEXM &
    &                    + (S12M + S12T) * ZEYM &
    &                    + (T12M + T12T) * ZEZM )
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFZE
! ��`�I�� *************************************************************
END SUBROUTINE Turbulence3DRSMGL
!***********************************************************************
!**** �������f�� : RANS, RSM Speziale-Sarkar-Gatski Model (1991)    ****
!****              epsilon�������̒萔��Gibson-Launder�̒l�ɕύX    ****
!****              �����M�`�B�ɂ�Vandromme�̃��f�����g�p            ****
!**** �v�Z�Ώ� : �P��, �񎟌�, ���k��                               ****
!**** �v�Z�X�L�[�� : �񎟐��x���S����(�X�^�K�[�h�i�q��̓_���g�p)   ****
!***********************************************************************
SUBROUTINE Turbulence2DRSMSSG( &
&            PELIM, RG, GAMMA, PR, &
&            IS, IE, JS, JE, LS, LE, &
&            XIX, XIY, ETX, ETY, AJA, &
&            RHO, U, V, T, uu, vv, ww, uv, EPS, AMU, &
&            AMUT, DQD, DQP &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, PARAMETER :: C_se = 0.313
  ! REAL, PARAMETER :: C_s = 0.22, C_e = 0.183
  REAL, PARAMETER :: C_s = 0.22, C_e = 0.18
  REAL, PARAMETER :: C_1 = 3.4, C_2 = 4.2, C_3 = 0.8, &
  &                  C_4 = 1.25, C_5 = 0.4
  REAL, PARAMETER :: C_1a = 1.8, C_3a = 1.3
  ! REAL, PARAMETER :: C_e1 = 1.44, C_e2 = 1.83
  REAL, PARAMETER :: C_e1 = 1.44, C_e2 = 1.92
  REAL, PARAMETER :: OneThird = 0.33333333, TwoThird = 0.66666667
  REAL, PARAMETER :: ZERO = 1.0E-20
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: PELIM
  REAL,    INTENT(IN)  :: RG, GAMMA, PR
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE
  INTEGER, INTENT(IN)  :: LS, LE
  REAL,    INTENT(IN)  :: XIX(IS:IE, JS:JE), XIY(IS:IE, JS:JE), &
  &                       ETX(IS:IE, JS:JE), ETY(IS:IE, JS:JE), &
  &                       AJA(IS:IE, JS:JE)
  REAL,    INTENT(IN)  :: RHO(IS:IE, JS:JE), &
  &                       U(IS:IE, JS:JE), &
  &                       V(IS:IE, JS:JE), &
  &                       T(IS:IE, JS:JE), &
  &                       uu(IS:IE, JS:JE), &
  &                       vv(IS:IE, JS:JE), &
  &                       ww(IS:IE, JS:JE), &
  &                       uv(IS:IE, JS:JE), &
  &                       EPS(IS:IE, JS:JE)
  REAL,    INTENT(IN)  :: AMU(IS:IE, JS:JE)
  REAL,    INTENT(OUT) :: AMUT(IS:IE, JS:JE)
  REAL,    INTENT(OUT) :: DQD(IS:IE, JS:JE, LS:LE)
  REAL,    INTENT(OUT) :: DQP(IS:IE, JS:JE, LS:LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, ALLOCATABLE :: RH(:, :, :), SH(:, :, :)
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 9) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �������m�� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ALLOCATE(RH(IS: IE, JS: JE, LS: LE), SH(IS: IE, JS: JE, LS: LE))
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  AMUT = 0.0
  DQD  = 0.0
  DQP  = 0.0
  ! �����葱���̌Ăяo�� +++++++++++++++++++++++++++++++++++++++++++++++
  CALL NonDiffTerm
  CALL DiffTerm
  ! �����I�� ***********************************************************
  RETURN
! �����葱�� ***********************************************************
CONTAINS
!***********************************************************************
!**** ��g�U���̌v�Z                                                ****
!***********************************************************************
SUBROUTINE NonDiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: TMP, TMP1, TMP2
  REAL    :: UXI, VXI, UET, VET, UX, VX, UY, VY
  REAL    :: P11, P22, P33, P12, P_k
  REAL    :: eps11, eps22, eps33, eps12, e_k
  REAL    :: S11, S22, S33, S12, SS2
  REAL    :: O12
  REAL    :: b11, b22, b33, b12
  REAL    :: phi11, phi22, phi33, phi12
  REAL    :: AK, nu, AEAK
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, TMP, TMP1, TMP2, &
!$OMP& UXI, VXI, UET, VET, UX, VX, UY, VY, &
!$OMP& P11, P22, P33, P12, P_k, eps11, eps22, eps33, eps12, e_k, &
!$OMP& S11, S22, S33, S12, SS2, O12, b11, b22, b33, b12, &
!$OMP& phi11, phi22, phi33, phi12, AK, nu, AEAK, QH1 &
!$OMP& )
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF(RHO(I,J) .GT. 0.0) THEN
    ! �����G�l���M�[ ---------------------------------------------------
    AK = 0.5 * (uu(I,J) + vv(I,J) + ww(I,J))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = 0.5 * (U(I+1,J) - U(I-1,J))
    VXI = 0.5 * (V(I+1,J) - V(I-1,J))
    UET = 0.5 * (U(I,J+1) - U(I,J-1))
    VET = 0.5 * (V(I,J+1) - V(I,J-1))
    ! ������ԕ�����K����
    UX = UXI * XIX(I,J) + UET * ETX(I,J)
    UY = UXI * XIY(I,J) + UET * ETY(I,J)
    VX = VXI * XIX(I,J) + VET * ETX(I,J)
    VY = VXI * XIY(I,J) + VET * ETY(I,J)
    ! �������ƎU�퍀 ---------------------------------------------------
    P11 = - 2.0 * (uu(I,J) * UX + uv(I,J) * UY)
    P22 = - 2.0 * (uv(I,J) * VX + vv(I,J) * VY)
    P33 = 0.0
    P12 = - (uu(I,J) * VX + uv(I,J) * (UX + VY) + vv(I,J) * UY)
    P_k = 0.5 * (P11 + P22 + P33)
    e_k = EPS(I,J)
    ! �Ǐ����t����(�����ƎU��̃o�����X)�ɂ�郊�~�b�^�[
    IF(PELIM .GT. 0.0) THEN
      TMP = TwoThird * e_k / PELIM
      P11 = MIN(TMP, MAX(-TMP, P11))
      P22 = MIN(TMP, MAX(-TMP, P22))
      P33 = MIN(TMP, MAX(-TMP, P33))
      P_k = 0.5 * (P11 + P22 + P33)
    ENDIF
    TMP   = TwoThird * e_k
    eps11 = TMP
    eps22 = TMP
    eps33 = TMP
    eps12 = 0.0
    ! �c�ݑ��x ---------------------------------------------------------
    TMP = (UX + VY) * OneThird
    S11 = UX - TMP
    S22 = VY - TMP
    S33 =    - TMP
    S12 = 0.5 * (UY + VX)
    SS2 = S11 * S11 + S22 * S22 + S33 * S33 + 2.0 * S12 * S12
    ! �Q�x -------------------------------------------------------------
    O12 = 0.5 * (UY - VX)
    ! �񓙕����C�m���Y���̓e���\�� b_ij --------------------------------
    IF(AK .GT. ZERO) THEN
      b11 = 0.5 * uu(I,J) / AK - OneThird
      b22 = 0.5 * vv(I,J) / AK - OneThird
      b33 = 0.5 * ww(I,J) / AK - OneThird
      b12 = 0.5 * uv(I,J) / AK
      b11 = MIN(TwoThird, MAX(- OneThird, b11))
      b22 = MIN(TwoThird, MAX(- OneThird, b22))
      b33 = MIN(TwoThird, MAX(- OneThird, b33))
      b12 = MIN(0.5, MAX(-0.5, b12))
    ELSE
      b11 =-OneThird
      b22 =-OneThird
      b33 =-OneThird
      b12 = 0.0
    ENDIF
    ! �ĕ��z�� ---------------------------------------------------------
    TMP1 = b11 * b11 + b22 * b22 + b33 * b33 + 2.0 * b12 * b12
    TMP2 = b11 * S11 + b22 * S22 + b33 * S33 + 2.0 * b12 * S12
    TMP2 = TMP2 * TwoThird
    phi11 =-(C_1 * e_k + C_1a * P_k) * b11 &
    &     + C_2 * e_k * (b11**2 + b12**2 - TMP1 * OneThird) &
    &     + (C_3 - C_3a * SQRT(TMP1)) * AK * S11 &
    &     + C_4 * AK * (2.0 * (b11 * S11 + b12 * S12) - TMP2) &
    &     + C_5 * AK * (2.0 * b12 * O12)
    phi22 =-(C_1 * e_k + C_1a * P_k) * b22 &
    &     + C_2 * e_k * (b12**2 + b22**2 - TMP1 * OneThird) &
    &     + (C_3 - C_3a * SQRT(TMP1)) * AK * S22 &
    &     + C_4 * AK * (2.0 * (b12 * S12 + b22 * S22) - TMP2) &
    &     - C_5 * AK * (2.0 * b12 * O12)
    phi33 =-(C_1 * e_k + C_1a * P_k) * b33 &
    &     + C_2 * e_k * (b33 * b33 - TMP1 * OneThird) &
    &     + (C_3 - C_3a * SQRT(TMP1)) * AK * S33 &
    &     + C_4 * AK * (2.0 * b33 * S33 - TMP2)
    phi12 =-(C_1 * e_k + C_1a * P_k) * b12 &
    &     + C_2 * e_k * (b11 + b22) * b12 &
    &     + (C_3 - C_3a * SQRT(TMP1)) * AK * S12 &
    &     + C_4 * AK * ((b11 + b22) * S12 + b12 * (S11 + S22)) &
    &     + C_5 * AK * (b22 - b11) * O12
    ! �Q�S���W���̌v�Z -------------------------------------------------
    IF(e_k .GT. ZERO) THEN
      AMUT(I,J) = 0.09 * AK**2 / e_k * RHO(I,J)
    ENDIF
    ! �������A���͍ĕ��z���A�U�퍀�̘a ---------------------------------
    QH1  = RHO(I,J) / AJA(I,J)
    nu   = AMU(I,J) / RHO(I,J)
    AEAK = MIN( &
    &        MAX(SQRT(2.0 * SS2), SQRT(e_k / nu)), &
    &        e_k / MAX(ZERO, AK) &
    &    )
    DQP(I,J,5) = QH1 * (P11 - eps11 + phi11)
    DQP(I,J,6) = QH1 * (P22 - eps22 + phi22)
    DQP(I,J,7) = QH1 * (P33 - eps33 + phi33)
    DQP(I,J,8) = QH1 * (P12 - eps12 + phi12)
    DQP(I,J,9) = QH1 * AEAK * (C_e1 * P_k - C_e2 * e_k)
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE NonDiffTerm
!***********************************************************************
!**** �g�U���̌v�Z                                                  ****
!***********************************************************************
SUBROUTINE DiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, L
  ! �����J�n ***********************************************************
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  RH = 0.0
  SH = 0.0
  ! �g�U���̗v�f���v�Z +++++++++++++++++++++++++++++++++++++++++++++++++
  CALL DIFFXI
  CALL DIFFET
  ! �g�U���̍��� +++++++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE(I, J, L)
  DO L = LS, LE
  !$OMP DO
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( (RHO(I,J-1) .GT. 0.0) .AND. (RHO(I-1,J) .GT. 0.0) .AND. &
  &   (RHO(I,J)   .GT. 0.0) .AND. &
  &   (RHO(I+1,J) .GT. 0.0) .AND. (RHO(I,J+1) .GT. 0.0) &
  & ) THEN
    DQD(I,J,L) = (-RH(I-1,J  ,L) + RH(I,J,L)) &
    &          + (-SH(I  ,J-1,L) + SH(I,J,L))
  ENDIF
  ENDDO
  ENDDO
  !$OMP END DO
  ENDDO
  !$OMP END PARALLEL
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DiffTerm
!***********************************************************************
!**** �g�U���̌v�Z(xi���������p)                                    ****
!***********************************************************************
SUBROUTINE DIFFXI
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: XIXM, XIYM, ETXM, ETYM, AJAM
  REAL    :: RHOM, UM, VM, uuM, vvM, wwM, uvM, EPSM, AMUM
  REAL    :: UXI, UET, UX, UY
  REAL    :: VXI, VET, VX, VY
  REAL    :: TXI, TET, TX, TY
  REAL    :: uuXI, uuET, uuX, uuY
  REAL    :: vvXI, vvET, vvX, vvY
  REAL    :: wwXI, wwET, wwX, wwY
  REAL    :: uvXI, uvET, uvX, uvY
  REAL    :: AEXI, AEET, AEX, AEY
  REAL    :: nu
  REAL    :: S11, S22, S12, SS
  REAL    :: C_p, AKAE
  REAL    :: R2M, S2M, R2T, S2T
  REAL    :: R3M, S3M, R3T, S3T
  REAL    :: R4M, S4M, R4T, S4T
  REAL    :: R5M, S5M, R5T, S5T
  REAL    :: R6M, S6M, R6T, S6T
  REAL    :: R7M, S7M, R7T, S7T
  REAL    :: R8M, S8M, R8T, S8T
  REAL    :: R9M, S9M, R9T, S9T
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, &
!$OMP& XIXM, XIYM, ETXM, ETYM, AJAM, &
!$OMP& RHOM, UM, VM, uuM, vvM, wwM, uvM, EPSM, AMUM, &
!$OMP& UXI, UET, UX, UY, VXI, VET, VX, VY, TXI, TET, TX, TY, &
!$OMP& uuXI, uuET, uuX, uuY, vvXI, vvET, vvX, vvY, &
!$OMP& wwXI, wwET, wwX, wwY, uvXI, uvET, uvX, uvY, &
!$OMP& AEXI, AEET, AEX, AEY, &
!$OMP& nu, S11, S22, S12, SS, C_p, AKAE, &
!$OMP& R2M, S2M, R2T, S2T, R3M, S3M, R3T, S3T, R4M, S4M, R4T, S4T, &
!$OMP& R5M, S5M, R5T, S5T, R6M, S6M, R6T, S6T, R7M, S7M, R7T, S7T, &
!$OMP& R8M, S8M, R8T, S8T, R9M, S9M, R9T, S9T, QH1 &
!$OMP& )
  DO J = JS + 1, JE - 1
  DO I = IS    , IE - 1
  IF((RHO(I,J) .GT. 0.0) .AND. (RHO(I+1,J) .GT. 0.0)) THEN
    ! XI�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J) + XIX(I+1,J))
    XIYM = 0.5 * (XIY(I,J) + XIY(I+1,J))
    ETXM = 0.5 * (ETX(I,J) + ETX(I+1,J))
    ETYM = 0.5 * (ETY(I,J) + ETY(I+1,J))
    AJAM = 0.5 * (AJA(I,J) + AJA(I+1,J))
    ! ������
    RHOM = 0.5 * (RHO(I,J) + RHO(I+1,J))
    UM   = 0.5 * (  U(I,J) +   U(I+1,J))
    VM   = 0.5 * (  V(I,J) +   V(I+1,J))
    uuM  = 0.5 * ( uu(I,J) +  uu(I+1,J))
    vvM  = 0.5 * ( vv(I,J) +  vv(I+1,J))
    wwM  = 0.5 * ( ww(I,J) +  ww(I+1,J))
    uvM  = 0.5 * ( uv(I,J) +  uv(I+1,J))
    EPSM = 0.5 * (EPS(I,J) + EPS(I+1,J))
    AMUM = 0.5 * (AMU(I,J) + AMU(I+1,J))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = - U(I,J) + U(I+1,J)
    UET = 0.25 * (- U(I,J-1) - U(I+1,J-1) + U(I,J+1) + U(I+1,J+1))
    VXI = - V(I,J) + V(I+1,J)
    VET = 0.25 * (- V(I,J-1) - V(I+1,J-1) + V(I,J+1) + V(I+1,J+1))
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM
    UY = UXI * XIYM + UET * ETYM
    VX = VXI * XIXM + VET * ETXM
    VY = VXI * XIYM + VET * ETYM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = - T(I,J) + T(I+1,J)
    TET = 0.25 * (- T(I,J-1) - T(I+1,J-1) + T(I,J+1) + T(I+1,J+1))
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM
    TY = TXI * XIYM + TET * ETYM
    ! uu �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    uuXI = - uu(I,J) + uu(I+1,J)
    uuET = 0.25 * ( - uu(I,J-1) - uu(I+1,J-1) &
    &               + uu(I,J+1) + uu(I+1,J+1) )
    ! ������ԕ�����K����
    uuX = uuXI * XIXM + uuET * ETXM
    uuY = uuXI * XIYM + uuET * ETYM
    ! vv �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    vvXI = - vv(I,J) + vv(I+1,J)
    vvET = 0.25 * ( - vv(I,J-1) - vv(I+1,J-1) &
    &               + vv(I,J+1) + vv(I+1,J+1) )
    ! ������ԕ�����K����
    vvX = vvXI * XIXM + vvET * ETXM
    vvY = vvXI * XIYM + vvET * ETYM
    ! ww �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    wwXI = - ww(I,J) + ww(I+1,J)
    wwET = 0.25 * ( - ww(I,J-1) - ww(I+1,J-1) &
    &               + ww(I,J+1) + ww(I+1,J+1) )
    ! ������ԕ�����K����
    wwX = wwXI * XIXM + wwET * ETXM
    wwY = wwXI * XIYM + wwET * ETYM
    ! uv �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    uvXI = - uv(I,J) + uv(I+1,J)
    uvET = 0.25 * ( - uv(I,J-1) - uv(I+1,J-1) &
    &               + uv(I,J+1) + uv(I+1,J+1) )
    ! ������ԕ�����K����
    uvX = uvXI * XIXM + uvET * ETXM
    uvY = uvXI * XIYM + uvET * ETYM
    ! epsilon �̈�K�����̌v�Z -----------------------------------------
    ! �v�Z��ԕ�����K����
    AEXI = - EPS(I,J) + EPS(I+1,J)
    AEET = 0.25 * ( - EPS(I,J-1) - EPS(I+1,J-1) &
    &               + EPS(I,J+1) + EPS(I+1,J+1) )
    ! ������ԕ�����K����
    AEX = AEXI * XIXM + AEET * ETXM
    AEY = AEXI * XIYM + AEET * ETYM
    ! ���S�x -----------------------------------------------------------
    nu = AMUM / RHOM
    ! �c�ݑ��x ---------------------------------------------------------
    SS  = (UX + VY) * TwoThird
    S11 = 2.0 * UX - SS
    S22 = 2.0 * VY - SS
    S12 = UY + VX
    ! U �̊g�U ---------------------------------------------------------
    R2M = nu * S11
    S2M = nu * S12
    R2T =-uuM
    S2T =-uvM
    ! V �̊g�U ---------------------------------------------------------
    R3M = nu * S12
    S3M = nu * S22
    R3T =-uvM
    S3T =-vvM
    ! �G�l���M�[�̊g�U -------------------------------------------------
    C_p  = GAMMA * RG / (GAMMA - 1.0)
    IF(EPSM .GT. ZERO) THEN
      AKAE = 0.5 * (uuM + vvM + wwM) / EPSM
    ELSE
      AKAE = 0.0
    ENDIF
    R4M = C_p * nu / PR * TX + nu * (S11 * UM + S12 * VM)
    S4M = C_p * nu / PR * TY + nu * (S12 * UM + S22 * VM)
    R4T = AKAE * C_se * C_p * (uuM * TX + uvM * TY) &
    &   + AKAE * C_s  * ( &
    &     uuM * (uuX + vvX + wwX) + uvM * (uuY + vvY + wwY) &
    &   ) &
    &   - (uuM * UM + uvM * VM)
    S4T = AKAE * C_se * C_p * (uvM * TX + vvM * TY) &
    &   + AKAE * C_s  * ( &
    &     uvM * (uuX + vvX + wwX) + vvM * (uuY + vvY + wwY) &
    &   ) &
    &   - (uvM * UM + vvM * VM)
    ! uu �̊g�U --------------------------------------------------------
    R5M = nu * uuX
    S5M = nu * uuY
    R5T = C_s * AKAE * (uuM * uuX + uvM * uuY)
    S5T = C_s * AKAE * (uvM * uuX + vvM * uuY)
    ! vv �̊g�U --------------------------------------------------------
    R6M = nu * vvX
    S6M = nu * vvY
    R6T = C_s * AKAE * (uuM * vvX + uvM * vvY)
    S6T = C_s * AKAE * (uvM * vvX + vvM * vvY)
    ! ww �̊g�U --------------------------------------------------------
    R7M = nu * wwX
    S7M = nu * wwY
    R7T = C_s * AKAE * (uuM * wwX + uvM * wwY)
    S7T = C_s * AKAE * (uvM * wwX + vvM * wwY)
    ! uv �̊g�U --------------------------------------------------------
    R8M = nu * uvX
    S8M = nu * uvY
    R8T = C_s * AKAE * (uuM * uvX + uvM * uvY)
    S8T = C_s * AKAE * (uvM * uvX + vvM * uvY)
    ! epsilon �̊g�U ---------------------------------------------------
    R9M = nu * AEX
    S9M = nu * AEY
    R9T = C_e * AKAE * (uuM * AEX + uvM * AEY)
    S9T = C_e * AKAE * (uvM * AEX + vvM * AEY)
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    RH(I,J,1) = 0.0
    RH(I,J,2) = QH1 * ((R2M + R2T) * XIXM + (S2M + S2T) * XIYM)
    RH(I,J,3) = QH1 * ((R3M + R3T) * XIXM + (S3M + S3T) * XIYM)
    RH(I,J,4) = QH1 * ((R4M + R4T) * XIXM + (S4M + S4T) * XIYM)
    RH(I,J,5) = QH1 * ((R5M + R5T) * XIXM + (S5M + S5T) * XIYM)
    RH(I,J,6) = QH1 * ((R6M + R6T) * XIXM + (S6M + S6T) * XIYM)
    RH(I,J,7) = QH1 * ((R7M + R7T) * XIXM + (S7M + S7T) * XIYM)
    RH(I,J,8) = QH1 * ((R8M + R8T) * XIXM + (S8M + S8T) * XIYM)
    RH(I,J,9) = QH1 * ((R9M + R9T) * XIXM + (S9M + S9T) * XIYM)
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFXI
!***********************************************************************
!**** �g�U���̌v�Z(eta���������p)                                   ****
!***********************************************************************
SUBROUTINE DIFFET
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: XIXM, XIYM, ETXM, ETYM, AJAM
  REAL    :: RHOM, UM, VM, uuM, vvM, wwM, uvM, EPSM, AMUM
  REAL    :: UXI, UET, UX, UY
  REAL    :: VXI, VET, VX, VY
  REAL    :: TXI, TET, TX, TY
  REAL    :: uuXI, uuET, uuX, uuY
  REAL    :: vvXI, vvET, vvX, vvY
  REAL    :: wwXI, wwET, wwX, wwY
  REAL    :: uvXI, uvET, uvX, uvY
  REAL    :: AEXI, AEET, AEX, AEY
  REAL    :: nu
  REAL    :: S11, S22, S12, SS
  REAL    :: C_p, AKAE
  REAL    :: R2M, S2M, R2T, S2T
  REAL    :: R3M, S3M, R3T, S3T
  REAL    :: R4M, S4M, R4T, S4T
  REAL    :: R5M, S5M, R5T, S5T
  REAL    :: R6M, S6M, R6T, S6T
  REAL    :: R7M, S7M, R7T, S7T
  REAL    :: R8M, S8M, R8T, S8T
  REAL    :: R9M, S9M, R9T, S9T
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, &
!$OMP& XIXM, XIYM, ETXM, ETYM, AJAM, &
!$OMP& RHOM, UM, VM, uuM, vvM, wwM, uvM, EPSM, AMUM, &
!$OMP& UXI, UET, UX, UY, VXI, VET, VX, VY, TXI, TET, TX, TY, &
!$OMP& uuXI, uuET, uuX, uuY, vvXI, vvET, vvX, vvY, &
!$OMP& wwXI, wwET, wwX, wwY, uvXI, uvET, uvX, uvY, &
!$OMP& AEXI, AEET, AEX, AEY, &
!$OMP& nu, S11, S22, S12, SS, C_p, AKAE, &
!$OMP& R2M, S2M, R2T, S2T, R3M, S3M, R3T, S3T, R4M, S4M, R4T, S4T, &
!$OMP& R5M, S5M, R5T, S5T, R6M, S6M, R6T, S6T, R7M, S7M, R7T, S7T, &
!$OMP& R8M, S8M, R8T, S8T, R9M, S9M, R9T, S9T, QH1 &
!$OMP& )
  DO J = JS    , JE - 1
  DO I = IS + 1, IE - 1
  IF((RHO(I,J) .GT. 0.0) .AND. (RHO(I,J+1) .GT. 0.0)) THEN
    ! ET�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J) + XIX(I,J+1))
    XIYM = 0.5 * (XIY(I,J) + XIY(I,J+1))
    ETXM = 0.5 * (ETX(I,J) + ETX(I,J+1))
    ETYM = 0.5 * (ETY(I,J) + ETY(I,J+1))
    AJAM = 0.5 * (AJA(I,J) + AJA(I,J+1))
    ! ������
    RHOM = 0.5 * (RHO(I,J) + RHO(I,J+1))
    UM   = 0.5 * (  U(I,J) +   U(I,J+1))
    VM   = 0.5 * (  V(I,J) +   V(I,J+1))
    uuM  = 0.5 * ( uu(I,J) +  uu(I,J+1))
    vvM  = 0.5 * ( vv(I,J) +  vv(I,J+1))
    wwM  = 0.5 * ( ww(I,J) +  ww(I,J+1))
    uvM  = 0.5 * ( uv(I,J) +  uv(I,J+1))
    EPSM = 0.5 * (EPS(I,J) + EPS(I,J+1))
    AMUM = 0.5 * (AMU(I,J) + AMU(I,J+1))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = 0.25 * (- U(I-1,J) - U(I-1,J+1) + U(I+1,J) + U(I+1,J+1))
    UET = - U(I,J) + U(I,J+1)
    VXI = 0.25 * (- V(I-1,J) - V(I-1,J+1) + V(I+1,J) + V(I+1,J+1))
    VET = - V(I,J) + V(I,J+1)
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM
    UY = UXI * XIYM + UET * ETYM
    VX = VXI * XIXM + VET * ETXM
    VY = VXI * XIYM + VET * ETYM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = 0.25 * (- T(I-1,J) - T(I-1,J+1) + T(I+1,J) + T(I+1,J+1))
    TET = - T(I,J) + T(I,J+1)
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM
    TY = TXI * XIYM + TET * ETYM
    ! uu �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    uuXI = 0.25 * (- uu(I-1,J) - uu(I-1,J+1) + uu(I+1,J) + uu(I+1,J+1))
    uuET = - uu(I,J) + uu(I,J+1)
    ! ������ԕ�����K����
    uuX = uuXI * XIXM + uuET * ETXM
    uuY = uuXI * XIYM + uuET * ETYM
    ! vv �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    vvXI = 0.25 * (- vv(I-1,J) - vv(I-1,J+1) + vv(I+1,J) + vv(I+1,J+1))
    vvET = - vv(I,J) + vv(I,J+1)
    ! ������ԕ�����K����
    vvX = vvXI * XIXM + vvET * ETXM
    vvY = vvXI * XIYM + vvET * ETYM
    ! ww �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    wwXI = 0.25 * (- ww(I-1,J) - ww(I-1,J+1) + ww(I+1,J) + ww(I+1,J+1))
    wwET = - ww(I,J) + ww(I,J+1)
    ! ������ԕ�����K����
    wwX = wwXI * XIXM + wwET * ETXM
    wwY = wwXI * XIYM + wwET * ETYM
    ! uv �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    uvXI = 0.25 * (- uv(I-1,J) - uv(I-1,J+1) + uv(I+1,J) + uv(I+1,J+1))
    uvET = - uv(I,J) + uv(I,J+1)
    ! ������ԕ�����K����
    uvX = uvXI * XIXM + uvET * ETXM
    uvY = uvXI * XIYM + uvET * ETYM
    ! epsilon �̈�K�����̌v�Z -----------------------------------------
    ! �v�Z��ԕ�����K����
    AEXI = 0.25 * ( - EPS(I-1,J) - EPS(I-1,J+1) &
    &               + EPS(I+1,J) + EPS(I+1,J+1) )
    AEET = - EPS(I,J) + EPS(I,J+1)
    ! ������ԕ�����K����
    AEX = AEXI * XIXM + AEET * ETXM
    AEY = AEXI * XIYM + AEET * ETYM
    ! ���S�x -----------------------------------------------------------
    nu = AMUM / RHOM
    ! �c�ݑ��x ---------------------------------------------------------
    SS  = (UX + VY) * TwoThird
    S11 = 2.0 * UX - SS
    S22 = 2.0 * VY - SS
    S12 = UY + VX
    ! U �̊g�U ---------------------------------------------------------
    R2M = nu * S11
    S2M = nu * S12
    R2T =-uuM
    S2T =-uvM
    ! V �̊g�U ---------------------------------------------------------
    R3M = nu * S12
    S3M = nu * S22
    R3T =-uvM
    S3T =-vvM
    ! �G�l���M�[�̊g�U -------------------------------------------------
    C_p  = GAMMA * RG / (GAMMA - 1.0)
    IF(EPSM .GT. ZERO) THEN
      AKAE = 0.5 * (uuM + vvM + wwM) / EPSM
    ELSE
      AKAE = 0.0
    ENDIF
    R4M = C_p * nu / PR * TX + nu * (S11 * UM + S12 * VM)
    S4M = C_p * nu / PR * TY + nu * (S12 * UM + S22 * VM)
    R4T = AKAE * C_se * C_p * (uuM * TX + uvM * TY) &
    &   + AKAE * C_s  * ( &
    &     uuM * (uuX + vvX + wwX) + uvM * (uuY + vvY + wwY) &
    &   ) &
    &   - (uuM * UM + uvM * VM)
    S4T = AKAE * C_se * C_p * (uvM * TX + vvM * TY) &
    &   + AKAE * C_s  * ( &
    &     uvM * (uuX + vvX + wwX) + vvM * (uuY + vvY + wwY) &
    &   ) &
    &   - (uvM * UM + vvM * VM)
    ! uu �̊g�U --------------------------------------------------------
    R5M = nu * uuX
    S5M = nu * uuY
    R5T = C_s * AKAE * (uuM * uuX + uvM * uuY)
    S5T = C_s * AKAE * (uvM * uuX + vvM * uuY)
    ! vv �̊g�U --------------------------------------------------------
    R6M = nu * vvX
    S6M = nu * vvY
    R6T = C_s * AKAE * (uuM * vvX + uvM * vvY)
    S6T = C_s * AKAE * (uvM * vvX + vvM * vvY)
    ! ww �̊g�U --------------------------------------------------------
    R7M = nu * wwX
    S7M = nu * wwY
    R7T = C_s * AKAE * (uuM * wwX + uvM * wwY)
    S7T = C_s * AKAE * (uvM * wwX + vvM * wwY)
    ! uv �̊g�U --------------------------------------------------------
    R8M = nu * uvX
    S8M = nu * uvY
    R8T = C_s * AKAE * (uuM * uvX + uvM * uvY)
    S8T = C_s * AKAE * (uvM * uvX + vvM * uvY)
    ! epsilon �̊g�U ---------------------------------------------------
    R9M = nu * AEX
    S9M = nu * AEY
    R9T = C_e * AKAE * (uuM * AEX + uvM * AEY)
    S9T = C_e * AKAE * (uvM * AEX + vvM * AEY)
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    SH(I,J,1) = 0.0
    SH(I,J,2) = QH1 * ((R2M + R2T) * ETXM + (S2M + S2T) * ETYM)
    SH(I,J,3) = QH1 * ((R3M + R3T) * ETXM + (S3M + S3T) * ETYM)
    SH(I,J,4) = QH1 * ((R4M + R4T) * ETXM + (S4M + S4T) * ETYM)
    SH(I,J,5) = QH1 * ((R5M + R5T) * ETXM + (S5M + S5T) * ETYM)
    SH(I,J,6) = QH1 * ((R6M + R6T) * ETXM + (S6M + S6T) * ETYM)
    SH(I,J,7) = QH1 * ((R7M + R7T) * ETXM + (S7M + S7T) * ETYM)
    SH(I,J,8) = QH1 * ((R8M + R8T) * ETXM + (S8M + S8T) * ETYM)
    SH(I,J,9) = QH1 * ((R9M + R9T) * ETXM + (S9M + S9T) * ETYM)
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFET
! ��`�I�� *************************************************************
END SUBROUTINE Turbulence2DRSMSSG
!***********************************************************************
!**** �������f�� : RANS, RSM Speziale-Sarkar-Gatski Model (1991)    ****
!****              epsilon�������̒萔��Gibson-Launder�̒l�ɕύX    ****
!****              �����M�`�B�ɂ�Vandromme�̃��f�����g�p            ****
!**** �v�Z�Ώ� : �P��, �O����, ���k��                               ****
!**** �v�Z�X�L�[�� : �񎟐��x���S����(�X�^�K�[�h�i�q��̓_���g�p)   ****
!***********************************************************************
SUBROUTINE Turbulence3DRSMSSG( &
&            PELIM, RG, GAMMA, PR, &
&            IS, IE, JS, JE, KS, KE, LS, LE, &
&            XIX, XIY, XIZ, ETX, ETY, ETZ, ZEX, ZEY, ZEZ, AJA, &
&            RHO, U, V, W, T, uu, vv, ww, uv, vw, wu, EPS, AMU, &
&            AMUT, DQD, DQP &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, PARAMETER :: C_se = 0.313
  ! REAL, PARAMETER :: C_s = 0.22, C_e = 0.183
  REAL, PARAMETER :: C_s = 0.22, C_e = 0.18
  REAL, PARAMETER :: C_1 = 3.4, C_2 = 4.2, C_3 = 0.8, &
  &                  C_4 = 1.25, C_5 = 0.4
  REAL, PARAMETER :: C_1a = 1.8, C_3a = 1.3
  ! REAL, PARAMETER :: C_e1 = 1.44, C_e2 = 1.83
  REAL, PARAMETER :: C_e1 = 1.44, C_e2 = 1.92
  REAL, PARAMETER :: OneThird = 0.33333333, TwoThird = 0.66666667
  REAL, PARAMETER :: ZERO = 1.0E-20
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: PELIM
  REAL,    INTENT(IN)  :: RG, GAMMA, PR
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE, KS, KE
  INTEGER, INTENT(IN)  :: LS, LE
  REAL,    INTENT(IN)  :: XIX(IS:IE, JS:JE, KS:KE), &
  &                       XIY(IS:IE, JS:JE, KS:KE), &
  &                       XIZ(IS:IE, JS:JE, KS:KE), &
  &                       ETX(IS:IE, JS:JE, KS:KE), &
  &                       ETY(IS:IE, JS:JE, KS:KE), &
  &                       ETZ(IS:IE, JS:JE, KS:KE), &
  &                       ZEX(IS:IE, JS:JE, KS:KE), &
  &                       ZEY(IS:IE, JS:JE, KS:KE), &
  &                       ZEZ(IS:IE, JS:JE, KS:KE), &
  &                       AJA(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)  :: RHO(IS:IE, JS:JE, KS:KE), &
  &                       U(IS:IE, JS:JE, KS:KE), &
  &                       V(IS:IE, JS:JE, KS:KE), &
  &                       W(IS:IE, JS:JE, KS:KE), &
  &                       T(IS:IE, JS:JE, KS:KE), &
  &                       uu(IS:IE, JS:JE, KS:KE), &
  &                       vv(IS:IE, JS:JE, KS:KE), &
  &                       ww(IS:IE, JS:JE, KS:KE), &
  &                       uv(IS:IE, JS:JE, KS:KE), &
  &                       vw(IS:IE, JS:JE, KS:KE), &
  &                       wu(IS:IE, JS:JE, KS:KE), &
  &                       EPS(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)  :: AMU(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(OUT) :: AMUT(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(OUT) :: DQD(IS:IE, JS:JE, KS:KE, LS:LE)
  REAL,    INTENT(OUT) :: DQP(IS:IE, JS:JE, KS:KE, LS:LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, ALLOCATABLE :: RH(:, :, :, :), SH(:, :, :, :), TH(:, :, :, :)
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 12) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �������m�� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ALLOCATE(RH(IS: IE, JS: JE, KS: KE, LS: LE))
  ALLOCATE(SH(IS: IE, JS: JE, KS: KE, LS: LE))
  ALLOCATE(TH(IS: IE, JS: JE, KS: KE, LS: LE))
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  AMUT = 0.0
  DQD  = 0.0
  DQP  = 0.0
  ! �����葱���̌Ăяo�� +++++++++++++++++++++++++++++++++++++++++++++++
  CALL NonDiffTerm
  CALL DiffTerm
  ! �����I�� ***********************************************************
  RETURN
! �����葱�� ***********************************************************
CONTAINS
!***********************************************************************
!**** ��g�U���̌v�Z                                                ****
!***********************************************************************
SUBROUTINE NonDiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: TMP, TMPBB, TMPBS, TMP1, TMP3
  REAL    :: UXI, VXI, WXI, UET, VET, WET, UZE, VZE, WZE
  REAL    :: UX, VX, WX, UY, VY, WY, UZ, VZ, WZ
  REAL    :: P11, P22, P33, P12, P23, P31, P_k
  REAL    :: eps11, eps22, eps33, eps12, eps23, eps31, e_k
  REAL    :: S11, S22, S33, S12, S23, S31, SS2
  REAL    :: O12, O23, O31
  REAL    :: b11, b22, b33, b12, b23, b31
  REAL    :: phi11, phi22, phi33, phi12, phi23, phi31
  REAL    :: AK, nu, AEAK
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& TMP, TMPBB, TMPBS, TMP1, TMP3, &
!$OMP& UXI, VXI, WXI, UET, VET, WET, UZE, VZE, WZE, &
!$OMP& UX, VX, WX, UY, VY, WY, UZ, VZ, WZ, &
!$OMP& P11, P22, P33, P12, P23, P31, P_k, &
!$OMP& eps11, eps22, eps33, eps12, eps23, eps31, e_k, &
!$OMP& S11, S22, S33, S12, S23, S31, SS2, O12, O23, O31, &
!$OMP& b11, b22, b33, b12, b23, b31, &
!$OMP& phi11, phi22, phi33, phi12, phi23, phi31, AK, nu, AEAK, QH1 &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF(RHO(I,J,K) .GT. 0.0) THEN
    ! �����G�l���M�[ ---------------------------------------------------
    AK = 0.5 * (uu(I,J,K) + vv(I,J,K) + ww(I,J,K))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = 0.5 * (U(I+1,J,K) - U(I-1,J,K))
    UET = 0.5 * (U(I,J+1,K) - U(I,J-1,K))
    UZE = 0.5 * (U(I,J,K+1) - U(I,J,K-1))
    VXI = 0.5 * (V(I+1,J,K) - V(I-1,J,K))
    VET = 0.5 * (V(I,J+1,K) - V(I,J-1,K))
    VZE = 0.5 * (V(I,J,K+1) - V(I,J,K-1))
    WXI = 0.5 * (W(I+1,J,K) - W(I-1,J,K))
    WET = 0.5 * (W(I,J+1,K) - W(I,J-1,K))
    WZE = 0.5 * (W(I,J,K+1) - W(I,J,K-1))
    ! ������ԕ�����K����
    UX = UXI * XIX(I,J,K) + UET * ETX(I,J,K) + UZE * ZEX(I,J,K)
    UY = UXI * XIY(I,J,K) + UET * ETY(I,J,K) + UZE * ZEY(I,J,K)
    UZ = UXI * XIZ(I,J,K) + UET * ETZ(I,J,K) + UZE * ZEZ(I,J,K)
    VX = VXI * XIX(I,J,K) + VET * ETX(I,J,K) + VZE * ZEX(I,J,K)
    VY = VXI * XIY(I,J,K) + VET * ETY(I,J,K) + VZE * ZEY(I,J,K)
    VZ = VXI * XIZ(I,J,K) + VET * ETZ(I,J,K) + VZE * ZEZ(I,J,K)
    WX = WXI * XIX(I,J,K) + WET * ETX(I,J,K) + WZE * ZEX(I,J,K)
    WY = WXI * XIY(I,J,K) + WET * ETY(I,J,K) + WZE * ZEY(I,J,K)
    WZ = WXI * XIZ(I,J,K) + WET * ETZ(I,J,K) + WZE * ZEZ(I,J,K)
    ! �������ƎU�퍀 ---------------------------------------------------
    P11 = - 2.0 * (uu(I,J,K) * UX + uv(I,J,K) * UY + wu(I,J,K) * UZ)
    P22 = - 2.0 * (uv(I,J,K) * VX + vv(I,J,K) * VY + vw(I,J,K) * VZ)
    P33 = - 2.0 * (wu(I,J,K) * WX + vw(I,J,K) * WY + ww(I,J,K) * WZ)
    P12 = - (uv(I,J,K) * UX + uu(I,J,K) * VX) &
    &     - (vv(I,J,K) * UY + uv(I,J,K) * VY) &
    &     - (vw(I,J,K) * UZ + wu(I,J,K) * VZ)
    P23 = - (wu(I,J,K) * VX + uv(I,J,K) * WX) &
    &     - (vw(I,J,K) * VY + vv(I,J,K) * WY) &
    &     - (ww(I,J,K) * VZ + vw(I,J,K) * WZ)
    P31 = - (uu(I,J,K) * WX + wu(I,J,K) * UX) &
    &     - (uv(I,J,K) * WY + vw(I,J,K) * UY) &
    &     - (wu(I,J,K) * WZ + ww(I,J,K) * UZ)
    P_k = 0.5 * (P11 + P22 + P33)
    e_k = EPS(I,J,K)
    ! �Ǐ����t����(�����ƎU��̃o�����X)�ɂ�郊�~�b�^�[
    IF(PELIM .GT. 0.0) THEN
      TMP = TwoThird * e_k / PELIM
      P11 = MIN(TMP, MAX(-TMP, P11))
      P22 = MIN(TMP, MAX(-TMP, P22))
      P33 = MIN(TMP, MAX(-TMP, P33))
      P_k = 0.5 * (P11 + P22 + P33)
    ENDIF
    TMP   = TwoThird * e_k
    eps11 = TMP
    eps22 = TMP
    eps33 = TMP
    eps12 = 0.0
    eps23 = 0.0
    eps31 = 0.0
    ! �c�ݑ��x ---------------------------------------------------------
    TMP = (UX + VY + WZ) * OneThird
    S11 = UX - TMP
    S22 = VY - TMP
    S33 = WZ - TMP
    S12 = 0.5 * (UY + VX)
    S23 = 0.5 * (VZ + WY)
    S31 = 0.5 * (WX + UZ)
    SS2 = S11 * S11 + S22 * S22 + S33 * S33 &
    &   + 2.0 * (S12 * S12 + S23 * S23 + S31 * S31)
    ! �Q�x -------------------------------------------------------------
    O12 = 0.5 * (UY - VX)
    O23 = 0.5 * (VZ - WY)
    O31 = 0.5 * (WX - UZ)
    ! �񓙕����C�m���Y���̓e���\�� b_ij --------------------------------
    IF(AK .GT. ZERO) THEN
      b11 = 0.5 * uu(I,J,K) / AK - OneThird
      b22 = 0.5 * vv(I,J,K) / AK - OneThird
      b33 = 0.5 * ww(I,J,K) / AK - OneThird
      b12 = 0.5 * uv(I,J,K) / AK
      b23 = 0.5 * vw(I,J,K) / AK
      b31 = 0.5 * wu(I,J,K) / AK
      b11 = MIN(TwoThird, MAX(- OneThird, b11))
      b22 = MIN(TwoThird, MAX(- OneThird, b22))
      b33 = MIN(TwoThird, MAX(- OneThird, b33))
      b12 = MIN(0.5, MAX(-0.5, b12))
      b23 = MIN(0.5, MAX(-0.5, b23))
      b31 = MIN(0.5, MAX(-0.5, b31))
    ELSE
      b11 =-OneThird
      b22 =-OneThird
      b33 =-OneThird
      b12 = 0.0
      b23 = 0.0
      b31 = 0.0
    ENDIF
    ! �ĕ��z�� ---------------------------------------------------------
    TMPBB = b11 * b11 + b22 * b22 + b33 * b33 &
    &     + 2.0 * (b12 * b12 + b23 * b23 + b31 * b31)
    TMPBS = b11 * S11 + b22 * S22 + b33 * S33 &
    &     + 2.0 * (b12 * S12 + b23 * S23 + b31 * S31)
    TMP1  = - (C_1 * e_k + C_1a * P_k)
    TMP3  = (C_3 - C_3a * SQRT(TMPBB)) * AK
    phi11 = TMP1 * b11 &
    &     + C_2 * e_k * ( &
    &       b11 * b11 + b31 * b31 + b12 * b12 - OneThird * TMPBB &
    &     ) + TMP3 * S11 &
    &     + C_4 * AK * ( &
    &       2.0 * (b11 * S11 + b31 * S31 + b12 * S12) &
    &     - TwoThird * TMPBS &
    &     ) &
    &     + C_5 * AK * 2.0 * (b12 * O12 - b31 * O31)
    phi22 = TMP1 * b22 &
    &     + C_2 * e_k * ( &
    &       b22 * b22 + b12 * b12 + b23 * b23 - OneThird * TMPBB &
    &     ) + TMP3 * S22 &
    &     + C_4 * AK * ( &
    &       2.0 * (b22 * S22 + b12 * S12 + b23 * S23) &
    &     - TwoThird * TMPBS &
    &     ) &
    &     + C_5 * AK * 2.0 * (b23 * O23 - b12 * O12)
    phi33 = TMP1 * b33 &
    &     + C_2 * e_k * ( &
    &       b33 * b33 + b23 * b23 + b31 * b31 - OneThird * TMPBB &
    &     ) + TMP3 * S33 &
    &     + C_4 * AK * ( &
    &       2.0 * (b33 * S33 + b23 * S23 + b31 * S31) &
    &     - TwoThird * TMPBS &
    &     ) &
    &     + C_5 * AK * 2.0 * (b31 * O31 - b23 * O23)
    phi12 = TMP1 * b12 &
    &     + C_2 * e_k * (b12 * (b11 + b22) + b23 * b31) &
    &     + TMP3 * S12 &
    &     + C_4 * AK * ( &
    &       (b11 + b22) * S12 + b12 * (S11 + S22) &
    &     + b23 * S31 + b31 * S23 &
    &     ) &
    &     - C_5 * AK * ((b11 - b22) * O12 + b23 * O31 - b31 * O23)
    phi23 = TMP1 * b23 &
    &     + C_2 * e_k * (b23 * (b22 + b33) + b31 * b12) &
    &     + TMP3 * S23 &
    &     + C_4 * AK * ( &
    &       (b22 + b33) * S23 + b23 * (S22 + S33) &
    &     + b31 * S12 + b12 * S31 &
    &     ) &
    &     - C_5 * AK * ((b22 - b33) * O23 + b31 * O12 - b12 * O31)
    phi31 = TMP1 * b31 &
    &     + C_2 * e_k * (b31 * (b33 + b11) + b12 * b23) &
    &     + TMP3 * S31 &
    &     + C_4 * AK * ( &
    &       (b33 + b11) * S31 + b31 * (S33 + S11) &
    &     + b12 * S23 + b23 * S12 &
    &     ) &
    &     - C_5 * AK * ((b33 - b11) * O31 + b12 * O23 - b23 * O12)
    ! �Q�S���W���̌v�Z -------------------------------------------------
    IF(e_k .GT. ZERO) THEN
      AMUT(I,J,K) = 0.09 * AK**2 / e_k * RHO(I,J,K)
    ENDIF
    ! �������A���͍ĕ��z���A�U�퍀�̘a ---------------------------------
    QH1  = RHO(I,J,K) / AJA(I,J,K)
    nu   = AMU(I,J,K) / RHO(I,J,K)
    AEAK = MIN( &
    &        MAX(SQRT(2.0 * SS2), SQRT(e_k / nu)), &
    &        e_k / MAX(ZERO, AK) &
    &    )
    DQP(I,J,K, 6) = QH1 * (P11 - eps11 + phi11)
    DQP(I,J,K, 7) = QH1 * (P22 - eps22 + phi22)
    DQP(I,J,K, 8) = QH1 * (P33 - eps33 + phi33)
    DQP(I,J,K, 9) = QH1 * (P12 - eps12 + phi12)
    DQP(I,J,K,10) = QH1 * (P23 - eps23 + phi23)
    DQP(I,J,K,11) = QH1 * (P31 - eps31 + phi31)
    DQP(I,J,K,12) = QH1 * AEAK * (C_e1 * P_k - C_e2 * e_k)
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE NonDiffTerm
!***********************************************************************
!**** �g�U���̌v�Z                                                  ****
!***********************************************************************
SUBROUTINE DiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K, L
  ! �����J�n ***********************************************************
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  RH = 0.0
  SH = 0.0
  TH = 0.0
  ! �g�U���̗v�f���v�Z +++++++++++++++++++++++++++++++++++++++++++++++++
  CALL DIFFXI
  CALL DIFFET
  CALL DIFFZE
  ! �g�U���̍��� +++++++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE(I, J, K, L)
  DO L = LS, LE
  !$OMP DO
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( (RHO(I,J,K-1) .GT. 0.0) .AND. (RHO(I,J-1,K) .GT. 0.0) .AND. &
  &   (RHO(I-1,J,K) .GT. 0.0) .AND. (RHO(I,J,K)   .GT. 0.0) .AND. &
  &   (RHO(I+1,J,K) .GT. 0.0) .AND. (RHO(I,J+1,K) .GT. 0.0) .AND. &
  &   (RHO(I,J,K+1) .GT. 0.0) &
  & ) THEN
    DQD(I,J,K,L) = (-RH(I-1,J  ,K  ,L) + RH(I,J,K,L) ) &
    &            + (-SH(I  ,J-1,K  ,L) + SH(I,J,K,L) ) &
    &            + (-TH(I  ,J  ,K-1,L) + TH(I,J,K,L) )
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END DO
  ENDDO
  !$OMP END PARALLEL
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DiffTerm
!***********************************************************************
!**** �g�U���̌v�Z(xi���������p)                                    ****
!***********************************************************************
SUBROUTINE DIFFXI
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM
  REAL    :: RHOM, UM, VM, WM, uuM, vvM, wwM, uvM, vwM, wuM, EPSM, AMUM
  REAL    :: UXI, UET, UZE, UX, UY, UZ
  REAL    :: VXI, VET, VZE, VX, VY, VZ
  REAL    :: WXI, WET, WZE, WX, WY, WZ
  REAL    :: TXI, TET, TZE, TX, TY, TZ
  REAL    :: uuXI, uuET, uuZE, uuX, uuY, uuZ
  REAL    :: vvXI, vvET, vvZE, vvX, vvY, vvZ
  REAL    :: wwXI, wwET, wwZE, wwX, wwY, wwZ
  REAL    :: uvXI, uvET, uvZE, uvX, uvY, uvZ
  REAL    :: vwXI, vwET, vwZE, vwX, vwY, vwZ
  REAL    :: wuXI, wuET, wuZE, wuX, wuY, wuZ
  REAL    :: AEXI, AEET, AEZE, AEX, AEY, AEZ
  REAL    :: nu
  REAL    :: S11, S22, S33, S12, S23, S31, SS
  REAL    :: C_p, AKAE
  REAL    :: R02M, S02M, T02M, R02T, S02T, T02T
  REAL    :: R03M, S03M, T03M, R03T, S03T, T03T
  REAL    :: R04M, S04M, T04M, R04T, S04T, T04T
  REAL    :: R05M, S05M, T05M, R05T, S05T, T05T
  REAL    :: R06M, S06M, T06M, R06T, S06T, T06T
  REAL    :: R07M, S07M, T07M, R07T, S07T, T07T
  REAL    :: R08M, S08M, T08M, R08T, S08T, T08T
  REAL    :: R09M, S09M, T09M, R09T, S09T, T09T
  REAL    :: R10M, S10M, T10M, R10T, S10T, T10T
  REAL    :: R11M, S11M, T11M, R11T, S11T, T11T
  REAL    :: R12M, S12M, T12M, R12T, S12T, T12T
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM, &
!$OMP& RHOM, UM, VM, WM, uuM, vvM, wwM, uvM, vwM, wuM, EPSM, AMUM, &
!$OMP& UXI, UET, UZE, UX, UY, UZ, &
!$OMP& VXI, VET, VZE, VX, VY, VZ, &
!$OMP& WXI, WET, WZE, WX, WY, WZ, &
!$OMP& TXI, TET, TZE, TX, TY, TZ, &
!$OMP& uuXI, uuET, uuZE, uuX, uuY, uuZ, &
!$OMP& vvXI, vvET, vvZE, vvX, vvY, vvZ, &
!$OMP& wwXI, wwET, wwZE, wwX, wwY, wwZ, &
!$OMP& uvXI, uvET, uvZE, uvX, uvY, uvZ, &
!$OMP& vwXI, vwET, vwZE, vwX, vwY, vwZ, &
!$OMP& wuXI, wuET, wuZE, wuX, wuY, wuZ, &
!$OMP& AEXI, AEET, AEZE, AEX, AEY, AEZ, &
!$OMP& nu, S11, S22, S33, S12, S23, S31, SS, C_p, AKAE, &
!$OMP& R02M, S02M, T02M, R02T, S02T, T02T, &
!$OMP& R03M, S03M, T03M, R03T, S03T, T03T, &
!$OMP& R04M, S04M, T04M, R04T, S04T, T04T, &
!$OMP& R05M, S05M, T05M, R05T, S05T, T05T, &
!$OMP& R06M, S06M, T06M, R06T, S06T, T06T, &
!$OMP& R07M, S07M, T07M, R07T, S07T, T07T, &
!$OMP& R08M, S08M, T08M, R08T, S08T, T08T, &
!$OMP& R09M, S09M, T09M, R09T, S09T, T09T, &
!$OMP& R10M, S10M, T10M, R10T, S10T, T10T, &
!$OMP& R11M, S11M, T11M, R11T, S11T, T11T, &
!$OMP& R12M, S12M, T12M, R12T, S12T, T12T, &
!$OMP& QH1 &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS    , IE - 1
  IF((RHO(I,J,K) .GT. 0.0) .AND. (RHO(I+1,J,K) .GT. 0.0)) THEN
    ! XI�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J,K) + XIX(I+1,J,K))
    XIYM = 0.5 * (XIY(I,J,K) + XIY(I+1,J,K))
    XIZM = 0.5 * (XIZ(I,J,K) + XIZ(I+1,J,K))
    ETXM = 0.5 * (ETX(I,J,K) + ETX(I+1,J,K))
    ETYM = 0.5 * (ETY(I,J,K) + ETY(I+1,J,K))
    ETZM = 0.5 * (ETZ(I,J,K) + ETZ(I+1,J,K))
    ZEXM = 0.5 * (ZEX(I,J,K) + ZEX(I+1,J,K))
    ZEYM = 0.5 * (ZEY(I,J,K) + ZEY(I+1,J,K))
    ZEZM = 0.5 * (ZEZ(I,J,K) + ZEZ(I+1,J,K))
    AJAM = 0.5 * (AJA(I,J,K) + AJA(I+1,J,K))
    ! ������
    RHOM = 0.5 * (RHO(I,J,K) + RHO(I+1,J,K))
    UM   = 0.5 * (  U(I,J,K) +   U(I+1,J,K))
    VM   = 0.5 * (  V(I,J,K) +   V(I+1,J,K))
    WM   = 0.5 * (  W(I,J,K) +   W(I+1,J,K))
    uuM  = 0.5 * ( uu(I,J,K) +  uu(I+1,J,K))
    vvM  = 0.5 * ( vv(I,J,K) +  vv(I+1,J,K))
    wwM  = 0.5 * ( ww(I,J,K) +  ww(I+1,J,K))
    uvM  = 0.5 * ( uv(I,J,K) +  uv(I+1,J,K))
    vwM  = 0.5 * ( vw(I,J,K) +  vw(I+1,J,K))
    wuM  = 0.5 * ( wu(I,J,K) +  wu(I+1,J,K))
    EPSM = 0.5 * (EPS(I,J,K) + EPS(I+1,J,K))
    AMUM = 0.5 * (AMU(I,J,K) + AMU(I+1,J,K))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = - U(I,J,K) + U(I+1,J,K)
    UET = 0.25 * ( - U(I,J-1,K) - U(I+1,J-1,K) &
    &              + U(I,J+1,K) + U(I+1,J+1,K) )
    UZE = 0.25 * ( - U(I,J,K-1) - U(I+1,J,K-1) &
    &              + U(I,J,K+1) + U(I+1,J,K+1) )
    VXI = - V(I,J,K) + V(I+1,J,K)
    VET = 0.25 * ( - V(I,J-1,K) - V(I+1,J-1,K) &
    &              + V(I,J+1,K) + V(I+1,J+1,K) )
    VZE = 0.25 * ( - V(I,J,K-1) - V(I+1,J,K-1) &
    &              + V(I,J,K+1) + V(I+1,J,K+1) )
    WXI = - W(I,J,K) + W(I+1,J,K)
    WET = 0.25 * ( - W(I,J-1,K) - W(I+1,J-1,K) &
    &              + W(I,J+1,K) + W(I+1,J+1,K) )
    WZE = 0.25 * ( - W(I,J,K-1) - W(I+1,J,K-1) &
    &              + W(I,J,K+1) + W(I+1,J,K+1) )
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM + UZE * ZEXM
    UY = UXI * XIYM + UET * ETYM + UZE * ZEYM
    UZ = UXI * XIZM + UET * ETZM + UZE * ZEZM
    VX = VXI * XIXM + VET * ETXM + VZE * ZEXM
    VY = VXI * XIYM + VET * ETYM + VZE * ZEYM
    VZ = VXI * XIZM + VET * ETZM + VZE * ZEZM
    WX = WXI * XIXM + WET * ETXM + WZE * ZEXM
    WY = WXI * XIYM + WET * ETYM + WZE * ZEYM
    WZ = WXI * XIZM + WET * ETZM + WZE * ZEZM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = - T(I,J,K) + T(I+1,J,K)
    TET = 0.25 * ( - T(I,J-1,K) - T(I+1,J-1,K) &
    &              + T(I,J+1,K) + T(I+1,J+1,K) )
    TZE = 0.25 * ( - T(I,J,K-1) - T(I+1,J,K-1) &
    &              + T(I,J,K+1) + T(I+1,J,K+1) )
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM + TZE * ZEXM
    TY = TXI * XIYM + TET * ETYM + TZE * ZEYM
    TZ = TXI * XIZM + TET * ETZM + TZE * ZEZM
    ! uu �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    uuXI = - uu(I,J,K) + uu(I+1,J,K)
    uuET = 0.25 * ( - uu(I,J-1,K) - uu(I+1,J-1,K) &
    &               + uu(I,J+1,K) + uu(I+1,J+1,K) )
    uuZE = 0.25 * ( - uu(I,J,K-1) - uu(I+1,J,K-1) &
    &               + uu(I,J,K+1) + uu(I+1,J,K+1) )
    ! ������ԕ�����K����
    uuX = uuXI * XIXM + uuET * ETXM + uuZE * ZEXM
    uuY = uuXI * XIYM + uuET * ETYM + uuZE * ZEYM
    uuZ = uuXI * XIZM + uuET * ETZM + uuZE * ZEZM
    ! vv �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    vvXI = - vv(I,J,K) + vv(I+1,J,K)
    vvET = 0.25 * ( - vv(I,J-1,K) - vv(I+1,J-1,K) &
    &               + vv(I,J+1,K) + vv(I+1,J+1,K) )
    vvZE = 0.25 * ( - vv(I,J,K-1) - vv(I+1,J,K-1) &
    &               + vv(I,J,K+1) + vv(I+1,J,K+1) )
    ! ������ԕ�����K����
    vvX = vvXI * XIXM + vvET * ETXM + vvZE * ZEXM
    vvY = vvXI * XIYM + vvET * ETYM + vvZE * ZEYM
    vvZ = vvXI * XIZM + vvET * ETZM + vvZE * ZEZM
    ! ww �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    wwXI = - ww(I,J,K) + ww(I+1,J,K)
    wwET = 0.25 * ( - ww(I,J-1,K) - ww(I+1,J-1,K) &
    &               + ww(I,J+1,K) + ww(I+1,J+1,K) )
    wwZE = 0.25 * ( - ww(I,J,K-1) - ww(I+1,J,K-1) &
    &               + ww(I,J,K+1) + ww(I+1,J,K+1) )
    ! ������ԕ�����K����
    wwX = wwXI * XIXM + wwET * ETXM + wwZE * ZEXM
    wwY = wwXI * XIYM + wwET * ETYM + wwZE * ZEYM
    wwZ = wwXI * XIZM + wwET * ETZM + wwZE * ZEZM
    ! uv �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    uvXI = - uv(I,J,K) + uv(I+1,J,K)
    uvET = 0.25 * ( - uv(I,J-1,K) - uv(I+1,J-1,K) &
    &               + uv(I,J+1,K) + uv(I+1,J+1,K) )
    uvZE = 0.25 * ( - uv(I,J,K-1) - uv(I+1,J,K-1) &
    &               + uv(I,J,K+1) + uv(I+1,J,K+1) )
    ! ������ԕ�����K����
    uvX = uvXI * XIXM + uvET * ETXM + uvZE * ZEXM
    uvY = uvXI * XIYM + uvET * ETYM + uvZE * ZEYM
    uvZ = uvXI * XIZM + uvET * ETZM + uvZE * ZEZM
    ! vw �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    vwXI = - vw(I,J,K) + vw(I+1,J,K)
    vwET = 0.25 * ( - vw(I,J-1,K) - vw(I+1,J-1,K) &
    &               + vw(I,J+1,K) + vw(I+1,J+1,K) )
    vwZE = 0.25 * ( - vw(I,J,K-1) - vw(I+1,J,K-1) &
    &               + vw(I,J,K+1) + vw(I+1,J,K+1) )
    ! ������ԕ�����K����
    vwX = vwXI * XIXM + vwET * ETXM + vwZE * ZEXM
    vwY = vwXI * XIYM + vwET * ETYM + vwZE * ZEYM
    vwZ = vwXI * XIZM + vwET * ETZM + vwZE * ZEZM
    ! wu �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    wuXI = - wu(I,J,K) + wu(I+1,J,K)
    wuET = 0.25 * ( - wu(I,J-1,K) - wu(I+1,J-1,K) &
    &               + wu(I,J+1,K) + wu(I+1,J+1,K) )
    wuZE = 0.25 * ( - wu(I,J,K-1) - wu(I+1,J,K-1) &
    &               + wu(I,J,K+1) + wu(I+1,J,K+1) )
    ! ������ԕ�����K����
    wuX = wuXI * XIXM + wuET * ETXM + wuZE * ZEXM
    wuY = wuXI * XIYM + wuET * ETYM + wuZE * ZEYM
    wuZ = wuXI * XIZM + wuET * ETZM + wuZE * ZEZM
    ! epsilon �̈�K�����̌v�Z -----------------------------------------
    ! �v�Z��ԕ�����K����
    AEXI = - EPS(I,J,K) + EPS(I+1,J,K)
    AEET = 0.25 * ( - EPS(I,J-1,K) - EPS(I+1,J-1,K) &
    &               + EPS(I,J+1,K) + EPS(I+1,J+1,K) )
    AEZE = 0.25 * ( - EPS(I,J,K-1) - EPS(I+1,J,K-1) &
    &               + EPS(I,J,K+1) + EPS(I+1,J,K+1) )
    ! ������ԕ�����K����
    AEX = AEXI * XIXM + AEET * ETXM + AEZE * ZEXM
    AEY = AEXI * XIYM + AEET * ETYM + AEZE * ZEYM
    AEZ = AEXI * XIZM + AEET * ETZM + AEZE * ZEZM
    ! ���S�x -----------------------------------------------------------
    nu = AMUM / RHOM
    ! �c�ݑ��x ---------------------------------------------------------
    SS  = (UX + VY + WZ) * TwoThird
    S11 = 2.0 * UX - SS
    S22 = 2.0 * VY - SS
    S33 = 2.0 * WZ - SS
    S12 = UY + VX
    S23 = VZ + WY
    S31 = WX + UZ
    ! U �̊g�U ---------------------------------------------------------
    R02M = nu * S11
    S02M = nu * S12
    T02M = nu * S31
    R02T =-uuM
    S02T =-uvM
    T02T =-wuM
    ! V �̊g�U ---------------------------------------------------------
    R03M = nu * S12
    S03M = nu * S22
    T03M = nu * S23
    R03T =-uvM
    S03T =-vvM
    T03T =-vwM
    ! W �̊g�U ---------------------------------------------------------
    R04M = nu * S31
    S04M = nu * S23
    T04M = nu * S33
    R04T =-wuM
    S04T =-vwM
    T04T =-wwM
    ! �G�l���M�[�̊g�U -------------------------------------------------
    C_p  = GAMMA * RG / (GAMMA - 1.0)
    IF(EPSM .GT. ZERO) THEN
      AKAE = 0.5 * (uuM + vvM + wwM) / EPSM
    ELSE
      AKAE = 0.0
    ENDIF
    R05M = C_p * nu / PR * TX + nu * (S11 * UM + S12 * VM + S31 * WM)
    S05M = C_p * nu / PR * TY + nu * (S12 * UM + S22 * VM + S23 * WM)
    T05M = C_p * nu / PR * TZ + nu * (S31 * UM + S23 * VM + S33 * WM)
    R05T = AKAE * C_se * C_p * (uuM * TX + uvM * TY + wuM * TZ) &
    &    + AKAE * C_s  * ( &
    &      uuM * (uuX + vvX + wwX) &
    &    + uvM * (uuY + vvY + wwY) &
    &    + wuM * (uuZ + vvZ + wwZ) &
    &    ) &
    &    - (uuM * UM + uvM * VM + wuM * WM)
    S05T = AKAE * C_se * C_p * (uvM * TX + vvM * TY + vwM * TZ) &
    &    + AKAE * C_s  * ( &
    &      uvM * (uuX + vvX + wwX) &
    &    + vvM * (uuY + vvY + wwY) &
    &    + vwM * (uuZ + vvZ + wwZ) &
    &    ) &
    &    - (uvM * UM + vvM * VM + vwM * WM)
    T05T = AKAE * C_se * C_p * (wuM * TX + vwM * TY + wwM * TZ) &
    &    + AKAE * C_s  * ( &
    &      wuM * (uuX + vvX + wwX) &
    &    + vwM * (uuY + vvY + wwY) &
    &    + wwM * (uuZ + vvZ + wwZ) &
    &    ) &
    &    - (wuM * UM + vwM * VM + wwM * WM)
    ! uu �̊g�U --------------------------------------------------------
    R06M = nu * uuX
    S06M = nu * uuY
    T06M = nu * uuZ
    R06T = C_s * AKAE * (uuM * uuX + uvM * uuY + wuM * uuZ)
    S06T = C_s * AKAE * (uvM * uuX + vvM * uuY + vwM * uuZ)
    T06T = C_s * AKAE * (wuM * uuX + vwM * uuY + wwM * uuZ)
    ! vv �̊g�U --------------------------------------------------------
    R07M = nu * vvX
    S07M = nu * vvY
    T07M = nu * vvZ
    R07T = C_s * AKAE * (uuM * vvX + uvM * vvY + wuM * vvZ)
    S07T = C_s * AKAE * (uvM * vvX + vvM * vvY + vwM * vvZ)
    T07T = C_s * AKAE * (wuM * vvX + vwM * vvY + wwM * vvZ)
    ! ww �̊g�U --------------------------------------------------------
    R08M = nu * wwX
    S08M = nu * wwY
    T08M = nu * wwZ
    R08T = C_s * AKAE * (uuM * wwX + uvM * wwY + wuM * wwZ)
    S08T = C_s * AKAE * (uvM * wwX + vvM * wwY + vwM * wwZ)
    T08T = C_s * AKAE * (wuM * wwX + vwM * wwY + wwM * wwZ)
    ! uv �̊g�U --------------------------------------------------------
    R09M = nu * uvX
    S09M = nu * uvY
    T09M = nu * uvZ
    R09T = C_s * AKAE * (uuM * uvX + uvM * uvY + wuM * uvZ)
    S09T = C_s * AKAE * (uvM * uvX + vvM * uvY + vwM * uvZ)
    T09T = C_s * AKAE * (wuM * uvX + vwM * uvY + wwM * uvZ)
    ! vw �̊g�U --------------------------------------------------------
    R10M = nu * vwX
    S10M = nu * vwY
    T10M = nu * vwZ
    R10T = C_s * AKAE * (uuM * vwX + uvM * vwY + wuM * vwZ)
    S10T = C_s * AKAE * (uvM * vwX + vvM * vwY + vwM * vwZ)
    T10T = C_s * AKAE * (wuM * vwX + vwM * vwY + wwM * vwZ)
    ! wu �̊g�U --------------------------------------------------------
    R11M = nu * wuX
    S11M = nu * wuY
    T11M = nu * wuZ
    R11T = C_s * AKAE * (uuM * wuX + uvM * wuY + wuM * wuZ)
    S11T = C_s * AKAE * (uvM * wuX + vvM * wuY + vwM * wuZ)
    T11T = C_s * AKAE * (wuM * wuX + vwM * wuY + wwM * wuZ)
    ! epsilon �̊g�U ---------------------------------------------------
    R12M = nu * AEX
    S12M = nu * AEY
    T12M = nu * AEZ
    R12T = C_e * AKAE * (uuM * AEX + uvM * AEY + wuM * AEZ)
    S12T = C_e * AKAE * (uvM * AEX + vvM * AEY + vwM * AEZ)
    T12T = C_e * AKAE * (wuM * AEX + vwM * AEY + wwM * AEZ)
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    RH(I,J,K, 1) = 0.0
    RH(I,J,K, 2) = QH1 * ( (R02M + R02T) * XIXM &
    &                    + (S02M + S02T) * XIYM &
    &                    + (T02M + T02T) * XIZM )
    RH(I,J,K, 3) = QH1 * ( (R03M + R03T) * XIXM &
    &                    + (S03M + S03T) * XIYM &
    &                    + (T03M + T03T) * XIZM )
    RH(I,J,K, 4) = QH1 * ( (R04M + R04T) * XIXM &
    &                    + (S04M + S04T) * XIYM &
    &                    + (T04M + T04T) * XIZM )
    RH(I,J,K, 5) = QH1 * ( (R05M + R05T) * XIXM &
    &                    + (S05M + S05T) * XIYM &
    &                    + (T05M + T05T) * XIZM )
    RH(I,J,K, 6) = QH1 * ( (R06M + R06T) * XIXM &
    &                    + (S06M + S06T) * XIYM &
    &                    + (T06M + T06T) * XIZM )
    RH(I,J,K, 7) = QH1 * ( (R07M + R07T) * XIXM &
    &                    + (S07M + S07T) * XIYM &
    &                    + (T07M + T07T) * XIZM )
    RH(I,J,K, 8) = QH1 * ( (R08M + R08T) * XIXM &
    &                    + (S08M + S08T) * XIYM &
    &                    + (T08M + T08T) * XIZM )
    RH(I,J,K, 9) = QH1 * ( (R09M + R09T) * XIXM &
    &                    + (S09M + S09T) * XIYM &
    &                    + (T09M + T09T) * XIZM )
    RH(I,J,K,10) = QH1 * ( (R10M + R10T) * XIXM &
    &                    + (S10M + S10T) * XIYM &
    &                    + (T10M + T10T) * XIZM )
    RH(I,J,K,11) = QH1 * ( (R11M + R11T) * XIXM &
    &                    + (S11M + S11T) * XIYM &
    &                    + (T11M + T11T) * XIZM )
    RH(I,J,K,12) = QH1 * ( (R12M + R12T) * XIXM &
    &                    + (S12M + S12T) * XIYM &
    &                    + (T12M + T12T) * XIZM )
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFXI
!***********************************************************************
!**** �g�U���̌v�Z(eta���������p)                                   ****
!***********************************************************************
SUBROUTINE DIFFET
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM
  REAL    :: RHOM, UM, VM, WM, uuM, vvM, wwM, uvM, vwM, wuM, EPSM, AMUM
  REAL    :: UXI, UET, UZE, UX, UY, UZ
  REAL    :: VXI, VET, VZE, VX, VY, VZ
  REAL    :: WXI, WET, WZE, WX, WY, WZ
  REAL    :: TXI, TET, TZE, TX, TY, TZ
  REAL    :: uuXI, uuET, uuZE, uuX, uuY, uuZ
  REAL    :: vvXI, vvET, vvZE, vvX, vvY, vvZ
  REAL    :: wwXI, wwET, wwZE, wwX, wwY, wwZ
  REAL    :: uvXI, uvET, uvZE, uvX, uvY, uvZ
  REAL    :: vwXI, vwET, vwZE, vwX, vwY, vwZ
  REAL    :: wuXI, wuET, wuZE, wuX, wuY, wuZ
  REAL    :: AEXI, AEET, AEZE, AEX, AEY, AEZ
  REAL    :: nu
  REAL    :: S11, S22, S33, S12, S23, S31, SS
  REAL    :: C_p, AKAE
  REAL    :: R02M, S02M, T02M, R02T, S02T, T02T
  REAL    :: R03M, S03M, T03M, R03T, S03T, T03T
  REAL    :: R04M, S04M, T04M, R04T, S04T, T04T
  REAL    :: R05M, S05M, T05M, R05T, S05T, T05T
  REAL    :: R06M, S06M, T06M, R06T, S06T, T06T
  REAL    :: R07M, S07M, T07M, R07T, S07T, T07T
  REAL    :: R08M, S08M, T08M, R08T, S08T, T08T
  REAL    :: R09M, S09M, T09M, R09T, S09T, T09T
  REAL    :: R10M, S10M, T10M, R10T, S10T, T10T
  REAL    :: R11M, S11M, T11M, R11T, S11T, T11T
  REAL    :: R12M, S12M, T12M, R12T, S12T, T12T
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM, &
!$OMP& RHOM, UM, VM, WM, uuM, vvM, wwM, uvM, vwM, wuM, EPSM, AMUM, &
!$OMP& UXI, UET, UZE, UX, UY, UZ, &
!$OMP& VXI, VET, VZE, VX, VY, VZ, &
!$OMP& WXI, WET, WZE, WX, WY, WZ, &
!$OMP& TXI, TET, TZE, TX, TY, TZ, &
!$OMP& uuXI, uuET, uuZE, uuX, uuY, uuZ, &
!$OMP& vvXI, vvET, vvZE, vvX, vvY, vvZ, &
!$OMP& wwXI, wwET, wwZE, wwX, wwY, wwZ, &
!$OMP& uvXI, uvET, uvZE, uvX, uvY, uvZ, &
!$OMP& vwXI, vwET, vwZE, vwX, vwY, vwZ, &
!$OMP& wuXI, wuET, wuZE, wuX, wuY, wuZ, &
!$OMP& AEXI, AEET, AEZE, AEX, AEY, AEZ, &
!$OMP& nu, S11, S22, S33, S12, S23, S31, SS, C_p, AKAE, &
!$OMP& R02M, S02M, T02M, R02T, S02T, T02T, &
!$OMP& R03M, S03M, T03M, R03T, S03T, T03T, &
!$OMP& R04M, S04M, T04M, R04T, S04T, T04T, &
!$OMP& R05M, S05M, T05M, R05T, S05T, T05T, &
!$OMP& R06M, S06M, T06M, R06T, S06T, T06T, &
!$OMP& R07M, S07M, T07M, R07T, S07T, T07T, &
!$OMP& R08M, S08M, T08M, R08T, S08T, T08T, &
!$OMP& R09M, S09M, T09M, R09T, S09T, T09T, &
!$OMP& R10M, S10M, T10M, R10T, S10T, T10T, &
!$OMP& R11M, S11M, T11M, R11T, S11T, T11T, &
!$OMP& R12M, S12M, T12M, R12T, S12T, T12T, &
!$OMP& QH1 &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS    , JE - 1
  DO I = IS + 1, IE - 1
  IF((RHO(I,J,K) .GT. 0.0) .AND. (RHO(I,J+1,K) .GT. 0.0)) THEN
    ! XI�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J,K) + XIX(I,J+1,K))
    XIYM = 0.5 * (XIY(I,J,K) + XIY(I,J+1,K))
    XIZM = 0.5 * (XIZ(I,J,K) + XIZ(I,J+1,K))
    ETXM = 0.5 * (ETX(I,J,K) + ETX(I,J+1,K))
    ETYM = 0.5 * (ETY(I,J,K) + ETY(I,J+1,K))
    ETZM = 0.5 * (ETZ(I,J,K) + ETZ(I,J+1,K))
    ZEXM = 0.5 * (ZEX(I,J,K) + ZEX(I,J+1,K))
    ZEYM = 0.5 * (ZEY(I,J,K) + ZEY(I,J+1,K))
    ZEZM = 0.5 * (ZEZ(I,J,K) + ZEZ(I,J+1,K))
    AJAM = 0.5 * (AJA(I,J,K) + AJA(I,J+1,K))
    ! ������
    RHOM = 0.5 * (RHO(I,J,K) + RHO(I,J+1,K))
    UM   = 0.5 * (  U(I,J,K) +   U(I,J+1,K))
    VM   = 0.5 * (  V(I,J,K) +   V(I,J+1,K))
    WM   = 0.5 * (  W(I,J,K) +   W(I,J+1,K))
    uuM  = 0.5 * ( uu(I,J,K) +  uu(I,J+1,K))
    vvM  = 0.5 * ( vv(I,J,K) +  vv(I,J+1,K))
    wwM  = 0.5 * ( ww(I,J,K) +  ww(I,J+1,K))
    uvM  = 0.5 * ( uv(I,J,K) +  uv(I,J+1,K))
    vwM  = 0.5 * ( vw(I,J,K) +  vw(I,J+1,K))
    wuM  = 0.5 * ( wu(I,J,K) +  wu(I,J+1,K))
    EPSM = 0.5 * (EPS(I,J,K) + EPS(I,J+1,K))
    AMUM = 0.5 * (AMU(I,J,K) + AMU(I,J+1,K))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = 0.25 * ( - U(I-1,J,K) - U(I-1,J+1,K) &
    &              + U(I+1,J,K) + U(I+1,J+1,K) )
    UET = - U(I,J,K) + U(I,J+1,K)
    UZE = 0.25 * ( - U(I,J,K-1) - U(I,J+1,K-1) &
    &              + U(I,J,K+1) + U(I,J+1,K+1) )
    VXI = 0.25 * ( - V(I-1,J,K) - V(I-1,J+1,K) &
    &              + V(I+1,J,K) + V(I+1,J+1,K) )
    VET = - V(I,J,K) + V(I,J+1,K)
    VZE = 0.25 * ( - V(I,J,K-1) - V(I,J+1,K-1) &
    &              + V(I,J,K+1) + V(I,J+1,K+1) )
    WXI = 0.25 * ( - W(I-1,J,K) - W(I-1,J+1,K) &
    &              + W(I+1,J,K) + W(I+1,J+1,K) )
    WET = - W(I,J,K) + W(I,J+1,K)
    WZE = 0.25 * ( - W(I,J,K-1) - W(I,J+1,K-1) &
    &              + W(I,J,K+1) + W(I,J+1,K+1) )
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM + UZE * ZEXM
    UY = UXI * XIYM + UET * ETYM + UZE * ZEYM
    UZ = UXI * XIZM + UET * ETZM + UZE * ZEZM
    VX = VXI * XIXM + VET * ETXM + VZE * ZEXM
    VY = VXI * XIYM + VET * ETYM + VZE * ZEYM
    VZ = VXI * XIZM + VET * ETZM + VZE * ZEZM
    WX = WXI * XIXM + WET * ETXM + WZE * ZEXM
    WY = WXI * XIYM + WET * ETYM + WZE * ZEYM
    WZ = WXI * XIZM + WET * ETZM + WZE * ZEZM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = 0.25 * ( - T(I-1,J,K) - T(I-1,J+1,K) &
    &              + T(I+1,J,K) + T(I+1,J+1,K) )
    TET = - T(I,J,K) + T(I,J+1,K)
    TZE = 0.25 * ( - T(I,J,K-1) - T(I,J+1,K-1) &
    &              + T(I,J,K+1) + T(I,J+1,K+1) )
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM + TZE * ZEXM
    TY = TXI * XIYM + TET * ETYM + TZE * ZEYM
    TZ = TXI * XIZM + TET * ETZM + TZE * ZEZM
    ! uu �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    uuXI = 0.25 * ( - uu(I-1,J,K) - uu(I-1,J+1,K) &
    &               + uu(I+1,J,K) + uu(I+1,J+1,K) )
    uuET = - uu(I,J,K) + uu(I,J+1,K)
    uuZE = 0.25 * ( - uu(I,J,K-1) - uu(I,J+1,K-1) &
    &               + uu(I,J,K+1) + uu(I,J+1,K+1) )
    ! ������ԕ�����K����
    uuX = uuXI * XIXM + uuET * ETXM + uuZE * ZEXM
    uuY = uuXI * XIYM + uuET * ETYM + uuZE * ZEYM
    uuZ = uuXI * XIZM + uuET * ETZM + uuZE * ZEZM
    ! vv �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    vvXI = 0.25 * ( - vv(I-1,J,K) - vv(I-1,J+1,K) &
    &               + vv(I+1,J,K) + vv(I+1,J+1,K) )
    vvET = - vv(I,J,K) + vv(I,J+1,K)
    vvZE = 0.25 * ( - vv(I,J,K-1) - vv(I,J+1,K-1) &
    &               + vv(I,J,K+1) + vv(I,J+1,K+1) )
    ! ������ԕ�����K����
    vvX = vvXI * XIXM + vvET * ETXM + vvZE * ZEXM
    vvY = vvXI * XIYM + vvET * ETYM + vvZE * ZEYM
    vvZ = vvXI * XIZM + vvET * ETZM + vvZE * ZEZM
    ! ww �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    wwXI = 0.25 * ( - ww(I-1,J,K) - ww(I-1,J+1,K) &
    &               + ww(I+1,J,K) + ww(I+1,J+1,K) )
    wwET = - ww(I,J,K) + ww(I,J+1,K)
    wwZE = 0.25 * ( - ww(I,J,K-1) - ww(I,J+1,K-1) &
    &               + ww(I,J,K+1) + ww(I,J+1,K+1) )
    ! ������ԕ�����K����
    wwX = wwXI * XIXM + wwET * ETXM + wwZE * ZEXM
    wwY = wwXI * XIYM + wwET * ETYM + wwZE * ZEYM
    wwZ = wwXI * XIZM + wwET * ETZM + wwZE * ZEZM
    ! uv �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    uvXI = 0.25 * ( - uv(I-1,J,K) - uv(I-1,J+1,K) &
    &               + uv(I+1,J,K) + uv(I+1,J+1,K) )
    uvET = - uv(I,J,K) + uv(I,J+1,K)
    uvZE = 0.25 * ( - uv(I,J,K-1) - uv(I,J+1,K-1) &
    &               + uv(I,J,K+1) + uv(I,J+1,K+1) )
    ! ������ԕ�����K����
    uvX = uvXI * XIXM + uvET * ETXM + uvZE * ZEXM
    uvY = uvXI * XIYM + uvET * ETYM + uvZE * ZEYM
    uvZ = uvXI * XIZM + uvET * ETZM + uvZE * ZEZM
    ! vw �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    vwXI = 0.25 * ( - vw(I-1,J,K) - vw(I-1,J+1,K) &
    &               + vw(I+1,J,K) + vw(I+1,J+1,K) )
    vwET = - vw(I,J,K) + vw(I,J+1,K)
    vwZE = 0.25 * ( - vw(I,J,K-1) - vw(I,J+1,K-1) &
    &               + vw(I,J,K+1) + vw(I,J+1,K+1) )
    ! ������ԕ�����K����
    vwX = vwXI * XIXM + vwET * ETXM + vwZE * ZEXM
    vwY = vwXI * XIYM + vwET * ETYM + vwZE * ZEYM
    vwZ = vwXI * XIZM + vwET * ETZM + vwZE * ZEZM
    ! wu �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    wuXI = 0.25 * ( - wu(I-1,J,K) - wu(I-1,J+1,K) &
    &               + wu(I+1,J,K) + wu(I+1,J+1,K) )
    wuET = - wu(I,J,K) + wu(I,J+1,K)
    wuZE = 0.25 * ( - wu(I,J,K-1) - wu(I,J+1,K-1) &
    &               + wu(I,J,K+1) + wu(I,J+1,K+1) )
    ! ������ԕ�����K����
    wuX = wuXI * XIXM + wuET * ETXM + wuZE * ZEXM
    wuY = wuXI * XIYM + wuET * ETYM + wuZE * ZEYM
    wuZ = wuXI * XIZM + wuET * ETZM + wuZE * ZEZM
    ! epsilon �̈�K�����̌v�Z -----------------------------------------
    ! �v�Z��ԕ�����K����
    AEXI = 0.25 * ( - EPS(I-1,J,K) - EPS(I-1,J+1,K) &
    &               + EPS(I+1,J,K) + EPS(I+1,J+1,K) )
    AEET = - EPS(I,J,K) + EPS(I,J+1,K)
    AEZE = 0.25 * ( - EPS(I,J,K-1) - EPS(I,J+1,K-1) &
    &               + EPS(I,J,K+1) + EPS(I,J+1,K+1) )
    ! ������ԕ�����K����
    AEX = AEXI * XIXM + AEET * ETXM + AEZE * ZEXM
    AEY = AEXI * XIYM + AEET * ETYM + AEZE * ZEYM
    AEZ = AEXI * XIZM + AEET * ETZM + AEZE * ZEZM
    ! ���S�x -----------------------------------------------------------
    nu = AMUM / RHOM
    ! �c�ݑ��x ---------------------------------------------------------
    SS  = (UX + VY + WZ) * TwoThird
    S11 = 2.0 * UX - SS
    S22 = 2.0 * VY - SS
    S33 = 2.0 * WZ - SS
    S12 = UY + VX
    S23 = VZ + WY
    S31 = WX + UZ
    ! U �̊g�U ---------------------------------------------------------
    R02M = nu * S11
    S02M = nu * S12
    T02M = nu * S31
    R02T =-uuM
    S02T =-uvM
    T02T =-wuM
    ! V �̊g�U ---------------------------------------------------------
    R03M = nu * S12
    S03M = nu * S22
    T03M = nu * S23
    R03T =-uvM
    S03T =-vvM
    T03T =-vwM
    ! W �̊g�U ---------------------------------------------------------
    R04M = nu * S31
    S04M = nu * S23
    T04M = nu * S33
    R04T =-wuM
    S04T =-vwM
    T04T =-wwM
    ! �G�l���M�[�̊g�U -------------------------------------------------
    C_p  = GAMMA * RG / (GAMMA - 1.0)
    IF(EPSM .GT. ZERO) THEN
      AKAE = 0.5 * (uuM + vvM + wwM) / EPSM
    ELSE
      AKAE = 0.0
    ENDIF
    R05M = C_p * nu / PR * TX + nu * (S11 * UM + S12 * VM + S31 * WM)
    S05M = C_p * nu / PR * TY + nu * (S12 * UM + S22 * VM + S23 * WM)
    T05M = C_p * nu / PR * TZ + nu * (S31 * UM + S23 * VM + S33 * WM)
    R05T = AKAE * C_se * C_p * (uuM * TX + uvM * TY + wuM * TZ) &
    &    + AKAE * C_s  * ( &
    &      uuM * (uuX + vvX + wwX) &
    &    + uvM * (uuY + vvY + wwY) &
    &    + wuM * (uuZ + vvZ + wwZ) &
    &    ) &
    &    - (uuM * UM + uvM * VM + wuM * WM)
    S05T = AKAE * C_se * C_p * (uvM * TX + vvM * TY + vwM * TZ) &
    &    + AKAE * C_s  * ( &
    &      uvM * (uuX + vvX + wwX) &
    &    + vvM * (uuY + vvY + wwY) &
    &    + vwM * (uuZ + vvZ + wwZ) &
    &    ) &
    &    - (uvM * UM + vvM * VM + vwM * WM)
    T05T = AKAE * C_se * C_p * (wuM * TX + vwM * TY + wwM * TZ) &
    &    + AKAE * C_s  * ( &
    &      wuM * (uuX + vvX + wwX) &
    &    + vwM * (uuY + vvY + wwY) &
    &    + wwM * (uuZ + vvZ + wwZ) &
    &    ) &
    &    - (wuM * UM + vwM * VM + wwM * WM)
    ! uu �̊g�U --------------------------------------------------------
    R06M = nu * uuX
    S06M = nu * uuY
    T06M = nu * uuZ
    R06T = C_s * AKAE * (uuM * uuX + uvM * uuY + wuM * uuZ)
    S06T = C_s * AKAE * (uvM * uuX + vvM * uuY + vwM * uuZ)
    T06T = C_s * AKAE * (wuM * uuX + vwM * uuY + wwM * uuZ)
    ! vv �̊g�U --------------------------------------------------------
    R07M = nu * vvX
    S07M = nu * vvY
    T07M = nu * vvZ
    R07T = C_s * AKAE * (uuM * vvX + uvM * vvY + wuM * vvZ)
    S07T = C_s * AKAE * (uvM * vvX + vvM * vvY + vwM * vvZ)
    T07T = C_s * AKAE * (wuM * vvX + vwM * vvY + wwM * vvZ)
    ! ww �̊g�U --------------------------------------------------------
    R08M = nu * wwX
    S08M = nu * wwY
    T08M = nu * wwZ
    R08T = C_s * AKAE * (uuM * wwX + uvM * wwY + wuM * wwZ)
    S08T = C_s * AKAE * (uvM * wwX + vvM * wwY + vwM * wwZ)
    T08T = C_s * AKAE * (wuM * wwX + vwM * wwY + wwM * wwZ)
    ! uv �̊g�U --------------------------------------------------------
    R09M = nu * uvX
    S09M = nu * uvY
    T09M = nu * uvZ
    R09T = C_s * AKAE * (uuM * uvX + uvM * uvY + wuM * uvZ)
    S09T = C_s * AKAE * (uvM * uvX + vvM * uvY + vwM * uvZ)
    T09T = C_s * AKAE * (wuM * uvX + vwM * uvY + wwM * uvZ)
    ! vw �̊g�U --------------------------------------------------------
    R10M = nu * vwX
    S10M = nu * vwY
    T10M = nu * vwZ
    R10T = C_s * AKAE * (uuM * vwX + uvM * vwY + wuM * vwZ)
    S10T = C_s * AKAE * (uvM * vwX + vvM * vwY + vwM * vwZ)
    T10T = C_s * AKAE * (wuM * vwX + vwM * vwY + wwM * vwZ)
    ! wu �̊g�U --------------------------------------------------------
    R11M = nu * wuX
    S11M = nu * wuY
    T11M = nu * wuZ
    R11T = C_s * AKAE * (uuM * wuX + uvM * wuY + wuM * wuZ)
    S11T = C_s * AKAE * (uvM * wuX + vvM * wuY + vwM * wuZ)
    T11T = C_s * AKAE * (wuM * wuX + vwM * wuY + wwM * wuZ)
    ! epsilon �̊g�U ---------------------------------------------------
    R12M = nu * AEX
    S12M = nu * AEY
    T12M = nu * AEZ
    R12T = C_e * AKAE * (uuM * AEX + uvM * AEY + wuM * AEZ)
    S12T = C_e * AKAE * (uvM * AEX + vvM * AEY + vwM * AEZ)
    T12T = C_e * AKAE * (wuM * AEX + vwM * AEY + wwM * AEZ)
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    SH(I,J,K, 1) = 0.0
    SH(I,J,K, 2) = QH1 * ( (R02M + R02T) * ETXM &
    &                    + (S02M + S02T) * ETYM &
    &                    + (T02M + T02T) * ETZM )
    SH(I,J,K, 3) = QH1 * ( (R03M + R03T) * ETXM &
    &                    + (S03M + S03T) * ETYM &
    &                    + (T03M + T03T) * ETZM )
    SH(I,J,K, 4) = QH1 * ( (R04M + R04T) * ETXM &
    &                    + (S04M + S04T) * ETYM &
    &                    + (T04M + T04T) * ETZM )
    SH(I,J,K, 5) = QH1 * ( (R05M + R05T) * ETXM &
    &                    + (S05M + S05T) * ETYM &
    &                    + (T05M + T05T) * ETZM )
    SH(I,J,K, 6) = QH1 * ( (R06M + R06T) * ETXM &
    &                    + (S06M + S06T) * ETYM &
    &                    + (T06M + T06T) * ETZM )
    SH(I,J,K, 7) = QH1 * ( (R07M + R07T) * ETXM &
    &                    + (S07M + S07T) * ETYM &
    &                    + (T07M + T07T) * ETZM )
    SH(I,J,K, 8) = QH1 * ( (R08M + R08T) * ETXM &
    &                    + (S08M + S08T) * ETYM &
    &                    + (T08M + T08T) * ETZM )
    SH(I,J,K, 9) = QH1 * ( (R09M + R09T) * ETXM &
    &                    + (S09M + S09T) * ETYM &
    &                    + (T09M + T09T) * ETZM )
    SH(I,J,K,10) = QH1 * ( (R10M + R10T) * ETXM &
    &                    + (S10M + S10T) * ETYM &
    &                    + (T10M + T10T) * ETZM )
    SH(I,J,K,11) = QH1 * ( (R11M + R11T) * ETXM &
    &                    + (S11M + S11T) * ETYM &
    &                    + (T11M + T11T) * ETZM )
    SH(I,J,K,12) = QH1 * ( (R12M + R12T) * ETXM &
    &                    + (S12M + S12T) * ETYM &
    &                    + (T12M + T12T) * ETZM )
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFET
!***********************************************************************
!**** �g�U���̌v�Z(zeta���������p)                                  ****
!***********************************************************************
SUBROUTINE DIFFZE
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM
  REAL    :: RHOM, UM, VM, WM, uuM, vvM, wwM, uvM, vwM, wuM, EPSM, AMUM
  REAL    :: UXI, UET, UZE, UX, UY, UZ
  REAL    :: VXI, VET, VZE, VX, VY, VZ
  REAL    :: WXI, WET, WZE, WX, WY, WZ
  REAL    :: TXI, TET, TZE, TX, TY, TZ
  REAL    :: uuXI, uuET, uuZE, uuX, uuY, uuZ
  REAL    :: vvXI, vvET, vvZE, vvX, vvY, vvZ
  REAL    :: wwXI, wwET, wwZE, wwX, wwY, wwZ
  REAL    :: uvXI, uvET, uvZE, uvX, uvY, uvZ
  REAL    :: vwXI, vwET, vwZE, vwX, vwY, vwZ
  REAL    :: wuXI, wuET, wuZE, wuX, wuY, wuZ
  REAL    :: AEXI, AEET, AEZE, AEX, AEY, AEZ
  REAL    :: nu
  REAL    :: S11, S22, S33, S12, S23, S31, SS
  REAL    :: C_p, AKAE
  REAL    :: R02M, S02M, T02M, R02T, S02T, T02T
  REAL    :: R03M, S03M, T03M, R03T, S03T, T03T
  REAL    :: R04M, S04M, T04M, R04T, S04T, T04T
  REAL    :: R05M, S05M, T05M, R05T, S05T, T05T
  REAL    :: R06M, S06M, T06M, R06T, S06T, T06T
  REAL    :: R07M, S07M, T07M, R07T, S07T, T07T
  REAL    :: R08M, S08M, T08M, R08T, S08T, T08T
  REAL    :: R09M, S09M, T09M, R09T, S09T, T09T
  REAL    :: R10M, S10M, T10M, R10T, S10T, T10T
  REAL    :: R11M, S11M, T11M, R11T, S11T, T11T
  REAL    :: R12M, S12M, T12M, R12T, S12T, T12T
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM, &
!$OMP& RHOM, UM, VM, WM, uuM, vvM, wwM, uvM, vwM, wuM, EPSM, AMUM, &
!$OMP& UXI, UET, UZE, UX, UY, UZ, &
!$OMP& VXI, VET, VZE, VX, VY, VZ, &
!$OMP& WXI, WET, WZE, WX, WY, WZ, &
!$OMP& TXI, TET, TZE, TX, TY, TZ, &
!$OMP& uuXI, uuET, uuZE, uuX, uuY, uuZ, &
!$OMP& vvXI, vvET, vvZE, vvX, vvY, vvZ, &
!$OMP& wwXI, wwET, wwZE, wwX, wwY, wwZ, &
!$OMP& uvXI, uvET, uvZE, uvX, uvY, uvZ, &
!$OMP& vwXI, vwET, vwZE, vwX, vwY, vwZ, &
!$OMP& wuXI, wuET, wuZE, wuX, wuY, wuZ, &
!$OMP& AEXI, AEET, AEZE, AEX, AEY, AEZ, &
!$OMP& nu, S11, S22, S33, S12, S23, S31, SS, C_p, AKAE, &
!$OMP& R02M, S02M, T02M, R02T, S02T, T02T, &
!$OMP& R03M, S03M, T03M, R03T, S03T, T03T, &
!$OMP& R04M, S04M, T04M, R04T, S04T, T04T, &
!$OMP& R05M, S05M, T05M, R05T, S05T, T05T, &
!$OMP& R06M, S06M, T06M, R06T, S06T, T06T, &
!$OMP& R07M, S07M, T07M, R07T, S07T, T07T, &
!$OMP& R08M, S08M, T08M, R08T, S08T, T08T, &
!$OMP& R09M, S09M, T09M, R09T, S09T, T09T, &
!$OMP& R10M, S10M, T10M, R10T, S10T, T10T, &
!$OMP& R11M, S11M, T11M, R11T, S11T, T11T, &
!$OMP& R12M, S12M, T12M, R12T, S12T, T12T, &
!$OMP& QH1 &
!$OMP& )
  DO K = KS    , KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF((RHO(I,J,K) .GT. 0.0) .AND. (RHO(I,J,K+1) .GT. 0.0)) THEN
    ! XI�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J,K) + XIX(I,J,K+1))
    XIYM = 0.5 * (XIY(I,J,K) + XIY(I,J,K+1))
    XIZM = 0.5 * (XIZ(I,J,K) + XIZ(I,J,K+1))
    ETXM = 0.5 * (ETX(I,J,K) + ETX(I,J,K+1))
    ETYM = 0.5 * (ETY(I,J,K) + ETY(I,J,K+1))
    ETZM = 0.5 * (ETZ(I,J,K) + ETZ(I,J,K+1))
    ZEXM = 0.5 * (ZEX(I,J,K) + ZEX(I,J,K+1))
    ZEYM = 0.5 * (ZEY(I,J,K) + ZEY(I,J,K+1))
    ZEZM = 0.5 * (ZEZ(I,J,K) + ZEZ(I,J,K+1))
    AJAM = 0.5 * (AJA(I,J,K) + AJA(I,J,K+1))
    ! ������
    RHOM = 0.5 * (RHO(I,J,K) + RHO(I,J,K+1))
    UM   = 0.5 * (  U(I,J,K) +   U(I,J,K+1))
    VM   = 0.5 * (  V(I,J,K) +   V(I,J,K+1))
    WM   = 0.5 * (  W(I,J,K) +   W(I,J,K+1))
    uuM  = 0.5 * ( uu(I,J,K) +  uu(I,J,K+1))
    vvM  = 0.5 * ( vv(I,J,K) +  vv(I,J,K+1))
    wwM  = 0.5 * ( ww(I,J,K) +  ww(I,J,K+1))
    uvM  = 0.5 * ( uv(I,J,K) +  uv(I,J,K+1))
    vwM  = 0.5 * ( vw(I,J,K) +  vw(I,J,K+1))
    wuM  = 0.5 * ( wu(I,J,K) +  wu(I,J,K+1))
    EPSM = 0.5 * (EPS(I,J,K) + EPS(I,J,K+1))
    AMUM = 0.5 * (AMU(I,J,K) + AMU(I,J,K+1))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = 0.25 * ( - U(I-1,J,K) - U(I-1,J,K+1) &
    &              + U(I+1,J,K) + U(I+1,J,K+1) )
    UET = 0.25 * ( - U(I,J-1,K) - U(I,J-1,K+1) &
    &              + U(I,J+1,K) + U(I,J+1,K+1) )
    UZE = - U(I,J,K) + U(I,J,K+1)
    VXI = 0.25 * ( - V(I-1,J,K) - V(I-1,J,K+1) &
    &              + V(I+1,J,K) + V(I+1,J,K+1) )
    VET = 0.25 * ( - V(I,J-1,K) - V(I,J-1,K+1) &
    &              + V(I,J+1,K) + V(I,J+1,K+1) )
    VZE = - V(I,J,K) + V(I,J,K+1)
    WXI = 0.25 * ( - W(I-1,J,K) - W(I-1,J,K+1) &
    &              + W(I+1,J,K) + W(I+1,J,K+1) )
    WET = 0.25 * ( - W(I,J-1,K) - W(I,J-1,K+1) &
    &              + W(I,J+1,K) + W(I,J+1,K+1) )
    WZE = - W(I,J,K) + W(I,J,K+1)
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM + UZE * ZEXM
    UY = UXI * XIYM + UET * ETYM + UZE * ZEYM
    UZ = UXI * XIZM + UET * ETZM + UZE * ZEZM
    VX = VXI * XIXM + VET * ETXM + VZE * ZEXM
    VY = VXI * XIYM + VET * ETYM + VZE * ZEYM
    VZ = VXI * XIZM + VET * ETZM + VZE * ZEZM
    WX = WXI * XIXM + WET * ETXM + WZE * ZEXM
    WY = WXI * XIYM + WET * ETYM + WZE * ZEYM
    WZ = WXI * XIZM + WET * ETZM + WZE * ZEZM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = 0.25 * ( - T(I-1,J,K) - T(I-1,J,K+1) &
    &              + T(I+1,J,K) + T(I+1,J,K+1) )
    TET = 0.25 * ( - T(I,J-1,K) - T(I,J-1,K+1) &
    &              + T(I,J+1,K) + T(I,J+1,K+1) )
    TZE = - T(I,J,K) + T(I,J,K+1)
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM + TZE * ZEXM
    TY = TXI * XIYM + TET * ETYM + TZE * ZEYM
    TZ = TXI * XIZM + TET * ETZM + TZE * ZEZM
    ! uu �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    uuXI = 0.25 * ( - uu(I-1,J,K) - uu(I-1,J,K+1) &
    &               + uu(I+1,J,K) + uu(I+1,J,K+1) )
    uuET = 0.25 * ( - uu(I,J-1,K) - uu(I,J-1,K+1) &
    &               + uu(I,J+1,K) + uu(I,J+1,K+1) )
    uuZE = - uu(I,J,K) + uu(I,J,K+1)
    ! ������ԕ�����K����
    uuX = uuXI * XIXM + uuET * ETXM + uuZE * ZEXM
    uuY = uuXI * XIYM + uuET * ETYM + uuZE * ZEYM
    uuZ = uuXI * XIZM + uuET * ETZM + uuZE * ZEZM
    ! vv �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    vvXI = 0.25 * ( - vv(I-1,J,K) - vv(I-1,J,K+1) &
    &               + vv(I+1,J,K) + vv(I+1,J,K+1) )
    vvET = 0.25 * ( - vv(I,J-1,K) - vv(I,J-1,K+1) &
    &               + vv(I,J+1,K) + vv(I,J+1,K+1) )
    vvZE = - vv(I,J,K) + vv(I,J,K+1)
    ! ������ԕ�����K����
    vvX = vvXI * XIXM + vvET * ETXM + vvZE * ZEXM
    vvY = vvXI * XIYM + vvET * ETYM + vvZE * ZEYM
    vvZ = vvXI * XIZM + vvET * ETZM + vvZE * ZEZM
    ! ww �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    wwXI = 0.25 * ( - ww(I-1,J,K) - ww(I-1,J,K+1) &
    &               + ww(I+1,J,K) + ww(I+1,J,K+1) )
    wwET = 0.25 * ( - ww(I,J-1,K) - ww(I,J-1,K+1) &
    &               + ww(I,J+1,K) + ww(I,J+1,K+1) )
    wwZE = - ww(I,J,K) + ww(I,J,K+1)
    ! ������ԕ�����K����
    wwX = wwXI * XIXM + wwET * ETXM + wwZE * ZEXM
    wwY = wwXI * XIYM + wwET * ETYM + wwZE * ZEYM
    wwZ = wwXI * XIZM + wwET * ETZM + wwZE * ZEZM
    ! uv �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    uvXI = 0.25 * ( - uv(I-1,J,K) - uv(I-1,J,K+1) &
    &               + uv(I+1,J,K) + uv(I+1,J,K+1) )
    uvET = 0.25 * ( - uv(I,J-1,K) - uv(I,J-1,K+1) &
    &               + uv(I,J+1,K) + uv(I,J+1,K+1) )
    uvZE = - uv(I,J,K) + uv(I,J,K+1)
    ! ������ԕ�����K����
    uvX = uvXI * XIXM + uvET * ETXM + uvZE * ZEXM
    uvY = uvXI * XIYM + uvET * ETYM + uvZE * ZEYM
    uvZ = uvXI * XIZM + uvET * ETZM + uvZE * ZEZM
    ! vw �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    vwXI = 0.25 * ( - vw(I-1,J,K) - vw(I-1,J,K+1) &
    &               + vw(I+1,J,K) + vw(I+1,J,K+1) )
    vwET = 0.25 * ( - vw(I,J-1,K) - vw(I,J-1,K+1) &
    &               + vw(I,J+1,K) + vw(I,J+1,K+1) )
    vwZE = - vw(I,J,K) + vw(I,J,K+1)
    ! ������ԕ�����K����
    vwX = vwXI * XIXM + vwET * ETXM + vwZE * ZEXM
    vwY = vwXI * XIYM + vwET * ETYM + vwZE * ZEYM
    vwZ = vwXI * XIZM + vwET * ETZM + vwZE * ZEZM
    ! wu �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    wuXI = 0.25 * ( - wu(I-1,J,K) - wu(I-1,J,K+1) &
    &               + wu(I+1,J,K) + wu(I+1,J,K+1) )
    wuET = 0.25 * ( - wu(I,J-1,K) - wu(I,J-1,K+1) &
    &               + wu(I,J+1,K) + wu(I,J+1,K+1) )
    wuZE = - wu(I,J,K) + wu(I,J,K+1)
    ! ������ԕ�����K����
    wuX = wuXI * XIXM + wuET * ETXM + wuZE * ZEXM
    wuY = wuXI * XIYM + wuET * ETYM + wuZE * ZEYM
    wuZ = wuXI * XIZM + wuET * ETZM + wuZE * ZEZM
    ! epsilon �̈�K�����̌v�Z -----------------------------------------
    ! �v�Z��ԕ�����K����
    AEXI = 0.25 * ( - EPS(I-1,J,K) - EPS(I-1,J,K+1) &
    &               + EPS(I+1,J,K) + EPS(I+1,J,K+1) )
    AEET = 0.25 * ( - EPS(I,J-1,K) - EPS(I,J-1,K+1) &
    &               + EPS(I,J+1,K) + EPS(I,J+1,K+1) )
    AEZE = - EPS(I,J,K) + EPS(I,J,K+1)
    ! ������ԕ�����K����
    AEX = AEXI * XIXM + AEET * ETXM + AEZE * ZEXM
    AEY = AEXI * XIYM + AEET * ETYM + AEZE * ZEYM
    AEZ = AEXI * XIZM + AEET * ETZM + AEZE * ZEZM
    ! ���S�x -----------------------------------------------------------
    nu = AMUM / RHOM
    ! �c�ݑ��x ---------------------------------------------------------
    SS  = (UX + VY + WZ) * TwoThird
    S11 = 2.0 * UX - SS
    S22 = 2.0 * VY - SS
    S33 = 2.0 * WZ - SS
    S12 = UY + VX
    S23 = VZ + WY
    S31 = WX + UZ
    ! U �̊g�U ---------------------------------------------------------
    R02M = nu * S11
    S02M = nu * S12
    T02M = nu * S31
    R02T =-uuM
    S02T =-uvM
    T02T =-wuM
    ! V �̊g�U ---------------------------------------------------------
    R03M = nu * S12
    S03M = nu * S22
    T03M = nu * S23
    R03T =-uvM
    S03T =-vvM
    T03T =-vwM
    ! W �̊g�U ---------------------------------------------------------
    R04M = nu * S31
    S04M = nu * S23
    T04M = nu * S33
    R04T =-wuM
    S04T =-vwM
    T04T =-wwM
    ! �G�l���M�[�̊g�U -------------------------------------------------
    C_p  = GAMMA * RG / (GAMMA - 1.0)
    IF(EPSM .GT. ZERO) THEN
      AKAE = 0.5 * (uuM + vvM + wwM) / EPSM
    ELSE
      AKAE = 0.0
    ENDIF
    R05M = C_p * nu / PR * TX + nu * (S11 * UM + S12 * VM + S31 * WM)
    S05M = C_p * nu / PR * TY + nu * (S12 * UM + S22 * VM + S23 * WM)
    T05M = C_p * nu / PR * TZ + nu * (S31 * UM + S23 * VM + S33 * WM)
    R05T = AKAE * C_se * C_p * (uuM * TX + uvM * TY + wuM * TZ) &
    &    + AKAE * C_s  * ( &
    &      uuM * (uuX + vvX + wwX) &
    &    + uvM * (uuY + vvY + wwY) &
    &    + wuM * (uuZ + vvZ + wwZ) &
    &    ) &
    &    - (uuM * UM + uvM * VM + wuM * WM)
    S05T = AKAE * C_se * C_p * (uvM * TX + vvM * TY + vwM * TZ) &
    &    + AKAE * C_s  * ( &
    &      uvM * (uuX + vvX + wwX) &
    &    + vvM * (uuY + vvY + wwY) &
    &    + vwM * (uuZ + vvZ + wwZ) &
    &    ) &
    &    - (uvM * UM + vvM * VM + vwM * WM)
    T05T = AKAE * C_se * C_p * (wuM * TX + vwM * TY + wwM * TZ) &
    &    + AKAE * C_s  * ( &
    &      wuM * (uuX + vvX + wwX) &
    &    + vwM * (uuY + vvY + wwY) &
    &    + wwM * (uuZ + vvZ + wwZ) &
    &    ) &
    &    - (wuM * UM + vwM * VM + wwM * WM)
    ! uu �̊g�U --------------------------------------------------------
    R06M = nu * uuX
    S06M = nu * uuY
    T06M = nu * uuZ
    R06T = C_s * AKAE * (uuM * uuX + uvM * uuY + wuM * uuZ)
    S06T = C_s * AKAE * (uvM * uuX + vvM * uuY + vwM * uuZ)
    T06T = C_s * AKAE * (wuM * uuX + vwM * uuY + wwM * uuZ)
    ! vv �̊g�U --------------------------------------------------------
    R07M = nu * vvX
    S07M = nu * vvY
    T07M = nu * vvZ
    R07T = C_s * AKAE * (uuM * vvX + uvM * vvY + wuM * vvZ)
    S07T = C_s * AKAE * (uvM * vvX + vvM * vvY + vwM * vvZ)
    T07T = C_s * AKAE * (wuM * vvX + vwM * vvY + wwM * vvZ)
    ! ww �̊g�U --------------------------------------------------------
    R08M = nu * wwX
    S08M = nu * wwY
    T08M = nu * wwZ
    R08T = C_s * AKAE * (uuM * wwX + uvM * wwY + wuM * wwZ)
    S08T = C_s * AKAE * (uvM * wwX + vvM * wwY + vwM * wwZ)
    T08T = C_s * AKAE * (wuM * wwX + vwM * wwY + wwM * wwZ)
    ! uv �̊g�U --------------------------------------------------------
    R09M = nu * uvX
    S09M = nu * uvY
    T09M = nu * uvZ
    R09T = C_s * AKAE * (uuM * uvX + uvM * uvY + wuM * uvZ)
    S09T = C_s * AKAE * (uvM * uvX + vvM * uvY + vwM * uvZ)
    T09T = C_s * AKAE * (wuM * uvX + vwM * uvY + wwM * uvZ)
    ! vw �̊g�U --------------------------------------------------------
    R10M = nu * vwX
    S10M = nu * vwY
    T10M = nu * vwZ
    R10T = C_s * AKAE * (uuM * vwX + uvM * vwY + wuM * vwZ)
    S10T = C_s * AKAE * (uvM * vwX + vvM * vwY + vwM * vwZ)
    T10T = C_s * AKAE * (wuM * vwX + vwM * vwY + wwM * vwZ)
    ! wu �̊g�U --------------------------------------------------------
    R11M = nu * wuX
    S11M = nu * wuY
    T11M = nu * wuZ
    R11T = C_s * AKAE * (uuM * wuX + uvM * wuY + wuM * wuZ)
    S11T = C_s * AKAE * (uvM * wuX + vvM * wuY + vwM * wuZ)
    T11T = C_s * AKAE * (wuM * wuX + vwM * wuY + wwM * wuZ)
    ! epsilon �̊g�U ---------------------------------------------------
    R12M = nu * AEX
    S12M = nu * AEY
    T12M = nu * AEZ
    R12T = C_e * AKAE * (uuM * AEX + uvM * AEY + wuM * AEZ)
    S12T = C_e * AKAE * (uvM * AEX + vvM * AEY + vwM * AEZ)
    T12T = C_e * AKAE * (wuM * AEX + vwM * AEY + wwM * AEZ)
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    TH(I,J,K, 1) = 0.0
    TH(I,J,K, 2) = QH1 * ( (R02M + R02T) * ZEXM &
    &                    + (S02M + S02T) * ZEYM &
    &                    + (T02M + T02T) * ZEZM )
    TH(I,J,K, 3) = QH1 * ( (R03M + R03T) * ZEXM &
    &                    + (S03M + S03T) * ZEYM &
    &                    + (T03M + T03T) * ZEZM )
    TH(I,J,K, 4) = QH1 * ( (R04M + R04T) * ZEXM &
    &                    + (S04M + S04T) * ZEYM &
    &                    + (T04M + T04T) * ZEZM )
    TH(I,J,K, 5) = QH1 * ( (R05M + R05T) * ZEXM &
    &                    + (S05M + S05T) * ZEYM &
    &                    + (T05M + T05T) * ZEZM )
    TH(I,J,K, 6) = QH1 * ( (R06M + R06T) * ZEXM &
    &                    + (S06M + S06T) * ZEYM &
    &                    + (T06M + T06T) * ZEZM )
    TH(I,J,K, 7) = QH1 * ( (R07M + R07T) * ZEXM &
    &                    + (S07M + S07T) * ZEYM &
    &                    + (T07M + T07T) * ZEZM )
    TH(I,J,K, 8) = QH1 * ( (R08M + R08T) * ZEXM &
    &                    + (S08M + S08T) * ZEYM &
    &                    + (T08M + T08T) * ZEZM )
    TH(I,J,K, 9) = QH1 * ( (R09M + R09T) * ZEXM &
    &                    + (S09M + S09T) * ZEYM &
    &                    + (T09M + T09T) * ZEZM )
    TH(I,J,K,10) = QH1 * ( (R10M + R10T) * ZEXM &
    &                    + (S10M + S10T) * ZEYM &
    &                    + (T10M + T10T) * ZEZM )
    TH(I,J,K,11) = QH1 * ( (R11M + R11T) * ZEXM &
    &                    + (S11M + S11T) * ZEYM &
    &                    + (T11M + T11T) * ZEZM )
    TH(I,J,K,12) = QH1 * ( (R12M + R12T) * ZEXM &
    &                    + (S12M + S12T) * ZEYM &
    &                    + (T12M + T12T) * ZEZM )
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFZE
! ��`�I�� *************************************************************
END SUBROUTINE Turbulence3DRSMSSG
!***********************************************************************
!**** �������f�� : RANS, RSM Launder-Shima Model (1989, 1993)       ****
!****              �����M�`�B�ɂ�Vandromme�̃��f�����g�p            ****
!**** �v�Z�Ώ� : �P��, �񎟌�, ���k��                               ****
!**** �v�Z�X�L�[�� : �񎟐��x���S����(�X�^�K�[�h�i�q��̓_���g�p)   ****
!***********************************************************************
SUBROUTINE Turbulence2DRSMLS( &
&            PELIM, RG, GAMMA, PR, &
&            IS, IE, JS, JE, LS, LE, &
&            XIX, XIY, ETX, ETY, AJA, &
&            RHO, U, V, T, uu, vv, ww, uv, EPS, AMU, &
&            n1, n2, d, &
&            AMUT, DQD, DQP &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, PARAMETER :: C_se = 0.313
  REAL, PARAMETER :: C_s = 0.22, C_e = 0.18
  REAL, PARAMETER :: C_l = 2.5
  REAL, PARAMETER :: C_e1 = 1.45, C_e2 = 1.9
  REAL, PARAMETER :: aiimin = - 0.66666667, aiimax = 1.3333333
  REAL, PARAMETER :: TwoThird = 0.66666667
  REAL, PARAMETER :: ZERO = 1.0E-20
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: PELIM
  REAL,    INTENT(IN)  :: RG, GAMMA, PR
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE
  INTEGER, INTENT(IN)  :: LS, LE
  REAL,    INTENT(IN)  :: XIX(IS:IE, JS:JE), XIY(IS:IE, JS:JE), &
  &                       ETX(IS:IE, JS:JE), ETY(IS:IE, JS:JE), &
  &                       AJA(IS:IE, JS:JE)
  REAL,    INTENT(IN)  :: RHO(IS:IE, JS:JE), &
  &                       U(IS:IE, JS:JE), &
  &                       V(IS:IE, JS:JE), &
  &                       T(IS:IE, JS:JE), &
  &                       uu(IS:IE, JS:JE), &
  &                       vv(IS:IE, JS:JE), &
  &                       ww(IS:IE, JS:JE), &
  &                       uv(IS:IE, JS:JE), &
  &                       EPS(IS:IE, JS:JE)
  REAL,    INTENT(IN)  :: AMU(IS:IE, JS:JE)
  REAL,    INTENT(IN)  :: n1(IS:IE, JS:JE), n2(IS:IE, JS:JE)
  REAL,    INTENT(IN)  :: d(IS:IE, JS:JE)
  REAL,    INTENT(OUT) :: AMUT(IS:IE, JS:JE)
  REAL,    INTENT(OUT) :: DQD(IS:IE, JS:JE, LS:LE)
  REAL,    INTENT(OUT) :: DQP(IS:IE, JS:JE, LS:LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, ALLOCATABLE :: RH(:, :, :), SH(:, :, :)
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 9) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �������m�� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ALLOCATE(RH(IS: IE, JS: JE, LS: LE), SH(IS: IE, JS: JE, LS: LE))
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  AMUT = 0.0
  DQD  = 0.0
  DQP  = 0.0
  ! �����葱���̌Ăяo�� +++++++++++++++++++++++++++++++++++++++++++++++
  CALL NonDiffTerm
  CALL DiffTerm
  ! �����I�� ***********************************************************
  RETURN
! �����葱�� ***********************************************************
CONTAINS
!***********************************************************************
!**** ��g�U���̌v�Z                                                ****
!***********************************************************************
SUBROUTINE NonDiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: TMP, TMP1, TMPw, TMPw1, TMPw2, TMPw1km, TMPw2km
  REAL    :: UXI, VXI, UET, VET, UX, VX, UY, VY
  REAL    :: KRXI, KRET, KRX, KRY
  REAL    :: P11, P22, P33, P12, P_k
  REAL    :: eps11, eps22, eps33, eps12, e_k
  REAL    :: C_1, C_2, C_w1, C_w2
  REAL    :: psi1, psi2
  REAL    :: A, A2, A3
  REAL    :: a11, a22, a33, a12
  REAL    :: phi1_11, phi1_22, phi1_33, phi1_12
  REAL    :: phi2_11, phi2_22, phi2_33, phi2_12
  REAL    :: phiw1_11, phiw1_22, phiw1_33, phiw1_12
  REAL    :: phiw2_11, phiw2_22, phiw2_33, phiw2_12
  REAL    :: phi11, phi22, phi33, phi12
  REAL    :: AK, EPST, SS2, AEAK, nu, Rt
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, &
!$OMP& TMP, TMP1, TMPw, TMPw1, TMPw2, TMPw1km, TMPw2km, &
!$OMP& UXI, VXI, UET, VET, UX, VX, UY, VY, KRXI, KRET, KRX, KRY, &
!$OMP& P11, P22, P33, P12, P_k, eps11, eps22, eps33, eps12, e_k, &
!$OMP& C_1, C_2, C_w1, C_w2, psi1, psi2, A, A2, A3, &
!$OMP& a11, a22, a33, a12, &
!$OMP& phi1_11, phi1_22, phi1_33, phi1_12, &
!$OMP& phi2_11, phi2_22, phi2_33, phi2_12, &
!$OMP& phiw1_11, phiw1_22, phiw1_33, phiw1_12, &
!$OMP& phiw2_11, phiw2_22, phiw2_33, phiw2_12, &
!$OMP& phi11, phi22, phi33, phi12, &
!$OMP& AK, EPST, SS2, AEAK, nu, Rt, QH1 &
!$OMP& )
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF(RHO(I,J) .GT. 0.0) THEN
    ! �����G�l���M�[ ---------------------------------------------------
    AK = 0.5 * (uu(I,J) + vv(I,J) + ww(I,J))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = 0.5 * (U(I+1,J) - U(I-1,J))
    VXI = 0.5 * (V(I+1,J) - V(I-1,J))
    UET = 0.5 * (U(I,J+1) - U(I,J-1))
    VET = 0.5 * (V(I,J+1) - V(I,J-1))
    ! ������ԕ�����K����
    UX = UXI * XIX(I,J) + UET * ETX(I,J)
    UY = UXI * XIY(I,J) + UET * ETY(I,J)
    VX = VXI * XIX(I,J) + VET * ETX(I,J)
    VY = VXI * XIY(I,J) + VET * ETY(I,J)
    ! �������ƎU�퍀 ---------------------------------------------------
    P11 = - 2.0 * (uu(I,J) * UX + uv(I,J) * UY)
    P22 = - 2.0 * (uv(I,J) * VX + vv(I,J) * VY)
    P33 = 0.0
    P12 = - (uu(I,J) * VX + uv(I,J) * (UX + VY) + vv(I,J) * UY)
    P_k = 0.5 * (P11 + P22 + P33)
    e_k = EPS(I,J)
    ! �Ǐ����t����(�����ƎU��̃o�����X)�ɂ�郊�~�b�^�[
    IF(PELIM .GT. 0.0) THEN
      TMP = TwoThird * e_k / PELIM
      P11 = MIN(TMP, MAX(-TMP, P11))
      P22 = MIN(TMP, MAX(-TMP, P22))
      P33 = MIN(TMP, MAX(-TMP, P33))
      P_k = 0.5 * (P11 + P22 + P33)
    ENDIF
    TMP   = TwoThird * e_k
    eps11 = TMP
    eps22 = TMP
    eps33 = TMP
    eps12 = 0.0
    ! �񓙕����C�m���Y���̓e���\�� a_ij --------------------------------
    IF(AK .GT. ZERO) THEN
      a11 = uu(I,J) / AK - TwoThird
      a22 = vv(I,J) / AK - TwoThird
      a33 = ww(I,J) / AK - TwoThird
      a12 = uv(I,J) / AK
      a11 = MIN(aiimax, MAX(aiimin, a11))
      a22 = MIN(aiimax, MAX(aiimin, a22))
      a33 = MIN(aiimax, MAX(aiimin, a33))
      a12 = MIN(1.0, MAX(-1.0, a12))
    ELSE
      a11 = aiimin
      a22 = aiimin
      a33 = aiimin
      a12 = 0.0
    ENDIF
    ! A : Lumley's stress flatness factor ------------------------------
    A2 = a11 * a11 + a22 * a22 + a33 * a33 + 2.0 * a12 * a12
    A2 = MIN(8.0 / 3.0, MAX(0.0, A2))
    A3 = a11 * a11 * a11 + a22 * a22 * a22 + a33 * a33 * a33 &
    &  + 3.0 * a12 * a12 * (a11 + a22)
    A3 = MIN(A2, MAX(A2 - 8.0 / 9.0, A3))
    A  = 1.0 - 9.0 / 8.0 * (A2 - A3)
    A  = MIN(1.0, MAX(0.0, A))
    ! ����̎U�헦�Ȃ� -------------------------------------------------
    KRXI   = 0.5 * ( &
    &        - SQRT(0.5 * (uu(I-1,J) + vv(I-1,J) + ww(I-1,J))) &
    &        + SQRT(0.5 * (uu(I+1,J) + vv(I+1,J) + ww(I+1,J))) &
    &      )
    KRET   = 0.5 * ( &
    &        - SQRT(0.5 * (uu(I,J-1) + vv(I,J-1) + ww(I,J-1))) &
    &        + SQRT(0.5 * (uu(I,J+1) + vv(I,J+1) + ww(I,J+1))) &
    &      )
    KRX    = KRXI * XIX(I,J) + KRET * ETX(I,J)
    KRY    = KRXI * XIY(I,J) + KRET * ETY(I,J)
    nu     = AMU(I,J) / RHO(I,J)
    EPST   = e_k - 2.0 * nu * (KRX**2 + KRY**2)
    EPST   = MAX(0.0, EPST)
    IF(e_k .GT. ZERO) THEN
      Rt = AK**2 / (nu * e_k)
    ELSE
      Rt = 0.0
    ENDIF
    ! ���f���֐� -------------------------------------------------------
    C_1  = 1.0 + 2.58 * A * A2**0.25 * (1.0 - EXP(-(0.0067 * Rt)**2))
    C_2  = 0.75 * SQRT(A)
    C_w1 =-TwoThird * C_1 + 1.67
    IF(C_2 .GT. 0.25) THEN
      C_w2 = (TwoThird * (C_2 - 1.0) + 0.5) / C_2
    ELSE
      C_w2 = 0.0
    ENDIF
    IF(e_k .GT. ZERO) THEN
      psi1 = 1.5 * A * (P_k / e_k - 1.0)
    ELSE
      psi1 = 0.0
    ENDIF
    psi2 = 0.35 * (1.0 - 0.3 * A2) * EXP(-SQRT(0.002 * Rt))
    SS2  = 2.0 * (UX**2 + VY**2) + (UY + VX)**2 &
    &    - TwoThird * (UX + VY)**2
    AEAK = MIN(MAX(SQRT(SS2), SQRT(e_k / nu)), e_k / MAX(ZERO, AK))
    ! �ĕ��z�� ---------------------------------------------------------
    TMP1    = - C_1 * AEAK
    phi1_11 = TMP1 * (uu(I,J) - TwoThird * AK)
    phi1_22 = TMP1 * (vv(I,J) - TwoThird * AK)
    phi1_33 = TMP1 * (ww(I,J) - TwoThird * AK)
    phi1_12 = TMP1 * uv(I,J)
    phi2_11 = - C_2 * (P11 - TwoThird * P_k)
    phi2_22 = - C_2 * (P22 - TwoThird * P_k)
    phi2_33 = - C_2 * (P33 - TwoThird * P_k)
    phi2_12 = - C_2 * P12
    IF(C_l * e_k * d(I,J) .GT. ZERO) THEN
      TMPw = AK**1.5 / (C_l * e_k * d(I,J))
      ! �ǖʔ��ˍ��̃_���s���O�֐��̐���
      ! TMPw = MIN(1.0, MAX(0.0, TMPw))
    ELSE
      TMPw = 0.0
    ENDIF
    TMPw1   = C_w1 * TMPw * AEAK
    TMPw2   = C_w2 * TMPw
    TMPw1km = uu(I,J) * n1(I,J) * n1(I,J) &
    &       + vv(I,J) * n2(I,J) * n2(I,J) &
    &       + 2.0 * uv(I,J) * n1(I,J) * n2(I,J)
    TMPw2km = phi2_11 * n1(I,J) * n1(I,J) &
    &       + phi2_22 * n2(I,J) * n2(I,J) &
    &       + 2.0 * phi2_12 * n1(I,J) * n2(I,J)
    phiw1_11 = TMPw1 * (TMPw1km - 3.0 * n1(I,J) &
    &          * (uu(I,J) * n1(I,J) + uv(I,J) * n2(I,J)) &
    &        )
    phiw1_22 = TMPw1 * (TMPw1km - 3.0 * n2(I,J) &
    &          * (uv(I,J) * n1(I,J) + vv(I,J) * n2(I,J)) &
    &        )
    phiw1_33 = TMPw1 * TMPw1km
    phiw1_12 = - 1.5 * TMPw1 * ( &
    &          n1(I,J) * (uv(I,J) * n1(I,J) + vv(I,J) * n2(I,J)) &
    &        + n2(I,J) * (uu(I,J) * n1(I,J) + uv(I,J) * n2(I,J)) &
    &        )
    phiw2_11 = TMPw2 * (TMPw2km - 3.0 * n1(I,J) &
    &          * (phi2_11 * n1(I,J) + phi2_12 * n2(I,J)) &
    &        )
    phiw2_22 = TMPw2 * (TMPw2km - 3.0 * n2(I,J) &
    &          * (phi2_12 * n1(I,J) + phi2_22 * n2(I,J)) &
    &        )
    phiw2_33 = TMPw2 * TMPw2km
    phiw2_12 = - 1.5 * TMPw2 * ( &
    &          n1(I,J) * (phi2_12 * n1(I,J) + phi2_22 * n2(I,J)) &
    &        + n2(I,J) * (phi2_11 * n1(I,J) + phi2_12 * n2(I,J)) &
    &        )
    phi11 = phi1_11 + phi2_11 + phiw1_11 + phiw2_11
    phi22 = phi1_22 + phi2_22 + phiw1_22 + phiw2_22
    phi33 = phi1_33 + phi2_33 + phiw1_33 + phiw2_33
    phi12 = phi1_12 + phi2_12 + phiw1_12 + phiw2_12
    ! �Q�S���W���̌v�Z -------------------------------------------------
    IF(e_k .GT. ZERO) THEN
      AMUT(I,J) = 0.09 * AK**2 / e_k * RHO(I,J)
    ENDIF
    ! �������A���͍ĕ��z���A�U�퍀�̘a ---------------------------------
    QH1 = RHO(I,J) / AJA(I,J)
    DQP(I,J,5) = QH1 * (P11 - eps11 + phi11)
    DQP(I,J,6) = QH1 * (P22 - eps22 + phi22)
    DQP(I,J,7) = QH1 * (P33 - eps33 + phi33)
    DQP(I,J,8) = QH1 * (P12 - eps12 + phi12)
    DQP(I,J,9) = QH1 * AEAK * ( &
    &            (C_e1 + psi1 + psi2) * P_k - C_e2 * EPST &
    &          )
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE NonDiffTerm
!***********************************************************************
!**** �g�U���̌v�Z                                                  ****
!***********************************************************************
SUBROUTINE DiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, L
  ! �����J�n ***********************************************************
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  RH = 0.0
  SH = 0.0
  ! �g�U���̗v�f���v�Z +++++++++++++++++++++++++++++++++++++++++++++++++
  CALL DIFFXI
  CALL DIFFET
  ! �g�U���̍��� +++++++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE(I, J, L)
  DO L = LS, LE
  !$OMP DO
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( (RHO(I,J-1) .GT. 0.0) .AND. (RHO(I-1,J) .GT. 0.0) .AND. &
  &   (RHO(I,J)   .GT. 0.0) .AND. &
  &   (RHO(I+1,J) .GT. 0.0) .AND. (RHO(I,J+1) .GT. 0.0) &
  & ) THEN
    DQD(I,J,L) = (-RH(I-1,J  ,L) + RH(I,J,L)) &
    &          + (-SH(I  ,J-1,L) + SH(I,J,L))
  ENDIF
  ENDDO
  ENDDO
  !$OMP END DO
  ENDDO
  !$OMP END PARALLEL
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DiffTerm
!***********************************************************************
!**** �g�U���̌v�Z(xi���������p)                                    ****
!***********************************************************************
SUBROUTINE DIFFXI
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: XIXM, XIYM, ETXM, ETYM, AJAM
  REAL    :: RHOM, UM, VM, uuM, vvM, wwM, uvM, EPSM, AMUM
  REAL    :: UXI, UET, UX, UY
  REAL    :: VXI, VET, VX, VY
  REAL    :: TXI, TET, TX, TY
  REAL    :: uuXI, uuET, uuX, uuY
  REAL    :: vvXI, vvET, vvX, vvY
  REAL    :: wwXI, wwET, wwX, wwY
  REAL    :: uvXI, uvET, uvX, uvY
  REAL    :: AEXI, AEET, AEX, AEY
  REAL    :: nu
  REAL    :: S11, S22, S12, SS
  REAL    :: C_p, AKAE
  REAL    :: R2M, S2M, R2T, S2T
  REAL    :: R3M, S3M, R3T, S3T
  REAL    :: R4M, S4M, R4T, S4T
  REAL    :: R5M, S5M, R5T, S5T
  REAL    :: R6M, S6M, R6T, S6T
  REAL    :: R7M, S7M, R7T, S7T
  REAL    :: R8M, S8M, R8T, S8T
  REAL    :: R9M, S9M, R9T, S9T
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, &
!$OMP& XIXM, XIYM, ETXM, ETYM, AJAM, &
!$OMP& RHOM, UM, VM, uuM, vvM, wwM, uvM, EPSM, AMUM, &
!$OMP& UXI, UET, UX, UY, VXI, VET, VX, VY, TXI, TET, TX, TY, &
!$OMP& uuXI, uuET, uuX, uuY, vvXI, vvET, vvX, vvY, &
!$OMP& wwXI, wwET, wwX, wwY, uvXI, uvET, uvX, uvY, &
!$OMP& AEXI, AEET, AEX, AEY, &
!$OMP& nu, S11, S22, S12, SS, C_p, AKAE, &
!$OMP& R2M, S2M, R2T, S2T, R3M, S3M, R3T, S3T, R4M, S4M, R4T, S4T, &
!$OMP& R5M, S5M, R5T, S5T, R6M, S6M, R6T, S6T, R7M, S7M, R7T, S7T, &
!$OMP& R8M, S8M, R8T, S8T, R9M, S9M, R9T, S9T, QH1 &
!$OMP& )
  DO J = JS + 1, JE - 1
  DO I = IS    , IE - 1
  IF((RHO(I,J) .GT. 0.0) .AND. (RHO(I+1,J) .GT. 0.0)) THEN
    ! XI�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J) + XIX(I+1,J))
    XIYM = 0.5 * (XIY(I,J) + XIY(I+1,J))
    ETXM = 0.5 * (ETX(I,J) + ETX(I+1,J))
    ETYM = 0.5 * (ETY(I,J) + ETY(I+1,J))
    AJAM = 0.5 * (AJA(I,J) + AJA(I+1,J))
    ! ������
    RHOM = 0.5 * (RHO(I,J) + RHO(I+1,J))
    UM   = 0.5 * (  U(I,J) +   U(I+1,J))
    VM   = 0.5 * (  V(I,J) +   V(I+1,J))
    uuM  = 0.5 * ( uu(I,J) +  uu(I+1,J))
    vvM  = 0.5 * ( vv(I,J) +  vv(I+1,J))
    wwM  = 0.5 * ( ww(I,J) +  ww(I+1,J))
    uvM  = 0.5 * ( uv(I,J) +  uv(I+1,J))
    EPSM = 0.5 * (EPS(I,J) + EPS(I+1,J))
    AMUM = 0.5 * (AMU(I,J) + AMU(I+1,J))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = - U(I,J) + U(I+1,J)
    UET = 0.25 * (- U(I,J-1) - U(I+1,J-1) + U(I,J+1) + U(I+1,J+1))
    VXI = - V(I,J) + V(I+1,J)
    VET = 0.25 * (- V(I,J-1) - V(I+1,J-1) + V(I,J+1) + V(I+1,J+1))
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM
    UY = UXI * XIYM + UET * ETYM
    VX = VXI * XIXM + VET * ETXM
    VY = VXI * XIYM + VET * ETYM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = - T(I,J) + T(I+1,J)
    TET = 0.25 * (- T(I,J-1) - T(I+1,J-1) + T(I,J+1) + T(I+1,J+1))
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM
    TY = TXI * XIYM + TET * ETYM
    ! uu �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    uuXI = - uu(I,J) + uu(I+1,J)
    uuET = 0.25 * ( - uu(I,J-1) - uu(I+1,J-1) &
    &               + uu(I,J+1) + uu(I+1,J+1) )
    ! ������ԕ�����K����
    uuX = uuXI * XIXM + uuET * ETXM
    uuY = uuXI * XIYM + uuET * ETYM
    ! vv �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    vvXI = - vv(I,J) + vv(I+1,J)
    vvET = 0.25 * ( - vv(I,J-1) - vv(I+1,J-1) &
    &               + vv(I,J+1) + vv(I+1,J+1) )
    ! ������ԕ�����K����
    vvX = vvXI * XIXM + vvET * ETXM
    vvY = vvXI * XIYM + vvET * ETYM
    ! ww �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    wwXI = - ww(I,J) + ww(I+1,J)
    wwET = 0.25 * ( - ww(I,J-1) - ww(I+1,J-1) &
    &               + ww(I,J+1) + ww(I+1,J+1) )
    ! ������ԕ�����K����
    wwX = wwXI * XIXM + wwET * ETXM
    wwY = wwXI * XIYM + wwET * ETYM
    ! uv �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    uvXI = - uv(I,J) + uv(I+1,J)
    uvET = 0.25 * ( - uv(I,J-1) - uv(I+1,J-1) &
    &               + uv(I,J+1) + uv(I+1,J+1) )
    ! ������ԕ�����K����
    uvX = uvXI * XIXM + uvET * ETXM
    uvY = uvXI * XIYM + uvET * ETYM
    ! epsilon �̈�K�����̌v�Z -----------------------------------------
    ! �v�Z��ԕ�����K����
    AEXI = - EPS(I,J) + EPS(I+1,J)
    AEET = 0.25 * ( - EPS(I,J-1) - EPS(I+1,J-1) &
    &               + EPS(I,J+1) + EPS(I+1,J+1) )
    ! ������ԕ�����K����
    AEX = AEXI * XIXM + AEET * ETXM
    AEY = AEXI * XIYM + AEET * ETYM
    ! ���S�x -----------------------------------------------------------
    nu = AMUM / RHOM
    ! �c�ݑ��x ---------------------------------------------------------
    SS  = (UX + VY) * TwoThird
    S11 = 2.0 * UX - SS
    S22 = 2.0 * VY - SS
    S12 = UY + VX
    ! U �̊g�U ---------------------------------------------------------
    R2M = nu * S11
    S2M = nu * S12
    R2T =-uuM
    S2T =-uvM
    ! V �̊g�U ---------------------------------------------------------
    R3M = nu * S12
    S3M = nu * S22
    R3T =-uvM
    S3T =-vvM
    ! �G�l���M�[�̊g�U -------------------------------------------------
    C_p  = GAMMA * RG / (GAMMA - 1.0)
    IF(EPSM .GT. ZERO) THEN
      AKAE = 0.5 * (uuM + vvM + wwM) / EPSM
    ELSE
      AKAE = 0.0
    ENDIF
    R4M = C_p * nu / PR * TX + nu * (S11 * UM + S12 * VM)
    S4M = C_p * nu / PR * TY + nu * (S12 * UM + S22 * VM)
    R4T = AKAE * C_se * C_p * (uuM * TX + uvM * TY) &
    &   + AKAE * C_s  * ( &
    &     uuM * (uuX + vvX + wwX) + uvM * (uuY + vvY + wwY) &
    &   ) &
    &   - (uuM * UM + uvM * VM)
    S4T = AKAE * C_se * C_p * (uvM * TX + vvM * TY) &
    &   + AKAE * C_s  * ( &
    &     uvM * (uuX + vvX + wwX) + vvM * (uuY + vvY + wwY) &
    &   ) &
    &   - (uvM * UM + vvM * VM)
    ! uu �̊g�U --------------------------------------------------------
    R5M = nu * uuX
    S5M = nu * uuY
    R5T = C_s * AKAE * (uuM * uuX + uvM * uuY)
    S5T = C_s * AKAE * (uvM * uuX + vvM * uuY)
    ! vv �̊g�U --------------------------------------------------------
    R6M = nu * vvX
    S6M = nu * vvY
    R6T = C_s * AKAE * (uuM * vvX + uvM * vvY)
    S6T = C_s * AKAE * (uvM * vvX + vvM * vvY)
    ! ww �̊g�U --------------------------------------------------------
    R7M = nu * wwX
    S7M = nu * wwY
    R7T = C_s * AKAE * (uuM * wwX + uvM * wwY)
    S7T = C_s * AKAE * (uvM * wwX + vvM * wwY)
    ! uv �̊g�U --------------------------------------------------------
    R8M = nu * uvX
    S8M = nu * uvY
    R8T = C_s * AKAE * (uuM * uvX + uvM * uvY)
    S8T = C_s * AKAE * (uvM * uvX + vvM * uvY)
    ! epsilon �̊g�U ---------------------------------------------------
    R9M = nu * AEX
    S9M = nu * AEY
    R9T = C_e * AKAE * (uuM * AEX + uvM * AEY)
    S9T = C_e * AKAE * (uvM * AEX + vvM * AEY)
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    RH(I,J,1) = 0.0
    RH(I,J,2) = QH1 * ((R2M + R2T) * XIXM + (S2M + S2T) * XIYM)
    RH(I,J,3) = QH1 * ((R3M + R3T) * XIXM + (S3M + S3T) * XIYM)
    RH(I,J,4) = QH1 * ((R4M + R4T) * XIXM + (S4M + S4T) * XIYM)
    RH(I,J,5) = QH1 * ((R5M + R5T) * XIXM + (S5M + S5T) * XIYM)
    RH(I,J,6) = QH1 * ((R6M + R6T) * XIXM + (S6M + S6T) * XIYM)
    RH(I,J,7) = QH1 * ((R7M + R7T) * XIXM + (S7M + S7T) * XIYM)
    RH(I,J,8) = QH1 * ((R8M + R8T) * XIXM + (S8M + S8T) * XIYM)
    RH(I,J,9) = QH1 * ((R9M + R9T) * XIXM + (S9M + S9T) * XIYM)
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFXI
!***********************************************************************
!**** �g�U���̌v�Z(eta���������p)                                   ****
!***********************************************************************
SUBROUTINE DIFFET
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: XIXM, XIYM, ETXM, ETYM, AJAM
  REAL    :: RHOM, UM, VM, uuM, vvM, wwM, uvM, EPSM, AMUM
  REAL    :: UXI, UET, UX, UY
  REAL    :: VXI, VET, VX, VY
  REAL    :: TXI, TET, TX, TY
  REAL    :: uuXI, uuET, uuX, uuY
  REAL    :: vvXI, vvET, vvX, vvY
  REAL    :: wwXI, wwET, wwX, wwY
  REAL    :: uvXI, uvET, uvX, uvY
  REAL    :: AEXI, AEET, AEX, AEY
  REAL    :: nu
  REAL    :: S11, S22, S12, SS
  REAL    :: C_p, AKAE
  REAL    :: R2M, S2M, R2T, S2T
  REAL    :: R3M, S3M, R3T, S3T
  REAL    :: R4M, S4M, R4T, S4T
  REAL    :: R5M, S5M, R5T, S5T
  REAL    :: R6M, S6M, R6T, S6T
  REAL    :: R7M, S7M, R7T, S7T
  REAL    :: R8M, S8M, R8T, S8T
  REAL    :: R9M, S9M, R9T, S9T
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, &
!$OMP& XIXM, XIYM, ETXM, ETYM, AJAM, &
!$OMP& RHOM, UM, VM, uuM, vvM, wwM, uvM, EPSM, AMUM, &
!$OMP& UXI, UET, UX, UY, VXI, VET, VX, VY, TXI, TET, TX, TY, &
!$OMP& uuXI, uuET, uuX, uuY, vvXI, vvET, vvX, vvY, &
!$OMP& wwXI, wwET, wwX, wwY, uvXI, uvET, uvX, uvY, &
!$OMP& AEXI, AEET, AEX, AEY, &
!$OMP& nu, S11, S22, S12, SS, C_p, AKAE, &
!$OMP& R2M, S2M, R2T, S2T, R3M, S3M, R3T, S3T, R4M, S4M, R4T, S4T, &
!$OMP& R5M, S5M, R5T, S5T, R6M, S6M, R6T, S6T, R7M, S7M, R7T, S7T, &
!$OMP& R8M, S8M, R8T, S8T, R9M, S9M, R9T, S9T, QH1 &
!$OMP& )
  DO J = JS    , JE - 1
  DO I = IS + 1, IE - 1
  IF((RHO(I,J) .GT. 0.0) .AND. (RHO(I,J+1) .GT. 0.0)) THEN
    ! ET�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J) + XIX(I,J+1))
    XIYM = 0.5 * (XIY(I,J) + XIY(I,J+1))
    ETXM = 0.5 * (ETX(I,J) + ETX(I,J+1))
    ETYM = 0.5 * (ETY(I,J) + ETY(I,J+1))
    AJAM = 0.5 * (AJA(I,J) + AJA(I,J+1))
    ! ������
    RHOM = 0.5 * (RHO(I,J) + RHO(I,J+1))
    UM   = 0.5 * (  U(I,J) +   U(I,J+1))
    VM   = 0.5 * (  V(I,J) +   V(I,J+1))
    uuM  = 0.5 * ( uu(I,J) +  uu(I,J+1))
    vvM  = 0.5 * ( vv(I,J) +  vv(I,J+1))
    wwM  = 0.5 * ( ww(I,J) +  ww(I,J+1))
    uvM  = 0.5 * ( uv(I,J) +  uv(I,J+1))
    EPSM = 0.5 * (EPS(I,J) + EPS(I,J+1))
    AMUM = 0.5 * (AMU(I,J) + AMU(I,J+1))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = 0.25 * (- U(I-1,J) - U(I-1,J+1) + U(I+1,J) + U(I+1,J+1))
    UET = - U(I,J) + U(I,J+1)
    VXI = 0.25 * (- V(I-1,J) - V(I-1,J+1) + V(I+1,J) + V(I+1,J+1))
    VET = - V(I,J) + V(I,J+1)
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM
    UY = UXI * XIYM + UET * ETYM
    VX = VXI * XIXM + VET * ETXM
    VY = VXI * XIYM + VET * ETYM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = 0.25 * (- T(I-1,J) - T(I-1,J+1) + T(I+1,J) + T(I+1,J+1))
    TET = - T(I,J) + T(I,J+1)
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM
    TY = TXI * XIYM + TET * ETYM
    ! uu �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    uuXI = 0.25 * (- uu(I-1,J) - uu(I-1,J+1) + uu(I+1,J) + uu(I+1,J+1))
    uuET = - uu(I,J) + uu(I,J+1)
    ! ������ԕ�����K����
    uuX = uuXI * XIXM + uuET * ETXM
    uuY = uuXI * XIYM + uuET * ETYM
    ! vv �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    vvXI = 0.25 * (- vv(I-1,J) - vv(I-1,J+1) + vv(I+1,J) + vv(I+1,J+1))
    vvET = - vv(I,J) + vv(I,J+1)
    ! ������ԕ�����K����
    vvX = vvXI * XIXM + vvET * ETXM
    vvY = vvXI * XIYM + vvET * ETYM
    ! ww �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    wwXI = 0.25 * (- ww(I-1,J) - ww(I-1,J+1) + ww(I+1,J) + ww(I+1,J+1))
    wwET = - ww(I,J) + ww(I,J+1)
    ! ������ԕ�����K����
    wwX = wwXI * XIXM + wwET * ETXM
    wwY = wwXI * XIYM + wwET * ETYM
    ! uv �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    uvXI = 0.25 * (- uv(I-1,J) - uv(I-1,J+1) + uv(I+1,J) + uv(I+1,J+1))
    uvET = - uv(I,J) + uv(I,J+1)
    ! ������ԕ�����K����
    uvX = uvXI * XIXM + uvET * ETXM
    uvY = uvXI * XIYM + uvET * ETYM
    ! epsilon �̈�K�����̌v�Z -----------------------------------------
    ! �v�Z��ԕ�����K����
    AEXI = 0.25 * ( - EPS(I-1,J) - EPS(I-1,J+1) &
    &               + EPS(I+1,J) + EPS(I+1,J+1) )
    AEET = - EPS(I,J) + EPS(I,J+1)
    ! ������ԕ�����K����
    AEX = AEXI * XIXM + AEET * ETXM
    AEY = AEXI * XIYM + AEET * ETYM
    ! ���S�x -----------------------------------------------------------
    nu = AMUM / RHOM
    ! �c�ݑ��x ---------------------------------------------------------
    SS  = (UX + VY) * TwoThird
    S11 = 2.0 * UX - SS
    S22 = 2.0 * VY - SS
    S12 = UY + VX
    ! U �̊g�U ---------------------------------------------------------
    R2M = nu * S11
    S2M = nu * S12
    R2T =-uuM
    S2T =-uvM
    ! V �̊g�U ---------------------------------------------------------
    R3M = nu * S12
    S3M = nu * S22
    R3T =-uvM
    S3T =-vvM
    ! �G�l���M�[�̊g�U -------------------------------------------------
    C_p  = GAMMA * RG / (GAMMA - 1.0)
    IF(EPSM .GT. ZERO) THEN
      AKAE = 0.5 * (uuM + vvM + wwM) / EPSM
    ELSE
      AKAE = 0.0
    ENDIF
    R4M = C_p * nu / PR * TX + nu * (S11 * UM + S12 * VM)
    S4M = C_p * nu / PR * TY + nu * (S12 * UM + S22 * VM)
    R4T = AKAE * C_se * C_p * (uuM * TX + uvM * TY) &
    &   + AKAE * C_s  * ( &
    &     uuM * (uuX + vvX + wwX) + uvM * (uuY + vvY + wwY) &
    &   ) &
    &   - (uuM * UM + uvM * VM)
    S4T = AKAE * C_se * C_p * (uvM * TX + vvM * TY) &
    &   + AKAE * C_s  * ( &
    &     uvM * (uuX + vvX + wwX) + vvM * (uuY + vvY + wwY) &
    &   ) &
    &   - (uvM * UM + vvM * VM)
    ! uu �̊g�U --------------------------------------------------------
    R5M = nu * uuX
    S5M = nu * uuY
    R5T = C_s * AKAE * (uuM * uuX + uvM * uuY)
    S5T = C_s * AKAE * (uvM * uuX + vvM * uuY)
    ! vv �̊g�U --------------------------------------------------------
    R6M = nu * vvX
    S6M = nu * vvY
    R6T = C_s * AKAE * (uuM * vvX + uvM * vvY)
    S6T = C_s * AKAE * (uvM * vvX + vvM * vvY)
    ! ww �̊g�U --------------------------------------------------------
    R7M = nu * wwX
    S7M = nu * wwY
    R7T = C_s * AKAE * (uuM * wwX + uvM * wwY)
    S7T = C_s * AKAE * (uvM * wwX + vvM * wwY)
    ! uv �̊g�U --------------------------------------------------------
    R8M = nu * uvX
    S8M = nu * uvY
    R8T = C_s * AKAE * (uuM * uvX + uvM * uvY)
    S8T = C_s * AKAE * (uvM * uvX + vvM * uvY)
    ! epsilon �̊g�U ---------------------------------------------------
    R9M = nu * AEX
    S9M = nu * AEY
    R9T = C_e * AKAE * (uuM * AEX + uvM * AEY)
    S9T = C_e * AKAE * (uvM * AEX + vvM * AEY)
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    SH(I,J,1) = 0.0
    SH(I,J,2) = QH1 * ((R2M + R2T) * ETXM + (S2M + S2T) * ETYM)
    SH(I,J,3) = QH1 * ((R3M + R3T) * ETXM + (S3M + S3T) * ETYM)
    SH(I,J,4) = QH1 * ((R4M + R4T) * ETXM + (S4M + S4T) * ETYM)
    SH(I,J,5) = QH1 * ((R5M + R5T) * ETXM + (S5M + S5T) * ETYM)
    SH(I,J,6) = QH1 * ((R6M + R6T) * ETXM + (S6M + S6T) * ETYM)
    SH(I,J,7) = QH1 * ((R7M + R7T) * ETXM + (S7M + S7T) * ETYM)
    SH(I,J,8) = QH1 * ((R8M + R8T) * ETXM + (S8M + S8T) * ETYM)
    SH(I,J,9) = QH1 * ((R9M + R9T) * ETXM + (S9M + S9T) * ETYM)
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFET
! ��`�I�� *************************************************************
END SUBROUTINE Turbulence2DRSMLS
!***********************************************************************
!**** �������f�� : RANS, RSM Launder-Shima Model (1989, 1993)       ****
!****              �����M�`�B�ɂ�Vandromme�̃��f�����g�p            ****
!**** �v�Z�Ώ� : �P��, �O����, ���k��                               ****
!**** �v�Z�X�L�[�� : �񎟐��x���S����(�X�^�K�[�h�i�q��̓_���g�p)   ****
!***********************************************************************
SUBROUTINE Turbulence3DRSMLS( &
&            PELIM, RG, GAMMA, PR, &
&            IS, IE, JS, JE, KS, KE, LS, LE, &
&            XIX, XIY, XIZ, ETX, ETY, ETZ, ZEX, ZEY, ZEZ, AJA, &
&            RHO, U, V, W, T, uu, vv, ww, uv, vw, wu, EPS, AMU, &
&            n1, n2, n3, d, &
&            AMUT, DQD, DQP &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, PARAMETER :: C_se = 0.313
  REAL, PARAMETER :: C_s = 0.22, C_e = 0.18
  REAL, PARAMETER :: C_l = 2.5
  REAL, PARAMETER :: C_e1 = 1.45, C_e2 = 1.9
  REAL, PARAMETER :: aiimin = - 0.66666667, aiimax = 1.3333333
  REAL, PARAMETER :: TwoThird = 0.66666667
  REAL, PARAMETER :: ZERO = 1.0E-20
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: PELIM
  REAL,    INTENT(IN)  :: RG, GAMMA, PR
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE, KS, KE
  INTEGER, INTENT(IN)  :: LS, LE
  REAL,    INTENT(IN)  :: XIX(IS:IE, JS:JE, KS:KE), &
  &                       XIY(IS:IE, JS:JE, KS:KE), &
  &                       XIZ(IS:IE, JS:JE, KS:KE), &
  &                       ETX(IS:IE, JS:JE, KS:KE), &
  &                       ETY(IS:IE, JS:JE, KS:KE), &
  &                       ETZ(IS:IE, JS:JE, KS:KE), &
  &                       ZEX(IS:IE, JS:JE, KS:KE), &
  &                       ZEY(IS:IE, JS:JE, KS:KE), &
  &                       ZEZ(IS:IE, JS:JE, KS:KE), &
  &                       AJA(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)  :: RHO(IS:IE, JS:JE, KS:KE), &
  &                       U(IS:IE, JS:JE, KS:KE), &
  &                       V(IS:IE, JS:JE, KS:KE), &
  &                       W(IS:IE, JS:JE, KS:KE), &
  &                       T(IS:IE, JS:JE, KS:KE), &
  &                       uu(IS:IE, JS:JE, KS:KE), &
  &                       vv(IS:IE, JS:JE, KS:KE), &
  &                       ww(IS:IE, JS:JE, KS:KE), &
  &                       uv(IS:IE, JS:JE, KS:KE), &
  &                       vw(IS:IE, JS:JE, KS:KE), &
  &                       wu(IS:IE, JS:JE, KS:KE), &
  &                       EPS(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)  :: AMU(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)  :: n1(IS:IE, JS:JE, KS:KE), &
  &                       n2(IS:IE, JS:JE, KS:KE), &
  &                       n3(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)  :: d(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(OUT) :: AMUT(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(OUT) :: DQD(IS:IE, JS:JE, KS:KE, LS:LE)
  REAL,    INTENT(OUT) :: DQP(IS:IE, JS:JE, KS:KE, LS:LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, ALLOCATABLE :: RH(:, :, :, :), SH(:, :, :, :), TH(:, :, :, :)
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 12) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �������m�� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ALLOCATE(RH(IS: IE, JS: JE, KS: KE, LS: LE))
  ALLOCATE(SH(IS: IE, JS: JE, KS: KE, LS: LE))
  ALLOCATE(TH(IS: IE, JS: JE, KS: KE, LS: LE))
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  AMUT = 0.0
  DQD  = 0.0
  DQP  = 0.0
  ! �����葱���̌Ăяo�� +++++++++++++++++++++++++++++++++++++++++++++++
  CALL NonDiffTerm
  CALL DiffTerm
  ! �����I�� ***********************************************************
  RETURN
! �����葱�� ***********************************************************
CONTAINS
!***********************************************************************
!**** ��g�U���̌v�Z                                                ****
!***********************************************************************
SUBROUTINE NonDiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: TMP, TMP1, TMPw, TMPw1, TMPw2, TMPw1km, TMPw2km
  REAL    :: UXI, VXI, WXI, UET, VET, WET, UZE, VZE, WZE
  REAL    :: UX, VX, WX, UY, VY, WY, UZ, VZ, WZ
  REAL    :: KRXI, KRET, KRZE, KRX, KRY, KRZ
  REAL    :: P11, P22, P33, P12, P23, P31, P_k
  REAL    :: eps11, eps22, eps33, eps12, eps23, eps31, e_k
  REAL    :: C_1, C_2, C_w1, C_w2
  REAL    :: psi1, psi2
  REAL    :: A, A2, A3
  REAL    :: a11, a22, a33, a12, a23, a31
  REAL    :: phi1_11, phi1_22, phi1_33, phi1_12, phi1_23, phi1_31
  REAL    :: phi2_11, phi2_22, phi2_33, phi2_12, phi2_23, phi2_31
  REAL    :: phiw1_11, phiw1_22, phiw1_33, phiw1_12, phiw1_23, phiw1_31
  REAL    :: phiw2_11, phiw2_22, phiw2_33, phiw2_12, phiw2_23, phiw2_31
  REAL    :: phi11, phi22, phi33, phi12, phi23, phi31
  REAL    :: AK, EPST, SS2, AEAK, nu, Rt
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& TMP, TMP1, TMPw, TMPw1, TMPw2, TMPw1km, TMPw2km, &
!$OMP& UXI, VXI, WXI, UET, VET, WET, UZE, VZE, WZE, &
!$OMP& UX, VX, WX, UY, VY, WY, UZ, VZ, WZ, &
!$OMP& KRXI, KRET, KRZE, KRX, KRY, KRZ, &
!$OMP& P11, P22, P33, P12, P23, P31, P_k, &
!$OMP& eps11, eps22, eps33, eps12, eps23, eps31, e_k, &
!$OMP& C_1, C_2, C_w1, C_w2, psi1, psi2, A, A2, A3, &
!$OMP& a11, a22, a33, a12, a23, a31, &
!$OMP& phi1_11, phi1_22, phi1_33, phi1_12, phi1_23, phi1_31, &
!$OMP& phi2_11, phi2_22, phi2_33, phi2_12, phi2_23, phi2_31, &
!$OMP& phiw1_11, phiw1_22, phiw1_33, phiw1_12, phiw1_23, phiw1_31, &
!$OMP& phiw2_11, phiw2_22, phiw2_33, phiw2_12, phiw2_23, phiw2_31, &
!$OMP& phi11, phi22, phi33, phi12, phi23, phi31, &
!$OMP& AK, EPST, SS2, AEAK, nu, Rt, QH1 &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF(RHO(I,J,K) .GT. 0.0) THEN
    ! �����G�l���M�[ ---------------------------------------------------
    AK = 0.5 * (uu(I,J,K) + vv(I,J,K) + ww(I,J,K))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = 0.5 * (U(I+1,J,K) - U(I-1,J,K))
    UET = 0.5 * (U(I,J+1,K) - U(I,J-1,K))
    UZE = 0.5 * (U(I,J,K+1) - U(I,J,K-1))
    VXI = 0.5 * (V(I+1,J,K) - V(I-1,J,K))
    VET = 0.5 * (V(I,J+1,K) - V(I,J-1,K))
    VZE = 0.5 * (V(I,J,K+1) - V(I,J,K-1))
    WXI = 0.5 * (W(I+1,J,K) - W(I-1,J,K))
    WET = 0.5 * (W(I,J+1,K) - W(I,J-1,K))
    WZE = 0.5 * (W(I,J,K+1) - W(I,J,K-1))
    ! ������ԕ�����K����
    UX = UXI * XIX(I,J,K) + UET * ETX(I,J,K) + UZE * ZEX(I,J,K)
    UY = UXI * XIY(I,J,K) + UET * ETY(I,J,K) + UZE * ZEY(I,J,K)
    UZ = UXI * XIZ(I,J,K) + UET * ETZ(I,J,K) + UZE * ZEZ(I,J,K)
    VX = VXI * XIX(I,J,K) + VET * ETX(I,J,K) + VZE * ZEX(I,J,K)
    VY = VXI * XIY(I,J,K) + VET * ETY(I,J,K) + VZE * ZEY(I,J,K)
    VZ = VXI * XIZ(I,J,K) + VET * ETZ(I,J,K) + VZE * ZEZ(I,J,K)
    WX = WXI * XIX(I,J,K) + WET * ETX(I,J,K) + WZE * ZEX(I,J,K)
    WY = WXI * XIY(I,J,K) + WET * ETY(I,J,K) + WZE * ZEY(I,J,K)
    WZ = WXI * XIZ(I,J,K) + WET * ETZ(I,J,K) + WZE * ZEZ(I,J,K)
    ! �������ƎU�퍀 ---------------------------------------------------
    P11 = - 2.0 * (uu(I,J,K) * UX + uv(I,J,K) * UY + wu(I,J,K) * UZ)
    P22 = - 2.0 * (uv(I,J,K) * VX + vv(I,J,K) * VY + vw(I,J,K) * VZ)
    P33 = - 2.0 * (wu(I,J,K) * WX + vw(I,J,K) * WY + ww(I,J,K) * WZ)
    P12 = - (uv(I,J,K) * UX + uu(I,J,K) * VX) &
    &     - (vv(I,J,K) * UY + uv(I,J,K) * VY) &
    &     - (vw(I,J,K) * UZ + wu(I,J,K) * VZ)
    P23 = - (wu(I,J,K) * VX + uv(I,J,K) * WX) &
    &     - (vw(I,J,K) * VY + vv(I,J,K) * WY) &
    &     - (ww(I,J,K) * VZ + vw(I,J,K) * WZ)
    P31 = - (uu(I,J,K) * WX + wu(I,J,K) * UX) &
    &     - (uv(I,J,K) * WY + vw(I,J,K) * UY) &
    &     - (wu(I,J,K) * WZ + ww(I,J,K) * UZ)
    P_k = 0.5 * (P11 + P22 + P33)
    e_k = EPS(I,J,K)
    ! �Ǐ����t����(�����ƎU��̃o�����X)�ɂ�郊�~�b�^�[
    IF(PELIM .GT. 0.0) THEN
      TMP = TwoThird * e_k / PELIM
      P11 = MIN(TMP, MAX(-TMP, P11))
      P22 = MIN(TMP, MAX(-TMP, P22))
      P33 = MIN(TMP, MAX(-TMP, P33))
      P_k = 0.5 * (P11 + P22 + P33)
    ENDIF
    TMP   = TwoThird * e_k
    eps11 = TMP
    eps22 = TMP
    eps33 = TMP
    eps12 = 0.0
    eps23 = 0.0
    eps31 = 0.0
    ! �񓙕����C�m���Y���̓e���\�� a_ij --------------------------------
    IF(AK .GT. ZERO) THEN
      a11 = uu(I,J,K) / AK - TwoThird
      a22 = vv(I,J,K) / AK - TwoThird
      a33 = ww(I,J,K) / AK - TwoThird
      a12 = uv(I,J,K) / AK
      a23 = vw(I,J,K) / AK
      a31 = wu(I,J,K) / AK
      a11 = MIN(aiimax, MAX(aiimin, a11))
      a22 = MIN(aiimax, MAX(aiimin, a22))
      a33 = MIN(aiimax, MAX(aiimin, a33))
      a12 = MIN(1.0, MAX(-1.0, a12))
      a23 = MIN(1.0, MAX(-1.0, a23))
      a31 = MIN(1.0, MAX(-1.0, a31))
    ELSE
      a11 = aiimin
      a22 = aiimin
      a33 = aiimin
      a12 = 0.0
      a23 = 0.0
      a31 = 0.0
    ENDIF
    ! A : Lumley's stress flatness factor ------------------------------
    A2 = a11 * a11 + a22 * a22 + a33 * a33 &
    &  + 2.0 * (a12 * a12 + a23 * a23 + a31 * a31)
    A2 = MIN(8.0 / 3.0, MAX(0.0, A2))
    A3 = a11 * (a11 * a11 + a12 * a12 + a31 * a31) &
    &  + a22 * (a12 * a12 + a22 * a22 + a23 * a23) &
    &  + a33 * (a31 * a31 + a23 * a23 + a33 * a33) &
    &  + 2.0 * a12 * (a11 * a12 + a12 * a22 + a31 * a23) &
    &  + 2.0 * a23 * (a12 * a31 + a22 * a23 + a23 * a33) &
    &  + 2.0 * a31 * (a31 * a11 + a23 * a12 + a33 * a31)
    A3 = MIN(A2, MAX(A2 - 8.0 / 9.0, A3))
    A  = 1.0 - 9.0 / 8.0 * (A2 - A3)
    A  = MIN(1.0, MAX(0.0, A))
    ! ����̎U�헦�Ȃ� -------------------------------------------------
    KRXI   = 0.5 * ( &
    &        - SQRT(0.5 * (uu(I-1,J,K) + vv(I-1,J,K) + ww(I-1,J,K))) &
    &        + SQRT(0.5 * (uu(I+1,J,K) + vv(I+1,J,K) + ww(I+1,J,K))) &
    &      )
    KRET   = 0.5 * ( &
    &        - SQRT(0.5 * (uu(I,J-1,K) + vv(I,J-1,K) + ww(I,J-1,K))) &
    &        + SQRT(0.5 * (uu(I,J+1,K) + vv(I,J+1,K) + ww(I,J+1,K))) &
    &      )
    KRZE   = 0.5 * ( &
    &        - SQRT(0.5 * (uu(I,J,K-1) + vv(I,J,K-1) + ww(I,J,K-1))) &
    &        + SQRT(0.5 * (uu(I,J,K+1) + vv(I,J,K+1) + ww(I,J,K+1))) &
    &      )
    KRX    = KRXI * XIX(I,J,K) + KRET * ETX(I,J,K) + KRZE * ZEX(I,J,K)
    KRY    = KRXI * XIY(I,J,K) + KRET * ETY(I,J,K) + KRZE * ZEY(I,J,K)
    KRZ    = KRXI * XIZ(I,J,K) + KRET * ETZ(I,J,K) + KRZE * ZEZ(I,J,K)
    nu     = AMU(I,J,K) / RHO(I,J,K)
    EPST   = e_k - 2.0 * nu * (KRX**2 + KRY**2 + KRZ**2)
    EPST   = MAX(0.0, EPST)
    IF(e_k .GT. ZERO) THEN
      Rt = AK**2 / (nu * e_k)
    ELSE
      Rt = 0.0
    ENDIF
    ! ���f���֐� -------------------------------------------------------
    C_1  = 1.0 + 2.58 * A * A2**0.25 * (1.0 - EXP(-(0.0067 * Rt)**2))
    C_2  = 0.75 * SQRT(A)
    C_w1 =-TwoThird * C_1 + 1.67
    IF(C_2 .GT. 0.25) THEN
      C_w2 = (TwoThird * (C_2 - 1.0) + 0.5) / C_2
    ELSE
      C_w2 = 0.0
    ENDIF
    IF(e_k .GT. ZERO) THEN
      psi1 = 1.5 * A * (P_k / e_k - 1.0)
    ELSE
      psi1 = 0.0
    ENDIF
    psi2 = 0.35 * (1.0 - 0.3 * A2) * EXP(-SQRT(0.002 * Rt))
    SS2  = 2.0 * (UX**2 + VY**2 + WZ**2) &
    &    + (UY + VX)**2 + (VZ + WY)**2 + (WX + UZ)**2 &
    &    - TwoThird * (UX + VY + WZ)**2
    AEAK = MIN(MAX(SQRT(SS2), SQRT(e_k / nu)), e_k / MAX(ZERO, AK))
    ! �ĕ��z�� ---------------------------------------------------------
    TMP1    = - C_1 * AEAK
    phi1_11 = TMP1 * (uu(I,J,K) - TwoThird * AK)
    phi1_22 = TMP1 * (vv(I,J,K) - TwoThird * AK)
    phi1_33 = TMP1 * (ww(I,J,K) - TwoThird * AK)
    phi1_12 = TMP1 * uv(I,J,K)
    phi1_23 = TMP1 * vw(I,J,K)
    phi1_31 = TMP1 * wu(I,J,K)
    phi2_11 = - C_2 * (P11 - TwoThird * P_k)
    phi2_22 = - C_2 * (P22 - TwoThird * P_k)
    phi2_33 = - C_2 * (P33 - TwoThird * P_k)
    phi2_12 = - C_2 * P12
    phi2_23 = - C_2 * P23
    phi2_31 = - C_2 * P31
    IF(C_l * e_k * d(I,J,K) .GT. ZERO) THEN
      TMPw = AK**1.5 / (C_l * e_k * d(I,J,K))
      ! �ǖʔ��ˍ��̃_���s���O�֐��̐���
      ! TMPw = MIN(1.0, MAX(0.0, TMPw))
    ELSE
      TMPw = 0.0
    ENDIF
    TMPw1   = C_w1 * TMPw * AEAK
    TMPw2   = C_w2 * TMPw
    TMPw1km = uu(I,J,K) * n1(I,J,K) * n1(I,J,K) &
    &       + vv(I,J,K) * n2(I,J,K) * n2(I,J,K) &
    &       + ww(I,J,K) * n3(I,J,K) * n3(I,J,K) &
    &       + 2.0 * ( &
    &         uv(I,J,K) * n1(I,J,K) * n2(I,J,K) &
    &       + vw(I,J,K) * n2(I,J,K) * n3(I,J,K) &
    &       + wu(I,J,K) * n3(I,J,K) * n1(I,J,K) &
    &       )
    TMPw2km = phi2_11 * n1(I,J,K) * n1(I,J,K) &
    &       + phi2_22 * n2(I,J,K) * n2(I,J,K) &
    &       + phi2_33 * n3(I,J,K) * n3(I,J,K) &
    &       + 2.0 * ( &
    &         phi2_12 * n1(I,J,K) * n2(I,J,K) &
    &       + phi2_23 * n2(I,J,K) * n3(I,J,K) &
    &       + phi2_31 * n3(I,J,K) * n1(I,J,K) &
    &       )
    phiw1_11 = TMPw1 * (TMPw1km - 3.0 * n1(I,J,K) &
    &          * ( uu(I,J,K) * n1(I,J,K) &
    &            + uv(I,J,K) * n2(I,J,K) &
    &            + wu(I,J,K) * n3(I,J,K) ) &
    &        )
    phiw1_22 = TMPw1 * (TMPw1km - 3.0 * n2(I,J,K) &
    &          * ( uv(I,J,K) * n1(I,J,K) &
    &            + vv(I,J,K) * n2(I,J,K) &
    &            + vw(I,J,K) * n3(I,J,K) ) &
    &        )
    phiw1_33 = TMPw1 * (TMPw1km - 3.0 * n3(I,J,K) &
    &          * ( wu(I,J,K) * n1(I,J,K) &
    &            + vw(I,J,K) * n2(I,J,K) &
    &            + ww(I,J,K) * n3(I,J,K) ) &
    &        )
    phiw1_12 = - 1.5 * TMPw1 * ( &
    &          n1(I,J,K) * ( uv(I,J,K) * n1(I,J,K) &
    &                      + vv(I,J,K) * n2(I,J,K) &
    &                      + vw(I,J,K) * n3(I,J,K) ) &
    &        + n2(I,J,K) * ( uu(I,J,K) * n1(I,J,K) &
    &                      + uv(I,J,K) * n2(I,J,K) &
    &                      + wu(I,J,K) * n3(I,J,K) ) &
    &        )
    phiw1_23 = - 1.5 * TMPw1 * ( &
    &          n2(I,J,K) * ( wu(I,J,K) * n1(I,J,K) &
    &                      + vw(I,J,K) * n2(I,J,K) &
    &                      + ww(I,J,K) * n3(I,J,K) ) &
    &        + n3(I,J,K) * ( uv(I,J,K) * n1(I,J,K) &
    &                      + vv(I,J,K) * n2(I,J,K) &
    &                      + vw(I,J,K) * n3(I,J,K) ) &
    &        )
    phiw1_31 = - 1.5 * TMPw1 * ( &
    &          n3(I,J,K) * ( uu(I,J,K) * n1(I,J,K) &
    &                      + uv(I,J,K) * n2(I,J,K) &
    &                      + wu(I,J,K) * n3(I,J,K) ) &
    &        + n1(I,J,K) * ( wu(I,J,K) * n1(I,J,K) &
    &                      + vw(I,J,K) * n2(I,J,K) &
    &                      + ww(I,J,K) * n3(I,J,K) ) &
    &        )
    phiw2_11 = TMPw2 * (TMPw2km - 3.0 * n1(I,J,K) &
    &          * ( phi2_11 * n1(I,J,K) &
    &            + phi2_12 * n2(I,J,K) &
    &            + phi2_31 * n3(I,J,K) ) &
    &        )
    phiw2_22 = TMPw2 * (TMPw2km - 3.0 * n2(I,J,K) &
    &          * ( phi2_12 * n1(I,J,K) &
    &            + phi2_22 * n2(I,J,K) &
    &            + phi2_23 * n3(I,J,K) ) &
    &        )
    phiw2_33 = TMPw2 * (TMPw2km - 3.0 * n3(I,J,K) &
    &          * ( phi2_31 * n1(I,J,K) &
    &            + phi2_23 * n2(I,J,K) &
    &            + phi2_33 * n3(I,J,K) ) &
    &        )
    phiw2_12 = - 1.5 * TMPw2 * ( &
    &          n1(I,J,K) * ( phi2_12 * n1(I,J,K) &
    &                      + phi2_22 * n2(I,J,K) &
    &                      + phi2_23 * n3(I,J,K) ) &
    &        + n2(I,J,K) * ( phi2_11 * n1(I,J,K) &
    &                      + phi2_12 * n2(I,J,K) &
    &                      + phi2_31 * n3(I,J,K) ) &
    &        )
    phiw2_23 = - 1.5 * TMPw2 * ( &
    &          n2(I,J,K) * ( phi2_31 * n1(I,J,K) &
    &                      + phi2_23 * n2(I,J,K) &
    &                      + phi2_33 * n3(I,J,K) ) &
    &        + n3(I,J,K) * ( phi2_12 * n1(I,J,K) &
    &                      + phi2_22 * n2(I,J,K) &
    &                      + phi2_23 * n3(I,J,K) ) &
    &        )
    phiw2_31 = - 1.5 * TMPw2 * ( &
    &          n3(I,J,K) * ( phi2_11 * n1(I,J,K) &
    &                      + phi2_12 * n2(I,J,K) &
    &                      + phi2_31 * n3(I,J,K) ) &
    &        + n1(I,J,K) * ( phi2_31 * n1(I,J,K) &
    &                      + phi2_23 * n2(I,J,K) &
    &                      + phi2_33 * n3(I,J,K) ) &
    &        )
    phi11 = phi1_11 + phi2_11 + phiw1_11 + phiw2_11
    phi22 = phi1_22 + phi2_22 + phiw1_22 + phiw2_22
    phi33 = phi1_33 + phi2_33 + phiw1_33 + phiw2_33
    phi12 = phi1_12 + phi2_12 + phiw1_12 + phiw2_12
    phi23 = phi1_23 + phi2_23 + phiw1_23 + phiw2_23
    phi31 = phi1_31 + phi2_31 + phiw1_31 + phiw2_31
    ! �Q�S���W���̌v�Z -------------------------------------------------
    IF(e_k .GT. ZERO) THEN
      AMUT(I,J,K) = 0.09 * AK**2 / e_k * RHO(I,J,K)
    ENDIF
    ! �������A���͍ĕ��z���A�U�퍀�̘a ---------------------------------
    QH1 = RHO(I,J,K) / AJA(I,J,K)
    DQP(I,J,K, 6) = QH1 * (P11 - eps11 + phi11)
    DQP(I,J,K, 7) = QH1 * (P22 - eps22 + phi22)
    DQP(I,J,K, 8) = QH1 * (P33 - eps33 + phi33)
    DQP(I,J,K, 9) = QH1 * (P12 - eps12 + phi12)
    DQP(I,J,K,10) = QH1 * (P23 - eps23 + phi23)
    DQP(I,J,K,11) = QH1 * (P31 - eps31 + phi31)
    DQP(I,J,K,12) = QH1 * AEAK * ( &
    &               (C_e1 + psi1 + psi2) * P_k - C_e2 * EPST &
    &             )
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE NonDiffTerm
!***********************************************************************
!**** �g�U���̌v�Z                                                  ****
!***********************************************************************
SUBROUTINE DiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K, L
  ! �����J�n ***********************************************************
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  RH = 0.0
  SH = 0.0
  TH = 0.0
  ! �g�U���̗v�f���v�Z +++++++++++++++++++++++++++++++++++++++++++++++++
  CALL DIFFXI
  CALL DIFFET
  CALL DIFFZE
  ! �g�U���̍��� +++++++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE(I, J, K, L)
  DO L = LS, LE
  !$OMP DO
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( (RHO(I,J,K-1) .GT. 0.0) .AND. (RHO(I,J-1,K) .GT. 0.0) .AND. &
  &   (RHO(I-1,J,K) .GT. 0.0) .AND. (RHO(I,J,K)   .GT. 0.0) .AND. &
  &   (RHO(I+1,J,K) .GT. 0.0) .AND. (RHO(I,J+1,K) .GT. 0.0) .AND. &
  &   (RHO(I,J,K+1) .GT. 0.0) &
  & ) THEN
    DQD(I,J,K,L) = (-RH(I-1,J  ,K  ,L) + RH(I,J,K,L) ) &
    &            + (-SH(I  ,J-1,K  ,L) + SH(I,J,K,L) ) &
    &            + (-TH(I  ,J  ,K-1,L) + TH(I,J,K,L) )
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END DO
  ENDDO
  !$OMP END PARALLEL
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DiffTerm
!***********************************************************************
!**** �g�U���̌v�Z(xi���������p)                                    ****
!***********************************************************************
SUBROUTINE DIFFXI
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM
  REAL    :: RHOM, UM, VM, WM, uuM, vvM, wwM, uvM, vwM, wuM, EPSM, AMUM
  REAL    :: UXI, UET, UZE, UX, UY, UZ
  REAL    :: VXI, VET, VZE, VX, VY, VZ
  REAL    :: WXI, WET, WZE, WX, WY, WZ
  REAL    :: TXI, TET, TZE, TX, TY, TZ
  REAL    :: uuXI, uuET, uuZE, uuX, uuY, uuZ
  REAL    :: vvXI, vvET, vvZE, vvX, vvY, vvZ
  REAL    :: wwXI, wwET, wwZE, wwX, wwY, wwZ
  REAL    :: uvXI, uvET, uvZE, uvX, uvY, uvZ
  REAL    :: vwXI, vwET, vwZE, vwX, vwY, vwZ
  REAL    :: wuXI, wuET, wuZE, wuX, wuY, wuZ
  REAL    :: AEXI, AEET, AEZE, AEX, AEY, AEZ
  REAL    :: nu
  REAL    :: S11, S22, S33, S12, S23, S31, SS
  REAL    :: C_p, AKAE
  REAL    :: R02M, S02M, T02M, R02T, S02T, T02T
  REAL    :: R03M, S03M, T03M, R03T, S03T, T03T
  REAL    :: R04M, S04M, T04M, R04T, S04T, T04T
  REAL    :: R05M, S05M, T05M, R05T, S05T, T05T
  REAL    :: R06M, S06M, T06M, R06T, S06T, T06T
  REAL    :: R07M, S07M, T07M, R07T, S07T, T07T
  REAL    :: R08M, S08M, T08M, R08T, S08T, T08T
  REAL    :: R09M, S09M, T09M, R09T, S09T, T09T
  REAL    :: R10M, S10M, T10M, R10T, S10T, T10T
  REAL    :: R11M, S11M, T11M, R11T, S11T, T11T
  REAL    :: R12M, S12M, T12M, R12T, S12T, T12T
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM, &
!$OMP& RHOM, UM, VM, WM, uuM, vvM, wwM, uvM, vwM, wuM, EPSM, AMUM, &
!$OMP& UXI, UET, UZE, UX, UY, UZ, &
!$OMP& VXI, VET, VZE, VX, VY, VZ, &
!$OMP& WXI, WET, WZE, WX, WY, WZ, &
!$OMP& TXI, TET, TZE, TX, TY, TZ, &
!$OMP& uuXI, uuET, uuZE, uuX, uuY, uuZ, &
!$OMP& vvXI, vvET, vvZE, vvX, vvY, vvZ, &
!$OMP& wwXI, wwET, wwZE, wwX, wwY, wwZ, &
!$OMP& uvXI, uvET, uvZE, uvX, uvY, uvZ, &
!$OMP& vwXI, vwET, vwZE, vwX, vwY, vwZ, &
!$OMP& wuXI, wuET, wuZE, wuX, wuY, wuZ, &
!$OMP& AEXI, AEET, AEZE, AEX, AEY, AEZ, &
!$OMP& nu, S11, S22, S33, S12, S23, S31, SS, C_p, AKAE, &
!$OMP& R02M, S02M, T02M, R02T, S02T, T02T, &
!$OMP& R03M, S03M, T03M, R03T, S03T, T03T, &
!$OMP& R04M, S04M, T04M, R04T, S04T, T04T, &
!$OMP& R05M, S05M, T05M, R05T, S05T, T05T, &
!$OMP& R06M, S06M, T06M, R06T, S06T, T06T, &
!$OMP& R07M, S07M, T07M, R07T, S07T, T07T, &
!$OMP& R08M, S08M, T08M, R08T, S08T, T08T, &
!$OMP& R09M, S09M, T09M, R09T, S09T, T09T, &
!$OMP& R10M, S10M, T10M, R10T, S10T, T10T, &
!$OMP& R11M, S11M, T11M, R11T, S11T, T11T, &
!$OMP& R12M, S12M, T12M, R12T, S12T, T12T, &
!$OMP& QH1 &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS    , IE - 1
  IF((RHO(I,J,K) .GT. 0.0) .AND. (RHO(I+1,J,K) .GT. 0.0)) THEN
    ! XI�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J,K) + XIX(I+1,J,K))
    XIYM = 0.5 * (XIY(I,J,K) + XIY(I+1,J,K))
    XIZM = 0.5 * (XIZ(I,J,K) + XIZ(I+1,J,K))
    ETXM = 0.5 * (ETX(I,J,K) + ETX(I+1,J,K))
    ETYM = 0.5 * (ETY(I,J,K) + ETY(I+1,J,K))
    ETZM = 0.5 * (ETZ(I,J,K) + ETZ(I+1,J,K))
    ZEXM = 0.5 * (ZEX(I,J,K) + ZEX(I+1,J,K))
    ZEYM = 0.5 * (ZEY(I,J,K) + ZEY(I+1,J,K))
    ZEZM = 0.5 * (ZEZ(I,J,K) + ZEZ(I+1,J,K))
    AJAM = 0.5 * (AJA(I,J,K) + AJA(I+1,J,K))
    ! ������
    RHOM = 0.5 * (RHO(I,J,K) + RHO(I+1,J,K))
    UM   = 0.5 * (  U(I,J,K) +   U(I+1,J,K))
    VM   = 0.5 * (  V(I,J,K) +   V(I+1,J,K))
    WM   = 0.5 * (  W(I,J,K) +   W(I+1,J,K))
    uuM  = 0.5 * ( uu(I,J,K) +  uu(I+1,J,K))
    vvM  = 0.5 * ( vv(I,J,K) +  vv(I+1,J,K))
    wwM  = 0.5 * ( ww(I,J,K) +  ww(I+1,J,K))
    uvM  = 0.5 * ( uv(I,J,K) +  uv(I+1,J,K))
    vwM  = 0.5 * ( vw(I,J,K) +  vw(I+1,J,K))
    wuM  = 0.5 * ( wu(I,J,K) +  wu(I+1,J,K))
    EPSM = 0.5 * (EPS(I,J,K) + EPS(I+1,J,K))
    AMUM = 0.5 * (AMU(I,J,K) + AMU(I+1,J,K))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = - U(I,J,K) + U(I+1,J,K)
    UET = 0.25 * ( - U(I,J-1,K) - U(I+1,J-1,K) &
    &              + U(I,J+1,K) + U(I+1,J+1,K) )
    UZE = 0.25 * ( - U(I,J,K-1) - U(I+1,J,K-1) &
    &              + U(I,J,K+1) + U(I+1,J,K+1) )
    VXI = - V(I,J,K) + V(I+1,J,K)
    VET = 0.25 * ( - V(I,J-1,K) - V(I+1,J-1,K) &
    &              + V(I,J+1,K) + V(I+1,J+1,K) )
    VZE = 0.25 * ( - V(I,J,K-1) - V(I+1,J,K-1) &
    &              + V(I,J,K+1) + V(I+1,J,K+1) )
    WXI = - W(I,J,K) + W(I+1,J,K)
    WET = 0.25 * ( - W(I,J-1,K) - W(I+1,J-1,K) &
    &              + W(I,J+1,K) + W(I+1,J+1,K) )
    WZE = 0.25 * ( - W(I,J,K-1) - W(I+1,J,K-1) &
    &              + W(I,J,K+1) + W(I+1,J,K+1) )
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM + UZE * ZEXM
    UY = UXI * XIYM + UET * ETYM + UZE * ZEYM
    UZ = UXI * XIZM + UET * ETZM + UZE * ZEZM
    VX = VXI * XIXM + VET * ETXM + VZE * ZEXM
    VY = VXI * XIYM + VET * ETYM + VZE * ZEYM
    VZ = VXI * XIZM + VET * ETZM + VZE * ZEZM
    WX = WXI * XIXM + WET * ETXM + WZE * ZEXM
    WY = WXI * XIYM + WET * ETYM + WZE * ZEYM
    WZ = WXI * XIZM + WET * ETZM + WZE * ZEZM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = - T(I,J,K) + T(I+1,J,K)
    TET = 0.25 * ( - T(I,J-1,K) - T(I+1,J-1,K) &
    &              + T(I,J+1,K) + T(I+1,J+1,K) )
    TZE = 0.25 * ( - T(I,J,K-1) - T(I+1,J,K-1) &
    &              + T(I,J,K+1) + T(I+1,J,K+1) )
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM + TZE * ZEXM
    TY = TXI * XIYM + TET * ETYM + TZE * ZEYM
    TZ = TXI * XIZM + TET * ETZM + TZE * ZEZM
    ! uu �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    uuXI = - uu(I,J,K) + uu(I+1,J,K)
    uuET = 0.25 * ( - uu(I,J-1,K) - uu(I+1,J-1,K) &
    &               + uu(I,J+1,K) + uu(I+1,J+1,K) )
    uuZE = 0.25 * ( - uu(I,J,K-1) - uu(I+1,J,K-1) &
    &               + uu(I,J,K+1) + uu(I+1,J,K+1) )
    ! ������ԕ�����K����
    uuX = uuXI * XIXM + uuET * ETXM + uuZE * ZEXM
    uuY = uuXI * XIYM + uuET * ETYM + uuZE * ZEYM
    uuZ = uuXI * XIZM + uuET * ETZM + uuZE * ZEZM
    ! vv �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    vvXI = - vv(I,J,K) + vv(I+1,J,K)
    vvET = 0.25 * ( - vv(I,J-1,K) - vv(I+1,J-1,K) &
    &               + vv(I,J+1,K) + vv(I+1,J+1,K) )
    vvZE = 0.25 * ( - vv(I,J,K-1) - vv(I+1,J,K-1) &
    &               + vv(I,J,K+1) + vv(I+1,J,K+1) )
    ! ������ԕ�����K����
    vvX = vvXI * XIXM + vvET * ETXM + vvZE * ZEXM
    vvY = vvXI * XIYM + vvET * ETYM + vvZE * ZEYM
    vvZ = vvXI * XIZM + vvET * ETZM + vvZE * ZEZM
    ! ww �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    wwXI = - ww(I,J,K) + ww(I+1,J,K)
    wwET = 0.25 * ( - ww(I,J-1,K) - ww(I+1,J-1,K) &
    &               + ww(I,J+1,K) + ww(I+1,J+1,K) )
    wwZE = 0.25 * ( - ww(I,J,K-1) - ww(I+1,J,K-1) &
    &               + ww(I,J,K+1) + ww(I+1,J,K+1) )
    ! ������ԕ�����K����
    wwX = wwXI * XIXM + wwET * ETXM + wwZE * ZEXM
    wwY = wwXI * XIYM + wwET * ETYM + wwZE * ZEYM
    wwZ = wwXI * XIZM + wwET * ETZM + wwZE * ZEZM
    ! uv �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    uvXI = - uv(I,J,K) + uv(I+1,J,K)
    uvET = 0.25 * ( - uv(I,J-1,K) - uv(I+1,J-1,K) &
    &               + uv(I,J+1,K) + uv(I+1,J+1,K) )
    uvZE = 0.25 * ( - uv(I,J,K-1) - uv(I+1,J,K-1) &
    &               + uv(I,J,K+1) + uv(I+1,J,K+1) )
    ! ������ԕ�����K����
    uvX = uvXI * XIXM + uvET * ETXM + uvZE * ZEXM
    uvY = uvXI * XIYM + uvET * ETYM + uvZE * ZEYM
    uvZ = uvXI * XIZM + uvET * ETZM + uvZE * ZEZM
    ! vw �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    vwXI = - vw(I,J,K) + vw(I+1,J,K)
    vwET = 0.25 * ( - vw(I,J-1,K) - vw(I+1,J-1,K) &
    &               + vw(I,J+1,K) + vw(I+1,J+1,K) )
    vwZE = 0.25 * ( - vw(I,J,K-1) - vw(I+1,J,K-1) &
    &               + vw(I,J,K+1) + vw(I+1,J,K+1) )
    ! ������ԕ�����K����
    vwX = vwXI * XIXM + vwET * ETXM + vwZE * ZEXM
    vwY = vwXI * XIYM + vwET * ETYM + vwZE * ZEYM
    vwZ = vwXI * XIZM + vwET * ETZM + vwZE * ZEZM
    ! wu �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    wuXI = - wu(I,J,K) + wu(I+1,J,K)
    wuET = 0.25 * ( - wu(I,J-1,K) - wu(I+1,J-1,K) &
    &               + wu(I,J+1,K) + wu(I+1,J+1,K) )
    wuZE = 0.25 * ( - wu(I,J,K-1) - wu(I+1,J,K-1) &
    &               + wu(I,J,K+1) + wu(I+1,J,K+1) )
    ! ������ԕ�����K����
    wuX = wuXI * XIXM + wuET * ETXM + wuZE * ZEXM
    wuY = wuXI * XIYM + wuET * ETYM + wuZE * ZEYM
    wuZ = wuXI * XIZM + wuET * ETZM + wuZE * ZEZM
    ! epsilon �̈�K�����̌v�Z -----------------------------------------
    ! �v�Z��ԕ�����K����
    AEXI = - EPS(I,J,K) + EPS(I+1,J,K)
    AEET = 0.25 * ( - EPS(I,J-1,K) - EPS(I+1,J-1,K) &
    &               + EPS(I,J+1,K) + EPS(I+1,J+1,K) )
    AEZE = 0.25 * ( - EPS(I,J,K-1) - EPS(I+1,J,K-1) &
    &               + EPS(I,J,K+1) + EPS(I+1,J,K+1) )
    ! ������ԕ�����K����
    AEX = AEXI * XIXM + AEET * ETXM + AEZE * ZEXM
    AEY = AEXI * XIYM + AEET * ETYM + AEZE * ZEYM
    AEZ = AEXI * XIZM + AEET * ETZM + AEZE * ZEZM
    ! ���S�x -----------------------------------------------------------
    nu = AMUM / RHOM
    ! �c�ݑ��x ---------------------------------------------------------
    SS  = (UX + VY + WZ) * TwoThird
    S11 = 2.0 * UX - SS
    S22 = 2.0 * VY - SS
    S33 = 2.0 * WZ - SS
    S12 = UY + VX
    S23 = VZ + WY
    S31 = WX + UZ
    ! U �̊g�U ---------------------------------------------------------
    R02M = nu * S11
    S02M = nu * S12
    T02M = nu * S31
    R02T =-uuM
    S02T =-uvM
    T02T =-wuM
    ! V �̊g�U ---------------------------------------------------------
    R03M = nu * S12
    S03M = nu * S22
    T03M = nu * S23
    R03T =-uvM
    S03T =-vvM
    T03T =-vwM
    ! W �̊g�U ---------------------------------------------------------
    R04M = nu * S31
    S04M = nu * S23
    T04M = nu * S33
    R04T =-wuM
    S04T =-vwM
    T04T =-wwM
    ! �G�l���M�[�̊g�U -------------------------------------------------
    C_p  = GAMMA * RG / (GAMMA - 1.0)
    IF(EPSM .GT. ZERO) THEN
      AKAE = 0.5 * (uuM + vvM + wwM) / EPSM
    ELSE
      AKAE = 0.0
    ENDIF
    R05M = C_p * nu / PR * TX + nu * (S11 * UM + S12 * VM + S31 * WM)
    S05M = C_p * nu / PR * TY + nu * (S12 * UM + S22 * VM + S23 * WM)
    T05M = C_p * nu / PR * TZ + nu * (S31 * UM + S23 * VM + S33 * WM)
    R05T = AKAE * C_se * C_p * (uuM * TX + uvM * TY + wuM * TZ) &
    &    + AKAE * C_s  * ( &
    &      uuM * (uuX + vvX + wwX) &
    &    + uvM * (uuY + vvY + wwY) &
    &    + wuM * (uuZ + vvZ + wwZ) &
    &    ) &
    &    - (uuM * UM + uvM * VM + wuM * WM)
    S05T = AKAE * C_se * C_p * (uvM * TX + vvM * TY + vwM * TZ) &
    &    + AKAE * C_s  * ( &
    &      uvM * (uuX + vvX + wwX) &
    &    + vvM * (uuY + vvY + wwY) &
    &    + vwM * (uuZ + vvZ + wwZ) &
    &    ) &
    &    - (uvM * UM + vvM * VM + vwM * WM)
    T05T = AKAE * C_se * C_p * (wuM * TX + vwM * TY + wwM * TZ) &
    &    + AKAE * C_s  * ( &
    &      wuM * (uuX + vvX + wwX) &
    &    + vwM * (uuY + vvY + wwY) &
    &    + wwM * (uuZ + vvZ + wwZ) &
    &    ) &
    &    - (wuM * UM + vwM * VM + wwM * WM)
    ! uu �̊g�U --------------------------------------------------------
    R06M = nu * uuX
    S06M = nu * uuY
    T06M = nu * uuZ
    R06T = C_s * AKAE * (uuM * uuX + uvM * uuY + wuM * uuZ)
    S06T = C_s * AKAE * (uvM * uuX + vvM * uuY + vwM * uuZ)
    T06T = C_s * AKAE * (wuM * uuX + vwM * uuY + wwM * uuZ)
    ! vv �̊g�U --------------------------------------------------------
    R07M = nu * vvX
    S07M = nu * vvY
    T07M = nu * vvZ
    R07T = C_s * AKAE * (uuM * vvX + uvM * vvY + wuM * vvZ)
    S07T = C_s * AKAE * (uvM * vvX + vvM * vvY + vwM * vvZ)
    T07T = C_s * AKAE * (wuM * vvX + vwM * vvY + wwM * vvZ)
    ! ww �̊g�U --------------------------------------------------------
    R08M = nu * wwX
    S08M = nu * wwY
    T08M = nu * wwZ
    R08T = C_s * AKAE * (uuM * wwX + uvM * wwY + wuM * wwZ)
    S08T = C_s * AKAE * (uvM * wwX + vvM * wwY + vwM * wwZ)
    T08T = C_s * AKAE * (wuM * wwX + vwM * wwY + wwM * wwZ)
    ! uv �̊g�U --------------------------------------------------------
    R09M = nu * uvX
    S09M = nu * uvY
    T09M = nu * uvZ
    R09T = C_s * AKAE * (uuM * uvX + uvM * uvY + wuM * uvZ)
    S09T = C_s * AKAE * (uvM * uvX + vvM * uvY + vwM * uvZ)
    T09T = C_s * AKAE * (wuM * uvX + vwM * uvY + wwM * uvZ)
    ! vw �̊g�U --------------------------------------------------------
    R10M = nu * vwX
    S10M = nu * vwY
    T10M = nu * vwZ
    R10T = C_s * AKAE * (uuM * vwX + uvM * vwY + wuM * vwZ)
    S10T = C_s * AKAE * (uvM * vwX + vvM * vwY + vwM * vwZ)
    T10T = C_s * AKAE * (wuM * vwX + vwM * vwY + wwM * vwZ)
    ! wu �̊g�U --------------------------------------------------------
    R11M = nu * wuX
    S11M = nu * wuY
    T11M = nu * wuZ
    R11T = C_s * AKAE * (uuM * wuX + uvM * wuY + wuM * wuZ)
    S11T = C_s * AKAE * (uvM * wuX + vvM * wuY + vwM * wuZ)
    T11T = C_s * AKAE * (wuM * wuX + vwM * wuY + wwM * wuZ)
    ! epsilon �̊g�U ---------------------------------------------------
    R12M = nu * AEX
    S12M = nu * AEY
    T12M = nu * AEZ
    R12T = C_e * AKAE * (uuM * AEX + uvM * AEY + wuM * AEZ)
    S12T = C_e * AKAE * (uvM * AEX + vvM * AEY + vwM * AEZ)
    T12T = C_e * AKAE * (wuM * AEX + vwM * AEY + wwM * AEZ)
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    RH(I,J,K, 1) = 0.0
    RH(I,J,K, 2) = QH1 * ( (R02M + R02T) * XIXM &
    &                    + (S02M + S02T) * XIYM &
    &                    + (T02M + T02T) * XIZM )
    RH(I,J,K, 3) = QH1 * ( (R03M + R03T) * XIXM &
    &                    + (S03M + S03T) * XIYM &
    &                    + (T03M + T03T) * XIZM )
    RH(I,J,K, 4) = QH1 * ( (R04M + R04T) * XIXM &
    &                    + (S04M + S04T) * XIYM &
    &                    + (T04M + T04T) * XIZM )
    RH(I,J,K, 5) = QH1 * ( (R05M + R05T) * XIXM &
    &                    + (S05M + S05T) * XIYM &
    &                    + (T05M + T05T) * XIZM )
    RH(I,J,K, 6) = QH1 * ( (R06M + R06T) * XIXM &
    &                    + (S06M + S06T) * XIYM &
    &                    + (T06M + T06T) * XIZM )
    RH(I,J,K, 7) = QH1 * ( (R07M + R07T) * XIXM &
    &                    + (S07M + S07T) * XIYM &
    &                    + (T07M + T07T) * XIZM )
    RH(I,J,K, 8) = QH1 * ( (R08M + R08T) * XIXM &
    &                    + (S08M + S08T) * XIYM &
    &                    + (T08M + T08T) * XIZM )
    RH(I,J,K, 9) = QH1 * ( (R09M + R09T) * XIXM &
    &                    + (S09M + S09T) * XIYM &
    &                    + (T09M + T09T) * XIZM )
    RH(I,J,K,10) = QH1 * ( (R10M + R10T) * XIXM &
    &                    + (S10M + S10T) * XIYM &
    &                    + (T10M + T10T) * XIZM )
    RH(I,J,K,11) = QH1 * ( (R11M + R11T) * XIXM &
    &                    + (S11M + S11T) * XIYM &
    &                    + (T11M + T11T) * XIZM )
    RH(I,J,K,12) = QH1 * ( (R12M + R12T) * XIXM &
    &                    + (S12M + S12T) * XIYM &
    &                    + (T12M + T12T) * XIZM )
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFXI
!***********************************************************************
!**** �g�U���̌v�Z(eta���������p)                                   ****
!***********************************************************************
SUBROUTINE DIFFET
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM
  REAL    :: RHOM, UM, VM, WM, uuM, vvM, wwM, uvM, vwM, wuM, EPSM, AMUM
  REAL    :: UXI, UET, UZE, UX, UY, UZ
  REAL    :: VXI, VET, VZE, VX, VY, VZ
  REAL    :: WXI, WET, WZE, WX, WY, WZ
  REAL    :: TXI, TET, TZE, TX, TY, TZ
  REAL    :: uuXI, uuET, uuZE, uuX, uuY, uuZ
  REAL    :: vvXI, vvET, vvZE, vvX, vvY, vvZ
  REAL    :: wwXI, wwET, wwZE, wwX, wwY, wwZ
  REAL    :: uvXI, uvET, uvZE, uvX, uvY, uvZ
  REAL    :: vwXI, vwET, vwZE, vwX, vwY, vwZ
  REAL    :: wuXI, wuET, wuZE, wuX, wuY, wuZ
  REAL    :: AEXI, AEET, AEZE, AEX, AEY, AEZ
  REAL    :: nu
  REAL    :: S11, S22, S33, S12, S23, S31, SS
  REAL    :: C_p, AKAE
  REAL    :: R02M, S02M, T02M, R02T, S02T, T02T
  REAL    :: R03M, S03M, T03M, R03T, S03T, T03T
  REAL    :: R04M, S04M, T04M, R04T, S04T, T04T
  REAL    :: R05M, S05M, T05M, R05T, S05T, T05T
  REAL    :: R06M, S06M, T06M, R06T, S06T, T06T
  REAL    :: R07M, S07M, T07M, R07T, S07T, T07T
  REAL    :: R08M, S08M, T08M, R08T, S08T, T08T
  REAL    :: R09M, S09M, T09M, R09T, S09T, T09T
  REAL    :: R10M, S10M, T10M, R10T, S10T, T10T
  REAL    :: R11M, S11M, T11M, R11T, S11T, T11T
  REAL    :: R12M, S12M, T12M, R12T, S12T, T12T
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM, &
!$OMP& RHOM, UM, VM, WM, uuM, vvM, wwM, uvM, vwM, wuM, EPSM, AMUM, &
!$OMP& UXI, UET, UZE, UX, UY, UZ, &
!$OMP& VXI, VET, VZE, VX, VY, VZ, &
!$OMP& WXI, WET, WZE, WX, WY, WZ, &
!$OMP& TXI, TET, TZE, TX, TY, TZ, &
!$OMP& uuXI, uuET, uuZE, uuX, uuY, uuZ, &
!$OMP& vvXI, vvET, vvZE, vvX, vvY, vvZ, &
!$OMP& wwXI, wwET, wwZE, wwX, wwY, wwZ, &
!$OMP& uvXI, uvET, uvZE, uvX, uvY, uvZ, &
!$OMP& vwXI, vwET, vwZE, vwX, vwY, vwZ, &
!$OMP& wuXI, wuET, wuZE, wuX, wuY, wuZ, &
!$OMP& AEXI, AEET, AEZE, AEX, AEY, AEZ, &
!$OMP& nu, S11, S22, S33, S12, S23, S31, SS, C_p, AKAE, &
!$OMP& R02M, S02M, T02M, R02T, S02T, T02T, &
!$OMP& R03M, S03M, T03M, R03T, S03T, T03T, &
!$OMP& R04M, S04M, T04M, R04T, S04T, T04T, &
!$OMP& R05M, S05M, T05M, R05T, S05T, T05T, &
!$OMP& R06M, S06M, T06M, R06T, S06T, T06T, &
!$OMP& R07M, S07M, T07M, R07T, S07T, T07T, &
!$OMP& R08M, S08M, T08M, R08T, S08T, T08T, &
!$OMP& R09M, S09M, T09M, R09T, S09T, T09T, &
!$OMP& R10M, S10M, T10M, R10T, S10T, T10T, &
!$OMP& R11M, S11M, T11M, R11T, S11T, T11T, &
!$OMP& R12M, S12M, T12M, R12T, S12T, T12T, &
!$OMP& QH1 &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS    , JE - 1
  DO I = IS + 1, IE - 1
  IF((RHO(I,J,K) .GT. 0.0) .AND. (RHO(I,J+1,K) .GT. 0.0)) THEN
    ! XI�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J,K) + XIX(I,J+1,K))
    XIYM = 0.5 * (XIY(I,J,K) + XIY(I,J+1,K))
    XIZM = 0.5 * (XIZ(I,J,K) + XIZ(I,J+1,K))
    ETXM = 0.5 * (ETX(I,J,K) + ETX(I,J+1,K))
    ETYM = 0.5 * (ETY(I,J,K) + ETY(I,J+1,K))
    ETZM = 0.5 * (ETZ(I,J,K) + ETZ(I,J+1,K))
    ZEXM = 0.5 * (ZEX(I,J,K) + ZEX(I,J+1,K))
    ZEYM = 0.5 * (ZEY(I,J,K) + ZEY(I,J+1,K))
    ZEZM = 0.5 * (ZEZ(I,J,K) + ZEZ(I,J+1,K))
    AJAM = 0.5 * (AJA(I,J,K) + AJA(I,J+1,K))
    ! ������
    RHOM = 0.5 * (RHO(I,J,K) + RHO(I,J+1,K))
    UM   = 0.5 * (  U(I,J,K) +   U(I,J+1,K))
    VM   = 0.5 * (  V(I,J,K) +   V(I,J+1,K))
    WM   = 0.5 * (  W(I,J,K) +   W(I,J+1,K))
    uuM  = 0.5 * ( uu(I,J,K) +  uu(I,J+1,K))
    vvM  = 0.5 * ( vv(I,J,K) +  vv(I,J+1,K))
    wwM  = 0.5 * ( ww(I,J,K) +  ww(I,J+1,K))
    uvM  = 0.5 * ( uv(I,J,K) +  uv(I,J+1,K))
    vwM  = 0.5 * ( vw(I,J,K) +  vw(I,J+1,K))
    wuM  = 0.5 * ( wu(I,J,K) +  wu(I,J+1,K))
    EPSM = 0.5 * (EPS(I,J,K) + EPS(I,J+1,K))
    AMUM = 0.5 * (AMU(I,J,K) + AMU(I,J+1,K))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = 0.25 * ( - U(I-1,J,K) - U(I-1,J+1,K) &
    &              + U(I+1,J,K) + U(I+1,J+1,K) )
    UET = - U(I,J,K) + U(I,J+1,K)
    UZE = 0.25 * ( - U(I,J,K-1) - U(I,J+1,K-1) &
    &              + U(I,J,K+1) + U(I,J+1,K+1) )
    VXI = 0.25 * ( - V(I-1,J,K) - V(I-1,J+1,K) &
    &              + V(I+1,J,K) + V(I+1,J+1,K) )
    VET = - V(I,J,K) + V(I,J+1,K)
    VZE = 0.25 * ( - V(I,J,K-1) - V(I,J+1,K-1) &
    &              + V(I,J,K+1) + V(I,J+1,K+1) )
    WXI = 0.25 * ( - W(I-1,J,K) - W(I-1,J+1,K) &
    &              + W(I+1,J,K) + W(I+1,J+1,K) )
    WET = - W(I,J,K) + W(I,J+1,K)
    WZE = 0.25 * ( - W(I,J,K-1) - W(I,J+1,K-1) &
    &              + W(I,J,K+1) + W(I,J+1,K+1) )
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM + UZE * ZEXM
    UY = UXI * XIYM + UET * ETYM + UZE * ZEYM
    UZ = UXI * XIZM + UET * ETZM + UZE * ZEZM
    VX = VXI * XIXM + VET * ETXM + VZE * ZEXM
    VY = VXI * XIYM + VET * ETYM + VZE * ZEYM
    VZ = VXI * XIZM + VET * ETZM + VZE * ZEZM
    WX = WXI * XIXM + WET * ETXM + WZE * ZEXM
    WY = WXI * XIYM + WET * ETYM + WZE * ZEYM
    WZ = WXI * XIZM + WET * ETZM + WZE * ZEZM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = 0.25 * ( - T(I-1,J,K) - T(I-1,J+1,K) &
    &              + T(I+1,J,K) + T(I+1,J+1,K) )
    TET = - T(I,J,K) + T(I,J+1,K)
    TZE = 0.25 * ( - T(I,J,K-1) - T(I,J+1,K-1) &
    &              + T(I,J,K+1) + T(I,J+1,K+1) )
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM + TZE * ZEXM
    TY = TXI * XIYM + TET * ETYM + TZE * ZEYM
    TZ = TXI * XIZM + TET * ETZM + TZE * ZEZM
    ! uu �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    uuXI = 0.25 * ( - uu(I-1,J,K) - uu(I-1,J+1,K) &
    &               + uu(I+1,J,K) + uu(I+1,J+1,K) )
    uuET = - uu(I,J,K) + uu(I,J+1,K)
    uuZE = 0.25 * ( - uu(I,J,K-1) - uu(I,J+1,K-1) &
    &               + uu(I,J,K+1) + uu(I,J+1,K+1) )
    ! ������ԕ�����K����
    uuX = uuXI * XIXM + uuET * ETXM + uuZE * ZEXM
    uuY = uuXI * XIYM + uuET * ETYM + uuZE * ZEYM
    uuZ = uuXI * XIZM + uuET * ETZM + uuZE * ZEZM
    ! vv �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    vvXI = 0.25 * ( - vv(I-1,J,K) - vv(I-1,J+1,K) &
    &               + vv(I+1,J,K) + vv(I+1,J+1,K) )
    vvET = - vv(I,J,K) + vv(I,J+1,K)
    vvZE = 0.25 * ( - vv(I,J,K-1) - vv(I,J+1,K-1) &
    &               + vv(I,J,K+1) + vv(I,J+1,K+1) )
    ! ������ԕ�����K����
    vvX = vvXI * XIXM + vvET * ETXM + vvZE * ZEXM
    vvY = vvXI * XIYM + vvET * ETYM + vvZE * ZEYM
    vvZ = vvXI * XIZM + vvET * ETZM + vvZE * ZEZM
    ! ww �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    wwXI = 0.25 * ( - ww(I-1,J,K) - ww(I-1,J+1,K) &
    &               + ww(I+1,J,K) + ww(I+1,J+1,K) )
    wwET = - ww(I,J,K) + ww(I,J+1,K)
    wwZE = 0.25 * ( - ww(I,J,K-1) - ww(I,J+1,K-1) &
    &               + ww(I,J,K+1) + ww(I,J+1,K+1) )
    ! ������ԕ�����K����
    wwX = wwXI * XIXM + wwET * ETXM + wwZE * ZEXM
    wwY = wwXI * XIYM + wwET * ETYM + wwZE * ZEYM
    wwZ = wwXI * XIZM + wwET * ETZM + wwZE * ZEZM
    ! uv �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    uvXI = 0.25 * ( - uv(I-1,J,K) - uv(I-1,J+1,K) &
    &               + uv(I+1,J,K) + uv(I+1,J+1,K) )
    uvET = - uv(I,J,K) + uv(I,J+1,K)
    uvZE = 0.25 * ( - uv(I,J,K-1) - uv(I,J+1,K-1) &
    &               + uv(I,J,K+1) + uv(I,J+1,K+1) )
    ! ������ԕ�����K����
    uvX = uvXI * XIXM + uvET * ETXM + uvZE * ZEXM
    uvY = uvXI * XIYM + uvET * ETYM + uvZE * ZEYM
    uvZ = uvXI * XIZM + uvET * ETZM + uvZE * ZEZM
    ! vw �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    vwXI = 0.25 * ( - vw(I-1,J,K) - vw(I-1,J+1,K) &
    &               + vw(I+1,J,K) + vw(I+1,J+1,K) )
    vwET = - vw(I,J,K) + vw(I,J+1,K)
    vwZE = 0.25 * ( - vw(I,J,K-1) - vw(I,J+1,K-1) &
    &               + vw(I,J,K+1) + vw(I,J+1,K+1) )
    ! ������ԕ�����K����
    vwX = vwXI * XIXM + vwET * ETXM + vwZE * ZEXM
    vwY = vwXI * XIYM + vwET * ETYM + vwZE * ZEYM
    vwZ = vwXI * XIZM + vwET * ETZM + vwZE * ZEZM
    ! wu �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    wuXI = 0.25 * ( - wu(I-1,J,K) - wu(I-1,J+1,K) &
    &               + wu(I+1,J,K) + wu(I+1,J+1,K) )
    wuET = - wu(I,J,K) + wu(I,J+1,K)
    wuZE = 0.25 * ( - wu(I,J,K-1) - wu(I,J+1,K-1) &
    &               + wu(I,J,K+1) + wu(I,J+1,K+1) )
    ! ������ԕ�����K����
    wuX = wuXI * XIXM + wuET * ETXM + wuZE * ZEXM
    wuY = wuXI * XIYM + wuET * ETYM + wuZE * ZEYM
    wuZ = wuXI * XIZM + wuET * ETZM + wuZE * ZEZM
    ! epsilon �̈�K�����̌v�Z -----------------------------------------
    ! �v�Z��ԕ�����K����
    AEXI = 0.25 * ( - EPS(I-1,J,K) - EPS(I-1,J+1,K) &
    &               + EPS(I+1,J,K) + EPS(I+1,J+1,K) )
    AEET = - EPS(I,J,K) + EPS(I,J+1,K)
    AEZE = 0.25 * ( - EPS(I,J,K-1) - EPS(I,J+1,K-1) &
    &               + EPS(I,J,K+1) + EPS(I,J+1,K+1) )
    ! ������ԕ�����K����
    AEX = AEXI * XIXM + AEET * ETXM + AEZE * ZEXM
    AEY = AEXI * XIYM + AEET * ETYM + AEZE * ZEYM
    AEZ = AEXI * XIZM + AEET * ETZM + AEZE * ZEZM
    ! ���S�x -----------------------------------------------------------
    nu = AMUM / RHOM
    ! �c�ݑ��x ---------------------------------------------------------
    SS  = (UX + VY + WZ) * TwoThird
    S11 = 2.0 * UX - SS
    S22 = 2.0 * VY - SS
    S33 = 2.0 * WZ - SS
    S12 = UY + VX
    S23 = VZ + WY
    S31 = WX + UZ
    ! U �̊g�U ---------------------------------------------------------
    R02M = nu * S11
    S02M = nu * S12
    T02M = nu * S31
    R02T =-uuM
    S02T =-uvM
    T02T =-wuM
    ! V �̊g�U ---------------------------------------------------------
    R03M = nu * S12
    S03M = nu * S22
    T03M = nu * S23
    R03T =-uvM
    S03T =-vvM
    T03T =-vwM
    ! W �̊g�U ---------------------------------------------------------
    R04M = nu * S31
    S04M = nu * S23
    T04M = nu * S33
    R04T =-wuM
    S04T =-vwM
    T04T =-wwM
    ! �G�l���M�[�̊g�U -------------------------------------------------
    C_p  = GAMMA * RG / (GAMMA - 1.0)
    IF(EPSM .GT. ZERO) THEN
      AKAE = 0.5 * (uuM + vvM + wwM) / EPSM
    ELSE
      AKAE = 0.0
    ENDIF
    R05M = C_p * nu / PR * TX + nu * (S11 * UM + S12 * VM + S31 * WM)
    S05M = C_p * nu / PR * TY + nu * (S12 * UM + S22 * VM + S23 * WM)
    T05M = C_p * nu / PR * TZ + nu * (S31 * UM + S23 * VM + S33 * WM)
    R05T = AKAE * C_se * C_p * (uuM * TX + uvM * TY + wuM * TZ) &
    &    + AKAE * C_s  * ( &
    &      uuM * (uuX + vvX + wwX) &
    &    + uvM * (uuY + vvY + wwY) &
    &    + wuM * (uuZ + vvZ + wwZ) &
    &    ) &
    &    - (uuM * UM + uvM * VM + wuM * WM)
    S05T = AKAE * C_se * C_p * (uvM * TX + vvM * TY + vwM * TZ) &
    &    + AKAE * C_s  * ( &
    &      uvM * (uuX + vvX + wwX) &
    &    + vvM * (uuY + vvY + wwY) &
    &    + vwM * (uuZ + vvZ + wwZ) &
    &    ) &
    &    - (uvM * UM + vvM * VM + vwM * WM)
    T05T = AKAE * C_se * C_p * (wuM * TX + vwM * TY + wwM * TZ) &
    &    + AKAE * C_s  * ( &
    &      wuM * (uuX + vvX + wwX) &
    &    + vwM * (uuY + vvY + wwY) &
    &    + wwM * (uuZ + vvZ + wwZ) &
    &    ) &
    &    - (wuM * UM + vwM * VM + wwM * WM)
    ! uu �̊g�U --------------------------------------------------------
    R06M = nu * uuX
    S06M = nu * uuY
    T06M = nu * uuZ
    R06T = C_s * AKAE * (uuM * uuX + uvM * uuY + wuM * uuZ)
    S06T = C_s * AKAE * (uvM * uuX + vvM * uuY + vwM * uuZ)
    T06T = C_s * AKAE * (wuM * uuX + vwM * uuY + wwM * uuZ)
    ! vv �̊g�U --------------------------------------------------------
    R07M = nu * vvX
    S07M = nu * vvY
    T07M = nu * vvZ
    R07T = C_s * AKAE * (uuM * vvX + uvM * vvY + wuM * vvZ)
    S07T = C_s * AKAE * (uvM * vvX + vvM * vvY + vwM * vvZ)
    T07T = C_s * AKAE * (wuM * vvX + vwM * vvY + wwM * vvZ)
    ! ww �̊g�U --------------------------------------------------------
    R08M = nu * wwX
    S08M = nu * wwY
    T08M = nu * wwZ
    R08T = C_s * AKAE * (uuM * wwX + uvM * wwY + wuM * wwZ)
    S08T = C_s * AKAE * (uvM * wwX + vvM * wwY + vwM * wwZ)
    T08T = C_s * AKAE * (wuM * wwX + vwM * wwY + wwM * wwZ)
    ! uv �̊g�U --------------------------------------------------------
    R09M = nu * uvX
    S09M = nu * uvY
    T09M = nu * uvZ
    R09T = C_s * AKAE * (uuM * uvX + uvM * uvY + wuM * uvZ)
    S09T = C_s * AKAE * (uvM * uvX + vvM * uvY + vwM * uvZ)
    T09T = C_s * AKAE * (wuM * uvX + vwM * uvY + wwM * uvZ)
    ! vw �̊g�U --------------------------------------------------------
    R10M = nu * vwX
    S10M = nu * vwY
    T10M = nu * vwZ
    R10T = C_s * AKAE * (uuM * vwX + uvM * vwY + wuM * vwZ)
    S10T = C_s * AKAE * (uvM * vwX + vvM * vwY + vwM * vwZ)
    T10T = C_s * AKAE * (wuM * vwX + vwM * vwY + wwM * vwZ)
    ! wu �̊g�U --------------------------------------------------------
    R11M = nu * wuX
    S11M = nu * wuY
    T11M = nu * wuZ
    R11T = C_s * AKAE * (uuM * wuX + uvM * wuY + wuM * wuZ)
    S11T = C_s * AKAE * (uvM * wuX + vvM * wuY + vwM * wuZ)
    T11T = C_s * AKAE * (wuM * wuX + vwM * wuY + wwM * wuZ)
    ! epsilon �̊g�U ---------------------------------------------------
    R12M = nu * AEX
    S12M = nu * AEY
    T12M = nu * AEZ
    R12T = C_e * AKAE * (uuM * AEX + uvM * AEY + wuM * AEZ)
    S12T = C_e * AKAE * (uvM * AEX + vvM * AEY + vwM * AEZ)
    T12T = C_e * AKAE * (wuM * AEX + vwM * AEY + wwM * AEZ)
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    SH(I,J,K, 1) = 0.0
    SH(I,J,K, 2) = QH1 * ( (R02M + R02T) * ETXM &
    &                    + (S02M + S02T) * ETYM &
    &                    + (T02M + T02T) * ETZM )
    SH(I,J,K, 3) = QH1 * ( (R03M + R03T) * ETXM &
    &                    + (S03M + S03T) * ETYM &
    &                    + (T03M + T03T) * ETZM )
    SH(I,J,K, 4) = QH1 * ( (R04M + R04T) * ETXM &
    &                    + (S04M + S04T) * ETYM &
    &                    + (T04M + T04T) * ETZM )
    SH(I,J,K, 5) = QH1 * ( (R05M + R05T) * ETXM &
    &                    + (S05M + S05T) * ETYM &
    &                    + (T05M + T05T) * ETZM )
    SH(I,J,K, 6) = QH1 * ( (R06M + R06T) * ETXM &
    &                    + (S06M + S06T) * ETYM &
    &                    + (T06M + T06T) * ETZM )
    SH(I,J,K, 7) = QH1 * ( (R07M + R07T) * ETXM &
    &                    + (S07M + S07T) * ETYM &
    &                    + (T07M + T07T) * ETZM )
    SH(I,J,K, 8) = QH1 * ( (R08M + R08T) * ETXM &
    &                    + (S08M + S08T) * ETYM &
    &                    + (T08M + T08T) * ETZM )
    SH(I,J,K, 9) = QH1 * ( (R09M + R09T) * ETXM &
    &                    + (S09M + S09T) * ETYM &
    &                    + (T09M + T09T) * ETZM )
    SH(I,J,K,10) = QH1 * ( (R10M + R10T) * ETXM &
    &                    + (S10M + S10T) * ETYM &
    &                    + (T10M + T10T) * ETZM )
    SH(I,J,K,11) = QH1 * ( (R11M + R11T) * ETXM &
    &                    + (S11M + S11T) * ETYM &
    &                    + (T11M + T11T) * ETZM )
    SH(I,J,K,12) = QH1 * ( (R12M + R12T) * ETXM &
    &                    + (S12M + S12T) * ETYM &
    &                    + (T12M + T12T) * ETZM )
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFET
!***********************************************************************
!**** �g�U���̌v�Z(zeta���������p)                                  ****
!***********************************************************************
SUBROUTINE DIFFZE
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM
  REAL    :: RHOM, UM, VM, WM, uuM, vvM, wwM, uvM, vwM, wuM, EPSM, AMUM
  REAL    :: UXI, UET, UZE, UX, UY, UZ
  REAL    :: VXI, VET, VZE, VX, VY, VZ
  REAL    :: WXI, WET, WZE, WX, WY, WZ
  REAL    :: TXI, TET, TZE, TX, TY, TZ
  REAL    :: uuXI, uuET, uuZE, uuX, uuY, uuZ
  REAL    :: vvXI, vvET, vvZE, vvX, vvY, vvZ
  REAL    :: wwXI, wwET, wwZE, wwX, wwY, wwZ
  REAL    :: uvXI, uvET, uvZE, uvX, uvY, uvZ
  REAL    :: vwXI, vwET, vwZE, vwX, vwY, vwZ
  REAL    :: wuXI, wuET, wuZE, wuX, wuY, wuZ
  REAL    :: AEXI, AEET, AEZE, AEX, AEY, AEZ
  REAL    :: nu
  REAL    :: S11, S22, S33, S12, S23, S31, SS
  REAL    :: C_p, AKAE
  REAL    :: R02M, S02M, T02M, R02T, S02T, T02T
  REAL    :: R03M, S03M, T03M, R03T, S03T, T03T
  REAL    :: R04M, S04M, T04M, R04T, S04T, T04T
  REAL    :: R05M, S05M, T05M, R05T, S05T, T05T
  REAL    :: R06M, S06M, T06M, R06T, S06T, T06T
  REAL    :: R07M, S07M, T07M, R07T, S07T, T07T
  REAL    :: R08M, S08M, T08M, R08T, S08T, T08T
  REAL    :: R09M, S09M, T09M, R09T, S09T, T09T
  REAL    :: R10M, S10M, T10M, R10T, S10T, T10T
  REAL    :: R11M, S11M, T11M, R11T, S11T, T11T
  REAL    :: R12M, S12M, T12M, R12T, S12T, T12T
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM, &
!$OMP& RHOM, UM, VM, WM, uuM, vvM, wwM, uvM, vwM, wuM, EPSM, AMUM, &
!$OMP& UXI, UET, UZE, UX, UY, UZ, &
!$OMP& VXI, VET, VZE, VX, VY, VZ, &
!$OMP& WXI, WET, WZE, WX, WY, WZ, &
!$OMP& TXI, TET, TZE, TX, TY, TZ, &
!$OMP& uuXI, uuET, uuZE, uuX, uuY, uuZ, &
!$OMP& vvXI, vvET, vvZE, vvX, vvY, vvZ, &
!$OMP& wwXI, wwET, wwZE, wwX, wwY, wwZ, &
!$OMP& uvXI, uvET, uvZE, uvX, uvY, uvZ, &
!$OMP& vwXI, vwET, vwZE, vwX, vwY, vwZ, &
!$OMP& wuXI, wuET, wuZE, wuX, wuY, wuZ, &
!$OMP& AEXI, AEET, AEZE, AEX, AEY, AEZ, &
!$OMP& nu, S11, S22, S33, S12, S23, S31, SS, C_p, AKAE, &
!$OMP& R02M, S02M, T02M, R02T, S02T, T02T, &
!$OMP& R03M, S03M, T03M, R03T, S03T, T03T, &
!$OMP& R04M, S04M, T04M, R04T, S04T, T04T, &
!$OMP& R05M, S05M, T05M, R05T, S05T, T05T, &
!$OMP& R06M, S06M, T06M, R06T, S06T, T06T, &
!$OMP& R07M, S07M, T07M, R07T, S07T, T07T, &
!$OMP& R08M, S08M, T08M, R08T, S08T, T08T, &
!$OMP& R09M, S09M, T09M, R09T, S09T, T09T, &
!$OMP& R10M, S10M, T10M, R10T, S10T, T10T, &
!$OMP& R11M, S11M, T11M, R11T, S11T, T11T, &
!$OMP& R12M, S12M, T12M, R12T, S12T, T12T, &
!$OMP& QH1 &
!$OMP& )
  DO K = KS    , KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF((RHO(I,J,K) .GT. 0.0) .AND. (RHO(I,J,K+1) .GT. 0.0)) THEN
    ! XI�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J,K) + XIX(I,J,K+1))
    XIYM = 0.5 * (XIY(I,J,K) + XIY(I,J,K+1))
    XIZM = 0.5 * (XIZ(I,J,K) + XIZ(I,J,K+1))
    ETXM = 0.5 * (ETX(I,J,K) + ETX(I,J,K+1))
    ETYM = 0.5 * (ETY(I,J,K) + ETY(I,J,K+1))
    ETZM = 0.5 * (ETZ(I,J,K) + ETZ(I,J,K+1))
    ZEXM = 0.5 * (ZEX(I,J,K) + ZEX(I,J,K+1))
    ZEYM = 0.5 * (ZEY(I,J,K) + ZEY(I,J,K+1))
    ZEZM = 0.5 * (ZEZ(I,J,K) + ZEZ(I,J,K+1))
    AJAM = 0.5 * (AJA(I,J,K) + AJA(I,J,K+1))
    ! ������
    RHOM = 0.5 * (RHO(I,J,K) + RHO(I,J,K+1))
    UM   = 0.5 * (  U(I,J,K) +   U(I,J,K+1))
    VM   = 0.5 * (  V(I,J,K) +   V(I,J,K+1))
    WM   = 0.5 * (  W(I,J,K) +   W(I,J,K+1))
    uuM  = 0.5 * ( uu(I,J,K) +  uu(I,J,K+1))
    vvM  = 0.5 * ( vv(I,J,K) +  vv(I,J,K+1))
    wwM  = 0.5 * ( ww(I,J,K) +  ww(I,J,K+1))
    uvM  = 0.5 * ( uv(I,J,K) +  uv(I,J,K+1))
    vwM  = 0.5 * ( vw(I,J,K) +  vw(I,J,K+1))
    wuM  = 0.5 * ( wu(I,J,K) +  wu(I,J,K+1))
    EPSM = 0.5 * (EPS(I,J,K) + EPS(I,J,K+1))
    AMUM = 0.5 * (AMU(I,J,K) + AMU(I,J,K+1))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = 0.25 * ( - U(I-1,J,K) - U(I-1,J,K+1) &
    &              + U(I+1,J,K) + U(I+1,J,K+1) )
    UET = 0.25 * ( - U(I,J-1,K) - U(I,J-1,K+1) &
    &              + U(I,J+1,K) + U(I,J+1,K+1) )
    UZE = - U(I,J,K) + U(I,J,K+1)
    VXI = 0.25 * ( - V(I-1,J,K) - V(I-1,J,K+1) &
    &              + V(I+1,J,K) + V(I+1,J,K+1) )
    VET = 0.25 * ( - V(I,J-1,K) - V(I,J-1,K+1) &
    &              + V(I,J+1,K) + V(I,J+1,K+1) )
    VZE = - V(I,J,K) + V(I,J,K+1)
    WXI = 0.25 * ( - W(I-1,J,K) - W(I-1,J,K+1) &
    &              + W(I+1,J,K) + W(I+1,J,K+1) )
    WET = 0.25 * ( - W(I,J-1,K) - W(I,J-1,K+1) &
    &              + W(I,J+1,K) + W(I,J+1,K+1) )
    WZE = - W(I,J,K) + W(I,J,K+1)
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM + UZE * ZEXM
    UY = UXI * XIYM + UET * ETYM + UZE * ZEYM
    UZ = UXI * XIZM + UET * ETZM + UZE * ZEZM
    VX = VXI * XIXM + VET * ETXM + VZE * ZEXM
    VY = VXI * XIYM + VET * ETYM + VZE * ZEYM
    VZ = VXI * XIZM + VET * ETZM + VZE * ZEZM
    WX = WXI * XIXM + WET * ETXM + WZE * ZEXM
    WY = WXI * XIYM + WET * ETYM + WZE * ZEYM
    WZ = WXI * XIZM + WET * ETZM + WZE * ZEZM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = 0.25 * ( - T(I-1,J,K) - T(I-1,J,K+1) &
    &              + T(I+1,J,K) + T(I+1,J,K+1) )
    TET = 0.25 * ( - T(I,J-1,K) - T(I,J-1,K+1) &
    &              + T(I,J+1,K) + T(I,J+1,K+1) )
    TZE = - T(I,J,K) + T(I,J,K+1)
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM + TZE * ZEXM
    TY = TXI * XIYM + TET * ETYM + TZE * ZEYM
    TZ = TXI * XIZM + TET * ETZM + TZE * ZEZM
    ! uu �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    uuXI = 0.25 * ( - uu(I-1,J,K) - uu(I-1,J,K+1) &
    &               + uu(I+1,J,K) + uu(I+1,J,K+1) )
    uuET = 0.25 * ( - uu(I,J-1,K) - uu(I,J-1,K+1) &
    &               + uu(I,J+1,K) + uu(I,J+1,K+1) )
    uuZE = - uu(I,J,K) + uu(I,J,K+1)
    ! ������ԕ�����K����
    uuX = uuXI * XIXM + uuET * ETXM + uuZE * ZEXM
    uuY = uuXI * XIYM + uuET * ETYM + uuZE * ZEYM
    uuZ = uuXI * XIZM + uuET * ETZM + uuZE * ZEZM
    ! vv �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    vvXI = 0.25 * ( - vv(I-1,J,K) - vv(I-1,J,K+1) &
    &               + vv(I+1,J,K) + vv(I+1,J,K+1) )
    vvET = 0.25 * ( - vv(I,J-1,K) - vv(I,J-1,K+1) &
    &               + vv(I,J+1,K) + vv(I,J+1,K+1) )
    vvZE = - vv(I,J,K) + vv(I,J,K+1)
    ! ������ԕ�����K����
    vvX = vvXI * XIXM + vvET * ETXM + vvZE * ZEXM
    vvY = vvXI * XIYM + vvET * ETYM + vvZE * ZEYM
    vvZ = vvXI * XIZM + vvET * ETZM + vvZE * ZEZM
    ! ww �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    wwXI = 0.25 * ( - ww(I-1,J,K) - ww(I-1,J,K+1) &
    &               + ww(I+1,J,K) + ww(I+1,J,K+1) )
    wwET = 0.25 * ( - ww(I,J-1,K) - ww(I,J-1,K+1) &
    &               + ww(I,J+1,K) + ww(I,J+1,K+1) )
    wwZE = - ww(I,J,K) + ww(I,J,K+1)
    ! ������ԕ�����K����
    wwX = wwXI * XIXM + wwET * ETXM + wwZE * ZEXM
    wwY = wwXI * XIYM + wwET * ETYM + wwZE * ZEYM
    wwZ = wwXI * XIZM + wwET * ETZM + wwZE * ZEZM
    ! uv �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    uvXI = 0.25 * ( - uv(I-1,J,K) - uv(I-1,J,K+1) &
    &               + uv(I+1,J,K) + uv(I+1,J,K+1) )
    uvET = 0.25 * ( - uv(I,J-1,K) - uv(I,J-1,K+1) &
    &               + uv(I,J+1,K) + uv(I,J+1,K+1) )
    uvZE = - uv(I,J,K) + uv(I,J,K+1)
    ! ������ԕ�����K����
    uvX = uvXI * XIXM + uvET * ETXM + uvZE * ZEXM
    uvY = uvXI * XIYM + uvET * ETYM + uvZE * ZEYM
    uvZ = uvXI * XIZM + uvET * ETZM + uvZE * ZEZM
    ! vw �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    vwXI = 0.25 * ( - vw(I-1,J,K) - vw(I-1,J,K+1) &
    &               + vw(I+1,J,K) + vw(I+1,J,K+1) )
    vwET = 0.25 * ( - vw(I,J-1,K) - vw(I,J-1,K+1) &
    &               + vw(I,J+1,K) + vw(I,J+1,K+1) )
    vwZE = - vw(I,J,K) + vw(I,J,K+1)
    ! ������ԕ�����K����
    vwX = vwXI * XIXM + vwET * ETXM + vwZE * ZEXM
    vwY = vwXI * XIYM + vwET * ETYM + vwZE * ZEYM
    vwZ = vwXI * XIZM + vwET * ETZM + vwZE * ZEZM
    ! wu �̈�K�����̌v�Z ----------------------------------------------
    ! �v�Z��ԕ�����K����
    wuXI = 0.25 * ( - wu(I-1,J,K) - wu(I-1,J,K+1) &
    &               + wu(I+1,J,K) + wu(I+1,J,K+1) )
    wuET = 0.25 * ( - wu(I,J-1,K) - wu(I,J-1,K+1) &
    &               + wu(I,J+1,K) + wu(I,J+1,K+1) )
    wuZE = - wu(I,J,K) + wu(I,J,K+1)
    ! ������ԕ�����K����
    wuX = wuXI * XIXM + wuET * ETXM + wuZE * ZEXM
    wuY = wuXI * XIYM + wuET * ETYM + wuZE * ZEYM
    wuZ = wuXI * XIZM + wuET * ETZM + wuZE * ZEZM
    ! epsilon �̈�K�����̌v�Z -----------------------------------------
    ! �v�Z��ԕ�����K����
    AEXI = 0.25 * ( - EPS(I-1,J,K) - EPS(I-1,J,K+1) &
    &               + EPS(I+1,J,K) + EPS(I+1,J,K+1) )
    AEET = 0.25 * ( - EPS(I,J-1,K) - EPS(I,J-1,K+1) &
    &               + EPS(I,J+1,K) + EPS(I,J+1,K+1) )
    AEZE = - EPS(I,J,K) + EPS(I,J,K+1)
    ! ������ԕ�����K����
    AEX = AEXI * XIXM + AEET * ETXM + AEZE * ZEXM
    AEY = AEXI * XIYM + AEET * ETYM + AEZE * ZEYM
    AEZ = AEXI * XIZM + AEET * ETZM + AEZE * ZEZM
    ! ���S�x -----------------------------------------------------------
    nu = AMUM / RHOM
    ! �c�ݑ��x ---------------------------------------------------------
    SS  = (UX + VY + WZ) * TwoThird
    S11 = 2.0 * UX - SS
    S22 = 2.0 * VY - SS
    S33 = 2.0 * WZ - SS
    S12 = UY + VX
    S23 = VZ + WY
    S31 = WX + UZ
    ! U �̊g�U ---------------------------------------------------------
    R02M = nu * S11
    S02M = nu * S12
    T02M = nu * S31
    R02T =-uuM
    S02T =-uvM
    T02T =-wuM
    ! V �̊g�U ---------------------------------------------------------
    R03M = nu * S12
    S03M = nu * S22
    T03M = nu * S23
    R03T =-uvM
    S03T =-vvM
    T03T =-vwM
    ! W �̊g�U ---------------------------------------------------------
    R04M = nu * S31
    S04M = nu * S23
    T04M = nu * S33
    R04T =-wuM
    S04T =-vwM
    T04T =-wwM
    ! �G�l���M�[�̊g�U -------------------------------------------------
    C_p  = GAMMA * RG / (GAMMA - 1.0)
    IF(EPSM .GT. ZERO) THEN
      AKAE = 0.5 * (uuM + vvM + wwM) / EPSM
    ELSE
      AKAE = 0.0
    ENDIF
    R05M = C_p * nu / PR * TX + nu * (S11 * UM + S12 * VM + S31 * WM)
    S05M = C_p * nu / PR * TY + nu * (S12 * UM + S22 * VM + S23 * WM)
    T05M = C_p * nu / PR * TZ + nu * (S31 * UM + S23 * VM + S33 * WM)
    R05T = AKAE * C_se * C_p * (uuM * TX + uvM * TY + wuM * TZ) &
    &    + AKAE * C_s  * ( &
    &      uuM * (uuX + vvX + wwX) &
    &    + uvM * (uuY + vvY + wwY) &
    &    + wuM * (uuZ + vvZ + wwZ) &
    &    ) &
    &    - (uuM * UM + uvM * VM + wuM * WM)
    S05T = AKAE * C_se * C_p * (uvM * TX + vvM * TY + vwM * TZ) &
    &    + AKAE * C_s  * ( &
    &      uvM * (uuX + vvX + wwX) &
    &    + vvM * (uuY + vvY + wwY) &
    &    + vwM * (uuZ + vvZ + wwZ) &
    &    ) &
    &    - (uvM * UM + vvM * VM + vwM * WM)
    T05T = AKAE * C_se * C_p * (wuM * TX + vwM * TY + wwM * TZ) &
    &    + AKAE * C_s  * ( &
    &      wuM * (uuX + vvX + wwX) &
    &    + vwM * (uuY + vvY + wwY) &
    &    + wwM * (uuZ + vvZ + wwZ) &
    &    ) &
    &    - (wuM * UM + vwM * VM + wwM * WM)
    ! uu �̊g�U --------------------------------------------------------
    R06M = nu * uuX
    S06M = nu * uuY
    T06M = nu * uuZ
    R06T = C_s * AKAE * (uuM * uuX + uvM * uuY + wuM * uuZ)
    S06T = C_s * AKAE * (uvM * uuX + vvM * uuY + vwM * uuZ)
    T06T = C_s * AKAE * (wuM * uuX + vwM * uuY + wwM * uuZ)
    ! vv �̊g�U --------------------------------------------------------
    R07M = nu * vvX
    S07M = nu * vvY
    T07M = nu * vvZ
    R07T = C_s * AKAE * (uuM * vvX + uvM * vvY + wuM * vvZ)
    S07T = C_s * AKAE * (uvM * vvX + vvM * vvY + vwM * vvZ)
    T07T = C_s * AKAE * (wuM * vvX + vwM * vvY + wwM * vvZ)
    ! ww �̊g�U --------------------------------------------------------
    R08M = nu * wwX
    S08M = nu * wwY
    T08M = nu * wwZ
    R08T = C_s * AKAE * (uuM * wwX + uvM * wwY + wuM * wwZ)
    S08T = C_s * AKAE * (uvM * wwX + vvM * wwY + vwM * wwZ)
    T08T = C_s * AKAE * (wuM * wwX + vwM * wwY + wwM * wwZ)
    ! uv �̊g�U --------------------------------------------------------
    R09M = nu * uvX
    S09M = nu * uvY
    T09M = nu * uvZ
    R09T = C_s * AKAE * (uuM * uvX + uvM * uvY + wuM * uvZ)
    S09T = C_s * AKAE * (uvM * uvX + vvM * uvY + vwM * uvZ)
    T09T = C_s * AKAE * (wuM * uvX + vwM * uvY + wwM * uvZ)
    ! vw �̊g�U --------------------------------------------------------
    R10M = nu * vwX
    S10M = nu * vwY
    T10M = nu * vwZ
    R10T = C_s * AKAE * (uuM * vwX + uvM * vwY + wuM * vwZ)
    S10T = C_s * AKAE * (uvM * vwX + vvM * vwY + vwM * vwZ)
    T10T = C_s * AKAE * (wuM * vwX + vwM * vwY + wwM * vwZ)
    ! wu �̊g�U --------------------------------------------------------
    R11M = nu * wuX
    S11M = nu * wuY
    T11M = nu * wuZ
    R11T = C_s * AKAE * (uuM * wuX + uvM * wuY + wuM * wuZ)
    S11T = C_s * AKAE * (uvM * wuX + vvM * wuY + vwM * wuZ)
    T11T = C_s * AKAE * (wuM * wuX + vwM * wuY + wwM * wuZ)
    ! epsilon �̊g�U ---------------------------------------------------
    R12M = nu * AEX
    S12M = nu * AEY
    T12M = nu * AEZ
    R12T = C_e * AKAE * (uuM * AEX + uvM * AEY + wuM * AEZ)
    S12T = C_e * AKAE * (uvM * AEX + vvM * AEY + vwM * AEZ)
    T12T = C_e * AKAE * (wuM * AEX + vwM * AEY + wwM * AEZ)
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    TH(I,J,K, 1) = 0.0
    TH(I,J,K, 2) = QH1 * ( (R02M + R02T) * ZEXM &
    &                    + (S02M + S02T) * ZEYM &
    &                    + (T02M + T02T) * ZEZM )
    TH(I,J,K, 3) = QH1 * ( (R03M + R03T) * ZEXM &
    &                    + (S03M + S03T) * ZEYM &
    &                    + (T03M + T03T) * ZEZM )
    TH(I,J,K, 4) = QH1 * ( (R04M + R04T) * ZEXM &
    &                    + (S04M + S04T) * ZEYM &
    &                    + (T04M + T04T) * ZEZM )
    TH(I,J,K, 5) = QH1 * ( (R05M + R05T) * ZEXM &
    &                    + (S05M + S05T) * ZEYM &
    &                    + (T05M + T05T) * ZEZM )
    TH(I,J,K, 6) = QH1 * ( (R06M + R06T) * ZEXM &
    &                    + (S06M + S06T) * ZEYM &
    &                    + (T06M + T06T) * ZEZM )
    TH(I,J,K, 7) = QH1 * ( (R07M + R07T) * ZEXM &
    &                    + (S07M + S07T) * ZEYM &
    &                    + (T07M + T07T) * ZEZM )
    TH(I,J,K, 8) = QH1 * ( (R08M + R08T) * ZEXM &
    &                    + (S08M + S08T) * ZEYM &
    &                    + (T08M + T08T) * ZEZM )
    TH(I,J,K, 9) = QH1 * ( (R09M + R09T) * ZEXM &
    &                    + (S09M + S09T) * ZEYM &
    &                    + (T09M + T09T) * ZEZM )
    TH(I,J,K,10) = QH1 * ( (R10M + R10T) * ZEXM &
    &                    + (S10M + S10T) * ZEYM &
    &                    + (T10M + T10T) * ZEZM )
    TH(I,J,K,11) = QH1 * ( (R11M + R11T) * ZEXM &
    &                    + (S11M + S11T) * ZEYM &
    &                    + (T11M + T11T) * ZEZM )
    TH(I,J,K,12) = QH1 * ( (R12M + R12T) * ZEXM &
    &                    + (S12M + S12T) * ZEYM &
    &                    + (T12M + T12T) * ZEZM )
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFZE
! ��`�I�� *************************************************************
END SUBROUTINE Turbulence3DRSMLS
!***********************************************************************
!**** �������f�� : LES, 0Eq, Coherent-Structure Smagorinsky Model   ****
!****              (Kobayashi, 2005, Phys. Fluids, 17, 045104)      ****
!**** �v�Z�Ώ� : �P��, �񎟌�, ���k��                               ****
!**** �v�Z�X�L�[�� : �񎟐��x���S����(�X�^�K�[�h�i�q��̓_���g�p)   ****
!***********************************************************************
SUBROUTINE Turbulence2DLESCSM( &
&            RG, GAMMA, PR, PRT, &
&            OmegaZ, &
&            IS, IE, JS, JE, LS, LE, &
&            XIX, XIY, ETX, ETY, AJA, &
&            RHO, U, V, T, AMU, &
&            AMUT, DQD &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, PARAMETER :: C1 = 0.05, C2 = 0.045
  REAL, PARAMETER :: ZERO = 1.0E-20
  REAL, PARAMETER :: TwoThird = 0.66666667
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: RG, GAMMA, PR, PRT
  REAL,    INTENT(IN)  :: OmegaZ
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE
  INTEGER, INTENT(IN)  :: LS, LE
  REAL,    INTENT(IN)  :: XIX(IS:IE, JS:JE), XIY(IS:IE, JS:JE), &
  &                       ETX(IS:IE, JS:JE), ETY(IS:IE, JS:JE), &
  &                       AJA(IS:IE, JS:JE)
  REAL,    INTENT(IN)  :: RHO(IS:IE, JS:JE), &
  &                       U(IS:IE, JS:JE), V(IS:IE, JS:JE), &
  &                       T(IS:IE, JS:JE)
  REAL,    INTENT(IN)  :: AMU(IS:IE, JS:JE)
  REAL,    INTENT(OUT) :: AMUT(IS:IE, JS:JE)
  REAL,    INTENT(OUT) :: DQD(IS:IE, JS:JE, LS:LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, ALLOCATABLE :: RH(:, :, :), SH(:, :, :)
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 4) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �������m�� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ALLOCATE(RH(IS: IE, JS: JE, LS: LE))
  ALLOCATE(SH(IS: IE, JS: JE, LS: LE))
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  AMUT = 0.0
  DQD  = 0.0
  ! �����葱���̌Ăяo�� +++++++++++++++++++++++++++++++++++++++++++++++
  CALL NonDiffTerm
  CALL DiffTerm
  ! �����I�� ***********************************************************
  RETURN
! �����葱�� ***********************************************************
CONTAINS
!***********************************************************************
!**** ��g�U���̌v�Z                                                ****
!***********************************************************************
SUBROUTINE NonDiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: UXI, VXI, UET, VET
  REAL    :: UX, VX, UY, VY
  REAL    :: S11, S22, S12, SS
  REAL    :: O12
  REAL    :: Q, E, FCS, FO, C, SS2
  ! �����J�n ***********************************************************
  ! �Q�S���W���̌v�Z +++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, &
!$OMP& UXI, VXI, UET, VET, UX, VX, UY, VY, &
!$OMP& S11, S22, S12, SS, O12, &
!$OMP& Q, E, FCS, FO, C, SS2 &
!$OMP& )
  DO J = JS, JE
  DO I = IS, IE
  IF(RHO(I,J) .GT. 0.0) THEN
    ! ���x���z
    IF(I .EQ. IS)THEN
      IF(RHO(I+1,J) .GT. 0.0 .AND. RHO(I+2,J) .GT. 0.0) THEN
        UXI =-1.5 * U(I,J) + 2.0 * U(I+1,J) - 0.5 * U(I+2,J)
        VXI =-1.5 * V(I,J) + 2.0 * V(I+1,J) - 0.5 * V(I+2,J)
      ELSE
        UXI = 0.0
        VXI = 0.0
      ENDIF
    ELSE IF(I .EQ. IE)THEN
      IF(RHO(I-2,J) .GT. 0.0 .AND. RHO(I-1,J) .GT. 0.0) THEN
        UXI = 0.5 * U(I-2,J) - 2.0 * U(I-1,J) + 1.5 * U(I,J)
        VXI = 0.5 * V(I-2,J) - 2.0 * V(I-1,J) + 1.5 * V(I,J)
      ELSE
        UXI = 0.0
        VXI = 0.0
      ENDIF
    ELSE
      IF(RHO(I-1,J) .GT. 0.0 .AND. RHO(I+1,J) .GT. 0.0) THEN
        UXI =-0.5 * (U(I-1,J) - U(I+1,J))
        VXI =-0.5 * (V(I-1,J) - V(I+1,J))
      ELSE
        UXI = 0.0
        VXI = 0.0
      ENDIF
    ENDIF
    IF(J .EQ. JS)THEN
      IF(RHO(I,J+1) .GT. 0.0 .AND. RHO(I,J+2) .GT. 0.0) THEN
        UET =-1.5 * U(I,J) + 2.0 * U(I,J+1) - 0.5 * U(I,J+2)
        VET =-1.5 * V(I,J) + 2.0 * V(I,J+1) - 0.5 * V(I,J+2)
      ELSE
        UET = 0.0
        VET = 0.0
      ENDIF
    ELSE IF(J .EQ. JE)THEN
      IF(RHO(I,J-2) .GT. 0.0 .AND. RHO(I,J-1) .GT. 0.0) THEN
        UET = 0.5 * U(I,J-2) - 2.0 * U(I,J-1) + 1.5 * U(I,J)
        VET = 0.5 * V(I,J-2) - 2.0 * V(I,J-1) + 1.5 * V(I,J)
      ELSE
        UET = 0.0
        VET = 0.0
      ENDIF
    ELSE
      IF(RHO(I,J-1) .GT. 0.0 .AND. RHO(I,J+1) .GT. 0.0) THEN
        UET =-0.5 * (U(I,J-1) - U(I,J+1))
        VET =-0.5 * (V(I,J-1) - V(I,J+1))
      ELSE
        UET = 0.0
        VET = 0.0
      ENDIF
    ENDIF
    UX = XIX(I,J) * UXI + ETX(I,J) * UET
    UY = XIY(I,J) * UXI + ETY(I,J) * UET
    VX = XIX(I,J) * VXI + ETX(I,J) * VET
    VY = XIY(I,J) * VXI + ETY(I,J) * VET
    ! �c�ݑ��x�e���\��, �p���x�e���\��
    SS  = (UX + VY) / 3.0
    S11 = UX - SS
    S22 = VY - SS
    S12 = 0.5 * (UY + VX)
    O12 = 0.5 * (UY - VX) - OmegaZ
    ! ���x���z�̑��s�ϗ�
    Q   = O12 * O12 - S12 * S12 &
    &   - 0.5 * (S11 * S11 + S22 * S22)
    ! ���x���z�̑傫��
    E   = O12 * O12 + S12 * S12 &
    &   + 0.5 * (S11 * S11 + S22 * S22)
    ! �W��
    IF(E .GT. ZERO) THEN
      FCS = Q / E
    ELSE
      FCS = 1.0
    ENDIF
    FO  = 1.0 - FCS
    C   = C2 * (ABS(FCS))**1.5 * FO
    SS2 = S11 * S11 + S22 * S22 + 2.0 * S12 * S12
    SS2 = SQRT(2.0 * SS2)
    AMUT(I,J) = RHO(I,J) * 2.0 * C * SS2 / AJA(I,J)
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE NonDiffTerm
!***********************************************************************
!**** �g�U���̌v�Z                                                  ****
!***********************************************************************
SUBROUTINE DiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, L
  ! �����J�n ***********************************************************
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  RH = 0.0
  SH = 0.0
  ! �g�U���̗v�f���v�Z +++++++++++++++++++++++++++++++++++++++++++++++++
  CALL DIFFXI
  CALL DIFFET
  ! �g�U���̍��� +++++++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE(I, J, L)
  DO L = LS, LE
  !$OMP DO
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( (RHO(I,J-1) .GT. 0.0) .AND. (RHO(I-1,J) .GT. 0.0) .AND. &
  &   (RHO(I,J)   .GT. 0.0) .AND. &
  &   (RHO(I+1,J) .GT. 0.0) .AND. (RHO(I,J+1) .GT. 0.0) &
  & ) THEN
    DQD(I,J,L) = (-RH(I-1,J  ,L) + RH(I,J,L)) &
    &          + (-SH(I  ,J-1,L) + SH(I,J,L))
  ENDIF
  ENDDO
  ENDDO
  !$OMP END DO
  ENDDO
  !$OMP END PARALLEL
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DiffTerm
!***********************************************************************
!**** �g�U���̌v�Z(xi���������p)                                    ****
!***********************************************************************
SUBROUTINE DIFFXI
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: XIXM, XIYM, ETXM, ETYM, AJAM
  REAL    :: RHOM, UM, VM, TM, AMUM, AMUTM
  REAL    :: UXI, UET, UX, UY
  REAL    :: VXI, VET, VX, VY
  REAL    :: TXI, TET, TX, TY
  REAL    :: nu, nu_t
  REAL    :: c_u, c_t
  REAL    :: TAUXX, TAUYY, TAUXY, DELV
  REAL    :: R4, S4
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, &
!$OMP& XIXM, XIYM, ETXM, ETYM, AJAM, &
!$OMP& RHOM, UM, VM, TM, AMUM, AMUTM, &
!$OMP& UXI, UET, UX, UY, &
!$OMP& VXI, VET, VX, VY, &
!$OMP& TXI, TET, TX, TY, &
!$OMP& nu, nu_t, c_u, c_t, &
!$OMP& TAUXX, TAUYY, TAUXY, DELV, R4, S4, QH1 &
!$OMP& )
  DO J = JS + 1, JE - 1
  DO I = IS    , IE - 1
  IF( (RHO(I,J-1) .GT. 0.0) .AND. (RHO(I,J)   .GT. 0.0) .AND. &
  &   (RHO(I+1,J) .GT. 0.0) .AND. (RHO(I,J+1) .GT. 0.0)  &
  & ) THEN
    ! XI�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J) + XIX(I+1,J))
    XIYM = 0.5 * (XIY(I,J) + XIY(I+1,J))
    ETXM = 0.5 * (ETX(I,J) + ETX(I+1,J))
    ETYM = 0.5 * (ETY(I,J) + ETY(I+1,J))
    AJAM = 0.5 * (AJA(I,J) + AJA(I+1,J))
    ! ������
    RHOM  = 0.5 * ( RHO(I,J) +  RHO(I+1,J))
    UM    = 0.5 * (   U(I,J) +    U(I+1,J))
    VM    = 0.5 * (   V(I,J) +    V(I+1,J))
    TM    = 0.5 * (   T(I,J) +    T(I+1,J))
    AMUM  = 0.5 * ( AMU(I,J) +  AMU(I+1,J))
    AMUTM = 0.5 * (AMUT(I,J) + AMUT(I+1,J))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = - U(I,J) + U(I+1,J)
    VXI = - V(I,J) + V(I+1,J)
    UET = 0.25 * (- U(I,J-1) - U(I+1,J-1) + U(I,J+1) + U(I+1,J+1))
    VET = 0.25 * (- V(I,J-1) - V(I+1,J-1) + V(I,J+1) + V(I+1,J+1))
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM
    UY = UXI * XIYM + UET * ETYM
    VX = VXI * XIXM + VET * ETXM
    VY = VXI * XIYM + VET * ETYM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = - T(I,J) + T(I+1,J)
    TET = 0.25 * (- T(I,J-1) - T(I+1,J-1) + T(I,J+1) + T(I+1,J+1))
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM
    TY = TXI * XIYM + TET * ETYM
    ! �W���v�Z ---------------------------------------------------------
    nu   = AMUM  / RHOM
    nu_t = AMUTM / RHOM
    c_u  = nu + nu_t
    c_t  = (nu / PR + nu_t / PRT) / (GAMMA - 1.0) * GAMMA * RG
    ! �S�����͂ƃ��C�m���Y���̘͂a -------------------------------------
    DELV  = UX + VY
    TAUXX = c_u * (2.0 * UX - TwoThird * DELV) ! - TwoThird * AKM
    TAUYY = c_u * (2.0 * VY - TwoThird * DELV) ! - TwoThird * AKM
    TAUXY = c_u * (UY + VX)
    ! �G�l���M�[�̊g�U -------------------------------------------------
    R4 = TAUXX * UM + TAUXY * VM + c_t * TX
    S4 = TAUXY * UM + TAUYY * VM + c_t * TY
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    RH(I,J,1) = 0.0
    RH(I,J,2) = QH1 * (TAUXX * XIXM + TAUXY * XIYM)
    RH(I,J,3) = QH1 * (TAUXY * XIXM + TAUYY * XIYM)
    RH(I,J,4) = QH1 * (R4 * XIXM + S4 * XIYM)
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFXI
!***********************************************************************
!**** �g�U���̌v�Z(eta���������p)                                   ****
!***********************************************************************
SUBROUTINE DIFFET
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: XIXM, XIYM, ETXM, ETYM, AJAM
  REAL    :: RHOM, UM, VM, TM, AMUM, AMUTM
  REAL    :: UXI, UET, UX, UY
  REAL    :: VXI, VET, VX, VY
  REAL    :: TXI, TET, TX, TY
  REAL    :: nu, nu_t
  REAL    :: c_u, c_t
  REAL    :: TAUXX, TAUYY, TAUXY, DELV
  REAL    :: R4, S4
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, &
!$OMP& XIXM, XIYM, ETXM, ETYM, AJAM, &
!$OMP& RHOM, UM, VM, TM, AMUM, AMUTM, &
!$OMP& UXI, UET, UX, UY, &
!$OMP& VXI, VET, VX, VY, &
!$OMP& TXI, TET, TX, TY, &
!$OMP& nu, nu_t, c_u, c_t, &
!$OMP& TAUXX, TAUYY, TAUXY, DELV, R4, S4, QH1 &
!$OMP& )
  DO J = JS    , JE - 1
  DO I = IS + 1, IE - 1
  IF( (RHO(I-1,J) .GT. 0.0) .AND. (RHO(I,J)   .GT. 0.0) .AND. &
  &   (RHO(I+1,J) .GT. 0.0) .AND. (RHO(I,J+1) .GT. 0.0) &
  & ) THEN
    ! ET�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J) + XIX(I,J+1))
    XIYM = 0.5 * (XIY(I,J) + XIY(I,J+1))
    ETXM = 0.5 * (ETX(I,J) + ETX(I,J+1))
    ETYM = 0.5 * (ETY(I,J) + ETY(I,J+1))
    AJAM = 0.5 * (AJA(I,J) + AJA(I,J+1))
    ! ������
    RHOM  = 0.5 * ( RHO(I,J) +  RHO(I,J+1))
    UM    = 0.5 * (   U(I,J) +    U(I,J+1))
    VM    = 0.5 * (   V(I,J) +    V(I,J+1))
    TM    = 0.5 * (   T(I,J) +    T(I,J+1))
    AMUM  = 0.5 * ( AMU(I,J) +  AMU(I,J+1))
    AMUTM = 0.5 * (AMUT(I,J) + AMUT(I,J+1))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = 0.25 * (- U(I-1,J) - U(I-1,J+1) + U(I+1,J) + U(I+1,J+1))
    VXI = 0.25 * (- V(I-1,J) - V(I-1,J+1) + V(I+1,J) + V(I+1,J+1))
    UET = - U(I,J) + U(I,J+1)
    VET = - V(I,J) + V(I,J+1)
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM
    UY = UXI * XIYM + UET * ETYM
    VX = VXI * XIXM + VET * ETXM
    VY = VXI * XIYM + VET * ETYM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = 0.25 * (- T(I-1,J) - T(I-1,J+1) + T(I+1,J) + T(I+1,J+1))
    TET = - T(I,J) + T(I,J+1)
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM
    TY = TXI * XIYM + TET * ETYM
    ! �W���v�Z ---------------------------------------------------------
    nu   = AMUM  / RHOM
    nu_t = AMUTM / RHOM
    c_u  = nu + nu_t
    c_t  = (nu / PR + nu_t / PRT) / (GAMMA - 1.0) * GAMMA * RG
    ! �S�����͂ƃ��C�m���Y���̘͂a -------------------------------------
    DELV  = UX + VY
    TAUXX = c_u * (2.0 * UX - TwoThird * DELV) ! - TwoThird * AKM
    TAUYY = c_u * (2.0 * VY - TwoThird * DELV) ! - TwoThird * AKM
    TAUXY = c_u * (UY + VX)
    ! �G�l���M�[�̊g�U -------------------------------------------------
    R4 = TAUXX * UM + TAUXY * VM + c_t * TX
    S4 = TAUXY * UM + TAUYY * VM + c_t * TY
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    SH(I,J,1) = 0.0
    SH(I,J,2) = QH1 * (TAUXX * ETXM + TAUXY * ETYM)
    SH(I,J,3) = QH1 * (TAUXY * ETXM + TAUYY * ETYM)
    SH(I,J,4) = QH1 * (R4 * ETXM + S4 * ETYM)
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFET
! ��`�I�� *************************************************************
END SUBROUTINE Turbulence2DLESCSM
!***********************************************************************
!**** �������f�� : LES, 0Eq, Coherent-Structure Smagorinsky Model   ****
!****              (Kobayashi, 2005, Phys. Fluids, 17, 045104)      ****
!**** �v�Z�Ώ� : �P��, �O����, ���k��                               ****
!**** �v�Z�X�L�[�� : �񎟐��x���S����(�X�^�K�[�h�i�q��̓_���g�p)   ****
!***********************************************************************
SUBROUTINE Turbulence3DLESCSM( &
&            RG, GAMMA, PR, PRT, &
&            OmegaX, OmegaY, OmegaZ, &
&            IS, IE, JS, JE, KS, KE, LS, LE, &
&            XIX, XIY, XIZ, ETX, ETY, ETZ, ZEX, ZEY, ZEZ, AJA, &
&            RHO, U, V, W, T, AMU, &
&            AMUT, DQD &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, PARAMETER :: C1 = 0.05, C2 = 0.045
  REAL, PARAMETER :: ZERO = 1.0E-20
  REAL, PARAMETER :: TwoThird = 0.66666667
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: RG, GAMMA, PR, PRT
  REAL,    INTENT(IN)  :: OmegaX, OmegaY, OmegaZ
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE, KS, KE
  INTEGER, INTENT(IN)  :: LS, LE
  REAL,    INTENT(IN)  :: XIX(IS:IE, JS:JE, KS:KE), &
  &                       XIY(IS:IE, JS:JE, KS:KE), &
  &                       XIZ(IS:IE, JS:JE, KS:KE), &
  &                       ETX(IS:IE, JS:JE, KS:KE), &
  &                       ETY(IS:IE, JS:JE, KS:KE), &
  &                       ETZ(IS:IE, JS:JE, KS:KE), &
  &                       ZEX(IS:IE, JS:JE, KS:KE), &
  &                       ZEY(IS:IE, JS:JE, KS:KE), &
  &                       ZEZ(IS:IE, JS:JE, KS:KE), &
  &                       AJA(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)  :: RHO(IS:IE, JS:JE, KS:KE), &
  &                       U(IS:IE, JS:JE, KS:KE), &
  &                       V(IS:IE, JS:JE, KS:KE), &
  &                       W(IS:IE, JS:JE, KS:KE), &
  &                       T(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)  :: AMU(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(OUT) :: AMUT(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(OUT) :: DQD(IS:IE, JS:JE, KS:KE, LS:LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, ALLOCATABLE :: RH(:, :, :, :), SH(:, :, :, :), TH(:, :, :, :)
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 5) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! �������m�� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ALLOCATE(RH(IS: IE, JS: JE, KS: KE, LS: LE))
  ALLOCATE(SH(IS: IE, JS: JE, KS: KE, LS: LE))
  ALLOCATE(TH(IS: IE, JS: JE, KS: KE, LS: LE))
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  AMUT = 0.0
  DQD  = 0.0
  ! �����葱���̌Ăяo�� +++++++++++++++++++++++++++++++++++++++++++++++
  CALL NonDiffTerm
  CALL DiffTerm
  ! �����I�� ***********************************************************
  RETURN
! �����葱�� ***********************************************************
CONTAINS
!***********************************************************************
!**** ��g�U���̌v�Z                                                ****
!***********************************************************************
SUBROUTINE NonDiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: UXI, VXI, WXI, UET, VET, WET, UZE, VZE, WZE
  REAL    :: UX, VX, WX, UY, VY, WY, UZ, VZ, WZ
  REAL    :: S11, S22, S33, S12, S23, S31, SS
  REAL    :: O12, O23, O31
  REAL    :: Q, E, FCS, FO, C, SS2
  ! �����J�n ***********************************************************
  ! �Q�S���W���̌v�Z +++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& UXI, VXI, WXI, UET, VET, WET, UZE, VZE, WZE, &
!$OMP& UX, VX, WX, UY, VY, WY, UZ, VZ, WZ, &
!$OMP& S11, S22, S33, S12, S23, S31, SS, &
!$OMP& O12, O23, O31, &
!$OMP& Q, E, FCS, FO, C, SS2 &
!$OMP& )
  DO K = KS, KE
  DO J = JS, JE
  DO I = IS, IE
  IF(RHO(I,J,K) .GT. 0.0) THEN
    ! ���x���z
    IF(I .EQ. IS)THEN
      IF(RHO(I+1,J,K) .GT. 0.0 .AND. RHO(I+2,J,K) .GT. 0.0) THEN
        UXI =-1.5 * U(I,J,K) + 2.0 * U(I+1,J,K) - 0.5 * U(I+2,J,K)
        VXI =-1.5 * V(I,J,K) + 2.0 * V(I+1,J,K) - 0.5 * V(I+2,J,K)
        WXI =-1.5 * W(I,J,K) + 2.0 * W(I+1,J,K) - 0.5 * W(I+2,J,K)
      ELSE
        UXI = 0.0
        VXI = 0.0
        WXI = 0.0
      ENDIF
    ELSE IF(I .EQ. IE)THEN
      IF(RHO(I-2,J,K) .GT. 0.0 .AND. RHO(I-1,J,K) .GT. 0.0) THEN
        UXI = 0.5 * U(I-2,J,K) - 2.0 * U(I-1,J,K) + 1.5 * U(I,J,K)
        VXI = 0.5 * V(I-2,J,K) - 2.0 * V(I-1,J,K) + 1.5 * V(I,J,K)
        WXI = 0.5 * W(I-2,J,K) - 2.0 * W(I-1,J,K) + 1.5 * W(I,J,K)
      ELSE
        UXI = 0.0
        VXI = 0.0
        WXI = 0.0
      ENDIF
    ELSE
      IF(RHO(I-1,J,K) .GT. 0.0 .AND. RHO(I+1,J,K) .GT. 0.0) THEN
        UXI =-0.5 * (U(I-1,J,K) - U(I+1,J,K))
        VXI =-0.5 * (V(I-1,J,K) - V(I+1,J,K))
        WXI =-0.5 * (W(I-1,J,K) - W(I+1,J,K))
      ELSE
        UXI = 0.0
        VXI = 0.0
        WXI = 0.0
      ENDIF
    ENDIF
    IF(J .EQ. JS)THEN
      IF(RHO(I,J+1,K) .GT. 0.0 .AND. RHO(I,J+2,K) .GT. 0.0) THEN
        UET =-1.5 * U(I,J,K) + 2.0 * U(I,J+1,K) - 0.5 * U(I,J+2,K)
        VET =-1.5 * V(I,J,K) + 2.0 * V(I,J+1,K) - 0.5 * V(I,J+2,K)
        WET =-1.5 * W(I,J,K) + 2.0 * W(I,J+1,K) - 0.5 * W(I,J+2,K)
      ELSE
        UET = 0.0
        VET = 0.0
        WET = 0.0
      ENDIF
    ELSE IF(J .EQ. JE)THEN
      IF(RHO(I,J-2,K) .GT. 0.0 .AND. RHO(I,J-1,K) .GT. 0.0) THEN
        UET = 0.5 * U(I,J-2,K) - 2.0 * U(I,J-1,K) + 1.5 * U(I,J,K)
        VET = 0.5 * V(I,J-2,K) - 2.0 * V(I,J-1,K) + 1.5 * V(I,J,K)
        WET = 0.5 * W(I,J-2,K) - 2.0 * W(I,J-1,K) + 1.5 * W(I,J,K)
      ELSE
        UET = 0.0
        VET = 0.0
        WET = 0.0
      ENDIF
    ELSE
      IF(RHO(I,J-1,K) .GT. 0.0 .AND. RHO(I,J+1,K) .GT. 0.0) THEN
        UET =-0.5 * (U(I,J-1,K) - U(I,J+1,K))
        VET =-0.5 * (V(I,J-1,K) - V(I,J+1,K))
        WET =-0.5 * (W(I,J-1,K) - W(I,J+1,K))
      ELSE
        UET = 0.0
        VET = 0.0
        WET = 0.0
      ENDIF
    ENDIF
    IF(K .EQ. KS)THEN
      IF(RHO(I,J,K+1) .GT. 0.0 .AND. RHO(I,J,K+2) .GT. 0.0) THEN
        UZE =-1.5 * U(I,J,K) + 2.0 * U(I,J,K+1) - 0.5 * U(I,J,K+2)
        VZE =-1.5 * V(I,J,K) + 2.0 * V(I,J,K+1) - 0.5 * V(I,J,K+2)
        WZE =-1.5 * W(I,J,K) + 2.0 * W(I,J,K+1) - 0.5 * W(I,J,K+2)
      ELSE
        UZE = 0.0
        VZE = 0.0
        WZE = 0.0
      ENDIF
    ELSE IF(K .EQ. KE)THEN
      IF(RHO(I,J,K-2) .GT. 0.0 .AND. RHO(I,J,K-1) .GT. 0.0) THEN
        UZE = 0.5 * U(I,J,K-2) - 2.0 * U(I,J,K-1) + 1.5 * U(I,J,K)
        VZE = 0.5 * V(I,J,K-2) - 2.0 * V(I,J,K-1) + 1.5 * V(I,J,K)
        WZE = 0.5 * W(I,J,K-2) - 2.0 * W(I,J,K-1) + 1.5 * W(I,J,K)
      ELSE
        UZE = 0.0
        VZE = 0.0
        WZE = 0.0
      ENDIF
    ELSE
      IF(RHO(I,J,K-1) .GT. 0.0 .AND. RHO(I,J,K+1) .GT. 0.0) THEN
        UZE =-0.5 * (U(I,J,K-1) - U(I,J,K+1))
        VZE =-0.5 * (V(I,J,K-1) - V(I,J,K+1))
        WZE =-0.5 * (W(I,J,K-1) - W(I,J,K+1))
      ELSE
        UZE = 0.0
        VZE = 0.0
        WZE = 0.0
      ENDIF
    ENDIF
    UX = XIX(I,J,K) * UXI + ETX(I,J,K) * UET + ZEX(I,J,K) * UZE
    UY = XIY(I,J,K) * UXI + ETY(I,J,K) * UET + ZEY(I,J,K) * UZE
    UZ = XIZ(I,J,K) * UXI + ETZ(I,J,K) * UET + ZEZ(I,J,K) * UZE
    VX = XIX(I,J,K) * VXI + ETX(I,J,K) * VET + ZEX(I,J,K) * VZE
    VY = XIY(I,J,K) * VXI + ETY(I,J,K) * VET + ZEY(I,J,K) * VZE
    VZ = XIZ(I,J,K) * VXI + ETZ(I,J,K) * VET + ZEZ(I,J,K) * VZE
    WX = XIX(I,J,K) * WXI + ETX(I,J,K) * WET + ZEX(I,J,K) * WZE
    WY = XIY(I,J,K) * WXI + ETY(I,J,K) * WET + ZEY(I,J,K) * WZE
    WZ = XIZ(I,J,K) * WXI + ETZ(I,J,K) * WET + ZEZ(I,J,K) * WZE
    ! �c�ݑ��x�e���\��, �p���x�e���\��
    SS  = (UX + VY + WZ) / 3.0
    S11 = UX - SS
    S22 = VY - SS
    S33 = WZ - SS
    S12 = 0.5 * (UY + VX)
    S23 = 0.5 * (VZ + WY)
    S31 = 0.5 * (WX + UZ)
    O12 = 0.5 * (UY - VX) - OmegaZ
    O23 = 0.5 * (VZ - WY) - OmegaX
    O31 = 0.5 * (WX - UZ) - OmegaY
    ! ���x���z�̑��s�ϗ�
    Q   = O12 * O12 - S12 * S12 &
    &   + O23 * O23 - S23 * S23 &
    &   + O31 * O31 - S31 * S31 &
    &   - 0.5 * (S11 * S11 + S22 * S22 + S33 * S33)
    ! ���x���z�̑傫��
    E   = O12 * O12 + S12 * S12 &
    &   + O23 * O23 + S23 * S23 &
    &   + O31 * O31 + S31 * S31 &
    &   + 0.5 * (S11 * S11 + S22 * S22 + S33 * S33)
    ! �W��
    IF(E .GT. ZERO) THEN
      FCS = Q / E
    ELSE
      FCS = 1.0
    ENDIF
    FO  = 1.0 - FCS
    C   = C2 * (ABS(FCS))**1.5 * FO
    SS2 = S11 * S11 + S22 * S22 + S33 * S33 &
    &   + 2.0 * (S12 * S12 + S23 * S23 + S31 * S31)
    SS2 = SQRT(2.0 * SS2)
    AMUT(I,J,K) = RHO(I,J,K) * 2.0 * C * SS2 / AJA(I,J,K)**(2.0 / 3.0)
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE NonDiffTerm
!***********************************************************************
!**** �g�U���̌v�Z                                                  ****
!***********************************************************************
SUBROUTINE DiffTerm
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K, L
  ! �����J�n ***********************************************************
  ! ������ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  RH = 0.0
  SH = 0.0
  TH = 0.0
  ! �g�U���̗v�f���v�Z +++++++++++++++++++++++++++++++++++++++++++++++++
  CALL DIFFXI
  CALL DIFFET
  CALL DIFFZE
  ! �g�U���̍��� +++++++++++++++++++++++++++++++++++++++++++++++++++++++
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE(I, J, K, L)
  DO L = LS, LE
  !$OMP DO
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( (RHO(I,J,K-1) .GT. 0.0) .AND. (RHO(I,J-1,K) .GT. 0.0) .AND. &
  &   (RHO(I-1,J,K) .GT. 0.0) .AND. (RHO(I,J,K)   .GT. 0.0) .AND. &
  &   (RHO(I+1,J,K) .GT. 0.0) .AND. (RHO(I,J+1,K) .GT. 0.0) .AND. &
  &   (RHO(I,J,K+1) .GT. 0.0) &
  & ) THEN
    DQD(I,J,K,L) = (-RH(I-1,J  ,K  ,L) + RH(I,J,K,L) ) &
    &            + (-SH(I  ,J-1,K  ,L) + SH(I,J,K,L) ) &
    &            + (-TH(I  ,J  ,K-1,L) + TH(I,J,K,L) )
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END DO
  ENDDO
  !$OMP END PARALLEL
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DiffTerm
!***********************************************************************
!**** �g�U���̌v�Z(xi���������p)                                    ****
!***********************************************************************
SUBROUTINE DIFFXI
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM
  REAL    :: RHOM, UM, VM, WM, TM, AMUM, AMUTM
  REAL    :: UXI, UET, UZE, UX, UY, UZ
  REAL    :: VXI, VET, VZE, VX, VY, VZ
  REAL    :: WXI, WET, WZE, WX, WY, WZ
  REAL    :: TXI, TET, TZE, TX, TY, TZ
  REAL    :: nu, nu_t
  REAL    :: c_u, c_t
  REAL    :: TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX, DELV
  REAL    :: R5, S5, T5
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM, &
!$OMP& RHOM, UM, VM, WM, TM, AMUM, AMUTM, &
!$OMP& UXI, UET, UZE, UX, UY, UZ, &
!$OMP& VXI, VET, VZE, VX, VY, VZ, &
!$OMP& WXI, WET, WZE, WX, WY, WZ, &
!$OMP& TXI, TET, TZE, TX, TY, TZ, &
!$OMP& nu, nu_t, c_u, c_t, &
!$OMP& TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX, DELV, R5, S5, T5, QH1 &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS    , IE - 1
  IF( (RHO(I,J,K-1) .GT. 0.0) .AND. (RHO(I,J-1,K) .GT. 0.0) .AND. &
  &   (RHO(I,J,K)   .GT. 0.0) .AND. (RHO(I+1,J,K) .GT. 0.0) .AND. &
  &   (RHO(I,J+1,K) .GT. 0.0) .AND. (RHO(I,J,K+1) .GT. 0.0) &
  & ) THEN
    ! XI�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J,K) + XIX(I+1,J,K))
    XIYM = 0.5 * (XIY(I,J,K) + XIY(I+1,J,K))
    XIZM = 0.5 * (XIZ(I,J,K) + XIZ(I+1,J,K))
    ETXM = 0.5 * (ETX(I,J,K) + ETX(I+1,J,K))
    ETYM = 0.5 * (ETY(I,J,K) + ETY(I+1,J,K))
    ETZM = 0.5 * (ETZ(I,J,K) + ETZ(I+1,J,K))
    ZEXM = 0.5 * (ZEX(I,J,K) + ZEX(I+1,J,K))
    ZEYM = 0.5 * (ZEY(I,J,K) + ZEY(I+1,J,K))
    ZEZM = 0.5 * (ZEZ(I,J,K) + ZEZ(I+1,J,K))
    AJAM = 0.5 * (AJA(I,J,K) + AJA(I+1,J,K))
    ! ������
    RHOM  = 0.5 * ( RHO(I,J,K) +  RHO(I+1,J,K))
    UM    = 0.5 * (   U(I,J,K) +    U(I+1,J,K))
    VM    = 0.5 * (   V(I,J,K) +    V(I+1,J,K))
    WM    = 0.5 * (   W(I,J,K) +    W(I+1,J,K))
    TM    = 0.5 * (   T(I,J,K) +    T(I+1,J,K))
    AMUM  = 0.5 * ( AMU(I,J,K) +  AMU(I+1,J,K))
    AMUTM = 0.5 * (AMUT(I,J,K) + AMUT(I+1,J,K))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = - U(I,J,K) + U(I+1,J,K)
    VXI = - V(I,J,K) + V(I+1,J,K)
    WXI = - W(I,J,K) + W(I+1,J,K)
    UET = 0.25 * ( - U(I,J-1,K) - U(I+1,J-1,K) &
    &              + U(I,J+1,K) + U(I+1,J+1,K) )
    VET = 0.25 * ( - V(I,J-1,K) - V(I+1,J-1,K) &
    &              + V(I,J+1,K) + V(I+1,J+1,K) )
    WET = 0.25 * ( - W(I,J-1,K) - W(I+1,J-1,K) &
    &              + W(I,J+1,K) + W(I+1,J+1,K) )
    UZE = 0.25 * ( - U(I,J,K-1) - U(I+1,J,K-1) &
    &              + U(I,J,K+1) + U(I+1,J,K+1) )
    VZE = 0.25 * ( - V(I,J,K-1) - V(I+1,J,K-1) &
    &              + V(I,J,K+1) + V(I+1,J,K+1) )
    WZE = 0.25 * ( - W(I,J,K-1) - W(I+1,J,K-1) &
    &              + W(I,J,K+1) + W(I+1,J,K+1) )
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM + UZE * ZEXM
    UY = UXI * XIYM + UET * ETYM + UZE * ZEYM
    UZ = UXI * XIZM + UET * ETZM + UZE * ZEZM
    VX = VXI * XIXM + VET * ETXM + VZE * ZEXM
    VY = VXI * XIYM + VET * ETYM + VZE * ZEYM
    VZ = VXI * XIZM + VET * ETZM + VZE * ZEZM
    WX = WXI * XIXM + WET * ETXM + WZE * ZEXM
    WY = WXI * XIYM + WET * ETYM + WZE * ZEYM
    WZ = WXI * XIZM + WET * ETZM + WZE * ZEZM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = - T(I,J,K) + T(I+1,J,K)
    TET = 0.25 * ( - T(I,J-1,K) - T(I+1,J-1,K) &
    &              + T(I,J+1,K) + T(I+1,J+1,K) )
    TZE = 0.25 * ( - T(I,J,K-1) - T(I+1,J,K-1) &
    &              + T(I,J,K+1) + T(I+1,J,K+1) )
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM + TZE * ZEXM
    TY = TXI * XIYM + TET * ETYM + TZE * ZEYM
    TZ = TXI * XIZM + TET * ETZM + TZE * ZEZM
    ! �W���v�Z ---------------------------------------------------------
    nu   = AMUM  / RHOM
    nu_t = AMUTM / RHOM
    c_u  = nu + nu_t
    c_t  = (nu / PR + nu_t / PRT) / (GAMMA - 1.0) * GAMMA * RG
    ! �S�����͂ƃ��C�m���Y���̘͂a -------------------------------------
    DELV  = UX + VY + WZ
    TAUXX = c_u * (2.0 * UX - TwoThird * DELV) ! - TwoThird * AKM
    TAUYY = c_u * (2.0 * VY - TwoThird * DELV) ! - TwoThird * AKM
    TAUZZ = c_u * (2.0 * WZ - TwoThird * DELV) ! - TwoThird * AKM
    TAUXY = c_u * (UY + VX)
    TAUYZ = c_u * (VZ + WY)
    TAUZX = c_u * (WX + UZ)
    ! �G�l���M�[�̊g�U -------------------------------------------------
    R5 = TAUXX * UM + TAUXY * VM + TAUZX * WM + c_t * TX
    S5 = TAUXY * UM + TAUYY * VM + TAUYZ * WM + c_t * TY
    T5 = TAUZX * UM + TAUYZ * VM + TAUZZ * WM + c_t * TZ
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    RH(I,J,K,1) = 0.0
    RH(I,J,K,2) = QH1 * (TAUXX * XIXM + TAUXY * XIYM + TAUZX * XIZM)
    RH(I,J,K,3) = QH1 * (TAUXY * XIXM + TAUYY * XIYM + TAUYZ * XIZM)
    RH(I,J,K,4) = QH1 * (TAUZX * XIXM + TAUYZ * XIYM + TAUZZ * XIZM)
    RH(I,J,K,5) = QH1 * (R5 * XIXM + S5 * XIYM + T5 * XIZM)
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFXI
!***********************************************************************
!**** �g�U���̌v�Z(eta���������p)                                   ****
!***********************************************************************
SUBROUTINE DIFFET
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM
  REAL    :: RHOM, UM, VM, WM, TM, AMUM, AMUTM
  REAL    :: UXI, UET, UZE, UX, UY, UZ
  REAL    :: VXI, VET, VZE, VX, VY, VZ
  REAL    :: WXI, WET, WZE, WX, WY, WZ
  REAL    :: TXI, TET, TZE, TX, TY, TZ
  REAL    :: nu, nu_t
  REAL    :: c_u, c_t
  REAL    :: TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX, DELV
  REAL    :: R5, S5, T5
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM, &
!$OMP& RHOM, UM, VM, WM, TM, AMUM, AMUTM, &
!$OMP& UXI, UET, UZE, UX, UY, UZ, &
!$OMP& VXI, VET, VZE, VX, VY, VZ, &
!$OMP& WXI, WET, WZE, WX, WY, WZ, &
!$OMP& TXI, TET, TZE, TX, TY, TZ, &
!$OMP& nu, nu_t, c_u, c_t, &
!$OMP& TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX, DELV, R5, S5, T5, QH1 &
!$OMP& )
  DO K = KS + 1, KE - 1
  DO J = JS    , JE - 1
  DO I = IS + 1, IE - 1
  IF( (RHO(I,J,K-1) .GT. 0.0) .AND. (RHO(I-1,J,K) .GT. 0.0) .AND. &
  &   (RHO(I,J,K)   .GT. 0.0) .AND. (RHO(I+1,J,K) .GT. 0.0) .AND. &
  &   (RHO(I,J+1,K) .GT. 0.0) .AND. (RHO(I,J,K+1) .GT. 0.0) &
  & ) THEN
    ! ET�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J,K) + XIX(I,J+1,K))
    XIYM = 0.5 * (XIY(I,J,K) + XIY(I,J+1,K))
    XIZM = 0.5 * (XIZ(I,J,K) + XIZ(I,J+1,K))
    ETXM = 0.5 * (ETX(I,J,K) + ETX(I,J+1,K))
    ETYM = 0.5 * (ETY(I,J,K) + ETY(I,J+1,K))
    ETZM = 0.5 * (ETZ(I,J,K) + ETZ(I,J+1,K))
    ZEXM = 0.5 * (ZEX(I,J,K) + ZEX(I,J+1,K))
    ZEYM = 0.5 * (ZEY(I,J,K) + ZEY(I,J+1,K))
    ZEZM = 0.5 * (ZEZ(I,J,K) + ZEZ(I,J+1,K))
    AJAM = 0.5 * (AJA(I,J,K) + AJA(I,J+1,K))
    ! ������
    RHOM  = 0.5 * ( RHO(I,J,K) +  RHO(I,J+1,K))
    UM    = 0.5 * (   U(I,J,K) +    U(I,J+1,K))
    VM    = 0.5 * (   V(I,J,K) +    V(I,J+1,K))
    WM    = 0.5 * (   W(I,J,K) +    W(I,J+1,K))
    TM    = 0.5 * (   T(I,J,K) +    T(I,J+1,K))
    AMUM  = 0.5 * ( AMU(I,J,K) +  AMU(I,J+1,K))
    AMUTM = 0.5 * (AMUT(I,J,K) + AMUT(I,J+1,K))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = 0.25 * ( - U(I-1,J,K) - U(I-1,J+1,K) &
    &            + U(I+1,J,K) + U(I+1,J+1,K) )
    VXI = 0.25 * ( - V(I-1,J,K) - V(I-1,J+1,K) &
    &            + V(I+1,J,K) + V(I+1,J+1,K) )
    WXI = 0.25 * ( - W(I-1,J,K) - W(I-1,J+1,K) &
    &            + W(I+1,J,K) + W(I+1,J+1,K) )
    UET = - U(I,J,K) + U(I,J+1,K)
    VET = - V(I,J,K) + V(I,J+1,K)
    WET = - W(I,J,K) + W(I,J+1,K)
    UZE = 0.25 * ( - U(I,J,K-1) - U(I,J+1,K-1) &
    &              + U(I,J,K+1) + U(I,J+1,K+1) )
    VZE = 0.25 * ( - V(I,J,K-1) - V(I,J+1,K-1) &
    &              + V(I,J,K+1) + V(I,J+1,K+1) )
    WZE = 0.25 * ( - W(I,J,K-1) - W(I,J+1,K-1) &
    &              + W(I,J,K+1) + W(I,J+1,K+1) )
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM + UZE * ZEXM
    UY = UXI * XIYM + UET * ETYM + UZE * ZEYM
    UZ = UXI * XIZM + UET * ETZM + UZE * ZEZM
    VX = VXI * XIXM + VET * ETXM + VZE * ZEXM
    VY = VXI * XIYM + VET * ETYM + VZE * ZEYM
    VZ = VXI * XIZM + VET * ETZM + VZE * ZEZM
    WX = WXI * XIXM + WET * ETXM + WZE * ZEXM
    WY = WXI * XIYM + WET * ETYM + WZE * ZEYM
    WZ = WXI * XIZM + WET * ETZM + WZE * ZEZM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = 0.25 * ( - T(I-1,J,K) - T(I-1,J+1,K) &
    &              + T(I+1,J,K) + T(I+1,J+1,K) )
    TET = - T(I,J,K) + T(I,J+1,K)
    TZE = 0.25 * ( - T(I,J,K-1) - T(I,J+1,K-1) &
    &              + T(I,J,K+1) + T(I,J+1,K+1) )
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM + TZE * ZEXM
    TY = TXI * XIYM + TET * ETYM + TZE * ZEYM
    TZ = TXI * XIZM + TET * ETZM + TZE * ZEZM
    ! �W���v�Z ---------------------------------------------------------
    nu   = AMUM  / RHOM
    nu_t = AMUTM / RHOM
    c_u  = nu + nu_t
    c_t  = (nu / PR + nu_t / PRT) / (GAMMA - 1.0) * GAMMA * RG
    ! �S�����͂ƃ��C�m���Y���̘͂a -------------------------------------
    DELV  = UX + VY + WZ
    TAUXX = c_u * (2.0 * UX - TwoThird * DELV) ! - TwoThird * AKM
    TAUYY = c_u * (2.0 * VY - TwoThird * DELV) ! - TwoThird * AKM
    TAUZZ = c_u * (2.0 * WZ - TwoThird * DELV) ! - TwoThird * AKM
    TAUXY = c_u * (UY + VX)
    TAUYZ = c_u * (VZ + WY)
    TAUZX = c_u * (WX + UZ)
    ! �G�l���M�[�̊g�U -------------------------------------------------
    R5 = TAUXX * UM + TAUXY * VM + TAUZX * WM + c_t * TX
    S5 = TAUXY * UM + TAUYY * VM + TAUYZ * WM + c_t * TY
    T5 = TAUZX * UM + TAUYZ * VM + TAUZZ * WM + c_t * TZ
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    SH(I,J,K,1) = 0.0
    SH(I,J,K,2) = QH1 * (TAUXX * ETXM + TAUXY * ETYM + TAUZX * ETZM)
    SH(I,J,K,3) = QH1 * (TAUXY * ETXM + TAUYY * ETYM + TAUYZ * ETZM)
    SH(I,J,K,4) = QH1 * (TAUZX * ETXM + TAUYZ * ETYM + TAUZZ * ETZM)
    SH(I,J,K,5) = QH1 * (R5 * ETXM + S5 * ETYM + T5 * ETZM)
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFET
!***********************************************************************
!**** �g�U���̌v�Z(zeta���������p)                                  ****
!***********************************************************************
SUBROUTINE DIFFZE
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM
  REAL    :: RHOM, UM, VM, WM, TM, AMUM, AMUTM
  REAL    :: UXI, UET, UZE, UX, UY, UZ
  REAL    :: VXI, VET, VZE, VX, VY, VZ
  REAL    :: WXI, WET, WZE, WX, WY, WZ
  REAL    :: TXI, TET, TZE, TX, TY, TZ
  REAL    :: nu, nu_t
  REAL    :: c_u, c_t
  REAL    :: TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX, DELV
  REAL    :: R5, S5, T5
  REAL    :: QH1
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE( &
!$OMP& I, J, K, &
!$OMP& XIXM, XIYM, XIZM, ETXM, ETYM, ETZM, ZEXM, ZEYM, ZEZM, AJAM, &
!$OMP& RHOM, UM, VM, WM, TM, AMUM, AMUTM, &
!$OMP& UXI, UET, UZE, UX, UY, UZ, &
!$OMP& VXI, VET, VZE, VX, VY, VZ, &
!$OMP& WXI, WET, WZE, WX, WY, WZ, &
!$OMP& TXI, TET, TZE, TX, TY, TZ, &
!$OMP& nu, nu_t, c_u, c_t, &
!$OMP& TAUXX, TAUYY, TAUZZ, TAUXY, TAUYZ, TAUZX, DELV, R5, S5, T5, QH1 &
!$OMP& )
  DO K = KS    , KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( (RHO(I,J-1,K) .GT. 0.0) .AND. (RHO(I-1,J,K) .GT. 0.0) .AND. &
  &   (RHO(I,J,K)   .GT. 0.0) .AND. (RHO(I+1,J,K) .GT. 0.0) .AND. &
  &   (RHO(I,J+1,K) .GT. 0.0) .AND. (RHO(I,J,K+1) .GT. 0.0) &
  & ) THEN
    ! ZE�����̕��ϗʂ̌v�Z ---------------------------------------------
    ! ���W�ϊ��p�����[�^
    XIXM = 0.5 * (XIX(I,J,K) + XIX(I,J,K+1))
    XIYM = 0.5 * (XIY(I,J,K) + XIY(I,J,K+1))
    XIZM = 0.5 * (XIZ(I,J,K) + XIZ(I,J,K+1))
    ETXM = 0.5 * (ETX(I,J,K) + ETX(I,J,K+1))
    ETYM = 0.5 * (ETY(I,J,K) + ETY(I,J,K+1))
    ETZM = 0.5 * (ETZ(I,J,K) + ETZ(I,J,K+1))
    ZEXM = 0.5 * (ZEX(I,J,K) + ZEX(I,J,K+1))
    ZEYM = 0.5 * (ZEY(I,J,K) + ZEY(I,J,K+1))
    ZEZM = 0.5 * (ZEZ(I,J,K) + ZEZ(I,J,K+1))
    AJAM = 0.5 * (AJA(I,J,K) + AJA(I,J,K+1))
    ! ������
    RHOM  = 0.5 * ( RHO(I,J,K) +  RHO(I,J,K+1))
    UM    = 0.5 * (   U(I,J,K) +    U(I,J,K+1))
    VM    = 0.5 * (   V(I,J,K) +    V(I,J,K+1))
    WM    = 0.5 * (   W(I,J,K) +    W(I,J,K+1))
    TM    = 0.5 * (   T(I,J,K) +    T(I,J,K+1))
    AMUM  = 0.5 * ( AMU(I,J,K) +  AMU(I,J,K+1))
    AMUTM = 0.5 * (AMUT(I,J,K) + AMUT(I,J,K+1))
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    UXI = 0.25 * ( - U(I-1,J,K) - U(I-1,J,K+1) &
    &              + U(I+1,J,K) + U(I+1,J,K+1) )
    VXI = 0.25 * ( - V(I-1,J,K) - V(I-1,J,K+1) &
    &              + V(I+1,J,K) + V(I+1,J,K+1) )
    WXI = 0.25 * ( - W(I-1,J,K) - W(I-1,J,K+1) &
    &              + W(I+1,J,K) + W(I+1,J,K+1) )
    UET = 0.25 * ( - U(I,J-1,K) - U(I,J-1,K+1) &
    &              + U(I,J+1,K) + U(I,J+1,K+1) )
    VET = 0.25 * ( - V(I,J-1,K) - V(I,J-1,K+1) &
    &              + V(I,J+1,K) + V(I,J+1,K+1) )
    WET = 0.25 * ( - W(I,J-1,K) - W(I,J-1,K+1) &
    &              + W(I,J+1,K) + W(I,J+1,K+1) )
    UZE = - U(I,J,K) + U(I,J,K+1)
    VZE = - V(I,J,K) + V(I,J,K+1)
    WZE = - W(I,J,K) + W(I,J,K+1)
    ! ������ԕ�����K����
    UX = UXI * XIXM + UET * ETXM + UZE * ZEXM
    UY = UXI * XIYM + UET * ETYM + UZE * ZEYM
    UZ = UXI * XIZM + UET * ETZM + UZE * ZEZM
    VX = VXI * XIXM + VET * ETXM + VZE * ZEXM
    VY = VXI * XIYM + VET * ETYM + VZE * ZEYM
    VZ = VXI * XIZM + VET * ETZM + VZE * ZEZM
    WX = WXI * XIXM + WET * ETXM + WZE * ZEXM
    WY = WXI * XIYM + WET * ETYM + WZE * ZEYM
    WZ = WXI * XIZM + WET * ETZM + WZE * ZEZM
    ! ���x�̈�K�����̌v�Z ---------------------------------------------
    ! �v�Z��ԕ�����K����
    TXI = 0.25 * ( - T(I-1,J,K) - T(I-1,J,K+1) &
    &              + T(I+1,J,K) + T(I+1,J,K+1) )
    TET = 0.25 * ( - T(I,J-1,K) - T(I,J-1,K+1) &
    &              + T(I,J+1,K) + T(I,J+1,K+1) )
    TZE = - T(I,J,K) + T(I,J,K+1)
    ! ������ԕ�����K����
    TX = TXI * XIXM + TET * ETXM + TZE * ZEXM
    TY = TXI * XIYM + TET * ETYM + TZE * ZEYM
    TZ = TXI * XIZM + TET * ETZM + TZE * ZEZM
    ! �W���v�Z ---------------------------------------------------------
    nu   = AMUM  / RHOM
    nu_t = AMUTM / RHOM
    c_u  = nu + nu_t
    c_t  = (nu / PR + nu_t / PRT) / (GAMMA - 1.0) * GAMMA * RG
    ! �S�����͂ƃ��C�m���Y���̘͂a -------------------------------------
    DELV  = UX + VY + WZ
    TAUXX = c_u * (2.0 * UX - TwoThird * DELV) ! - TwoThird * AKM
    TAUYY = c_u * (2.0 * VY - TwoThird * DELV) ! - TwoThird * AKM
    TAUZZ = c_u * (2.0 * WZ - TwoThird * DELV) ! - TwoThird * AKM
    TAUXY = c_u * (UY + VX)
    TAUYZ = c_u * (VZ + WY)
    TAUZX = c_u * (WX + UZ)
    ! �G�l���M�[�̊g�U -------------------------------------------------
    R5 = TAUXX * UM + TAUXY * VM + TAUZX * WM + c_t * TX
    S5 = TAUXY * UM + TAUYY * VM + TAUYZ * WM + c_t * TY
    T5 = TAUZX * UM + TAUYZ * VM + TAUZZ * WM + c_t * TZ
    ! �e�������̊g�U�� -------------------------------------------------
    QH1 = RHOM / AJAM
    TH(I,J,K,1) = 0.0
    TH(I,J,K,2) = QH1 * (TAUXX * ZEXM + TAUXY * ZEYM + TAUZX * ZEZM)
    TH(I,J,K,3) = QH1 * (TAUXY * ZEXM + TAUYY * ZEYM + TAUYZ * ZEZM)
    TH(I,J,K,4) = QH1 * (TAUZX * ZEXM + TAUYZ * ZEYM + TAUZZ * ZEZM)
    TH(I,J,K,5) = QH1 * (R5 * ZEXM + S5 * ZEYM + T5 * ZEZM)
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE DIFFZE
! ��`�I�� *************************************************************
END SUBROUTINE Turbulence3DLESCSM
!***********************************************************************
!**** �����֐��p���~�b�^�[                                          ****
!**** �v�Z�Ώ� : �P��, �񎟌�, ���k��, k-e                          ****
!***********************************************************************
SUBROUTINE Limiter2DKEM( &
&            AVELIM, &
&            IS, IE, JS, JE, LS, LE, AJA, &
&            QH &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)    :: AVELIM
  INTEGER, INTENT(IN)    :: IS, IE, JS, JE
  INTEGER, INTENT(IN)    :: LS, LE
  REAL,    INTENT(IN)    :: AJA(IS:IE, JS:JE)
  REAL,    INTENT(INOUT) :: QH(IS:IE, JS:JE, LS:LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, L
  REAL    :: AKMAX
  REAL    :: QHAVE
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 6) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! ����Ɖ����ɐ����������� +++++++++++++++++++++++++++++++++++++++++++
  DO J = JS, JE
  DO I = IS, IE
  IF(QH(I,J,1) .GT. 0.0) THEN
    AKMAX     = 0.5 * (QH(I,J,2)**2 + QH(I,J,3)**2) / QH(I,J,1)
    QH(I,J,4) = QH(I,J,4) - QH(I,J,5)
    QH(I,J,5) = MIN(AKMAX, MAX(0.0, QH(I,J,5)))
    QH(I,J,6) = MAX(0.0, QH(I,J,6))
    QH(I,J,4) = QH(I,J,4) + QH(I,J,5)
  ENDIF
  ENDDO
  ENDDO
  ! ���ϒl���疾�炩�Ɉ�E����_�ɐ����������� +++++++++++++++++++++++++
  IF(AVELIM .LE. 0.0) RETURN
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( (QH(I  ,J-1,1) .GT. 0.0) .AND. (QH(I-1,J  ,1) .GT. 0.0) .AND. &
  &   (QH(I  ,J  ,1) .GT. 0.0) .AND. &
  &   (QH(I+1,J  ,1) .GT. 0.0) .AND. (QH(I  ,J+1,1) .GT. 0.0) &
  & ) THEN
  DO L = 5, 6
    QHAVE = ( QH(I  ,J-1,L) * AJA(I  ,J-1) &
    &       + QH(I-1,J  ,L) * AJA(I-1,J  ) &
    &       + QH(I+1,J  ,L) * AJA(I+1,J  ) &
    &       + QH(I  ,J+1,L) * AJA(I  ,J+1) &
    &       ) / (4.0 * AJA(I,J))
    QH(I,J,L) = MAX(QHAVE / AVELIM, MIN(QHAVE * AVELIM, QH(I,J,L)))
  ENDDO
  ENDIF
  ENDDO
  ENDDO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE Limiter2DKEM
!***********************************************************************
!**** �����֐��p���~�b�^�[                                          ****
!**** �v�Z�Ώ� : �P��, �O����, ���k��, k-e                          ****
!***********************************************************************
SUBROUTINE Limiter3DKEM( &
&            AVELIM, &
&            IS, IE, JS, JE, KS, KE, LS, LE, AJA, &
&            QH &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)    :: AVELIM
  INTEGER, INTENT(IN)    :: IS, IE, JS, JE, KS, KE
  INTEGER, INTENT(IN)    :: LS, LE
  REAL,    INTENT(IN)    :: AJA(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(INOUT) :: QH(IS:IE, JS:JE, KS:KE, LS:LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K, L
  REAL    :: AKMAX
  REAL    :: QHAVE
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 7) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! ����Ɖ����ɐ����������� +++++++++++++++++++++++++++++++++++++++++++
  DO K = KS, KE
  DO J = JS, JE
  DO I = IS, IE
  IF(QH(I,J,K,1) .GT. 0.0) THEN
    AKMAX       = 0.5 * ( QH(I,J,K,2)**2 &
    &                   + QH(I,J,K,3)**2 &
    &                   + QH(I,J,K,4)**2) / QH(I,J,K,1)
    QH(I,J,K,5) = QH(I,J,K,5) - QH(I,J,K,6)
    QH(I,J,K,6) = MIN(AKMAX, MAX(0.0, QH(I,J,K,6)))
    QH(I,J,K,7) = MAX(0.0, QH(I,J,K,7))
    QH(I,J,K,5) = QH(I,J,K,5) + QH(I,J,K,6)
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  ! ���ϒl���疾�炩�Ɉ�E����_�ɐ����������� +++++++++++++++++++++++++
  IF(AVELIM .LE. 0.0) RETURN
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( ( QH(I  ,J  ,K-1,1) .GT. 0.0 ) .AND. &
  &   ( QH(I  ,J-1,K  ,1) .GT. 0.0 ) .AND. &
  &   ( QH(I-1,J  ,K  ,1) .GT. 0.0 ) .AND. &
  &   ( QH(I  ,J  ,K  ,1) .GT. 0.0 ) .AND. &
  &   ( QH(I+1,J  ,K  ,1) .GT. 0.0 ) .AND. &
  &   ( QH(I  ,J+1,K  ,1) .GT. 0.0 ) .AND. &
  &   ( QH(I  ,J  ,K+1,1) .GT. 0.0 ) &
  & ) THEN
  DO L = 6, 7
    QHAVE = ( QH(I  ,J  ,K-1,L)*AJA(I  ,J  ,K-1) &
    &       + QH(I  ,J-1,K  ,L)*AJA(I  ,J-1,K  ) &
    &       + QH(I-1,J  ,K  ,L)*AJA(I-1,J  ,K  ) &
    &       + QH(I+1,J  ,K  ,L)*AJA(I+1,J  ,K  ) &
    &       + QH(I  ,J+1,K  ,L)*AJA(I  ,J+1,K  ) &
    &       + QH(I  ,J  ,K+1,L)*AJA(I  ,J  ,K+1) &
    &       ) / (6.0 * AJA(I,J,K))
    QH(I,J,K,L) = MAX(QHAVE / AVELIM, MIN(QHAVE * AVELIM, QH(I,J,K,L)))
  ENDDO
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE Limiter3DKEM
!***********************************************************************
!**** �����֐��p���~�b�^�[                                          ****
!**** �v�Z�Ώ� : �P��, �񎟌�, ���k��, RSM                          ****
!***********************************************************************
SUBROUTINE Limiter2DRSM( &
&            AVELIM, &
&            IS, IE, JS, JE, LS, LE, AJA, &
&            QH &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)    :: AVELIM
  INTEGER, INTENT(IN)    :: IS, IE, JS, JE
  INTEGER, INTENT(IN)    :: LS, LE
  REAL,    INTENT(IN)    :: AJA(IS:IE, JS:JE)
  REAL,    INTENT(INOUT) :: QH(IS:IE, JS:JE, LS:LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, L
  REAL    :: uiuimax, uiujmax
  REAL    :: QHAVE
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 9) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! ����Ɖ����ɐ����������� +++++++++++++++++++++++++++++++++++++++++++
  DO J = JS, JE
  DO I = IS, IE
  IF(QH(I,J,1) .GT. 0.0) THEN
    uiuimax   = (QH(I,J,2)**2 + QH(I,J,3)**2) / QH(I,J,1)
    QH(I,J,4) = QH(I,J,4) - 0.5 * (QH(I,J,5) + QH(I,J,6) + QH(I,J,7))
    QH(I,J,5) = MIN(uiuimax, MAX(0.0, QH(I,J,5)))
    QH(I,J,6) = MIN(uiuimax, MAX(0.0, QH(I,J,6)))
    QH(I,J,7) = MIN(uiuimax, MAX(0.0, QH(I,J,7)))
    uiujmax   = 0.5 * (QH(I,J,5) + QH(I,J,6) + QH(I,J,7))
    QH(I,J,8) = MIN(uiujmax, MAX(- uiujmax, QH(I,J,8)))
    QH(I,J,9) = MAX(0.0, QH(I,J,9))
    QH(I,J,4) = QH(I,J,4) + 0.5 * (QH(I,J,5) + QH(I,J,6) + QH(I,J,7))
  ENDIF
  ENDDO
  ENDDO
  ! ���ϒl���疾�炩�Ɉ�E����_�ɐ����������� +++++++++++++++++++++++++
  IF(AVELIM .LE. 0.0) RETURN
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( (QH(I  ,J-1,1) .GT. 0.0) .AND. (QH(I-1,J  ,1) .GT. 0.0) .AND. &
  &   (QH(I  ,J  ,1) .GT. 0.0) .AND. &
  &   (QH(I+1,J  ,1) .GT. 0.0) .AND. (QH(I  ,J+1,1) .GT. 0.0) &
  & ) THEN
  L = 9
    QHAVE = ( QH(I  ,J-1,L) * AJA(I  ,J-1) &
    &       + QH(I-1,J  ,L) * AJA(I-1,J  ) &
    &       + QH(I+1,J  ,L) * AJA(I+1,J  ) &
    &       + QH(I  ,J+1,L) * AJA(I  ,J+1) &
    &       ) / (4.0 * AJA(I,J))
    QH(I,J,L) = MAX(QHAVE / AVELIM, MIN(QHAVE * AVELIM, QH(I,J,L)))
  ENDIF
  ENDDO
  ENDDO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE Limiter2DRSM
!***********************************************************************
!**** �����֐��p���~�b�^�[                                          ****
!**** �v�Z�Ώ� : �P��, �O����, ���k��, RSM                          ****
!***********************************************************************
SUBROUTINE Limiter3DRSM( &
&            AVELIM, &
&            IS, IE, JS, JE, KS, KE, LS, LE, AJA, &
&            QH &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)    :: AVELIM
  INTEGER, INTENT(IN)    :: IS, IE, JS, JE, KS, KE
  INTEGER, INTENT(IN)    :: LS, LE
  REAL,    INTENT(IN)    :: AJA(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(INOUT) :: QH(IS:IE, JS:JE, KS:KE, LS:LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K, L
  REAL    :: uiuimax, uiujmax
  REAL    :: QHAVE
  ! �����J�n ***********************************************************
  ! ��O����(�v�Z�Ώۂ��K�����Ă��Ȃ��ꍇ�͏I��) +++++++++++++++++++++++
  IF(LS .NE. 1 .OR. LE .LT. 12) THEN
    WRITE(*,'(A)') 'Error : LS or LE Irregal'
    STOP
  ENDIF
  ! ����Ɖ����ɐ����������� +++++++++++++++++++++++++++++++++++++++++++
  DO K = KS, KE
  DO J = JS, JE
  DO I = IS, IE
  IF(QH(I,J,K,1) .GT. 0.0) THEN
    uiuimax = ( QH(I,J,K,2)**2 &
    &         + QH(I,J,K,3)**2 &
    &         + QH(I,J,K,4)**2 ) / QH(I,J,K,1)
    QH(I,J,K, 5) = QH(I,J,K,5) &
    &            - 0.5 * (QH(I,J,K,6) + QH(I,J,K,7) + QH(I,J,K,8))
    QH(I,J,K, 6) = MIN(uiuimax, MAX(0.0, QH(I,J,K, 6)))
    QH(I,J,K, 7) = MIN(uiuimax, MAX(0.0, QH(I,J,K, 7)))
    QH(I,J,K, 8) = MIN(uiuimax, MAX(0.0, QH(I,J,K, 8)))
    uiujmax = 0.5 * (QH(I,J,K,6) + QH(I,J,K,7) + QH(I,J,K,8))
    QH(I,J,K, 9) = MIN(uiujmax, MAX(- uiujmax, QH(I,J,K, 9)))
    QH(I,J,K,10) = MIN(uiujmax, MAX(- uiujmax, QH(I,J,K,10)))
    QH(I,J,K,11) = MIN(uiujmax, MAX(- uiujmax, QH(I,J,K,11)))
    QH(I,J,K,12) = MAX(0.0, QH(I,J,K,12))
    QH(I,J,K, 5) = QH(I,J,K,5) &
    &            + 0.5 * (QH(I,J,K,6) + QH(I,J,K,7) + QH(I,J,K,8))
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  ! ���ϒl���疾�炩�Ɉ�E����_�ɐ����������� +++++++++++++++++++++++++
  IF(AVELIM .LE. 0.0) RETURN
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF( ( QH(I  ,J  ,K-1,1) .GT. 0.0 ) .AND. &
  &   ( QH(I  ,J-1,K  ,1) .GT. 0.0 ) .AND. &
  &   ( QH(I-1,J  ,K  ,1) .GT. 0.0 ) .AND. &
  &   ( QH(I  ,J  ,K  ,1) .GT. 0.0 ) .AND. &
  &   ( QH(I+1,J  ,K  ,1) .GT. 0.0 ) .AND. &
  &   ( QH(I  ,J+1,K  ,1) .GT. 0.0 ) .AND. &
  &   ( QH(I  ,J  ,K+1,1) .GT. 0.0 ) &
  & ) THEN
  L = 12
    QHAVE = ( QH(I  ,J  ,K-1,L)*AJA(I  ,J  ,K-1) &
    &       + QH(I  ,J-1,K  ,L)*AJA(I  ,J-1,K  ) &
    &       + QH(I-1,J  ,K  ,L)*AJA(I-1,J  ,K  ) &
    &       + QH(I+1,J  ,K  ,L)*AJA(I+1,J  ,K  ) &
    &       + QH(I  ,J+1,K  ,L)*AJA(I  ,J+1,K  ) &
    &       + QH(I  ,J  ,K+1,L)*AJA(I  ,J  ,K+1) &
    &       ) / (6.0 * AJA(I,J,K))
    QH(I,J,K,L) = MAX(QHAVE / AVELIM, MIN(QHAVE * AVELIM, QH(I,J,K,L)))
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE Limiter3DRSM
!***********************************************************************
!**** �c���v�Z                                                      ****
!**** �v�Z�Ώ� : �P��, �񎟌�, ���k��                               ****
!***********************************************************************
SUBROUTINE CalResidual2D( &
&            IS, IE, JS, JE, LS, LE, &
&            DTLOCL, QH0, QH, RES &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE
  INTEGER, INTENT(IN)  :: LS, LE
  REAL,    INTENT(IN)  :: DTLOCL(IS:IE, JS:JE)
  REAL,    INTENT(IN)  :: QH0(IS:IE, JS:JE, LS:LE)
  REAL,    INTENT(IN)  :: QH(IS:IE, JS:JE, LS:LE)
  REAL,    INTENT(OUT) :: RES(IS:IE, JS:JE, LS:LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, L
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE(I, J, L)
  DO L = LS, LE
  !$OMP DO
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF(QH0(I,J,1) .GT. 0.0 .AND. DTLOCL(I,J) .GT. 0.0) THEN
    RES(I,J,L) = ((QH(I,J,L) - QH0(I,J,L)) / QH(I,J,1))**2 &
    &          / DTLOCL(I,J)
  ELSE
    RES(I,J,L) = 0.0
  ENDIF
  ENDDO
  ENDDO
  !$OMP END DO
  ENDDO
  !$OMP END PARALLEL
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE CalResidual2D
!***********************************************************************
!**** �c���v�Z                                                      ****
!**** �v�Z�Ώ� : �P��, �O����, ���k��                               ****
!***********************************************************************
SUBROUTINE CalResidual3D( &
&            IS, IE, JS, JE, KS, KE, LS, LE, &
&            DTLOCL, QH0, QH, RES &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE, KS, KE
  INTEGER, INTENT(IN)  :: LS, LE
  REAL,    INTENT(IN)  :: DTLOCL(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(IN)  :: QH0(IS:IE, JS:JE, KS:KE, LS:LE)
  REAL,    INTENT(IN)  :: QH(IS:IE, JS:JE, KS:KE, LS:LE)
  REAL,    INTENT(OUT) :: RES(IS:IE, JS:JE, KS:KE, LS:LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K, L
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DEFAULT(SHARED) PRIVATE(I, J, K, L)
  DO L = LS, LE
  !$OMP DO
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
  IF(QH0(I,J,K,1) .GT. 0.0 .AND. DTLOCL(I,J,K) .GT. 0.0) THEN
    RES(I,J,K,L) = ((QH(I,J,K,L) - QH0(I,J,K,L)) / QH(I,J,K,1))**2 &
    &            / DTLOCL(I,J,K)
  ELSE
    RES(I,J,K,L) = 0.0
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END DO
  ENDDO
  !$OMP END PARALLEL
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE CalResidual3D
!***********************************************************************
!**** Yap�̒����X�P�[���␳(1987)                                   ****
!****   KEM�̔�������ɂ�����ǋߖT�̒����X�P�[���̉ߑ�]���A       ****
!****   ���Ȃ킿epsilon�̉ߏ��]����␳����epsilon�̕t���I�Ȑ�����  ****
!***********************************************************************
SUBROUTINE YapCorrection2D( &
&            IS, IE, JS, JE, Y, AJA, RHO, AK, EPS, Yc &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, PARAMETER :: ZERO = 1.0E-20
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE
  REAL,    INTENT(IN)  :: Y(IS: IE, JS: JE)
  REAL,    INTENT(IN)  :: AJA(IS: IE, JS: JE)
  REAL,    INTENT(IN)  :: RHO(IS: IE, JS: JE)
  REAL,    INTENT(IN)  :: AK(IS: IE, JS: JE)
  REAL,    INTENT(IN)  :: EPS(IS: IE, JS: JE)
  REAL,    INTENT(OUT) :: Yc(IS: IE, JS: JE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: Le, k32PeLe
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I, J, Le, k32PeLe)
  DO J = JS, JE
  DO I = IS, IE
  IF(RHO(I,J) .GT. 0.0) THEN
    Le      = 2.5 * Y(I,J)
    k32PeLe = AK(I,J)**1.5 / MAX(ZERO, Le * EPS(I,J))
    Yc(I,J) = 0.83 * EPS(I,J)**2 / MAX(ZERO, AK(I,J)) &
    &       * (k32PeLe - 1.0) * k32PeLe**2
    Yc(I,J) = RHO(I,J) / AJA(I,J) * MAX(Yc(I,J), 0.0)
  ELSE
    Yc(I,J) = 0.0
  ENDIF
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE YapCorrection2D
!***********************************************************************
!**** Yap�̒����X�P�[���␳(1987)                                   ****
!****   KEM�̔�������ɂ�����ǋߖT�̒����X�P�[���̉ߑ�]���A       ****
!****   ���Ȃ킿epsilon�̉ߏ��]����␳����epsilon�̕t���I�Ȑ�����  ****
!***********************************************************************
SUBROUTINE YapCorrection3D( &
&            IS, IE, JS, JE, KS, KE, Y, AJA, RHO, AK, EPS, Yc &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, PARAMETER :: ZERO = 1.0E-20
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE, KS, KE
  REAL,    INTENT(IN)  :: Y(IS: IE, JS: JE, KS: KE)
  REAL,    INTENT(IN)  :: AJA(IS: IE, JS: JE, KS: KE)
  REAL,    INTENT(IN)  :: RHO(IS: IE, JS: JE, KS: KE)
  REAL,    INTENT(IN)  :: AK(IS: IE, JS: JE, KS: KE)
  REAL,    INTENT(IN)  :: EPS(IS: IE, JS: JE, KS: KE)
  REAL,    INTENT(OUT) :: Yc(IS: IE, JS: JE, KS: KE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: Le, k32PeLe
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I, J, K, Le, k32PeLe)
  DO K = KS, KE
  DO J = JS, JE
  DO I = IS, IE
  IF(RHO(I,J,K) .GT. 0.0) THEN
    Le        = 2.5 * Y(I,J,K)
    k32PeLe   = AK(I,J,K)**1.5 / MAX(ZERO, Le * EPS(I,J,K))
    Yc(I,J,K) = 0.83 * EPS(I,J,K)**2 / MAX(ZERO, AK(I,J,K)) &
    &         * (k32PeLe - 1.0) * k32PeLe**2
    Yc(I,J,K) = RHO(I,J,K) / AJA(I,J,K) * MAX(Yc(I,J,K), 0.0)
  ELSE
    Yc(I,J,K) = 0.0
  ENDIF
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE YapCorrection3D
!***********************************************************************
!**** KEM�p�̕Ǌ֐�(����)                                           ****
!***********************************************************************
SUBROUTINE WallFunctionKEM1S( &
&            yp, up, nup, kp0, epsp0, &
&            utau, dudy1, dudy2, kp, epsp &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, PARAMETER :: cmu = 0.09
  ! REAL, PARAMETER :: kappa = 0.41, E = 9.0
  REAL, PARAMETER :: kappa = 0.40, B = 5.5
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, INTENT(IN)  :: yp                 ! �ǂ���̋���   (yp > 0)
  REAL, INTENT(IN)  :: up                 ! �ǐ����������x (up > 0)
  REAL, INTENT(IN)  :: nup                ! ���S�x         (nup > 0)
  REAL, INTENT(IN)  :: kp0, epsp0         ! �O�X�e�b�v�̗�����
  REAL, INTENT(OUT) :: utau               ! ���C���x       (utau > 0)
  REAL, INTENT(OUT) :: dudy1, dudy2       ! ���x�̈�K�����Ɠ�K����
  REAL, INTENT(OUT) :: kp, epsp           ! ������
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL :: utau0, yplusp
  ! �����J�n ***********************************************************
  utau0  = cmu / (kappa * yp) * kp0**2 / epsp0
  yplusp = yp * utau0 / nup
  IF(yplusp .LE. 11.635)THEN
    utau = SQRT(nup * up / yp)
  ELSE
    ! utau = kappa * up / LOG(yplusp * E)
    utau = up / (LOG(yplusp) / kappa + B)
  ENDIF
  dudy1 = utau / (kappa * yp)
  dudy2 =-dudy1 / yp
  kp    = utau**2 / SQRT(cmu)
  epsp  = utau**3 / (kappa * yp)
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE WallFunctionKEM1S
!***********************************************************************
!**** RSM�p�̕Ǌ֐�(����)                                           ****
!***********************************************************************
SUBROUTINE WallFunctionRSM1S( &
&            yp, up, nup, uv0, epsp0, &
&            utau, dudy1, dudy2, uup, vvp, wwp, uvp, epsp &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ! REAL, PARAMETER :: kappa = 0.41, E = 9.0
  REAL, PARAMETER :: kappa = 0.40, B = 5.5
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, INTENT(IN)  :: yp                   ! �ǂ���̋���   (yp > 0)
  REAL, INTENT(IN)  :: up                   ! �ǐ����������x (up > 0)
  REAL, INTENT(IN)  :: nup                  ! ���S�x         (nup > 0)
  REAL, INTENT(IN)  :: uv0                  ! �O�X�e�b�v�̃��C�m���Y����
  REAL, INTENT(IN)  :: epsp0                ! �O�X�e�b�v�̗���̎U�헦
  REAL, INTENT(OUT) :: utau                 ! ���C���x       (utau > 0)
  REAL, INTENT(OUT) :: dudy1, dudy2         ! ���x�̈�K�����Ɠ�K����
  REAL, INTENT(OUT) :: uup, vvp, wwp, uvp   ! ���C�m���Y����
  REAL, INTENT(OUT) :: epsp                 ! ����̎U�헦
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL :: utau0, yplusp
  ! �����J�n ***********************************************************
  utau0  = SQRT(ABS(uv0))
  yplusp = yp * utau0 / nup
  IF(yplusp .LE. 11.635)THEN
    utau = SQRT(nup * up / yp)
  ELSE
    ! utau = kappa * up / LOG(yplusp * E)
    utau = up / (LOG(yplusp) / kappa + B)
  ENDIF
  dudy1 = utau / (kappa * yp)
  dudy2 =-dudy1 / yp
  uvp   =-utau**2
  uup   =-4.9 * uvp
  vvp   =-1.0 * uvp
  wwp   =-2.4 * uvp
  epsp  = utau**3 / (kappa * yp)
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE WallFunctionRSM1S
!***********************************************************************
!**** KEM�p�̕Ǌ֐�(����)                                           ****
!***********************************************************************
SUBROUTINE WallFunctionKEM2S( &
&            yp, up, nup, &
&            utau, dudy1, dudy2, kp, epsp &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, PARAMETER :: cmu = 0.09
  REAL, PARAMETER :: kappa = 0.40, B = 5.5
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: yp                 ! �ǂ���̋���   (yp > 0)
  REAL,    INTENT(IN)  :: up                 ! �ǐ����������x (up > 0)
  REAL,    INTENT(IN)  :: nup                ! ���S�x         (nup > 0)
  REAL,    INTENT(OUT) :: utau               ! ���C���x       (utau > 0)
  REAL,    INTENT(OUT) :: dudy1, dudy2       ! ���x�̈�K�����Ɠ�K����
  REAL,    INTENT(OUT) :: kp, epsp           ! ������
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ! �����J�n ***********************************************************
  CALL CalUtauS(kappa, B, yp, up, nup, utau, dudy1, dudy2)
  kp   = utau**2 / SQRT(cmu)
  epsp = utau**3 / (kappa * yp)
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE WallFunctionKEM2S
!***********************************************************************
!**** RSM�p�̕Ǌ֐�(����)                                           ****
!***********************************************************************
SUBROUTINE WallFunctionRSM2S( &
&            yp, up, nup, &
&            utau, dudy1, dudy2, uup, vvp, wwp, uvp, epsp &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, PARAMETER :: kappa = 0.40, B = 5.5
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: yp                 ! �ǂ���̋���   (yp > 0)
  REAL,    INTENT(IN)  :: up                 ! �ǐ����������x (up > 0)
  REAL,    INTENT(IN)  :: nup                ! ���S�x         (nup > 0)
  REAL,    INTENT(OUT) :: utau               ! ���C���x       (utau > 0)
  REAL,    INTENT(OUT) :: dudy1, dudy2       ! ���x�̈�K�����Ɠ�K����
  REAL,    INTENT(OUT) :: uup, vvp, wwp, uvp ! ���C�m���Y����
  REAL,    INTENT(OUT) :: epsp               ! ����̎U�헦
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ! �����J�n ***********************************************************
  CALL CalUtauS(kappa, B, yp, up, nup, utau, dudy1, dudy2)
  uvp  = - utau**2
  uup  = - 4.9 * uvp
  vvp  = - 1.0 * uvp
  wwp  = - 2.4 * uvp
  epsp = utau**3 / (kappa * yp)
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE WallFunctionRSM2S
!***********************************************************************
!**** ���C���x�̌v�Z(�ΐ���)                                        ****
!***********************************************************************
SUBROUTINE CalUtauS( &
&            kappa, B, yp, up, nup, &
&            utau, dudy1, dudy2 &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, PARAMETER :: NMAX = 100
  REAL,    PARAMETER :: ZERO = 1.0E-20, RESMIN = 1.0E-8
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: kappa, B           ! �ΐ����̃��f���萔
  REAL,    INTENT(IN)  :: yp                 ! �ǂ���̋���   (yp > 0)
  REAL,    INTENT(IN)  :: up                 ! �ǐ����������x (up > 0)
  REAL,    INTENT(IN)  :: nup                ! ���S�x         (nup > 0)
  REAL,    INTENT(OUT) :: utau               ! ���C���x       (utau > 0)
  REAL,    INTENT(OUT) :: dudy1, dudy2       ! ���x�̈�K�����Ɠ�K����
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: n
  REAL    :: f, futau, dutau
  ! �����J�n ***********************************************************
  utau = SQRT(nup * up / yp)
  DO n = 1, NMAX
    f     = up / utau - LOG(yp * utau / nup) / kappa - B
    futau = - (up / utau + 1 / kappa) / utau
    IF(ABS(futau) .LE. ZERO) futau = SIGN(ZERO, futau)
    dutau = - f / futau
    utau  = MAX(ZERO, utau + dutau)
    IF(ABS(dutau) .LT. utau * RESMIN) EXIT
  ENDDO
  IF(yp * utau / nup .LE. 11.635) THEN
    utau = SQRT(nup * up / yp)
  ENDIF
  dudy1 = utau / (kappa * yp)
  dudy2 =-dudy1 / yp
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE CalUtauS
!***********************************************************************
!**** KEM�p�̕Ǌ֐�(�e��)                                           ****
!***********************************************************************
SUBROUTINE WallFunctionKEM1R( &
&            ks, yp, up, nup, kp0, epsp0, &
&            utau, dudy1, dudy2, kp, epsp &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, PARAMETER :: cmu = 0.09
  REAL, PARAMETER :: kappa = 0.40, B = 5.5
  REAL, PARAMETER :: ksp1 = 4.0, ksp2 = 15.0, ksp3 = 55.0
  REAL, PARAMETER :: At = 9.5, Ar = 8.5
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, INTENT(IN)  :: ks                    ! �e�x�v�f����   (ks > 0)
  REAL, INTENT(IN)  :: yp                    ! �ǂ���̋���   (yp > 0)
  REAL, INTENT(IN)  :: up                    ! �ǐ����������x (up > 0)
  REAL, INTENT(IN)  :: nup                   ! ���S�x         (nup > 0)
  REAL, INTENT(IN)  :: kp0, epsp0            ! �O�X�e�b�v�̗�����
  REAL, INTENT(OUT) :: utau                  ! ���C���x       (utau > 0)
  REAL, INTENT(OUT) :: dudy1, dudy2          ! ���x�̈�K�����Ɠ�K����
  REAL, INTENT(OUT) :: kp, epsp              ! ������
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL :: utau0, yplusp
  REAL :: ksp
  REAL :: lnksp1, lnksp2, lnksp3
  REAL :: alpha, beta, gamma
  REAL :: DB
  ! �����J�n ***********************************************************
  utau0  = cmu / (kappa * yp) * kp0**2 / epsp0
  yplusp = yp * utau0 / nup
  ksp    = ks * utau0 / nup
  IF(yplusp .LE. 11.635)THEN
    utau = SQRT(nup * up / yp)
  ELSE
    lnksp1 = LOG(ksp1)
    lnksp2 = LOG(ksp2)
    lnksp3 = LOG(ksp3)
    beta   = 0.5 &
    &      * ( (B - Ar + lnksp3 / kappa) * (lnksp2**2 - lnksp1**2) &
    &        - (B - At + lnksp2 / kappa) * (lnksp3**2 - lnksp1**2) ) &
    &      / ( (B - At + lnksp2 / kappa) * (lnksp1 - lnksp3) &
    &        - (B - Ar + lnksp3 / kappa) * (lnksp1 - lnksp2) )
    alpha  = (B - At + lnksp2 / kappa) &
    &      / ((lnksp2 - beta)**2 - (lnksp1 - beta)**2)
    gamma  = - alpha * (lnksp1 - beta)**2
    IF(ksp .LT. ksp1) THEN
      DB = 0.0
    ELSEIF(ksp .GT. ksp3) THEN
      DB = B - Ar + LOG(ksp) / kappa
    ELSE
      DB = alpha * (LOG(ksp) - beta)**2 + gamma
    ENDIF
    utau = up / (LOG(yplusp) / kappa + B - DB)
  ENDIF
  dudy1 = utau / (kappa * yp)
  dudy2 =-dudy1 / yp
  kp    = utau**2 / SQRT(cmu)
  epsp  = utau**3 / (kappa * yp)
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE WallFunctionKEM1R
!***********************************************************************
!**** RSM�p�̕Ǌ֐�(�e��)                                           ****
!***********************************************************************
SUBROUTINE WallFunctionRSM1R( &
&            ks, yp, up, nup, uv0, epsp0, &
&            utau, dudy1, dudy2, uup, vvp, wwp, uvp, epsp &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, PARAMETER :: kappa = 0.40, B = 5.5
  REAL, PARAMETER :: ksp1 = 4.0, ksp2 = 15.0, ksp3 = 55.0
  REAL, PARAMETER :: At = 9.5, Ar = 8.5
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, INTENT(IN)  :: ks                   ! �e�x�v�f����   (ks > 0)
  REAL, INTENT(IN)  :: yp                   ! �ǂ���̋���   (yp > 0)
  REAL, INTENT(IN)  :: up                   ! �ǐ����������x (up > 0)
  REAL, INTENT(IN)  :: nup                  ! ���S�x         (nup > 0)
  REAL, INTENT(IN)  :: uv0                  ! �O�X�e�b�v�̃��C�m���Y����
  REAL, INTENT(IN)  :: epsp0                ! �O�X�e�b�v�̗���̎U�헦
  REAL, INTENT(OUT) :: utau                 ! ���C���x       (utau > 0)
  REAL, INTENT(OUT) :: dudy1, dudy2         ! ���x�̈�K�����Ɠ�K����
  REAL, INTENT(OUT) :: uup, vvp, wwp, uvp   ! ���C�m���Y����
  REAL, INTENT(OUT) :: epsp                 ! ����̎U�헦
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL :: utau0, yplusp
  REAL :: ksp
  REAL :: lnksp1, lnksp2, lnksp3
  REAL :: alpha, beta, gamma
  REAL :: DB
  ! �����J�n ***********************************************************
  utau0  = SQRT(ABS(uv0))
  yplusp = yp * utau0 / nup
  ksp    = ks * utau0 / nup
  IF(yplusp .LE. 11.635)THEN
    utau = SQRT(nup * up / yp)
  ELSE
    lnksp1 = LOG(ksp1)
    lnksp2 = LOG(ksp2)
    lnksp3 = LOG(ksp3)
    beta   = 0.5 &
    &      * ( (B - Ar + lnksp3 / kappa) * (lnksp2**2 - lnksp1**2) &
    &        - (B - At + lnksp2 / kappa) * (lnksp3**2 - lnksp1**2) ) &
    &      / ( (B - At + lnksp2 / kappa) * (lnksp1 - lnksp3) &
    &        - (B - Ar + lnksp3 / kappa) * (lnksp1 - lnksp2) )
    alpha  = (B - At + lnksp2 / kappa) &
    &      / ((lnksp2 - beta)**2 - (lnksp1 - beta)**2)
    gamma  = - alpha * (lnksp1 - beta)**2
    IF(ksp .LT. ksp1) THEN
      DB = 0.0
    ELSEIF(ksp .GT. ksp3) THEN
      DB = B - Ar + LOG(ksp) / kappa
    ELSE
      DB = alpha * (LOG(ksp) - beta)**2 + gamma
    ENDIF
    utau = up / (LOG(yplusp) / kappa + B - DB)
  ENDIF
  dudy1 = utau / (kappa * yp)
  dudy2 =-dudy1 / yp
  uvp  = - utau**2
  uup  = - 4.9 * uvp
  vvp  = - 1.0 * uvp
  wwp  = - 2.4 * uvp
  epsp = utau**3 / (kappa * yp)
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE WallFunctionRSM1R
!***********************************************************************
!**** KEM�p�̕Ǌ֐�(�e��)                                           ****
!***********************************************************************
SUBROUTINE WallFunctionKEM2R( &
&            ks, yp, up, nup, &
&            utau, dudy1, dudy2, kp, epsp &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, PARAMETER :: cmu = 0.09
  REAL, PARAMETER :: kappa = 0.40, B = 5.5
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, INTENT(IN)  :: ks                    ! �e�x�v�f����   (ks > 0)
  REAL, INTENT(IN)  :: yp                    ! �ǂ���̋���   (yp > 0)
  REAL, INTENT(IN)  :: up                    ! �ǐ����������x (up > 0)
  REAL, INTENT(IN)  :: nup                   ! ���S�x         (nup > 0)
  REAL, INTENT(OUT) :: utau                  ! ���C���x       (utau > 0)
  REAL, INTENT(OUT) :: dudy1, dudy2          ! ���x�̈�K�����Ɠ�K����
  REAL, INTENT(OUT) :: kp, epsp              ! ������
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ! �����J�n ***********************************************************
  CALL CalUtauR(kappa, B, ks, yp, up, nup, utau, dudy1, dudy2)
  kp   = utau**2 / SQRT(cmu)
  epsp = utau**3 / (kappa * yp)
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE WallFunctionKEM2R
!***********************************************************************
!**** RSM�p�̕Ǌ֐�(�e��)                                           ****
!***********************************************************************
SUBROUTINE WallFunctionRSM2R( &
&            ks, yp, up, nup, &
&            utau, dudy1, dudy2, uup, vvp, wwp, uvp, epsp &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, PARAMETER :: kappa = 0.40, B = 5.5
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL, INTENT(IN)  :: ks                    ! �e�x�v�f����   (ks > 0)
  REAL, INTENT(IN)  :: yp                    ! �ǂ���̋���   (yp > 0)
  REAL, INTENT(IN)  :: up                    ! �ǐ����������x (up > 0)
  REAL, INTENT(IN)  :: nup                   ! ���S�x         (nup > 0)
  REAL, INTENT(OUT) :: utau                  ! ���C���x       (utau > 0)
  REAL, INTENT(OUT) :: dudy1, dudy2          ! ���x�̈�K�����Ɠ�K����
  REAL, INTENT(OUT) :: uup, vvp, wwp, uvp    ! ���C�m���Y����
  REAL, INTENT(OUT) :: epsp                  ! ����̎U�헦
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ! �����J�n ***********************************************************
  CALL CalUtauR(kappa, B, ks, yp, up, nup, utau, dudy1, dudy2)
  uvp  = - utau**2
  uup  = - 4.9 * uvp
  vvp  = - 1.0 * uvp
  wwp  = - 2.4 * uvp
  epsp = utau**3 / (kappa * yp)
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE WallFunctionRSM2R
!***********************************************************************
!**** ���C���x�̌v�Z(�e�ʂ̑ΐ���)                                  ****
!***********************************************************************
SUBROUTINE CalUtauR( &
&            kappa, B, ks, yp, up, nup, &
&            utau, dudy1, dudy2 &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �Ǐ��萔 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, PARAMETER :: NMAX = 100
  REAL,    PARAMETER :: ZERO = 1.0E-20, RESMIN = 1.0E-8
  REAL,    PARAMETER :: ksp1 = 4.0, ksp2 = 15.0, ksp3 = 55.0
  REAL,    PARAMETER :: At = 9.5, Ar = 8.5
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: kappa, B           ! �ΐ����̃��f���萔
  REAL,    INTENT(IN)  :: ks                 ! �e�x�v�f����   (ks > 0)
  REAL,    INTENT(IN)  :: yp                 ! �ǂ���̋���   (yp > 0)
  REAL,    INTENT(IN)  :: up                 ! �ǐ����������x (up > 0)
  REAL,    INTENT(IN)  :: nup                ! ���S�x         (nup > 0)
  REAL,    INTENT(OUT) :: utau               ! ���C���x       (utau > 0)
  REAL,    INTENT(OUT) :: dudy1, dudy2       ! ���x�̈�K�����Ɠ�K����
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: n
  REAL    :: ksp
  REAL    :: lnksp1, lnksp2, lnksp3
  REAL    :: alpha, beta, gamma
  REAL    :: DB, DButau, f, futau, dutau
  ! �����J�n ***********************************************************
  lnksp1 = LOG(ksp1)
  lnksp2 = LOG(ksp2)
  lnksp3 = LOG(ksp3)
  beta   = 0.5 &
  &      * ( (B - Ar + lnksp3 / kappa) * (lnksp2**2 - lnksp1**2) &
  &        - (B - At + lnksp2 / kappa) * (lnksp3**2 - lnksp1**2) ) &
  &      / ( (B - At + lnksp2 / kappa) * (lnksp1 - lnksp3) &
  &        - (B - Ar + lnksp3 / kappa) * (lnksp1 - lnksp2) )
  alpha  = (B - At + lnksp2 / kappa) &
  &      / ((lnksp2 - beta)**2 - (lnksp1 - beta)**2)
  gamma  = - alpha * (lnksp1 - beta)**2
  utau = SQRT(nup * up / yp)
  DO n = 1, NMAX
    ksp  = ks * utau / nup
    IF(ksp .LT. ksp1) THEN
      DB     = 0.0
      DButau = 0.0
    ELSEIF(ksp .GT. ksp3) THEN
      DB     = B - Ar + LOG(ksp) / kappa
      DButau = 1.0 / (kappa * ksp)
    ELSE
      DB     = alpha * (LOG(ksp) - beta)**2 + gamma
      DButau = 2.0 * alpha * (LOG(ksp) - beta) / ksp
    ENDIF
    f     = up / utau - LOG(yp * utau / nup) / kappa - B + DB
    futau = - (up / utau + 1 / kappa) / utau + DButau
    IF(ABS(futau) .LE. ZERO) futau = SIGN(ZERO, futau)
    dutau = - f / futau
    utau  = MAX(ZERO, utau + dutau)
    IF(ABS(dutau) .LT. utau * RESMIN) EXIT
  ENDDO
  IF(yp * utau / nup .LE. 11.635) THEN
    utau = SQRT(nup * up / yp)
  ENDIF
  dudy1 = utau / (kappa * yp)
  dudy2 =-dudy1 / yp
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE CalUtauR
!***********************************************************************
!**** ��X�e�b�v�O�̗�������ۑ�                                    ****
!**** �v�Z�Ώ� : �P��, �O����, ���k��, k-e                          ****
!***********************************************************************
SUBROUTINE SaveFlux3DKEM( &
&            IS, IE, JS, JE, KS, KE, LS, LE, &
&            QH, DQH, QH0, DQH0  &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE, KS, KE, LS, LE
  REAL   , INTENT(IN)  :: QH  (IS:IE, JS:JE, KS:KE, LS:LE)
  REAL   , INTENT(IN)  :: DQH (IS:IE, JS:JE, KS:KE, LS:LE)
  REAL   , INTENT(OUT) :: QH0 (IS:IE, JS:JE, KS:KE, LS:LE)
  REAL   , INTENT(OUT) :: DQH0(IS:IE, JS:JE, KS:KE, LS:LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K, L
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I, J, K, L)
  DO L = LS, LE
  DO K = KS, KE
  DO J = JS, JE
  DO I = IS, IE
    QH0(I,J,K,L)  = QH(I,J,K,L)
    DQH0(I,J,K,L) = DQH(I,J,K,L)
  ENDDO
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE SaveFlux3DKEM
!***********************************************************************
!**** �e���̑��a		                                    ****
!**** �v�Z�Ώ� : �P��, �O����, ���k��, k-e                          ****
!***********************************************************************
SUBROUTINE SumDQH3D( &
&            IS, IE, JS, JE, KS, KE, LS, LE, &
&            DQC, DQD, DQP, DQR, DQH &
&          )
  ! �ϐ��錾 ***********************************************************
  IMPLICIT NONE
  ! �����ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE, KS, KE, LS, LE
  REAL   , INTENT(IN)  :: DQC(IS:IE, JS:JE, KS:KE, LS:LE)
  REAL   , INTENT(IN)  :: DQD(IS:IE, JS:JE, KS:KE, LS:LE)
  REAL   , INTENT(IN)  :: DQP(IS:IE, JS:JE, KS:KE, LS:LE)
  REAL   , INTENT(IN)  :: DQR(IS:IE, JS:JE, KS:KE, LS:LE)
  REAL   , INTENT(OUT) :: DQH(IS:IE, JS:JE, KS:KE, LS:LE)
  ! �Ǐ��ϐ� +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K, L
  ! �����J�n ***********************************************************
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I, J, K, L)
  DO L = LS, LE
  DO K = KS, KE
  DO J = JS, JE
  DO I = IS, IE
    DQH(I,J,K,L) = DQC(I,J,K,L) + DQD(I,J,K,L) &
  &              + DQP(I,J,K,L) + DQR(I,J,K,L)
  ENDDO
  ENDDO
  ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  ! �����I�� ***********************************************************
  RETURN
END SUBROUTINE SumDQH3D
! ��`�I�� *************************************************************
END MODULE Package_Flow
```

## file "Mod_Package_Grid.f90"

```fortran
!***********************************************************************
!***********************************************************************
!**** パッケージ型モジュール                                        ****
!**** 格子生成用サブルーチン群                                      ****
!****                         2010.02.04 PROGRAMED BY SUZUKI MASAYA ****
!****                         2011.10.15 UPDATED BY RYOSUKE HAYASHI ****
!***********************************************************************
!***********************************************************************
MODULE Package_Grid
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 局所定数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  PRIVATE
  ! サブルーチン宣言 ***************************************************
  ! 共有サブルーチン (正也さん作) ++++++++++++++++++++++++++++++++++++++
  PUBLIC :: CheckGrid2D, CheckGrid3D
  PUBLIC :: FUNCR, GeometricInterpolation, GeometricInterpolationInv
  PUBLIC :: VinokurInterpolation
  PUBLIC :: GridEPDE1D,  GridEPDE2D,  GridEPDE3D
  PUBLIC :: GridEHPDE1D, GridEHPDE2D, GridEHPDE3D
  PUBLIC :: TwoBoundaryMethod2D
  PUBLIC :: Transfinite1D, Transfinite2D, Transfinite3D
  PUBLIC :: Metrics2D, Metrics3D
  PUBLIC :: WallDistance2D, WallDistance3D
  PUBLIC :: WideSearch2D4Point, WideSearch3D8Point
  PUBLIC :: Interpolation2D3Point, Interpolation3D4Point
  PUBLIC :: Interpolation2D4Point, Interpolation3D8Point
  ! 共有サブルーチン (自作) ++++++++++++++++++++++++++++++++++++++++++++
  PUBLIC :: BladeInOut
! 内部手続き ***********************************************************
CONTAINS
!***********************************************************************
!**** 二次元格子間隔のチェック                                      ****
!***********************************************************************
SUBROUTINE CheckGrid2D( &
&            IS, IE, JS, JE, X, Y &
&          )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN) :: IS, IE, JS, JE
  REAL,    INTENT(IN) :: X(IS:IE, JS:JE), Y(IS:IE, JS:JE)
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J
  REAL    :: RATE_MAX, RATE_MIN
  REAL    :: DL1, DL2, RATE
  ! 処理開始 ***********************************************************
  ! 格子点間隔の比に問題がないかを判定 +++++++++++++++++++++++++++++++++
  RATE_MAX = 1.2
  RATE_MIN = RATE_MAX**(-1.0)
  OPEN(16,FILE='Check.txt')
  ! I方向
  DO J=JS,JE
    DO I=IS+1,IE-1
      DL1 = SQRT( (X(I  ,J) - X(I-1,J))**2 &
      &         + (Y(I  ,J) - Y(I-1,J))**2 )
      DL2 = SQRT( (X(I+1,J) - X(I  ,J))**2 &
      &         + (Y(I+1,J) - Y(I  ,J))**2 )
      RATE = DL2 / DL1
      IF((RATE .GT. RATE_MAX) .OR. (RATE .LT. RATE_MIN)) THEN
        WRITE(16,'(A,F12.8,A,I4,A,I4,A)') &
        & 'Bad Rate : ', RATE, ' Grid ', I, '-',J, ' I Direction'
      ENDIF
    ENDDO
  ENDDO
  ! J方向
  DO I=IS,IE
    DO J=JS+1,JE-1
      DL1 = SQRT( (X(I,J  ) - X(I,J-1))**2 &
      &         + (Y(I,J  ) - Y(I,J-1))**2 )
      DL2 = SQRT( (X(I,J+1) - X(I,J  ))**2 &
      &         + (Y(I,J+1) - Y(I,J  ))**2 )
      RATE = DL2 / DL1
      IF((RATE .GT. RATE_MAX ) .OR. (RATE .LT. RATE_MIN)) THEN
        WRITE(16,'(A,F12.8,A,I4,A,I4,A)') &
        & 'Bad Rate : ', RATE, ' Grid ', I, '-', J, ' J Direction'
      ENDIF
    ENDDO
  ENDDO
  CLOSE(16)
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE CheckGrid2D
!***********************************************************************
!**** 三次元格子間隔のチェック                                      ****
!***********************************************************************
SUBROUTINE CheckGrid3D( &
&            IS, IE, JS, JE, KS, KE, X, Y, Z &
&          )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN) :: IS, IE, JS, JE, KS, KE
  REAL,    INTENT(IN) :: X(IS:IE, JS:JE, KS:KE), &
  &                      Y(IS:IE, JS:JE, KS:KE), &
  &                      Z(IS:IE, JS:JE, KS:KE)
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K
  REAL    :: RATE_MAX, RATE_MIN
  REAL    :: DL1, DL2, RATE
  ! 処理開始 ***********************************************************
  ! 格子点間隔の比に問題がないかを判定 +++++++++++++++++++++++++++++++++
  RATE_MAX = 1.2
  RATE_MIN = RATE_MAX**(-1.0)
  OPEN(16,FILE='Check.txt')
  ! I方向
  DO K=KS,KE
  DO J=JS,JE
    DO I=IS+1,IE-1
      DL1 = SQRT( ( X(I  ,J,K)-X(I-1,J,K) )**2 &
      &         + ( Y(I  ,J,K)-Y(I-1,J,K) )**2 &
      &         + ( Z(I  ,J,K)-Z(I-1,J,K) )**2 )
      DL2 = SQRT( ( X(I+1,J,K)-X(I  ,J,K) )**2 &
      &         + ( Y(I+1,J,K)-Y(I  ,J,K) )**2 &
      &         + ( Z(I+1,J,K)-Z(I  ,J,K) )**2 )
      RATE = DL2/DL1
      IF( ( RATE .GT. RATE_MAX ).OR.( RATE .LT. RATE_MIN ) ) THEN
        WRITE(16,'(A,F12.8,A,I4,A,I4,A,I4,A)') &
        & 'Bad Rate : ',RATE,' Grid ',I,'-',J,'-',K, &
        & ' I Direction'
      ENDIF
    ENDDO
  ENDDO
  ENDDO
  ! J方向
  DO K=KS,KE
  DO I=IS,IE
    DO J=JS+1,JE-1
      DL1 = SQRT( ( X(I,J  ,K)-X(I,J-1,K) )**2 &
      &         + ( Y(I,J  ,K)-Y(I,J-1,K) )**2 &
      &         + ( Z(I,J  ,K)-Z(I,J-1,K) )**2 )
      DL2 = SQRT( ( X(I,J+1,K)-X(I,J  ,K) )**2 &
      &         + ( Y(I,J+1,K)-Y(I,J  ,K) )**2 &
      &         + ( Z(I,J+1,K)-Z(I,J  ,K) )**2 )
      RATE = DL2/DL1
      IF( ( RATE .GT. RATE_MAX ).OR.( RATE .LT. RATE_MIN ) ) THEN
        WRITE(16,'(A,F12.8,A,I4,A,I4,A,I4,A)') &
        & 'Bad Rate : ',RATE,' Grid ',I,'-',J,'-',K, &
        & ' J Direction'
      ENDIF
    ENDDO
  ENDDO
  ENDDO
  ! K方向
  DO J=JS,JE
  DO I=IS,IE
    DO K=KS+1,KE-1
      DL1 = SQRT( ( X(I,J,K  )-X(I,J,K-1) )**2 &
      &         + ( Y(I,J,K  )-Y(I,J,K-1) )**2 &
      &         + ( Z(I,J,K  )-Z(I,J,K-1) )**2 )
      DL2 = SQRT( ( X(I,J,K+1)-X(I,J,K  ) )**2 &
      &         + ( Y(I,J,K+1)-Y(I,J,K  ) )**2 &
      &         + ( Z(I,J,K+1)-Z(I,J,K  ) )**2 )
      RATE = DL2/DL1
      IF( ( RATE .GT. RATE_MAX ).OR.( RATE .LT. RATE_MIN ) ) THEN
        WRITE(16,'(A,F12.8,A,I4,A,I4,A,I4,A)') &
        & 'Bad Rate : ',RATE,' Grid ',I,'-',J,'-',K, &
        & ' K Direction'
      ENDIF
    ENDDO
  ENDDO
  ENDDO
  CLOSE(16)
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE CheckGrid3D
!***********************************************************************
!**** 最終項数n、初項a、等比級数Sから公比FUNCRを計算する            ****
!***********************************************************************
REAL FUNCTION FUNCR(n, a, S)
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 局所定数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, PARAMETER :: MMAX = 1000 !100
  REAL(8), PARAMETER :: RMIN = 0.5D+0, RMAX = 2.0D+0
  REAL(8), PARAMETER :: ZERO = 1.0D-20, RESMIN = 1.0D-8
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN) :: n
  REAL,    INTENT(IN) :: a, S
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: m
  REAL(8) :: S1, Sn
  REAL(8) :: r, dr, f, fr
  ! 処理開始 ***********************************************************
  ! 初期値 -------------------------------------------------------------
  S1 = DBLE(a)
  Sn = DBLE(S)
  IF(S1 * DBLE(n) .LT. Sn) THEN
   r = RMAX
  ELSEIF(S1 * DBLE(n) .GT. Sn) THEN
   r = RMIN
  ELSE
   FUNCR = 1.0
   RETURN
  END IF
  ! Newton-Raphson Method ----------------------------------------------
  DO m = 1, MMAX
    f  = S1 * (1.0D+0 - r**DBLE(n)) / (1.0D+0 - r) - Sn
    fr = S1 * ( - DBLE(n) * r**DBLE(n - 1) * (1.0D+0 - r) &
    &         + 1.0D+0 - r**DBLE(n) &
    &    ) / (1.0D+0 - r)**2
    IF(ABS(fr) .LE. ZERO) fr = SIGN(ZERO, fr)
    dr =-f / fr
    r  = r + dr
    r  = MAX(RMIN, MIN(RMAX, r))
    IF(ABS(dr) .LE. ABS(r) * RESMIN .OR. r .EQ. 1.0D+0) EXIT
  ENDDO
  FUNCR = REAL(r)
  ! WRITE(*,*) 'Common ratio of geometric progression = ', FUNCR
  ! 処理終了 ***********************************************************
  RETURN
END FUNCTION FUNCR
!***********************************************************************
!**** 等比級数による一次元補間関数                                  ****
!**** 初項a、公比rの等比数列の和(等比級数)により、                  ****
!**** 区間0 <= x <= 1にn個の点を配置する                            ****
!***********************************************************************
SUBROUTINE GeometricInterpolation(a, n, x, r)
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: a
  INTEGER, INTENT(IN)  :: n
  REAL,    INTENT(OUT) :: x(n)
  REAL,    INTENT(OUT) :: r
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: i
  LOGICAL :: Check
  ! 処理開始 ***********************************************************
  ! 公比を決定 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  r = 1.030898977259116 !FUNCR(n - 1, a, 1.0)
  !r is calculated with Mathematica FindRoot
  ! 等比級数による補間関数を計算 +++++++++++++++++++++++++++++++++++++++
  x(1) = 0.0
  x(n) = 1.0
  Check = .FALSE.
  IF(r .NE. 1.0) THEN
    ! 等比級数を計算 ---------------------------------------------------
    DO i = 2, n - 1
      x(i) = a * (1.0 - r**(i - 1)) / (1.0 - r)
    ENDDO
    ! 単調性を検査 -----------------------------------------------------
    DO i = 2, n - 1
      IF(x(i-1) .GE. x(i) .OR. x(i) .GE. x(i+1)) THEN
        WRITE(*, '(A)') 'GeometricInterpolation -> No Monotone Error'
        Check = .TRUE.
        EXIT
      ENDIF
    ENDDO
  ELSE
    Check = .TRUE.
  ENDIF
  ! 公比が1の場合か単調性が保証されていない場合は等間隔の結果を返す ++++
  IF(Check) THEN
    DO i = 2, n - 1
      x(i) = REAL(i - 1) / REAL(n - 1)
    ENDDO
  ENDIF
  ! 処理終了 ***********************************************************
  RETURN
! 定義終了 *************************************************************
END SUBROUTINE GeometricInterpolation
!***********************************************************************
!**** 等比級数による一次元補間関数                                  ****
!**** 初項a、公比rの等比数列の和(等比級数)を逆順に並べて            ****
!**** 区間0 <= x <= 1にn個の点を配置する(終点の幅がaとなる)         ****
!***********************************************************************
SUBROUTINE GeometricInterpolationInv(a, n, x, r)
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: a
  INTEGER, INTENT(IN)  :: n
  REAL,    INTENT(OUT) :: x(n)
  REAL,    INTENT(OUT) :: r
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: i
  LOGICAL :: Check
  ! 処理開始 ***********************************************************
  ! 公比を決定 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  r = 1.00700309717312 !FUNCR(n - 1, a, 1.0)
  ! 等比級数による補間関数を計算 +++++++++++++++++++++++++++++++++++++++
  x(1) = 0.0
  x(n) = 1.0
  Check = .FALSE.
  IF(r .NE. 1.0) THEN
    ! 等比級数を計算 ---------------------------------------------------
    DO i = 2, n - 1
      x(i) = 1.0 - a * (1.0 - r**(n - i)) / (1.0 - r)
    ENDDO
    ! 単調性を検査 -----------------------------------------------------
    DO i = 2, n - 1
      IF(x(i-1) .GE. x(i) .OR. x(i) .GE. x(i+1)) THEN
        WRITE(*, '(A)') 'GeometricInterpolation -> No Monotone Error'
        Check = .TRUE.
        EXIT
      ENDIF
    ENDDO
  ELSE
    Check = .TRUE.
  ENDIF
  ! 公比が1の場合か単調性が保証されていない場合は等間隔の結果を返す ++++
  IF(Check) THEN
    DO i = 2, n - 1
      x(i) = REAL(i - 1) / REAL(n - 1)
    ENDDO
  ENDIF
  ! 処理終了 ***********************************************************
  RETURN
! 定義終了 *************************************************************
END SUBROUTINE GeometricInterpolationInv
!***********************************************************************
!**** Vinokurの一次元補間関数(1983, J. Comp. Phys., 50, 215-234)    ****
!****   区間0 <= x <= 1にN個の点を配置する                          ****
!****   Dx1 = x(2) - x(1), DxN = x(N) - x(N-1)                      ****
!***********************************************************************
SUBROUTINE VinokurInterpolation(Dx1, DxN, N, x)
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 局所定数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, PARAMETER :: JMAX = 100
  REAL(8), PARAMETER :: ZERO = 1.0D-20, RESMIN = 1.0D-12
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: Dx1, DxN
  INTEGER, INTENT(IN)  :: N
  REAL,    INTENT(OUT) :: x(N)
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: i, j
  REAL(8) :: S0, S1, B, A, xi, DZ, U
  REAL(8) :: f, fdz, ddz
  LOGICAL :: Check
  ! 処理開始 ***********************************************************
  ! Vinokurの一次元補間関数を計算 ++++++++++++++++++++++++++++++++++++++
  S0 = 1.0D+0 / (DBLE(N - 1) * DBLE(Dx1))
  S1 = 1.0D+0 / (DBLE(N - 1) * DBLE(DxN))
  B  = SQRT(S0 * S1)
  A  = SQRT(S0 / S1)
  IF(B .LT. 1.0D+0) THEN
    DZ = B
    DO j = 1, JMAX
      f   = SIN(DZ) / DZ - B
      fdz = (DZ * COS(DZ) - SIN(DZ)) / DZ**2
      IF(ABS(fdz) .LE. ZERO) fdz = SIGN(ZERO, fdz)
      ddz = - f / fdz
      DZ  = DZ + ddZ
      IF(ABS(DZ) .LE. ZERO) DZ = SIGN(ZERO, DZ)
      IF(ABS(ddz) .LT. DZ * RESMIN) EXIT
    ENDDO
    DO i = 1, N
      xi = DBLE(i - 1) / DBLE(N - 1)
      x(i) = REAL( &
      &      TAN(xi * DZ) &
      &    / (A * SIN(DZ) + (1.0D+0 - A * COS(DZ)) * TAN(xi * DZ)) &
      &    )
    ENDDO
  ELSEIF(B .GT. 1.0D+0) THEN
    DZ = B
    DO j = 1, JMAX
      f   = SINH(DZ) / DZ - B
      fdz = (DZ * COSH(DZ) - SINH(DZ)) / DZ**2
      IF(ABS(fdz) .LE. ZERO) fdz = SIGN(ZERO, fdz)
      ddz = - f / fdz
      DZ  = DZ + ddZ
      IF(ABS(DZ) .LE. ZERO) DZ = SIGN(ZERO, DZ)
      IF(ABS(ddz) .LT. DZ * RESMIN) EXIT
    ENDDO
    DO i = 1, N
      xi = DBLE(i - 1) / DBLE(N - 1)
      x(i) = REAL( &
      &      TANH(xi * DZ) &
      &    / (A * SINH(DZ) + (1.0D+0 - A * COSH(DZ)) * TANH(xi * DZ)) &
      &    )
    ENDDO
  ELSE
    DO i = 1, N
      xi = DBLE(i - 1) / DBLE(N - 1)
      U  = xi * ( 1.0D+0 &
      &  + 2.0D+0 * (B - 1.0D+0) * (xi - 0.5D+0) * (1.0D+0 - xi) &
      &  )
      x(i) = REAL(U / (A + (1.0D+0 - A) * U))
    ENDDO
  ENDIF
  ! 始点と終点を補正 +++++++++++++++++++++++++++++++++++++++++++++++++++
  x(1) = 0.0
  x(n) = 1.0
  ! 単調性を検査 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
  Check = .FALSE.
  DO i = 2, n - 1
    IF(x(i-1) .GE. x(i) .OR. x(i) .GE. x(i+1)) THEN
      WRITE(*, '(A)') 'VinokurInterpolation -> No Monotone Error'
      Check = .TRUE.
      EXIT
    ENDIF
  ENDDO
  ! 公比が1の場合か単調性が保証されていない場合は等間隔の結果を返す ++++
  IF(Check) THEN
    DO i = 2, n - 1
      x(i) = REAL(i - 1) / REAL(n - 1)
    ENDDO
  ENDIF
  ! 処理終了 ***********************************************************
  RETURN
! 定義終了 *************************************************************
END SUBROUTINE VinokurInterpolation
!***********************************************************************
!**** 楕円型偏微分方程式(Elliptic Partial Differential Equation)    ****
!**** による格子生成法(一次元ラプラス方程式)                        ****
!***********************************************************************
SUBROUTINE GridEPDE1D( &
&            OMG, &
&            IS, IE, &
&            X, DMAX &
&          )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)    :: OMG                             ! 緩和係数
  INTEGER, INTENT(IN)    :: IS, IE                          ! 格子数
  ! 格子点座標 ---------------------------------------------------------
  REAL,    INTENT(INOUT) :: X(IS: IE)                       ! x
  ! 残差 ---------------------------------------------------------------
  REAL,    INTENT(OUT)   :: DMAX                            ! 最大値
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER           :: I
  REAL, ALLOCATABLE :: DX(:)
  ! 処理開始 ***********************************************************
  ALLOCATE(DX(IS: IE)); DX(:) = 0.0
  DO I = IS + 1, IE - 1
    DX(I) = (X(I+1) + X(I-1)) / 2.0 - X(I)
  ENDDO
  DO I = IS + 1, IE - 1
    X(I) = X(I) + OMG * DX(I)
  ENDDO
  DMAX = MAXVAL(SQRT(DX(:)**2))
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE GridEPDE1D
!***********************************************************************
!**** 楕円型偏微分方程式(Elliptic Partial Differential Equation)    ****
!**** による格子生成法(二次元ラプラス方程式)                        ****
!***********************************************************************
SUBROUTINE GridEPDE2D( &
&            OMG, &
&            IS, IE, JS, JE, &
&            X, Y, DMAX &
&          )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)    :: OMG                             ! 緩和係数
  INTEGER, INTENT(IN)    :: IS, IE, JS, JE                  ! 格子数
  ! 格子点座標 ---------------------------------------------------------
  REAL,    INTENT(INOUT) :: X(IS: IE, JS: JE), &            ! x
  &                         Y(IS: IE, JS: JE)               ! y
  ! 残差 ---------------------------------------------------------------
  REAL,    INTENT(OUT)   :: DMAX                            ! 最大値
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER           :: I, J
  REAL              :: XXI, XET, YXI, YET
  REAL              :: AJA
  REAL              :: AJA11, AJA12, AJA21, AJA22
  REAL              :: ALP11, ALP12, ALP21, ALP22
  REAL              :: DXC, DXM, DYC, DYM
  REAL, ALLOCATABLE :: DX(:, :), DY(:, :)
  ! 処理開始 ***********************************************************
  ALLOCATE(DX(IS: IE, JS: JE)); DX(:, :) = 0.0
  ALLOCATE(DY(IS: IE, JS: JE)); DY(:, :) = 0.0
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
    ! x_xi (x = x, y; xi = xi, eta) ------------------------------------
    XXI =-0.5 * (X(I-1,J) - X(I+1,J))
    YXI =-0.5 * (Y(I-1,J) - Y(I+1,J))
    XET =-0.5 * (X(I,J-1) - X(I,J+1))
    YET =-0.5 * (Y(I,J-1) - Y(I,J+1))
    ! J (Jacobian) -----------------------------------------------------
    AJA = XXI * YET - XET * YXI
    ! J_ij (i = 1, 2; j = 1, 2) ----------------------------------------
    AJA11 = YET
    AJA12 =-YXI
    AJA21 =-XET
    AJA22 = XXI
    ! alpha_ij (i = 1, 2; j = 1, 2) ------------------------------------
    ALP11 = AJA11 * AJA11 + AJA21 * AJA21
    ALP12 = AJA11 * AJA12 + AJA21 * AJA22
    ALP21 = AJA12 * AJA11 + AJA22 * AJA21
    ALP22 = AJA12 * AJA12 + AJA22 * AJA22
    ! x, y -------------------------------------------------------------
    DXC = ALP11 * (X(I+1,J) + X(I-1,J)) &
    &   + ALP22 * (X(I,J+1) + X(I,J-1)) &
    &   + 0.5 * ALP12 * ( &
    &     X(I-1,J-1) - X(I+1,J-1) - X(I-1,J+1) + X(I+1,J+1) &
    &   )
    DXM = 2.0 * (ALP11 + ALP22)
    DYC = ALP11 * (Y(I+1,J) + Y(I-1,J)) &
    &   + ALP22 * (Y(I,J+1) + Y(I,J-1)) &
    &   + 0.5 * ALP12 * ( &
    &     Y(I-1,J-1) - Y(I+1,J-1) - Y(I-1,J+1) + Y(I+1,J+1) &
    &   )
    DYM = 2.0 * (ALP11 + ALP22)
    IF(DXM .NE. 0.0 .AND. DYM .NE. 0.0) THEN
      DX(I,J) = DXC / DXM - X(I,J)
      DY(I,J) = DYC / DYM - Y(I,J)
    ENDIF
  ENDDO
  ENDDO
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
    X(I,J) = X(I,J) + OMG * DX(I,J)
    Y(I,J) = Y(I,J) + OMG * DY(I,J)
  ENDDO
  ENDDO
  DMAX = MAXVAL(SQRT(DX(:, :)**2 + DY(:, :)**2))
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE GridEPDE2D
!***********************************************************************
!**** 楕円型偏微分方程式(Elliptic Partial Differential Equation)    ****
!**** による格子生成法(三次元ラプラス方程式)                        ****
!***********************************************************************
SUBROUTINE GridEPDE3D( &
&            OMG, &
&            IS, IE, JS, JE, KS, KE, &
&            X, Y, Z, DMAX &
&          )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)    :: OMG                             ! 緩和係数
  INTEGER, INTENT(IN)    :: IS, IE, JS, JE, KS, KE          ! 格子数
  ! 格子点座標 ---------------------------------------------------------
  REAL,    INTENT(INOUT) :: X(IS: IE, JS: JE, KS: KE), &    ! x
  &                         Y(IS: IE, JS: JE, KS: KE), &    ! y
  &                         Z(IS: IE, JS: JE, KS: KE)       ! z
  ! 残差 ---------------------------------------------------------------
  REAL,    INTENT(OUT)   :: DMAX                            ! 最大値
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER           :: I, J, K
  REAL              :: XXI, XET, XZE, YXI, YET, YZE, ZXI, ZET, ZZE
  REAL              :: AJA
  REAL              :: AJA11, AJA12, AJA13, &
  &                    AJA21, AJA22, AJA23, &
  &                    AJA31, AJA32, AJA33
  REAL              :: ALP11, ALP12, ALP13, &
  &                    ALP21, ALP22, ALP23, &
  &                    ALP31, ALP32, ALP33
  REAL              :: DXC, DXM, DYC, DYM, DZC, DZM
  REAL, ALLOCATABLE :: DX(:, :, :), DY(:, :, :), DZ(:, :, :)
  ! 処理開始 ***********************************************************
  ALLOCATE(DX(IS: IE, JS: JE, KS: KE)); DX(:, :, :) = 0.0
  ALLOCATE(DY(IS: IE, JS: JE, KS: KE)); DY(:, :, :) = 0.0
  ALLOCATE(DZ(IS: IE, JS: JE, KS: KE)); DZ(:, :, :) = 0.0
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
    ! x_xi (x = x, y, z; xi = xi, eta, zeta) ---------------------------
    XXI =-0.5 * (X(I-1,J,K) - X(I+1,J,K))
    YXI =-0.5 * (Y(I-1,J,K) - Y(I+1,J,K))
    ZXI =-0.5 * (Z(I-1,J,K) - Z(I+1,J,K))
    XET =-0.5 * (X(I,J-1,K) - X(I,J+1,K))
    YET =-0.5 * (Y(I,J-1,K) - Y(I,J+1,K))
    ZET =-0.5 * (Z(I,J-1,K) - Z(I,J+1,K))
    XZE =-0.5 * (X(I,J,K-1) - X(I,J,K+1))
    YZE =-0.5 * (Y(I,J,K-1) - Y(I,J,K+1))
    ZZE =-0.5 * (Z(I,J,K-1) - Z(I,J,K+1))
    ! J (Jacobian) -----------------------------------------------------
    AJA = XXI * (YET * ZZE - YZE * ZET) &
    &   + XET * (YZE * ZXI - YXI * ZZE) &
    &   + XZE * (YXI * ZET - YET * ZXI)
    ! J_ij (i = 1, 3; j = 1, 3) ----------------------------------------
    AJA11 = YET * ZZE - YZE * ZET
    AJA12 = YZE * ZXI - YXI * ZZE
    AJA13 = YXI * ZET - YET * ZXI
    AJA21 = XZE * ZET - XET * ZZE
    AJA22 = XXI * ZZE - XZE * ZXI
    AJA23 = XET * ZXI - XXI * ZET
    AJA31 = XET * YZE - XZE * YET
    AJA32 = XZE * YXI - XXI * YZE
    AJA33 = XXI * YET - XET * YXI
    ! alpha_ij (i = 1, 3; j = 1, 3) ------------------------------------
    ALP11 = AJA11 * AJA11 + AJA21 * AJA21 + AJA31 * AJA31
    ALP12 = AJA11 * AJA12 + AJA21 * AJA22 + AJA31 * AJA32
    ALP13 = AJA11 * AJA13 + AJA21 * AJA23 + AJA31 * AJA33
    ALP21 = AJA12 * AJA11 + AJA22 * AJA21 + AJA32 * AJA31
    ALP22 = AJA12 * AJA12 + AJA22 * AJA22 + AJA32 * AJA32
    ALP23 = AJA12 * AJA13 + AJA22 * AJA23 + AJA32 * AJA33
    ALP31 = AJA13 * AJA11 + AJA23 * AJA21 + AJA33 * AJA31
    ALP32 = AJA13 * AJA12 + AJA23 * AJA22 + AJA33 * AJA32
    ALP33 = AJA13 * AJA13 + AJA23 * AJA23 + AJA33 * AJA33
    ! x, y, z ----------------------------------------------------------
    DXC = ALP11 * (X(I+1,J,K) + X(I-1,J,K)) &
    &   + ALP22 * (X(I,J+1,K) + X(I,J-1,K)) &
    &   + ALP33 * (X(I,J,K+1) + X(I,J,K-1)) &
    &   + 0.5 * ALP12 * ( &
    &     X(I-1,J-1,K) - X(I+1,J-1,K) - X(I-1,J+1,K) + X(I+1,J+1,K) &
    &   ) &
    &   + 0.5 * ALP23 * ( &
    &     X(I,J-1,K-1) - X(I,J+1,K-1) - X(I,J-1,K+1) + X(I,J+1,K+1) &
    &   ) &
    &   + 0.5 * ALP31 * ( &
    &     X(I-1,J,K-1) - X(I+1,J,K-1) - X(I-1,J,K+1) + X(I+1,J,K+1) &
    &   )
    DXM = 2.0 * (ALP11 + ALP22 + ALP33)
    DYC = ALP11 * (Y(I+1,J,K) + Y(I-1,J,K)) &
    &   + ALP22 * (Y(I,J+1,K) + Y(I,J-1,K)) &
    &   + ALP33 * (Y(I,J,K+1) + Y(I,J,K-1)) &
    &   + 0.5 * ALP12 * ( &
    &     Y(I-1,J-1,K) - Y(I+1,J-1,K) - Y(I-1,J+1,K) + Y(I+1,J+1,K) &
    &   ) &
    &   + 0.5 * ALP23 * ( &
    &     Y(I,J-1,K-1) - Y(I,J+1,K-1) - Y(I,J-1,K+1) + Y(I,J+1,K+1) &
    &   ) &
    &   + 0.5 * ALP31 * ( &
    &     Y(I-1,J,K-1) - Y(I+1,J,K-1) - Y(I-1,J,K+1) + Y(I+1,J,K+1) &
    &   )
    DYM = 2.0 * (ALP11 + ALP22 + ALP33)
    DZC = ALP11 * (Z(I+1,J,K) + Z(I-1,J,K)) &
    &   + ALP22 * (Z(I,J+1,K) + Z(I,J-1,K)) &
    &   + ALP33 * (Z(I,J,K+1) + Z(I,J,K-1)) &
    &   + 0.5 * ALP12 * ( &
    &     Z(I-1,J-1,K) - Z(I+1,J-1,K) - Z(I-1,J+1,K) + Z(I+1,J+1,K) &
    &   ) &
    &   + 0.5 * ALP23 * ( &
    &     Z(I,J-1,K-1) - Z(I,J+1,K-1) - Z(I,J-1,K+1) + Z(I,J+1,K+1) &
    &   ) &
    &   + 0.5 * ALP31 * ( &
    &     Z(I-1,J,K-1) - Z(I+1,J,K-1) - Z(I-1,J,K+1) + Z(I+1,J,K+1) &
    &   )
    DZM = 2.0 * (ALP11 + ALP22 + ALP33)
    IF(DXM .NE. 0.0 .AND. DYM .NE. 0.0 .AND. DZM .NE. 0.0) THEN
      DX(I,J,K) = DXC / DXM - X(I,J,K)
      DY(I,J,K) = DYC / DYM - Y(I,J,K)
      DZ(I,J,K) = DZC / DZM - Z(I,J,K)
    ENDIF
  ENDDO
  ENDDO
  ENDDO
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
    X(I,J,K) = X(I,J,K) + OMG * DX(I,J,K)
    Y(I,J,K) = Y(I,J,K) + OMG * DY(I,J,K)
    Z(I,J,K) = Z(I,J,K) + OMG * DZ(I,J,K)
  ENDDO
  ENDDO
  ENDDO
  DMAX = MAXVAL(SQRT(DX(:, :, :)**2 + DY(:, :, :)**2 + DZ(:, :, :)**2))
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE GridEPDE3D
!***********************************************************************
!**** 一次元楕円-双曲型格子生成法(Yamamoto Kazuomi, 1992)           ****
!**** (1D Elliptic-Hyperbolic Grid Generation Method)               ****
!***********************************************************************
SUBROUTINE GridEHPDE1D( &
&            OMG, &
&            IS, IE, &
&            Cs, &
&            Cv1m, Cv1p, &
&            DX1m, DX1p, &
&            X, DMAX &
&          )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)    :: OMG                             ! 緩和係数
  INTEGER, INTENT(IN)    :: IS, IE                          ! 格子数
  ! 楕円型重み関数(0以上) ----------------------------------------------
  REAL,    INTENT(IN)    :: Cs(IS: IE)                      ! 1-Cvが基本
  ! 双曲型重み関数(0以上) ----------------------------------------------
  REAL,    INTENT(IN)    :: Cv1m(IS: IE), &                 ! I-方向
  &                         Cv1p(IS: IE)                    ! I+方向
  ! 境界の傾きと幅(partial x_i / partial xi_i) -------------------------
  REAL,    INTENT(IN)    :: DX1m(IS: IE), &                 ! I-方向(x)
  &                         DX1p(IS: IE)                    ! I+方向(x)
  ! 格子点座標 ---------------------------------------------------------
  REAL,    INTENT(INOUT) :: X(IS: IE)                       ! x
  ! 残差 ---------------------------------------------------------------
  REAL,    INTENT(OUT)   :: DMAX                            ! 最大値
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  LOGICAL           :: FLAG
  INTEGER           :: I
  REAL              :: DXC, DXM
  REAL, ALLOCATABLE :: DX(:)
  ! 処理開始 ***********************************************************
  ! 例外処理(重み関数が負の場合は終了) +++++++++++++++++++++++++++++++++
  FLAG = .FALSE.
  DO I = IS + 1, IE - 1
    FLAG = FLAG .OR. Cs(I) .LT. 0.0 .OR. &
    &      Cv1m(I) .LT. 0.0 .OR. Cv1p(I) .LT. 0.0
  ENDDO
  IF(FLAG) THEN
    WRITE(*, '(A)') 'Error : Weight function is negative...'
    WRITE(*, '(A)') 'GridEHPDE1D is abnormally Terminated !'
    RETURN
  ENDIF
  ! メモリ確保 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ALLOCATE(DX(IS: IE)); DX(:) = 0.0
  ! ソルバー部 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  DO I = IS + 1, IE - 1
    DXC = Cs(I) * (X(I+1) + X(I-1)) &
    &   + Cv1p(I) * (X(I+1) - DX1p(I)) &
    &   + Cv1m(I) * (X(I-1) + DX1m(I))
    DXM = 2.0 * Cs(I) + Cv1p(I) + Cv1m(I)
    IF(DXM .NE. 0.0) THEN
      DX(I) = DXC / DXM - X(I)
    ENDIF
  ENDDO
  DO I = IS + 1, IE - 1
    X(I) = X(I) + OMG * DX(I)
  ENDDO
  DMAX = MAXVAL(SQRT(DX(:)**2))
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE GridEHPDE1D
!***********************************************************************
!**** 二次元楕円-双曲型格子生成法(Yamamoto Kazuomi, 1992)           ****
!**** (2D Elliptic-Hyperbolic Grid Generation Method)               ****
!***********************************************************************
SUBROUTINE GridEHPDE2D( &
&            OMG, &
&            IS, IE, JS, JE, &
&            Cs, &
&            Cv1m, Cv1p, Cv2m, Cv2p, &
&            DX1m, DY1m, DX1p, DY1p, DX2m, DY2m, DX2p, DY2p, &
&            X, Y, DMAX &
&          )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)    :: OMG                             ! 緩和係数
  INTEGER, INTENT(IN)    :: IS, IE, JS, JE                  ! 格子数
  ! 楕円型重み関数(0以上) ----------------------------------------------
  REAL,    INTENT(IN)    :: Cs(IS: IE, JS: JE)              ! 1-Cvが基本
  ! 双曲型重み関数(0以上) ----------------------------------------------
  REAL,    INTENT(IN)    :: Cv1m(IS: IE, JS: JE), &         ! I-方向
  &                         Cv1p(IS: IE, JS: JE), &         ! I+方向
  &                         Cv2m(IS: IE, JS: JE), &         ! J-方向
  &                         Cv2p(IS: IE, JS: JE)            ! J+方向
  ! 境界の傾きと幅(partial x_i / partial xi_i) -------------------------
  REAL,    INTENT(IN)    :: DX1m(IS: IE, JS: JE), &         ! I-方向(x)
  &                         DY1m(IS: IE, JS: JE), &         ! I-方向(y)
  &                         DX1p(IS: IE, JS: JE), &         ! I+方向(x)
  &                         DY1p(IS: IE, JS: JE), &         ! I+方向(y)
  &                         DX2m(IS: IE, JS: JE), &         ! J-方向(x)
  &                         DY2m(IS: IE, JS: JE), &         ! J-方向(y)
  &                         DX2p(IS: IE, JS: JE), &         ! J+方向(x)
  &                         DY2p(IS: IE, JS: JE)            ! J+方向(y)
  ! 格子点座標 ---------------------------------------------------------
  REAL,    INTENT(INOUT) :: X(IS: IE, JS: JE), &            ! x
  &                         Y(IS: IE, JS: JE)               ! y
  ! 残差 ---------------------------------------------------------------
  REAL,    INTENT(OUT)   :: DMAX                            ! 最大値
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  LOGICAL           :: FLAG
  INTEGER           :: I, J
  REAL              :: XXI, XET, YXI, YET
  REAL              :: AJA
  REAL              :: AJA11, AJA12, AJA21, AJA22
  REAL              :: ALP11, ALP12, ALP21, ALP22
  REAL              :: DXC, DXM, DYC, DYM
  REAL, ALLOCATABLE :: DX(:, :), DY(:, :)
  ! 処理開始 ***********************************************************
  ! 例外処理(重み関数が負の場合は終了) +++++++++++++++++++++++++++++++++
  FLAG = .FALSE.
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
    FLAG = FLAG .OR. Cs(I,J) .LT. 0.0 .OR. &
    &      Cv1m(I,J) .LT. 0.0 .OR. Cv1p(I,J) .LT. 0.0 .OR. &
    &      Cv2m(I,J) .LT. 0.0 .OR. Cv2p(I,J) .LT. 0.0
  ENDDO
  ENDDO
  IF(FLAG) THEN
    WRITE(*, '(A)') 'Error : Weight function is negative...'
    WRITE(*, '(A)') 'GridEHPDE2D is abnormally Terminated !'
    RETURN
  ENDIF
  ! メモリ確保 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ALLOCATE(DX(IS: IE, JS: JE)); DX(:, :) = 0.0
  ALLOCATE(DY(IS: IE, JS: JE)); DY(:, :) = 0.0
  ! ソルバー部 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
    ! x_xi (x = x, y; xi = xi, eta) ------------------------------------
    XXI =-0.5 * (X(I-1,J) - X(I+1,J))
    YXI =-0.5 * (Y(I-1,J) - Y(I+1,J))
    XET =-0.5 * (X(I,J-1) - X(I,J+1))
    YET =-0.5 * (Y(I,J-1) - Y(I,J+1))
    ! J (Jacobian) -----------------------------------------------------
    AJA = XXI * YET - XET * YXI
    ! J_ij (i = 1, 2; j = 1, 2) ----------------------------------------
    AJA11 = YET
    AJA12 =-YXI
    AJA21 =-XET
    AJA22 = XXI
    ! alpha_ij (i = 1, 2; j = 1, 2) ------------------------------------
    ALP11 = AJA11 * AJA11 + AJA21 * AJA21
    ALP12 = AJA11 * AJA12 + AJA21 * AJA22
    ALP21 = AJA12 * AJA11 + AJA22 * AJA21
    ALP22 = AJA12 * AJA12 + AJA22 * AJA22
    ! x, y -------------------------------------------------------------
    DXC = Cs(I,J) * ( &
    &       ALP11 * (X(I+1,J) + X(I-1,J)) &
    &     + ALP22 * (X(I,J+1) + X(I,J-1)) &
    &     + 0.5 * ALP12 * ( &
    &       X(I-1,J-1) - X(I+1,J-1) - X(I-1,J+1) + X(I+1,J+1) &
    &     ) &
    &   ) &
    &   + ALP11 * ( Cv1p(I,J) * (X(I+1,J) - DX1p(I,J)) &
    &             + Cv1m(I,J) * (X(I-1,J) + DX1m(I,J)) ) &
    &   + ALP22 * ( Cv2p(I,J) * (X(I,J+1) - DX2p(I,J)) &
    &             + Cv2m(I,J) * (X(I,J-1) + DX2m(I,J)) )
    DXM = 2.0 * Cs(I,J) * (ALP11 + ALP22) &
    &   + ALP11 * (Cv1p(I,J) + Cv1m(I,J)) &
    &   + ALP22 * (Cv2p(I,J) + Cv2m(I,J))
    DYC = Cs(I,J) * ( &
    &       ALP11 * (Y(I+1,J) + Y(I-1,J)) &
    &     + ALP22 * (Y(I,J+1) + Y(I,J-1)) &
    &     + 0.5 * ALP12 * ( &
    &       Y(I-1,J-1) - Y(I+1,J-1) - Y(I-1,J+1) + Y(I+1,J+1) &
    &     ) &
    &   ) &
    &   + ALP11 * ( Cv1p(I,J) * (Y(I+1,J) - DY1p(I,J)) &
    &             + Cv1m(I,J) * (Y(I-1,J) + DY1m(I,J)) ) &
    &   + ALP22 * ( Cv2p(I,J) * (Y(I,J+1) - DY2p(I,J)) &
    &             + Cv2m(I,J) * (Y(I,J-1) + DY2m(I,J)) )
    DYM = 2.0 * Cs(I,J) * (ALP11 + ALP22) &
    &   + ALP11 * (Cv1p(I,J) + Cv1m(I,J)) &
    &   + ALP22 * (Cv2p(I,J) + Cv2m(I,J))
    IF(DXM .NE. 0.0 .AND. DYM .NE. 0.0) THEN
      DX(I,J) = DXC / DXM - X(I,J)
      DY(I,J) = DYC / DYM - Y(I,J)
    ENDIF
  ENDDO
  ENDDO
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
    X(I,J) = X(I,J) + OMG * DX(I,J)
    Y(I,J) = Y(I,J) + OMG * DY(I,J)
  ENDDO
  ENDDO
  DMAX = MAXVAL(SQRT(DX(:, :)**2 + DY(:, :)**2))
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE GridEHPDE2D
!***********************************************************************
!**** 三次元楕円-双曲型格子生成法(Yamamoto Kazuomi, 1992)           ****
!**** (3D Elliptic-Hyperbolic Grid Generation Method)               ****
!***********************************************************************
SUBROUTINE GridEHPDE3D( &
&            OMG, &
&            IS, IE, JS, JE, KS, KE, &
&            Cs, &
&            Cv1m, Cv1p, Cv2m, Cv2p, Cv3m, Cv3p, &
&            DX1m, DY1m, DZ1m, DX1p, DY1p, DZ1p, &
&            DX2m, DY2m, DZ2m, DX2p, DY2p, DZ2p, &
&            DX3m, DY3m, DZ3m, DX3p, DY3p, DZ3p, &
&            X, Y, Z, DMAX &
&          )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)    :: OMG                             ! 緩和係数
  INTEGER, INTENT(IN)    :: IS, IE, JS, JE, KS, KE          ! 格子数
  ! 楕円型重み関数(0以上) ----------------------------------------------
  REAL,    INTENT(IN)    :: Cs(IS: IE, JS: JE, KS: KE)      ! 1-Cvが基本
  ! 双曲型重み関数(0以上) ----------------------------------------------
  REAL,    INTENT(IN)    :: Cv1m(IS: IE, JS: JE, KS: KE), & ! I-方向
  &                         Cv1p(IS: IE, JS: JE, KS: KE), & ! I+方向
  &                         Cv2m(IS: IE, JS: JE, KS: KE), & ! J-方向
  &                         Cv2p(IS: IE, JS: JE, KS: KE), & ! J+方向
  &                         Cv3m(IS: IE, JS: JE, KS: KE), & ! K-方向
  &                         Cv3p(IS: IE, JS: JE, KS: KE)    ! K+方向
  ! 境界の傾きと幅(partial x_i / partial xi_i) -------------------------
  REAL,    INTENT(IN)    :: DX1m(IS: IE, JS: JE, KS: KE), & ! I方向-(x)
  &                         DY1m(IS: IE, JS: JE, KS: KE), & ! I方向-(y)
  &                         DZ1m(IS: IE, JS: JE, KS: KE), & ! I方向-(z)
  &                         DX1p(IS: IE, JS: JE, KS: KE), & ! I方向+(x)
  &                         DY1p(IS: IE, JS: JE, KS: KE), & ! I方向+(y)
  &                         DZ1p(IS: IE, JS: JE, KS: KE), & ! I方向+(z)
  &                         DX2m(IS: IE, JS: JE, KS: KE), & ! J方向-(x)
  &                         DY2m(IS: IE, JS: JE, KS: KE), & ! J方向-(y)
  &                         DZ2m(IS: IE, JS: JE, KS: KE), & ! J方向-(z)
  &                         DX2p(IS: IE, JS: JE, KS: KE), & ! J方向+(x)
  &                         DY2p(IS: IE, JS: JE, KS: KE), & ! J方向+(y)
  &                         DZ2p(IS: IE, JS: JE, KS: KE), & ! J方向+(z)
  &                         DX3m(IS: IE, JS: JE, KS: KE), & ! K方向-(x)
  &                         DY3m(IS: IE, JS: JE, KS: KE), & ! K方向-(y)
  &                         DZ3m(IS: IE, JS: JE, KS: KE), & ! K方向-(z)
  &                         DX3p(IS: IE, JS: JE, KS: KE), & ! K方向+(x)
  &                         DY3p(IS: IE, JS: JE, KS: KE), & ! K方向+(y)
  &                         DZ3p(IS: IE, JS: JE, KS: KE)    ! K方向+(z)
  ! 格子点座標 ---------------------------------------------------------
  REAL,    INTENT(INOUT) :: X(IS: IE, JS: JE, KS: KE), &    ! x
  &                         Y(IS: IE, JS: JE, KS: KE), &    ! y
  &                         Z(IS: IE, JS: JE, KS: KE)       ! z
  ! 残差 ---------------------------------------------------------------
  REAL,    INTENT(OUT)   :: DMAX                            ! 最大値
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  LOGICAL           :: FLAG
  INTEGER           :: I, J, K
  REAL              :: XXI, XET, XZE, YXI, YET, YZE, ZXI, ZET, ZZE
  REAL              :: AJA
  REAL              :: AJA11, AJA12, AJA13, &
  &                    AJA21, AJA22, AJA23, &
  &                    AJA31, AJA32, AJA33
  REAL              :: ALP11, ALP12, ALP13, &
  &                    ALP21, ALP22, ALP23, &
  &                    ALP31, ALP32, ALP33
  REAL              :: DXC, DXM, DYC, DYM, DZC, DZM
  REAL, ALLOCATABLE :: DX(:, :, :), DY(:, :, :), DZ(:, :, :)
  ! 処理開始 ***********************************************************
  ! 例外処理(重み関数が負の場合は終了) +++++++++++++++++++++++++++++++++
  FLAG = .FALSE.
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
    FLAG = FLAG .OR. Cs(I,J,K) .LT. 0.0 .OR. &
    &      Cv1m(I,J,K) .LT. 0.0 .OR. Cv1p(I,J,K) .LT. 0.0 .OR. &
    &      Cv2m(I,J,K) .LT. 0.0 .OR. Cv2p(I,J,K) .LT. 0.0 .OR. &
    &      Cv3m(I,J,K) .LT. 0.0 .OR. Cv3p(I,J,K) .LT. 0.0
  ENDDO
  ENDDO
  ENDDO
  IF(FLAG) THEN
    WRITE(*, '(A)') 'Error : Weight function is negative...'
    WRITE(*, '(A)') 'GridEHPDE3D is abnormally Terminated !'
    RETURN
  ENDIF
  ! メモリ確保 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ALLOCATE(DX(IS: IE, JS: JE, KS: KE)); DX(:, :, :) = 0.0
  ALLOCATE(DY(IS: IE, JS: JE, KS: KE)); DY(:, :, :) = 0.0
  ALLOCATE(DZ(IS: IE, JS: JE, KS: KE)); DZ(:, :, :) = 0.0
  ! ソルバー部 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
    ! x_xi (x = x, y, z; xi = xi, eta, zeta) ---------------------------
    XXI =-0.5 * (X(I-1,J,K) - X(I+1,J,K))
    YXI =-0.5 * (Y(I-1,J,K) - Y(I+1,J,K))
    ZXI =-0.5 * (Z(I-1,J,K) - Z(I+1,J,K))
    XET =-0.5 * (X(I,J-1,K) - X(I,J+1,K))
    YET =-0.5 * (Y(I,J-1,K) - Y(I,J+1,K))
    ZET =-0.5 * (Z(I,J-1,K) - Z(I,J+1,K))
    XZE =-0.5 * (X(I,J,K-1) - X(I,J,K+1))
    YZE =-0.5 * (Y(I,J,K-1) - Y(I,J,K+1))
    ZZE =-0.5 * (Z(I,J,K-1) - Z(I,J,K+1))
    ! J (Jacobian) -----------------------------------------------------
    AJA = XXI * (YET * ZZE - YZE * ZET) &
    &   + XET * (YZE * ZXI - YXI * ZZE) &
    &   + XZE * (YXI * ZET - YET * ZXI)
    ! J_ij (i = 1, 3; j = 1, 3) ----------------------------------------
    AJA11 = YET * ZZE - YZE * ZET
    AJA12 = YZE * ZXI - YXI * ZZE
    AJA13 = YXI * ZET - YET * ZXI
    AJA21 = XZE * ZET - XET * ZZE
    AJA22 = XXI * ZZE - XZE * ZXI
    AJA23 = XET * ZXI - XXI * ZET
    AJA31 = XET * YZE - XZE * YET
    AJA32 = XZE * YXI - XXI * YZE
    AJA33 = XXI * YET - XET * YXI
    ! alpha_ij (i = 1, 3; j = 1, 3) ------------------------------------
    ALP11 = AJA11 * AJA11 + AJA21 * AJA21 + AJA31 * AJA31
    ALP12 = AJA11 * AJA12 + AJA21 * AJA22 + AJA31 * AJA32
    ALP13 = AJA11 * AJA13 + AJA21 * AJA23 + AJA31 * AJA33
    ALP21 = AJA12 * AJA11 + AJA22 * AJA21 + AJA32 * AJA31
    ALP22 = AJA12 * AJA12 + AJA22 * AJA22 + AJA32 * AJA32
    ALP23 = AJA12 * AJA13 + AJA22 * AJA23 + AJA32 * AJA33
    ALP31 = AJA13 * AJA11 + AJA23 * AJA21 + AJA33 * AJA31
    ALP32 = AJA13 * AJA12 + AJA23 * AJA22 + AJA33 * AJA32
    ALP33 = AJA13 * AJA13 + AJA23 * AJA23 + AJA33 * AJA33
    ! x, y, z ----------------------------------------------------------
    DXC = Cs(I,J,K) * ( &
    &       ALP11 * (X(I+1,J,K) + X(I-1,J,K)) &
    &     + ALP22 * (X(I,J+1,K) + X(I,J-1,K)) &
    &     + ALP33 * (X(I,J,K+1) + X(I,J,K-1)) &
    &     + 0.5 * ALP12 * ( &
    &       X(I-1,J-1,K) - X(I+1,J-1,K) - X(I-1,J+1,K) + X(I+1,J+1,K) &
    &     ) &
    &     + 0.5 * ALP23 * ( &
    &       X(I,J-1,K-1) - X(I,J+1,K-1) - X(I,J-1,K+1) + X(I,J+1,K+1) &
    &     ) &
    &     + 0.5 * ALP31 * ( &
    &       X(I-1,J,K-1) - X(I+1,J,K-1) - X(I-1,J,K+1) + X(I+1,J,K+1) &
    &     ) &
    &   ) &
    &   + ALP11 * ( Cv1p(I,J,K) * (X(I+1,J,K) - DX1p(I,J,K)) &
    &             + Cv1m(I,J,K) * (X(I-1,J,K) + DX1m(I,J,K)) ) &
    &   + ALP22 * ( Cv2p(I,J,K) * (X(I,J+1,K) - DX2p(I,J,K)) &
    &             + Cv2m(I,J,K) * (X(I,J-1,K) + DX2m(I,J,K)) ) &
    &   + ALP33 * ( Cv3p(I,J,K) * (X(I,J,K+1) - DX3p(I,J,K)) &
    &             + Cv3m(I,J,K) * (X(I,J,K-1) + DX3m(I,J,K)) )
    DXM = 2.0 * Cs(I,J,K) * (ALP11 + ALP22 + ALP33) &
    &   + ALP11 * (Cv1p(I,J,K) + Cv1m(I,J,K)) &
    &   + ALP22 * (Cv2p(I,J,K) + Cv2m(I,J,K)) &
    &   + ALP33 * (Cv3p(I,J,K) + Cv3m(I,J,K))
    DYC = Cs(I,J,K) * ( &
    &       ALP11 * (Y(I+1,J,K) + Y(I-1,J,K)) &
    &     + ALP22 * (Y(I,J+1,K) + Y(I,J-1,K)) &
    &     + ALP33 * (Y(I,J,K+1) + Y(I,J,K-1)) &
    &     + 0.5 * ALP12 * ( &
    &       Y(I-1,J-1,K) - Y(I+1,J-1,K) - Y(I-1,J+1,K) + Y(I+1,J+1,K) &
    &     ) &
    &     + 0.5 * ALP23 * ( &
    &       Y(I,J-1,K-1) - Y(I,J+1,K-1) - Y(I,J-1,K+1) + Y(I,J+1,K+1) &
    &     ) &
    &     + 0.5 * ALP31 * ( &
    &       Y(I-1,J,K-1) - Y(I+1,J,K-1) - Y(I-1,J,K+1) + Y(I+1,J,K+1) &
    &     ) &
    &   ) &
    &   + ALP11 * ( Cv1p(I,J,K) * (Y(I+1,J,K) - DY1p(I,J,K)) &
    &             + Cv1m(I,J,K) * (Y(I-1,J,K) + DY1m(I,J,K)) ) &
    &   + ALP22 * ( Cv2p(I,J,K) * (Y(I,J+1,K) - DY2p(I,J,K)) &
    &             + Cv2m(I,J,K) * (Y(I,J-1,K) + DY2m(I,J,K)) ) &
    &   + ALP33 * ( Cv3p(I,J,K) * (Y(I,J,K+1) - DY3p(I,J,K)) &
    &             + Cv3m(I,J,K) * (Y(I,J,K-1) + DY3m(I,J,K)) )
    DYM = 2.0 * Cs(I,J,K) * (ALP11 + ALP22 + ALP33) &
    &   + ALP11 * (Cv1p(I,J,K) + Cv1m(I,J,K)) &
    &   + ALP22 * (Cv2p(I,J,K) + Cv2m(I,J,K)) &
    &   + ALP33 * (Cv3p(I,J,K) + Cv3m(I,J,K))
    DZC = Cs(I,J,K) * ( &
    &       ALP11 * (Z(I+1,J,K) + Z(I-1,J,K)) &
    &     + ALP22 * (Z(I,J+1,K) + Z(I,J-1,K)) &
    &     + ALP33 * (Z(I,J,K+1) + Z(I,J,K-1)) &
    &     + 0.5 * ALP12 * ( &
    &       Z(I-1,J-1,K) - Z(I+1,J-1,K) - Z(I-1,J+1,K) + Z(I+1,J+1,K) &
    &     ) &
    &     + 0.5 * ALP23 * ( &
    &       Z(I,J-1,K-1) - Z(I,J+1,K-1) - Z(I,J-1,K+1) + Z(I,J+1,K+1) &
    &     ) &
    &     + 0.5 * ALP31 * ( &
    &       Z(I-1,J,K-1) - Z(I+1,J,K-1) - Z(I-1,J,K+1) + Z(I+1,J,K+1) &
    &     ) &
    &   ) &
    &   + ALP11 * ( Cv1p(I,J,K) * (Z(I+1,J,K) - DZ1p(I,J,K)) &
    &             + Cv1m(I,J,K) * (Z(I-1,J,K) + DZ1m(I,J,K)) ) &
    &   + ALP22 * ( Cv2p(I,J,K) * (Z(I,J+1,K) - DZ2p(I,J,K)) &
    &             + Cv2m(I,J,K) * (Z(I,J-1,K) + DZ2m(I,J,K)) ) &
    &   + ALP33 * ( Cv3p(I,J,K) * (Z(I,J,K+1) - DZ3p(I,J,K)) &
    &             + Cv3m(I,J,K) * (Z(I,J,K-1) + DZ3m(I,J,K)) )
    DZM = 2.0 * Cs(I,J,K) * (ALP11 + ALP22 + ALP33) &
    &   + ALP11 * (Cv1p(I,J,K) + Cv1m(I,J,K)) &
    &   + ALP22 * (Cv2p(I,J,K) + Cv2m(I,J,K)) &
    &   + ALP33 * (Cv3p(I,J,K) + Cv3m(I,J,K))
    IF(DXM .NE. 0.0 .AND. DYM .NE. 0.0 .AND. DZM .NE. 0.0) THEN
      DX(I,J,K) = DXC / DXM - X(I,J,K)
      DY(I,J,K) = DYC / DYM - Y(I,J,K)
      DZ(I,J,K) = DZC / DZM - Z(I,J,K)
    ENDIF
  ENDDO
  ENDDO
  ENDDO
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
    X(I,J,K) = X(I,J,K) + OMG * DX(I,J,K)
    Y(I,J,K) = Y(I,J,K) + OMG * DY(I,J,K)
    Z(I,J,K) = Z(I,J,K) + OMG * DZ(I,J,K)
  ENDDO
  ENDDO
  ENDDO
  DMAX = MAXVAL(SQRT(DX(:, :, :)**2 + DY(:, :, :)**2 + DZ(:, :, :)**2))
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE GridEHPDE3D
!***********************************************************************
!**** 二次元二境界法(エルミート三次補間)                            ****
!****   T1, T2 : 格子の直交性を規定する(値が大きいほど直交性が強い) ****
!****   ETABAR : 格子の集中を規定する関数 ETABAR = ETABAR(ETA)      ****
!****            D ETABAR / D ETA が小さいほど格子が集中する        ****
!****            ただし 0 <= ETA <= 1                               ****
!***********************************************************************
SUBROUTINE TwoBoundaryMethod2D( &
&            IS, IE, JS, JE, T1, T2, ETABAR, X, Y &
&          )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)    :: IS, IE, JS, JE
  REAL,    INTENT(IN)    :: T1,T2
  REAL,    INTENT(IN)    :: ETABAR(JS:JE)
  REAL,    INTENT(INOUT) :: X(IS:IE,JS:JE), Y(IS:IE,JS:JE)
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, PARAMETER :: DIMNUM = 2
  REAL :: S1(DIMNUM, IS:IE), S2(DIMNUM, IS:IE), &
  &       G1(DIMNUM, IS:IE), G2(DIMNUM, IS:IE), MU(1:4)
  REAL :: DXDXI1, DYDXI1, DXDXI2, DYDXI2
  INTEGER :: I,J
  ! 処理開始 ***********************************************************
  ! 二境界のベクトル S_K(XI,ZETA) K=1~DIMNUM を定義 ++++++++++++++++++++
  DO I = IS, IE
    S1(1, I) = X(I, JS)
    S1(2, I) = Y(I, JS)
    S2(1, I) = X(I, JE)
    S2(2, I) = Y(I, JE)
  ENDDO
  ! S_K の法線ベクトル G_K(S_K(XI,ZETA),XI) K=1~DIMNUM を定義 ++++++++++
  DO I = IS, IE
    IF( I .EQ. IS ) THEN
      DXDXI1 = S1(1, I+1) - S1(1, I)
      DYDXI1 = S1(2, I+1) - S1(2, I)
      DXDXI2 = S2(1, I+1) - S2(1, I)
      DYDXI2 = S2(2, I+1) - S2(2, I)
    ENDIF
    IF( I .EQ. IE ) THEN
      DXDXI1 = S1(1, I) - S1(1, I-1)
      DYDXI1 = S1(2, I) - S1(2, I-1)
      DXDXI2 = S2(1, I) - S2(1, I-1)
      DYDXI2 = S2(2, I) - S2(2, I-1)
    ENDIF
    IF( ( I .NE. IS ) .AND. ( I .NE. IE ) ) THEN
      DXDXI1 = 0.5 * ( S1(1, I+1) - S1(1, I-1) )
      DYDXI1 = 0.5 * ( S1(2, I+1) - S1(2, I-1) )
      DXDXI2 = 0.5 * ( S2(1, I+1) - S2(1, I-1) )
      DYDXI2 = 0.5 * ( S2(2, I+1) - S2(2, I-1) )
    ENDIF
    G1(1, I) = -DYDXI1 / SQRT( DXDXI1**2 + DYDXI1**2 )
    G1(2, I) =  DXDXI1 / SQRT( DXDXI1**2 + DYDXI1**2 )
    G2(1, I) = -DYDXI2 / SQRT( DXDXI2**2 + DYDXI2**2 )
    G2(2, I) =  DXDXI2 / SQRT( DXDXI2**2 + DYDXI2**2 )
  ENDDO
  ! 補間関数 MU を定義し、座標ベクトル F を計算 ++++++++++++++++++++++++
  DO I = IS, IE
  DO J = JS+1, JE-1
    ! 補間関数の定義 MU_K(ETABAR)  K=1~4 -------------------------------
    MU(1) = 2.0 * ETABAR(J)**3 - 3.0 * ETABAR(J)**2             + 1.0
    MU(2) =-2.0 * ETABAR(J)**3 + 3.0 * ETABAR(J)**2
    MU(3) =       ETABAR(J)**3 - 2.0 * ETABAR(J)**2 + ETABAR(J)
    MU(4) =       ETABAR(J)**3 -       ETABAR(J)**2
    ! 定義 F(XI,MU,ZETA) -----------------------------------------------
    X(I,J) = MU(1) * S1(1,I)           + MU(2) * S2(1,I) &
    &      + MU(3) * T1      * G1(1,I) + MU(4) * T2      * G2(1,I)
    Y(I,J) = MU(1) * S1(2,I)           + MU(2) * S2(2,I) &
    &      + MU(3) * T1      * G1(2,I) + MU(4) * T2      * G2(2,I)
  ENDDO
  ENDDO
  ! 処理終了 ***********************************************************
  RETURN
! 定義終了 *************************************************************
END SUBROUTINE TwoBoundaryMethod2D
!***********************************************************************
!**** Transfinite補間法(Eriksson, 1982)                             ****
!****   ・Fの入力(境界上の値は与えられていなくてはならない)         ****
!****   ・Fの出力(境界上以外の値が補間により計算される)             ****
!****   ・混合関数の制限(以下の関係を満たし、単調に変化すること)    ****
!****     1.0 = ALP1(IS), ALP1(IE) = 0.0                            ****
!****     0.0 = ALP2(IS), ALP2(IE) = 1.0                            ****
!***********************************************************************
SUBROUTINE Transfinite1D( &
&            IS, IE, ALP1, ALP2, F &
&          )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)    :: IS, IE
  REAL,    INTENT(IN)    :: ALP1(IS: IE), ALP2(IS: IE)
  REAL,    INTENT(INOUT) :: F(IS: IE)
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I
  ! 処理開始 ***********************************************************
  DO I = IS + 1, IE - 1
    F(I) = ALP1(I) * F(IS) + ALP2(I) * F(IE)
  ENDDO
  ! 処理終了 ***********************************************************
  RETURN
! 定義終了 *************************************************************
END SUBROUTINE Transfinite1D
!***********************************************************************
!**** Transfinite補間法(Eriksson, 1982)                             ****
!****   ・Fの入力(境界上の値は与えられていなくてはならない)         ****
!****   ・Fの出力(境界上以外の値が補間により計算される)             ****
!****   ・混合関数の制限(以下の関係を満たし、単調に変化すること)    ****
!****     1.0 = ALP1(IS), ALP1(IE) = 0.0                            ****
!****     0.0 = ALP2(IS), ALP2(IE) = 1.0                            ****
!****     1.0 = BET1(JS), BET1(JE) = 0.0                            ****
!****     0.0 = BET2(JS), BET2(JE) = 1.0                            ****
!***********************************************************************
SUBROUTINE Transfinite2D( &
&            IS, IE, JS, JE, ALP1, ALP2, BET1, BET2, F &
&          )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)    :: IS, IE, JS, JE
  REAL,    INTENT(IN)    :: ALP1(IS: IE), ALP2(IS: IE)
  REAL,    INTENT(IN)    :: BET1(JS: JE), BET2(JS: JE)
  REAL,    INTENT(INOUT) :: F(IS: IE, JS: JE)
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER           :: I, J
  REAL, ALLOCATABLE :: F1(:, :)
  ! 処理開始 ***********************************************************
  ! メモリ確保 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ALLOCATE(F1(IS: IE, JS: JE))
  ! 一段目 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  DO J = JS, JE
  DO I = IS, IE
    F1(I,J) = ALP1(I) * F(IS,J) + ALP2(I) * F(IE,J)
  ENDDO
  ENDDO
  ! 二段目 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
    F(I,J) = F1(I,J) + BET1(J) * (F(I,JS) - F1(I,JS)) &
    &                + BET2(J) * (F(I,JE) - F1(I,JE))
  ENDDO
  ENDDO
  ! メモリ解放 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  DEALLOCATE(F1)
  ! 処理終了 ***********************************************************
  RETURN
! 定義終了 *************************************************************
END SUBROUTINE Transfinite2D
!***********************************************************************
!**** Transfinite補間法(Eriksson, 1982)                             ****
!****   ・Fの入力(境界上の値は与えられていなくてはならない)         ****
!****   ・Fの出力(境界上以外の値が補間により計算される)             ****
!****   ・混合関数の制限(以下の関係を満たし、単調に変化すること)    ****
!****     1.0 = ALP1(IS), ALP1(IE) = 0.0                            ****
!****     0.0 = ALP2(IS), ALP2(IE) = 1.0                            ****
!****     1.0 = BET1(JS), BET1(JE) = 0.0                            ****
!****     0.0 = BET2(JS), BET2(JE) = 1.0                            ****
!****     1.0 = GAM1(KS), GAM1(KE) = 0.0                            ****
!****     0.0 = GAM2(KS), GAM2(KE) = 1.0                            ****
!***********************************************************************
SUBROUTINE Transfinite3D( &
&            IS, IE, JS, JE, KS, KE, &
&            ALP1, ALP2, BET1, BET2, GAM1, GAM2, F &
&          )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)    :: IS, IE, JS, JE, KS, KE
  REAL,    INTENT(IN)    :: ALP1(IS: IE), ALP2(IS: IE)
  REAL,    INTENT(IN)    :: BET1(JS: JE), BET2(JS: JE)
  REAL,    INTENT(IN)    :: GAM1(KS: KE), GAM2(KS: KE)
  REAL,    INTENT(INOUT) :: F(IS: IE, JS: JE, KS: KE)
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER           :: I, J, K
  REAL, ALLOCATABLE :: F1(:, :, :), F2(:, :, :)
  ! 処理開始 ***********************************************************
  ! メモリ確保 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ALLOCATE(F1(IS: IE, JS: JE, KS: KE), F2(IS: IE, JS: JE, KS: KE))
  ! 一段目 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  DO K = KS, KE
  DO J = JS, JE
  DO I = IS, IE
    F1(I,J,K) = ALP1(I) * F(IS,J,K) + ALP2(I) * F(IE,J,K)
  ENDDO
  ENDDO
  ENDDO
  ! 二段目 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  DO K = KS, KE
  DO J = JS, JE
  DO I = IS, IE
    F2(I,J,K) = F1(I,J,K) + BET1(J) * (F(I,JS,K) - F1(I,JS,K)) &
    &                     + BET2(J) * (F(I,JE,K) - F1(I,JE,K))
  ENDDO
  ENDDO
  ENDDO
  ! 三段目 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  DO K = KS + 1, KE - 1
  DO J = JS + 1, JE - 1
  DO I = IS + 1, IE - 1
    F(I,J,K) = F2(I,J,K) + GAM1(K) * (F(I,J,KS) - F2(I,J,KS)) &
    &                    + GAM2(K) * (F(I,J,KE) - F2(I,J,KE))
  ENDDO
  ENDDO
  ENDDO
  ! メモリ解放 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  DEALLOCATE(F1, F2)
  ! 処理終了 ***********************************************************
  RETURN
! 定義終了 *************************************************************
END SUBROUTINE Transfinite3D
!***********************************************************************
!**** 二次元一般座標変換メトリックス計算                            ****
!***********************************************************************
SUBROUTINE Metrics2D( &
&            IS, IE, JS, JE, &
&            X, Y, XIX, XIY, ETX, ETY, AJA &
&          )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE
  REAL,    INTENT(IN)  :: X(IS:IE, JS:JE), Y(IS:IE, JS:JE)
  REAL,    INTENT(OUT) :: XIX(IS:IE, JS:JE), XIY(IS:IE, JS:JE), &
  &                       ETX(IS:IE, JS:JE), ETY(IS:IE, JS:JE), &
  &                       AJA(IS:IE, JS:JE)
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I,J
  REAL    :: XXI(IS:IE,JS:JE), XET(IS:IE,JS:JE), &
  &          YXI(IS:IE,JS:JE), YET(IS:IE,JS:JE)
  REAL    :: AJAINV
  ! 処理開始 ***********************************************************
  ! X_XI, Y_XI の計算 --------------------------------------------------
  DO J=JS,JE
    I=IS
      XXI(I,J) = (-3.0 * X(I,J) + 4.0 * X(I+1,J) - X(I+2,J)) * 0.5
      YXI(I,J) = (-3.0 * Y(I,J) + 4.0 * Y(I+1,J) - Y(I+2,J)) * 0.5
    DO I=IS+1,IE-1
      XXI(I,J) = (-X(I-1,J) + X(I+1,J)) * 0.5
      YXI(I,J) = (-Y(I-1,J) + Y(I+1,J)) * 0.5
    ENDDO
    I=IE
      XXI(I,J) = (X(I-2,J) - 4.0 * X(I-1,J) + 3.0 * X(I,J)) * 0.5
      YXI(I,J) = (Y(I-2,J) - 4.0 * Y(I-1,J) + 3.0 * Y(I,J)) * 0.5
  ENDDO
  ! X_ET, Y_ET の計算 --------------------------------------------------
  DO I=IS,IE
    J=JS
      XET(I,J) = (-3.0 * X(I,J) + 4.0 * X(I,J+1) - X(I,J+2)) * 0.5
      YET(I,J) = (-3.0 * Y(I,J) + 4.0 * Y(I,J+1) - Y(I,J+2)) * 0.5
    DO J=JS+1,JE-1
      XET(I,J) = (-X(I,J-1) + X(I,J+1)) * 0.5
      YET(I,J) = (-Y(I,J-1) + Y(I,J+1)) * 0.5
    ENDDO
    J=JE
      XET(I,J) = (X(I,J-2) - 4.0 * X(I,J-1) + 3.0 * X(I,J)) * 0.5
      YET(I,J) = (Y(I,J-2) - 4.0 * Y(I,J-1) + 3.0 * Y(I,J)) * 0.5
  ENDDO
  ! Jacobian , metrics の計算 ------------------------------------------
  DO J=JS,JE
  DO I=IS,IE
    AJAINV = XXI(I,J) * YET(I,J) - XET(I,J) * YXI(I,J)
    IF(AJAINV .GT. 0.0) THEN
      AJA(I,J) = 1.0 / AJAINV
    ELSE
      AJA(I,J) = 0.0
    ENDIF
    XIX(I,J) = AJA(I,J) * YET(I,J)
    XIY(I,J) =-AJA(I,J) * XET(I,J)
    ETX(I,J) =-AJA(I,J) * YXI(I,J)
    ETY(I,J) = AJA(I,J) * XXI(I,J)
  ENDDO
  ENDDO
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE Metrics2D
!***********************************************************************
!**** 三次元一般座標変換メトリックス計算                            ****
!***********************************************************************
SUBROUTINE Metrics3D( &
&            IS, IE, JS, JE, KS, KE, &
&            X, Y, Z, XIX, XIY, XIZ, ETX, ETY, ETZ, ZEX, ZEY, ZEZ, AJA &
&          )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE, KS, KE
  REAL,    INTENT(IN)  :: X(IS:IE, JS:JE, KS:KE), &
  &                       Y(IS:IE, JS:JE, KS:KE), &
  &                       Z(IS:IE, JS:JE, KS:KE)
  REAL,    INTENT(OUT) :: XIX(IS:IE, JS:JE, KS:KE), &
  &                       XIY(IS:IE, JS:JE, KS:KE), &
  &                       XIZ(IS:IE, JS:JE, KS:KE), &
  &                       ETX(IS:IE, JS:JE, KS:KE), &
  &                       ETY(IS:IE, JS:JE, KS:KE), &
  &                       ETZ(IS:IE, JS:JE, KS:KE), &
  &                       ZEX(IS:IE, JS:JE, KS:KE), &
  &                       ZEY(IS:IE, JS:JE, KS:KE), &
  &                       ZEZ(IS:IE, JS:JE, KS:KE), &
  &                       AJA(IS:IE, JS:JE, KS:KE)
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I,J,K
  REAL    :: XXI(IS:IE,JS:JE,KS:KE), XET(IS:IE,JS:JE,KS:KE), &
  &          XZE(IS:IE,JS:JE,KS:KE), YXI(IS:IE,JS:JE,KS:KE), &
  &          YET(IS:IE,JS:JE,KS:KE), YZE(IS:IE,JS:JE,KS:KE), &
  &          ZXI(IS:IE,JS:JE,KS:KE), ZET(IS:IE,JS:JE,KS:KE), &
  &          ZZE(IS:IE,JS:JE,KS:KE)
  REAL    :: AJAINV
  ! 処理開始 ***********************************************************
  ! X_XI, Y_XI, Z_XI の計算 --------------------------------------------
  DO K=KS,KE
  DO J=JS,JE
    I=IS
      XXI(I,J,K) = ( -3.0*X(I,J,K)+4.0*X(I+1,J,K)-X(I+2,J,K) )*0.5
      YXI(I,J,K) = ( -3.0*Y(I,J,K)+4.0*Y(I+1,J,K)-Y(I+2,J,K) )*0.5
      ZXI(I,J,K) = ( -3.0*Z(I,J,K)+4.0*Z(I+1,J,K)-Z(I+2,J,K) )*0.5
    DO I=IS+1,IE-1
      XXI(I,J,K) = ( -X(I-1,J,K)+X(I+1,J,K) )*0.5
      YXI(I,J,K) = ( -Y(I-1,J,K)+Y(I+1,J,K) )*0.5
      ZXI(I,J,K) = ( -Z(I-1,J,K)+Z(I+1,J,K) )*0.5
    ENDDO
    I=IE
      XXI(I,J,K) = ( X(I-2,J,K)-4.0*X(I-1,J,K)+3.0*X(I,J,K) )*0.5
      YXI(I,J,K) = ( Y(I-2,J,K)-4.0*Y(I-1,J,K)+3.0*Y(I,J,K) )*0.5
      ZXI(I,J,K) = ( Z(I-2,J,K)-4.0*Z(I-1,J,K)+3.0*Z(I,J,K) )*0.5
  ENDDO
  ENDDO
  ! X_ET, Y_ET, Z_ET の計算 --------------------------------------------
  DO K=KS,KE
  DO I=IS,IE
    J=JS
      XET(I,J,K) = ( -3.0*X(I,J,K)+4.0*X(I,J+1,K)-X(I,J+2,K) )*0.5
      YET(I,J,K) = ( -3.0*Y(I,J,K)+4.0*Y(I,J+1,K)-Y(I,J+2,K) )*0.5
      ZET(I,J,K) = ( -3.0*Z(I,J,K)+4.0*Z(I,J+1,K)-Z(I,J+2,K) )*0.5
    DO J=JS+1,JE-1
      XET(I,J,K) = ( -X(I,J-1,K)+X(I,J+1,K) )*0.5
      YET(I,J,K) = ( -Y(I,J-1,K)+Y(I,J+1,K) )*0.5
      ZET(I,J,K) = ( -Z(I,J-1,K)+Z(I,J+1,K) )*0.5
    ENDDO
    J=JE
      XET(I,J,K) = ( X(I,J-2,K)-4.0*X(I,J-1,K)+3.0*X(I,J,K) )*0.5
      YET(I,J,K) = ( Y(I,J-2,K)-4.0*Y(I,J-1,K)+3.0*Y(I,J,K) )*0.5
      ZET(I,J,K) = ( Z(I,J-2,K)-4.0*Z(I,J-1,K)+3.0*Z(I,J,K) )*0.5
  ENDDO
  ENDDO
  ! X_ZE, Y_ZE, Z_ZE の計算 --------------------------------------------
  DO J=JS,JE
  DO I=IS,IE
    K=KS
      XZE(I,J,K) = ( -3.0*X(I,J,K)+4.0*X(I,J,K+1)-X(I,J,K+2) )*0.5
      YZE(I,J,K) = ( -3.0*Y(I,J,K)+4.0*Y(I,J,K+1)-Y(I,J,K+2) )*0.5
      ZZE(I,J,K) = ( -3.0*Z(I,J,K)+4.0*Z(I,J,K+1)-Z(I,J,K+2) )*0.5
    DO K=KS+1,KE-1
      XZE(I,J,K) = ( -X(I,J,K-1)+X(I,J,K+1) )*0.5
      YZE(I,J,K) = ( -Y(I,J,K-1)+Y(I,J,K+1) )*0.5
      ZZE(I,J,K) = ( -Z(I,J,K-1)+Z(I,J,K+1) )*0.5
    ENDDO
    K=KE
      XZE(I,J,K) = ( X(I,J,K-2)-4.0*X(I,J,K-1)+3.0*X(I,J,K) )*0.5
      YZE(I,J,K) = ( Y(I,J,K-2)-4.0*Y(I,J,K-1)+3.0*Y(I,J,K) )*0.5
      ZZE(I,J,K) = ( Z(I,J,K-2)-4.0*Z(I,J,K-1)+3.0*Z(I,J,K) )*0.5
  ENDDO
  ENDDO
  ! Jacobian , metrics の計算 ------------------------------------------
  DO K=KS,KE
  DO J=JS,JE
  DO I=IS,IE
    AJAINV = XXI(I,J,K) * ( YET(I,J,K) * ZZE(I,J,K) &
    &                     - YZE(I,J,K) * ZET(I,J,K) ) &
    &      + XET(I,J,K) * ( YZE(I,J,K) * ZXI(I,J,K) &
    &                     - YXI(I,J,K) * ZZE(I,J,K) ) &
    &      + XZE(I,J,K) * ( YXI(I,J,K) * ZET(I,J,K) &
    &                     - YET(I,J,K) * ZXI(I,J,K) )
    IF(AJAINV .GT. 0.0) THEN
      AJA(I,J,K) = 1.0 / AJAINV
    ELSE
      AJA(I,J,K) = 0.0
    ENDIF
    XIX(I,J,K) = AJA(I,J,K) * ( YET(I,J,K) * ZZE(I,J,K) &
    &                         - YZE(I,J,K) * ZET(I,J,K) )
    XIY(I,J,K) = AJA(I,J,K) * ( ZET(I,J,K) * XZE(I,J,K) &
    &                         - ZZE(I,J,K) * XET(I,J,K) )
    XIZ(I,J,K) = AJA(I,J,K) * ( XET(I,J,K) * YZE(I,J,K) &
    &                         - XZE(I,J,K) * YET(I,J,K) )
    ETX(I,J,K) = AJA(I,J,K) * ( YZE(I,J,K) * ZXI(I,J,K) &
    &                         - YXI(I,J,K) * ZZE(I,J,K) )
    ETY(I,J,K) = AJA(I,J,K) * ( ZZE(I,J,K) * XXI(I,J,K) &
    &                         - ZXI(I,J,K) * XZE(I,J,K) )
    ETZ(I,J,K) = AJA(I,J,K) * ( XZE(I,J,K) * YXI(I,J,K) &
    &                         - XXI(I,J,K) * YZE(I,J,K) )
    ZEX(I,J,K) = AJA(I,J,K) * ( YXI(I,J,K) * ZET(I,J,K) &
    &                         - YET(I,J,K) * ZXI(I,J,K) )
    ZEY(I,J,K) = AJA(I,J,K) * ( ZXI(I,J,K) * XET(I,J,K) &
    &                         - ZET(I,J,K) * XXI(I,J,K) )
    ZEZ(I,J,K) = AJA(I,J,K) * ( XXI(I,J,K) * YET(I,J,K) &
    &                         - XET(I,J,K) * YXI(I,J,K) )
  ENDDO
  ENDDO
  ENDDO
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE Metrics3D
!***********************************************************************
!**** 壁からの距離を計算(二次元)                                    ****
!***********************************************************************
SUBROUTINE WallDistance2D( &
&            IS, IE, JS, JE, &
&            WallNum, WallX, WallY, X, Y, &
&            YWALL &
&          )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE
  INTEGER, INTENT(IN)  :: WallNum
  REAL,    INTENT(IN)  :: WallX(WallNum), WallY(WallNum)
  REAL,    INTENT(IN)  :: X(IS:IE ,JS:JE), Y(IS:IE ,JS:JE)
  REAL,    INTENT(OUT) :: YWALL(IS:IE ,JS:JE)
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, N
  ! 処理開始 ***********************************************************
  DO J=JS,JE
  DO I=IS,IE
    N=1
      YWALL(I,J) = SQRT( (X(I,J) - WallX(N) )**2 &
      &                + (Y(I,J) - WallY(N) )**2 )
    DO N=1,WallNum
      YWALL(I,J) = MIN( &
      &            YWALL(I,J), &
      &            SQRT( (X(I,J) - WallX(N) )**2 &
      &                + (Y(I,J) - WallY(N) )**2 ) &
      &          )
    ENDDO
  ENDDO
  ENDDO
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE WallDistance2D
!***********************************************************************
!**** 壁からの距離を計算(三次元)                                    ****
!***********************************************************************
SUBROUTINE WallDistance3D( &
&            IS, IE, JS, JE, KS, KE, &
&            WallNum, WallX, WallY, WallZ, X, Y, Z, &
&            YWALL &
&          )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, INTENT(IN)  :: IS, IE, JS, JE, KS, KE
  INTEGER, INTENT(IN)  :: WallNum
  REAL,    INTENT(IN)  :: WallX(WallNum), WallY(WallNum), WallZ(WallNum)
  REAL,    INTENT(IN)  :: X(IS:IE ,JS:JE, KS:KE), &
  &                       Y(IS:IE ,JS:JE, KS:KE), &
  &                       Z(IS:IE ,JS:JE, KS:KE)
  REAL,    INTENT(OUT) :: YWALL(IS:IE ,JS:JE, KS:KE)
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K, N
  ! 処理開始 ***********************************************************
  DO K=KS,KE
  DO J=JS,JE
  DO I=IS,IE
    N=1
      YWALL(I,J,K) = SQRT( (X(I,J,K) - WallX(N) )**2 &
      &                  + (Y(I,J,K) - WallY(N) )**2 &
      &                  + (Z(I,J,K) - WallZ(N) )**2 )
    DO N=1,WallNum
      YWALL(I,J,K) = MIN( YWALL(I,J,K) , &
      &              SQRT( (X(I,J,K) - WallX(N) )**2 &
      &                  + (Y(I,J,K) - WallY(N) )**2 &
      &                  + (Z(I,J,K) - WallZ(N) )**2 ) &
      &            )
    ENDDO
  ENDDO
  ENDDO
  ENDDO
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE WallDistance3D
!***********************************************************************
!**** ワイドサーチ(二次元, 四点)                                    ****
!***********************************************************************
SUBROUTINE WideSearch2D4Point( &
&            X0, Y0, X1, Y1, X2, Y2, X3, Y3, X4, Y4, &
&            MARGIN, &
&            FEXIST &
&          )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: X0, Y0
  REAL,    INTENT(IN)  :: X1, Y1
  REAL,    INTENT(IN)  :: X2, Y2
  REAL,    INTENT(IN)  :: X3, Y3
  REAL,    INTENT(IN)  :: X4, Y4
  REAL,    INTENT(IN)  :: MARGIN
  LOGICAL, INTENT(OUT) :: FEXIST
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL :: XMIN, XMAX, YMIN, YMAX
  REAL :: MARGINX, MARGINY
  ! 処理開始 ***********************************************************
  XMIN = MIN( X1, X2, X3, X4 )
  XMAX = MAX( X1, X2, X3, X4 )
  YMIN = MIN( Y1, Y2, Y3, Y4 )
  YMAX = MAX( Y1, Y2, Y3, Y4 )
  MARGINX = (XMAX - XMIN) * MARGIN
  MARGINY = (YMAX - YMIN) * MARGIN
  FEXIST = (XMIN - MARGINX .LE. X0) .AND. (X0 .LE. XMAX + MARGINX) &
  &  .AND. (YMIN - MARGINY .LE. Y0) .AND. (Y0 .LE. YMAX + MARGINY)
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE WideSearch2D4Point
!***********************************************************************
!**** ワイドサーチ(三次元, 八点)                                    ****
!***********************************************************************
SUBROUTINE WideSearch3D8Point( &
&            X0, Y0, Z0, &
&            X1, Y1, Z1, X2, Y2, Z2, X3, Y3, Z3, X4, Y4, Z4, &
&            X5, Y5, Z5, X6, Y6, Z6, X7, Y7, Z7, X8, Y8, Z8, &
&            MARGIN, &
&            FEXIST &
&          )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: X0, Y0, Z0
  REAL,    INTENT(IN)  :: X1, Y1, Z1
  REAL,    INTENT(IN)  :: X2, Y2, Z2
  REAL,    INTENT(IN)  :: X3, Y3, Z3
  REAL,    INTENT(IN)  :: X4, Y4, Z4
  REAL,    INTENT(IN)  :: X5, Y5, Z5
  REAL,    INTENT(IN)  :: X6, Y6, Z6
  REAL,    INTENT(IN)  :: X7, Y7, Z7
  REAL,    INTENT(IN)  :: X8, Y8, Z8
  REAL,    INTENT(IN)  :: MARGIN
  LOGICAL, INTENT(OUT) :: FEXIST
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL :: XMIN, XMAX, YMIN, YMAX, ZMIN, ZMAX
  REAL :: MARGINX, MARGINY, MARGINZ
  ! 処理開始 ***********************************************************
  XMIN = MIN( X1, X2, X3, X4, X5, X6, X7, X8 )
  XMAX = MAX( X1, X2, X3, X4, X5, X6, X7, X8 )
  YMIN = MIN( Y1, Y2, Y3, Y4, Y5, Y6, Y7, Y8 )
  YMAX = MAX( Y1, Y2, Y3, Y4, Y5, Y6, Y7, Y8 )
  ZMIN = MIN( Z1, Z2, Z3, Z4, Z5, Z6, Z7, Z8 )
  ZMAX = MAX( Z1, Z2, Z3, Z4, Z5, Z6, Z7, Z8 )
  MARGINX = (XMAX - XMIN) * MARGIN
  MARGINY = (YMAX - YMIN) * MARGIN
  MARGINZ = (ZMAX - ZMIN) * MARGIN
  FEXIST = (XMIN - MARGINX .LE. X0) .AND. (X0 .LE. XMAX + MARGINX) &
  &  .AND. (YMIN - MARGINY .LE. Y0) .AND. (Y0 .LE. YMAX + MARGINY) &
  &  .AND. (ZMIN - MARGINZ .LE. Z0) .AND. (Z0 .LE. ZMAX + MARGINZ)
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE WideSearch3D8Point
!***********************************************************************
!**** 線形補間(二次元, 三点)                                        ****
!****   X0 = X1 + ALP (X2 - X1) + BET (X3 - X1)                     ****
!****   Y0 = Y1 + ALP (Y2 - Y1) + BET (Y3 - Y1)                     ****
!***********************************************************************
SUBROUTINE Interpolation2D3Point( &
&            X0, Y0, X1, Y1, X2, Y2, X3, Y3, &
&            MARGIN, &
&            ALP, BET, FCOMP &
&          )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: X0, Y0
  REAL,    INTENT(IN)  :: X1, Y1
  REAL,    INTENT(IN)  :: X2, Y2
  REAL,    INTENT(IN)  :: X3, Y3
  REAL,    INTENT(IN)  :: MARGIN
  REAL,    INTENT(OUT) :: ALP, BET
  LOGICAL, INTENT(OUT) :: FCOMP
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL :: deti, detx, dety
  ! 処理開始 ***********************************************************
  deti = (X2 - X1) * (Y3 - Y1) - (Y2 - Y1) * (X3 - X1)
  detx = (X0 - X1) * (Y3 - Y1) - (Y0 - Y1) * (X3 - X1)
  dety = (X2 - X1) * (Y0 - Y1) - (Y2 - Y1) * (X0 - X1)
  IF(deti .NE. 0.0) THEN
    ALP = detx / deti
    BET = dety / deti
    FCOMP = 0.0 - MARGIN .LE. ALP .AND. ALP .LE. 1.0 + MARGIN .AND. &
    &       0.0 - MARGIN .LE. BET .AND. BET .LE. 1.0 + MARGIN .AND. &
    &       ALP + BET .LE. 1.0 + MARGIN
  ELSE
    ALP = 0.0
    BET = 0.0
    FCOMP = .FALSE.
  ENDIF
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE Interpolation2D3Point
!***********************************************************************
!**** 線形補間(三次元, 四点)                                        ****
!****   X0 = X1 + ALP (X2 - X1) + BET (X3 - X1) + GAM (X4 - X1)     ****
!****   Y0 = Y1 + ALP (Y2 - Y1) + BET (Y3 - Y1) + GAM (Y4 - Y1)     ****
!****   Z0 = Z1 + ALP (Z2 - Z1) + BET (Z3 - Z1) + GAM (Z4 - Z1)     ****
!***********************************************************************
SUBROUTINE Interpolation3D4Point( &
&            X0, Y0, Z0, &
&            X1, Y1, Z1, X2, Y2, Z2, X3, Y3, Z3, X4, Y4, Z4, &
&            MARGIN, &
&            ALP, BET, GAM, FCOMP &
&          )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)  :: X0, Y0, Z0
  REAL,    INTENT(IN)  :: X1, Y1, Z1
  REAL,    INTENT(IN)  :: X2, Y2, Z2
  REAL,    INTENT(IN)  :: X3, Y3, Z3
  REAL,    INTENT(IN)  :: X4, Y4, Z4
  REAL,    INTENT(IN)  :: MARGIN
  REAL,    INTENT(OUT) :: ALP, BET, GAM
  LOGICAL, INTENT(OUT) :: FCOMP
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL :: dx0, dx2, dx3, dx4
  REAL :: dy0, dy2, dy3, dy4
  REAL :: dz0, dz2, dz3, dz4
  REAL :: deti, detx, dety, detz
  ! 処理開始 ***********************************************************
  dx0 = X0 - X1; dx2 = X2 - X1; dx3 = X3 - X1; dx4 = X4 - X1
  dy0 = Y0 - Y1; dy2 = Y2 - Y1; dy3 = Y3 - Y1; dy4 = Y4 - Y1
  dz0 = Z0 - Z1; dz2 = Z2 - Z1; dz3 = Z3 - Z1; dz4 = Z4 - Z1
  deti = dx2 * dy3 * dz4 + dx3 * dy4 * dz2 + dx4 * dy2 * dz3 &
  &    - dz2 * dy3 * dx4 - dz3 * dy4 * dx2 - dz4 * dy2 * dx3
  detx = dx0 * dy3 * dz4 + dx3 * dy4 * dz0 + dx4 * dy0 * dz3 &
  &    - dz0 * dy3 * dx4 - dz3 * dy4 * dx0 - dz4 * dy0 * dx3
  dety = dx2 * dy0 * dz4 + dx0 * dy4 * dz2 + dx4 * dy2 * dz0 &
  &    - dz2 * dy0 * dx4 - dz0 * dy4 * dx2 - dz4 * dy2 * dx0
  detz = dx2 * dy3 * dz0 + dx3 * dy0 * dz2 + dx0 * dy2 * dz3 &
  &    - dz2 * dy3 * dx0 - dz3 * dy0 * dx2 - dz0 * dy2 * dx3
  IF(deti .NE. 0.0) THEN
    ALP = detx / deti
    BET = dety / deti
    GAM = detz / deti
    FCOMP = 0.0 - MARGIN .LE. ALP .AND. ALP .LE. 1.0 + MARGIN .AND. &
    &       0.0 - MARGIN .LE. BET .AND. BET .LE. 1.0 + MARGIN .AND. &
    &       0.0 - MARGIN .LE. GAM .AND. GAM .LE. 1.0 + MARGIN .AND. &
    &       ALP + BET + GAM .LE. 1.0 + MARGIN
  ELSE
    ALP = 0.0
    BET = 0.0
    GAM = 0.0
    FCOMP = .FALSE.
  ENDIF
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE Interpolation3D4Point
!***********************************************************************
!**** 双一次補間(二次元, 四点)                                      ****
!****   X0 = (1 - ALP) (1 - BET) X1 + ALP (1 - BET) X2              ****
!****      + (1 - ALP) BET       X3 + ALP BET       X4              ****
!****   Y0 = (1 - ALP) (1 - BET) Y1 + ALP (1 - BET) Y2              ****
!****      + (1 - ALP) BET       Y3 + ALP BET       Y4              ****
!***********************************************************************
SUBROUTINE Interpolation2D4Point( &
&            X0, Y0, X1, Y1, X2, Y2, X3, Y3, X4, Y4, &
&            MARGIN, &
&            ALP0, BET0, FCOMP &
&          )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 局所定数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, PARAMETER :: NMAX = 100
  REAL(8), PARAMETER :: DMIN = 1.0D-8
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)    :: X0, Y0
  REAL,    INTENT(IN)    :: X1, Y1
  REAL,    INTENT(IN)    :: X2, Y2
  REAL,    INTENT(IN)    :: X3, Y3
  REAL,    INTENT(IN)    :: X4, Y4
  REAL,    INTENT(IN)    :: MARGIN
  REAL,    INTENT(INOUT) :: ALP0, BET0
  LOGICAL, INTENT(OUT)   :: FCOMP
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL(8) :: XX1, XX2, XX4, XX8, YY1, YY2, YY4, YY8
  REAL(8) :: ALP, BET
  INTEGER :: N
  REAL(8) :: FX, FY
  REAL(8) :: FXA, FXB, FYA, FYB
  REAL(8) :: DELTA, DA, DB, DABMIN, DABMAX, DMAX
  REAL(8) :: CRLX
  REAL(8) :: MARGIND
  ! 処理開始 ***********************************************************
  ! 初期値 -------------------------------------------------------------
  ALP   = DBLE(ALP0)
  BET   = DBLE(BET0)
  FCOMP = .FALSE.
  ! 補間関数用定数設定 -------------------------------------------------
  XX1 = DBLE(X2) - DBLE(X1)
  XX2 = DBLE(X3) - DBLE(X1)
  XX4 = DBLE(X1) - DBLE(X2) - DBLE(X3) + DBLE(X4)
  XX8 = DBLE(X1) - DBLE(X0)
  YY1 = DBLE(Y2) - DBLE(Y1)
  YY2 = DBLE(Y3) - DBLE(Y1)
  YY4 = DBLE(Y1) - DBLE(Y2) - DBLE(Y3) + DBLE(Y4)
  YY8 = DBLE(Y1) - DBLE(Y0)
  ! Newton-Raphson Method で、補間パラメータを計算 ---------------------
  CRLX = 1.0
  DO N = 1, NMAX
    FX = XX1*ALP + XX2*BET + XX4*ALP*BET + XX8
    FY = YY1*ALP + YY2*BET + YY4*ALP*BET + YY8
    FXA = XX1 + XX4*BET
    FXB = XX2 + XX4*ALP
    FYA = YY1 + YY4*BET
    FYB = YY2 + YY4*ALP
    DELTA = FXA*FYB - FXB*FYA
    IF(ABS(DELTA) .LE. 1.0D-20) DELTA = SIGN(1.0D-20, DELTA)
    DA =-( FX*FYB - FXB*FY ) / DELTA
    DB =-( FXA*FY - FX*FYA ) / DELTA
    ALP = ALP + DA * CRLX
    BET = BET + DB * CRLX
    DABMIN = MIN(ABS(DA), ABS(DB))
    DABMAX = MAX(ABS(DA), ABS(DB))
    SELECT CASE(N)
      CASE(1)
        DMAX = DABMIN
      CASE DEFAULT
        IF(DMAX .LT. DABMIN) THEN
          DMAX = DABMIN
          CRLX = CRLX * 0.5
        ENDIF
    END SELECT
    IF(DABMAX .LE. DMIN) EXIT
  ENDDO
  ! 正当性検査 ---------------------------------------------------------
  MARGIND = DBLE(MARGIN)
  IF( DABMAX .LE. DMIN .AND. &
  &   0.0D+0 - MARGIND .LE. ALP .AND. ALP .LT. 1.0D+0 + MARGIND .AND. &
  &   0.0D+0 - MARGIND .LE. BET .AND. BET .LT. 1.0D+0 + MARGIND ) THEN
    FCOMP = .TRUE.
  ENDIF
  ALP0 = REAL(ALP)
  BET0 = REAL(BET)
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE Interpolation2D4Point
!***********************************************************************
!**** 三重線形補間(三次元, 八点)                                    ****
!****   X0 = (1 - ALP) (1 - BET) (1 - GAM) X1                       ****
!****      + ALP       (1 - BET) (1 - GAM) X2                       ****
!****      + (1 - ALP) BET       (1 - GAM) X3                       ****
!****      + ALP       BET       (1 - GAM) X4                       ****
!****      + (1 - ALP) (1 - BET) GAM       X5                       ****
!****      + ALP       (1 - BET) GAM       X6                       ****
!****      + (1 - ALP) BET       GAM       X7                       ****
!****      + ALP       BET       GAM       X8                       ****
!****   Y0 = (1 - ALP) (1 - BET) (1 - GAM) Y1                       ****
!****      + ALP       (1 - BET) (1 - GAM) Y2                       ****
!****      + (1 - ALP) BET       (1 - GAM) Y3                       ****
!****      + ALP       BET       (1 - GAM) Y4                       ****
!****      + (1 - ALP) (1 - BET) GAM       Y5                       ****
!****      + ALP       (1 - BET) GAM       Y6                       ****
!****      + (1 - ALP) BET       GAM       Y7                       ****
!****      + ALP       BET       GAM       Y8                       ****
!****   Z0 = (1 - ALP) (1 - BET) (1 - GAM) Z1                       ****
!****      + ALP       (1 - BET) (1 - GAM) Z2                       ****
!****      + (1 - ALP) BET       (1 - GAM) Z3                       ****
!****      + ALP       BET       (1 - GAM) Z4                       ****
!****      + (1 - ALP) (1 - BET) GAM       Z5                       ****
!****      + ALP       (1 - BET) GAM       Z6                       ****
!****      + (1 - ALP) BET       GAM       Z7                       ****
!****      + ALP       BET       GAM       Z8                       ****
!***********************************************************************
SUBROUTINE Interpolation3D8Point( &
&            X0, Y0, Z0, &
&            X1, Y1, Z1, X2, Y2, Z2, X3, Y3, Z3, X4, Y4, Z4, &
&            X5, Y5, Z5, X6, Y6, Z6, X7, Y7, Z7, X8, Y8, Z8, &
&            MARGIN, &
&            ALP0, BET0, GAM0, FCOMP &
&          )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 局所定数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER, PARAMETER :: NMAX = 100
  REAL(8), PARAMETER :: DMIN = 1.0D-8
!  REAL(8), PARAMETER :: DMIN = 1.0D-10
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL,    INTENT(IN)    :: X0, Y0, Z0
  REAL,    INTENT(IN)    :: X1, Y1, Z1
  REAL,    INTENT(IN)    :: X2, Y2, Z2
  REAL,    INTENT(IN)    :: X3, Y3, Z3
  REAL,    INTENT(IN)    :: X4, Y4, Z4
  REAL,    INTENT(IN)    :: X5, Y5, Z5
  REAL,    INTENT(IN)    :: X6, Y6, Z6
  REAL,    INTENT(IN)    :: X7, Y7, Z7
  REAL,    INTENT(IN)    :: X8, Y8, Z8
  REAL,    INTENT(IN)    :: MARGIN
  REAL,    INTENT(INOUT) :: ALP0, BET0, GAM0
  LOGICAL, INTENT(OUT)   :: FCOMP
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  REAL(8) :: XX1, XX2, XX3, XX4, XX5, XX6, XX7, XX8, &
  &          YY1, YY2, YY3, YY4, YY5, YY6, YY7, YY8, &
  &          ZZ1, ZZ2, ZZ3, ZZ4, ZZ5, ZZ6, ZZ7, ZZ8
  REAL(8) :: ALP, BET, GAM
  INTEGER :: N
  REAL(8) :: FX, FY, FZ
  REAL(8) :: FXA, FXB, FXG, FYA, FYB, FYG, FZA, FZB, FZG
  REAL(8) :: DELTA, DA, DB, DG, DABGMIN, DABGMAX, DMAX
  REAL(8) :: CRLX
  REAL(8) :: MARGIND
  ! 処理開始 ***********************************************************
  ! 初期値 -------------------------------------------------------------
  ALP   = DBLE(ALP0)
  BET   = DBLE(BET0)
  GAM   = DBLE(GAM0)
  FCOMP = .FALSE.
  ! 補間関数用定数設定 -------------------------------------------------
  XX1 = DBLE(X2) - DBLE(X1)
  XX2 = DBLE(X3) - DBLE(X1)
  XX3 = DBLE(X5) - DBLE(X1)
  XX4 = DBLE(X1) - DBLE(X2) - DBLE(X3) + DBLE(X4)
  XX5 = DBLE(X1) - DBLE(X3) - DBLE(X5) + DBLE(X7)
  XX6 = DBLE(X1) - DBLE(X2) - DBLE(X5) + DBLE(X6)
  XX7 =-DBLE(X1) + DBLE(X2) + DBLE(X3) - DBLE(X4) &
  &   + DBLE(X5) - DBLE(X6) - DBLE(X7) + DBLE(X8)
  XX8 = DBLE(X1) - DBLE(X0)
  YY1 = DBLE(Y2) - DBLE(Y1)
  YY2 = DBLE(Y3) - DBLE(Y1)
  YY3 = DBLE(Y5) - DBLE(Y1)
  YY4 = DBLE(Y1) - DBLE(Y2) - DBLE(Y3) + DBLE(Y4)
  YY5 = DBLE(Y1) - DBLE(Y3) - DBLE(Y5) + DBLE(Y7)
  YY6 = DBLE(Y1) - DBLE(Y2) - DBLE(Y5) + DBLE(Y6)
  YY7 =-DBLE(Y1) + DBLE(Y2) + DBLE(Y3) - DBLE(Y4) &
  &   + DBLE(Y5) - DBLE(Y6) - DBLE(Y7) + DBLE(Y8)
  YY8 = DBLE(Y1) - DBLE(Y0)
  ZZ1 = DBLE(Z2) - DBLE(Z1)
  ZZ2 = DBLE(Z3) - DBLE(Z1)
  ZZ3 = DBLE(Z5) - DBLE(Z1)
  ZZ4 = DBLE(Z1) - DBLE(Z2) - DBLE(Z3) + DBLE(Z4)
  ZZ5 = DBLE(Z1) - DBLE(Z3) - DBLE(Z5) + DBLE(Z7)
  ZZ6 = DBLE(Z1) - DBLE(Z2) - DBLE(Z5) + DBLE(Z6)
  ZZ7 =-DBLE(Z1) + DBLE(Z2) + DBLE(Z3) - DBLE(Z4) &
  &   + DBLE(Z5) - DBLE(Z6) - DBLE(Z7) + DBLE(Z8)
  ZZ8 = DBLE(Z1) - DBLE(Z0)
  ! Newton-Raphson Method で、補間パラメータを計算 ---------------------
  CRLX = 1.0
  DO N = 1, NMAX
    FX = XX1*ALP + XX2*BET + XX3*GAM + XX4*ALP*BET &
    &  + XX5*BET*GAM + XX6*ALP*GAM + XX7*ALP*BET*GAM + XX8
    FY = YY1*ALP + YY2*BET + YY3*GAM + YY4*ALP*BET &
    &  + YY5*BET*GAM + YY6*ALP*GAM + YY7*ALP*BET*GAM + YY8
    FZ = ZZ1*ALP + ZZ2*BET + ZZ3*GAM + ZZ4*ALP*BET &
    &  + ZZ5*BET*GAM + ZZ6*ALP*GAM + ZZ7*ALP*BET*GAM + ZZ8
!    FXA = XX1 + XX4*BET + XX6*GAM + XX8*BET*GAM
!    FXB = XX2 + XX4*ALP + XX5*GAM + XX8*ALP*GAM
!    FXG = XX3 + XX5*BET + XX6*ALP + XX8*ALP*BET
!    FYA = YY1 + YY4*BET + YY6*GAM + YY8*BET*GAM
!    FYB = YY2 + YY4*ALP + YY5*GAM + YY8*ALP*GAM
!    FYG = YY3 + YY5*BET + YY6*ALP + YY8*ALP*BET
!    FZA = ZZ1 + ZZ4*BET + ZZ6*GAM + ZZ8*BET*GAM
!    FZB = ZZ2 + ZZ4*ALP + ZZ5*GAM + ZZ8*ALP*GAM
!    FZG = ZZ3 + ZZ5*BET + ZZ6*ALP + ZZ8*ALP*BET
    FXA = XX1 + XX4*BET + XX6*GAM + XX7*BET*GAM
    FXB = XX2 + XX4*ALP + XX5*GAM + XX7*ALP*GAM
    FXG = XX3 + XX5*BET + XX6*ALP + XX7*ALP*BET
    FYA = YY1 + YY4*BET + YY6*GAM + YY7*BET*GAM
    FYB = YY2 + YY4*ALP + YY5*GAM + YY7*ALP*GAM
    FYG = YY3 + YY5*BET + YY6*ALP + YY7*ALP*BET
    FZA = ZZ1 + ZZ4*BET + ZZ6*GAM + ZZ7*BET*GAM
    FZB = ZZ2 + ZZ4*ALP + ZZ5*GAM + ZZ7*ALP*GAM
    FZG = ZZ3 + ZZ5*BET + ZZ6*ALP + ZZ7*ALP*BET
    DELTA = FXA*(FYB*FZG-FYG*FZB) - FXB*(FYA*FZG-FYG*FZA) &
    &     + FXG*(FYA*FZB-FYB*FZA)
    IF(ABS(DELTA) .LE. 1.0D-20) DELTA = SIGN(1.0D-20, DELTA)
    IF(ABS(DELTA) .GE. 1.0D+5) EXIT
    DA =-( FX*(FYB*FZG-FYG*FZB) - FXB*(FY*FZG-FYG*FZ) &
    &    + FXG*(FY*FZB-FYB*FZ) ) / DELTA
    DB =-( FXA*(FY*FZG-FYG*FZ) - FX*(FYA*FZG-FYG*FZA) &
    &    + FXG*(FYA*FZ-FY*FZA) ) / DELTA
    DG =-( FXA*(FYB*FZ-FY*FZB) - FXB*(FYA*FZ-FY*FZA) &
    &    + FX*(FYA*FZB-FYB*FZA) ) / DELTA
    ALP = ALP + DA * CRLX
    BET = BET + DB * CRLX
    GAM = GAM + DG * CRLX
    DABGMIN = MIN(ABS(DA), ABS(DB), ABS(DG))
    DABGMAX = MAX(ABS(DA), ABS(DB), ABS(DG))
    IF( (ABS(DA) .LE. 1.0D-10) .AND. &
    &   (ABS(DB) .LE. 1.0D-10) .AND. &
    &   (ABS(DG) .LE. 1.0D-10) ) EXIT
    IF( (ABS(DA) .GE. 1.0D+5 ) .AND. &
    &   (ABS(DB) .GE. 1.0D+5 ) .AND. &
    &   (ABS(DG) .GE. 1.0D+5 ) ) EXIT
    SELECT CASE(N)
      CASE(1)
        DMAX = DABGMIN
      CASE DEFAULT
        IF(DMAX .LT. DABGMIN) THEN
          DMAX = DABGMIN
          CRLX = CRLX * 0.5
        ENDIF
    END SELECT
    IF(DABGMAX .LE. DMIN) EXIT
  ENDDO
  ! 正当性検査 ---------------------------------------------------------
  MARGIND = DBLE(MARGIN)
  IF( DABGMAX .LE. DMIN .AND. &
  &   0.0D+0 - MARGIND .LE. ALP .AND. ALP .LT. 1.0D+0 + MARGIND .AND. &
  &   0.0D+0 - MARGIND .LE. BET .AND. BET .LT. 1.0D+0 + MARGIND .AND. &
  &   0.0D+0 - MARGIND .LE. GAM .AND. GAM .LT. 1.0D+0 + MARGIND ) THEN
    FCOMP = .TRUE.
  ENDIF
  ALP0 = REAL(ALP)
  BET0 = REAL(BET)
  GAM0 = REAL(GAM)
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE Interpolation3D8Point
!***********************************************************************
!**** 翼の中の点を探索                                              ****
!***********************************************************************
SUBROUTINE BladeInOut( &
&            IS1, IE1, JS1, JE1, KS1, KE1, X1, Y1, Z1,  &
&            IS2, IE2,           KS2, KE2, X2, Y2, Z2,  &
&            BIN )
  ! 変数宣言 ***********************************************************
  IMPLICIT NONE
  ! 引数変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ! メイン・グリッド ---------------------------------------------------
  INTEGER, INTENT(IN)  :: IS1, IE1, JS1, JE1, KS1, KE1
  REAL   , INTENT(IN)  :: X1(IS1:IE1, JS1:JE1, KS1:KE1), &
&                         Y1(IS1:IE1, JS1:JE1, KS1:KE1), &
&                         Z1(IS1:IE1, JS1:JE1, KS1:KE1)
  ! サブ・グリッド -----------------------------------------------------
  INTEGER, INTENT(IN)  :: IS2, IE2, KS2, KE2
  REAL   , INTENT(IN)  :: X2(IS2:IE2, KS2:KE2), &
&                         Y2(IS2:IE2, KS2:KE2), &
&                         Z2(IS2:IE2, KS2:KE2)
  ! 翼の中か外の判定値 -------------------------------------------------
  INTEGER, INTENT(OUT) :: BIN(IS1:IE1, JS1:JE1, KS1:KE1)
  ! 局所変数 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  INTEGER :: I, J, K, II, KK, IP, KP
  REAL    :: DL, DLMIN
  REAL    :: AX, AY, AZ, BX, BY, BZ, CX, CY, CZ, DX, DY, DZ
  REAL    :: HX1, HY1, HZ1, HX2, HY2, HZ2, PRO
  ! 処理開始 ***********************************************************
  DO K = KS1, KE1
  DO J = JS1, JE1
  DO I = IS1, IE1
  ! 翼面で最も近い点の算出 ---------------------------------------------
    DLMIN = 1.0E+10
    DO KK = KS2, KE2
    DO II = IS2, IE2
      DL = SQRT( (X2(II,KK) - X1(I,J,K))**2 &
      &        + (Y2(II,KK) - Y1(I,J,K))**2 &
      &        + (Z2(II,KK) - Z1(I,J,K))**2 )
      IF( DL .LT. DLMIN ) THEN
        DLMIN = DL
        IP = II
        KP = KK
      ENDIF
    END DO
    END DO
  ! 翼面の法線ベクトルを求め内積をとる ---------------------------------
  ! 翼表面からの単位法線ベクトル
    IF( KP .EQ. KS2 ) THEN
      AX = X2(IP,KP+1) - X2(IP,KP  )
      AY = Y2(IP,KP+1) - Y2(IP,KP  )
      AZ = Z2(IP,KP+1) - Z2(IP,KP  )
     ELSE IF( KP .EQ. KE2 ) THEN
      AX = X2(IP,KP  ) - X2(IP,KP-1)
      AY = Y2(IP,KP  ) - Y2(IP,KP-1)
      AZ = Z2(IP,KP  ) - Z2(IP,KP-1)
     ELSE
      AX = X2(IP,KP+1) - X2(IP,KP-1)
      AY = Y2(IP,KP+1) - Y2(IP,KP-1)
      AZ = Z2(IP,KP+1) - Z2(IP,KP-1)
    END IF
    IF( IP .EQ. IS2 )THEN
      BX = X2(IP+1,KP) - X2(IP  ,KP)
      BY = Y2(IP+1,KP) - Y2(IP  ,KP)
      BZ = Z2(IP+1,KP) - Z2(IP  ,KP)
     ELSE IF( IP .EQ. IE2 ) THEN
      BX = X2(IP  ,KP) - X2(IP-1,KP)
      BY = Y2(IP  ,KP) - Y2(IP-1,KP)
      BZ = Z2(IP  ,KP) - Z2(IP-1,KP)
     ELSE
      BX = X2(IP+1,KP) - X2(IP-1,KP)
      BY = Y2(IP+1,KP) - Y2(IP-1,KP)
      BZ = Z2(IP+1,KP) - Z2(IP-1,KP)
    END IF
    CX  = AY * BZ - AZ * BY
    CY  = AZ * BX - AX * BZ
    CZ  = AX * BY - AY * BX
    DL  = SQRT( CX**2 + CY**2 + CZ**2 )
    HX2 = CX / DL
    HY2 = CY / DL
    HZ2 = CZ / DL
  ! 翼近傍への単位ベクトル ---------------------------------------------
    DX  = X1(I,J,K) - X2(IP,KP)
    DY  = Y1(I,J,K) - Y2(IP,KP)
    DZ  = Z1(I,J,K) - Z2(IP,KP)
    DL  = SQRT( DX**2 + DY**2 + DZ**2 )
    HX1 = DX / DL
    HY1 = DY / DL
    HZ1 = DZ / DL
  ! 内積が正なら翼外:0 負なら翼内:1 ------------------------------------
    PRO = HX1 * HX2 + HY1 * HY2 + HZ1 * HZ2
    IF( PRO .GT. 0.0 )THEN
      BIN(I,J,K) = 0
     ELSE
      BIN(I,J,K) = 1
    END IF
  END DO
  END DO
  END DO
  ! 処理終了 ***********************************************************
  RETURN
END SUBROUTINE BladeInOut
! 定義終了 *************************************************************
END MODULE Package_Grid
```

## file "Mod_Package_NACA.f90"

```fortran
!*******************************************************************************************************
!*******************************************************************************************************
!******** NACA翼用の着氷モデル検証計算共通モジュール						********
!********					      2014.04.15  PROGRAMMED BY RYOSUKE HAYASHI ********
!*******************************************************************************************************
!*******************************************************************************************************
module Package_NACA
 ! 変数宣言 ********************************************************************************************
 implicit none
 public
 ! 構造体宣言 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ! 格子 ------------------------------------------------------------------------------------------------
 type Type_Grid
  integer, pointer :: f(:, :, :)
  real   , pointer :: x(:, :, :), y(:, :, :), z(:, :, :)
  integer :: is, ie, js, je, ks, ke
  integer :: i1, i2, i3, i4, i5, &
  &          j1, j2, j3, j4, j5, &
  &          k1, k2, k3, k4, k5
  real    :: xDom, yDom, zDom
 end type Type_Grid
 public :: Type_Grid
 type(Type_Grid), pointer :: Grd(:)
 ! 重合格子法補間係数 ----------------------------------------------------------------------------------
 type Type_Overset
  integer, pointer :: ip(:, :, :), jp(:, :, :), kp(:, :, :)		! 補間点
  integer, pointer :: fOver(:, :, :)					! 補間点のフラグ
  real   , pointer :: term1(:, :, :), term2(:, :, :), &
  &		      term3(:, :, :), term4(:, :, :), &
  &                   term5(:, :, :), term6(:, :, :), &
  &		      term7(:, :, :), term8(:, :, :)			! 補間係数
  integer :: is, ie, js, je, ks, ke					! 補間範囲
  integer :: m1								! 被補間ブロック
  integer :: m2								! 加補間ブロック
  real    :: MGN							! 補間係数許容誤差
 end type Type_Overset
 type(Type_Overset), pointer :: OSG(:)
 ! 流れ場 ----------------------------------------------------------------------------------------------
 type Type_Flow
  real   , pointer :: x(:, :, :), y(:, :, :), z(:, :, :)		! 格子座標
  integer, pointer :: f(:, :, :)
  real   , pointer :: xix(:, :, :), xiy(:, :, :), xiz(:, :, :), &
  &                   etx(:, :, :), ety(:, :, :), etz(:, :, :), &
  &                   zex(:, :, :), zey(:, :, :), zez(:, :, :), &
  &	              jac(:, :, :)					! メトリックス
  real   , pointer :: rho(:, :, :), u(:, :, :), v(:, :, :), w(:, :, :), &
  &                   p(:, :, :), t(:, :, :), &
  &                   kin(:, :, :), eps(:, :, :), &
  &                   mu(:, :, :), mut(:, :, :)				! 物理量
  real   , pointer :: qh(:, :, :, :), dqh(:, :, :, :), &
  &                   dqc(:, :, :, :), dqd(:, :, :, :), &
  &                   dqp(:, :, :, :), dqr(:, :, :, :), &
  &                   qh0(:, :, :, :), dqh0(:, :, :, :)			! 流束関数
  real   , pointer :: dt(:, :, :)					! 時間刻み
  real   , pointer :: Res(:)						! 残差
  real   , pointer :: nimp(:, :)					! 衝突個数
  real   , pointer :: uimp(:, :), vimp(:, :), wimp(:, :)		! 衝突速度の和
  real   , pointer :: simp(:, :) 					! 衝突面積
  real   , pointer :: CE(:, :)						! 収集効率
  real   , pointer :: ImpMass(:, :)					! 衝突質量
  integer, pointer :: fRough(:, :)					! 壁面粗さのフラグ
  real   , pointer :: RH(:, :)						! 局所粗さ
  integer :: is, ie, js, je, ks, ke					! 格子数
  integer :: i1, i2, i3, i4, i5, &
  &          j1, j2, j3, j4, j5, &
  &          k1, k2, k3, k4, k5						! 境界格子番号
 end type Type_Flow
 type(Type_Flow), pointer :: Flw(:)
 ! 液滴軌道 --------------------------------------------------------------------------------------------
 type Type_Drop
  integer, pointer :: m(:)						! 液滴軌道の格子番号
  real   , pointer :: x(:), y(:), z(:)					! 液滴軌道の位置
  real   , pointer :: u(:), v(:), w(:)					! 液滴の速度
  real   , pointer :: mr(:)						! 液滴質量比
  real   , pointer :: cd(:)						! 抗力係数
  real   , pointer :: Re(:)						! レイノルズ数
  real   , pointer :: AsRatio(:)					! 液滴のアスペクト比
  integer  :: step							! 液滴軌道の計算ステップ
 end type Type_Drop
 type(Type_Drop), pointer :: Drp(:)
 ! 着氷 ------------------------------------------------------------------------------------------------
 type Type_Ice
  real   , pointer :: x(:), y(:), z(:)					! 格子座標
  integer, pointer :: f(:)
  real   , pointer :: Uimp(:), Vimp(:)					! 液滴衝突速度
  real   , pointer :: CE(:)						! 液滴収集効率
  real   , pointer :: SA(:)						! 表面セル面積
  real   , pointer :: Yp(:)						! 表面から一点目の距離
  real   , pointer :: Up(:), Vp(:), Wp(:)				! 表面から一点目の速度成分
  real   , pointer :: Velp(:)						! 表面から一点目の速度
  real   , pointer :: nup(:)						! 表面から一点目の動粘性係数
  real   , pointer :: Ptp(:)						! 表面から一点目の全圧
  real   , pointer :: Rho0(:)						! 翼表面密度
  real   , pointer :: mu0(:)						! 翼表面粘性係数
  real   , pointer :: Ts0(:)						! 翼表面温度
  real   , pointer :: Ta(:)						! 周囲流体の温度
  real   , pointer :: Pa(:)						! 周囲流体の圧力
  real   , pointer :: Ue(:)						! 境界層外端の速度
  integer, pointer :: fRough(:)						! 壁面粗さのフラグ
  integer, pointer :: nPhase(:)						! 表面の状態
  real   , pointer :: Mes(:)						! 蒸発・昇華の質量
  real   , pointer :: Mim(:)						! 液滴衝突の質量
  real   , pointer :: Mrin(:)						! Runback-in の質量
  real   , pointer :: Mrout(:)						! Runback-out の質量
  real   , pointer :: Mst(:)						! 検査体積内に残る質量
  real   , pointer :: Mac(:)						! 堆積する氷の質量
  real   , pointer :: Bi(:)						! 氷層厚さ (絶対量)
  real   , pointer :: Bi0(:)						! 氷層厚さ (絶対量)
  real   , pointer :: dBi(:)						! 氷層厚さ (変化量)
  real   , pointer :: Ti(:)						! 氷層温度
  real   , pointer :: xi(:), yi(:)					! 着氷翼座標
  integer :: is, ie
  integer :: i1, i2, i3
 end type Type_Ice
 type(Type_Ice), pointer :: Ice(:)
 ! 共有定数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real   , parameter :: pi    = 3.1415926535897932			! 円周率
 real   , parameter :: zero  = 1.0e-20					! ゼロ割防止
 real   , parameter :: InvSix = 1.0 / 6.0
 real   , parameter :: IceTs = 273.15					! 氷結温度 [K]
 real   , parameter :: knot  = 0.514444444				! 1 [knot] = 0.514444444 [m/s]
 integer, parameter :: ls = 1
 integer, parameter :: le = 7						! 流れ場配列数
 integer, parameter :: ms = 1						! Main Grid 構造体番号
 integer, parameter :: me = 2						! Sub Grid 構造体番号
 ! 共有変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer, pointer :: IceIn(:, :, :)					! 氷の中の点
 integer :: BCNum, TurbNum						! 流れ場モデルの選択
 integer :: ThermoNum, RoughNum, RunbackNum, DropShedNum, IceShedNum	! 着氷モデル選択
 integer :: DragNum
 real    :: span, chord, AOA						! スパン長，コード長，迎角
 real    :: VelExp, TsExp, PsExp					! 実験条件
 real    :: VelIn, PtIn, TtIn, PsOut, TsOut				! 流入出境界固定値
 real    :: TsSth, muSth						! サザーランドの式の定数
 real    :: ReRef, aRef, LRef, RhoRef					! 無次元化参照値
 integer :: nRunge							! ルンゲ・クッタ法の階層
 integer :: nTVD							! TVDスキームの精度
 real    :: Cn, Cnd, Cmu, eTVD						! 計算条件
 real    :: Rg, gamma, Pr, Prt, Ret, s1					! 物性値
 real    :: dtMin, dti							! 時間刻み
 real    :: LmtPro, LmtAve						! k-eリミッター定数
 integer :: nStart, nCalMax, nDrpCalMax, nCount				! 計算回数
 integer :: nOutputLog, nDrpOutputLog, nOutputCount, nDrpOutputCount	! ファイル出力周期
 real    :: time							! 経過時間
 integer :: nDrop							! 液滴数のカウンタ
 integer :: nDrpIn							! 投入液滴数
 integer :: nDrpFile							! 液滴軌道ファイル出力数
 real    :: LWC								! 水分含有率
 real    :: MVD								! 平均液滴径
 real    :: RhoD							! 液滴密度
 real    :: SigD							! 液滴表面張力
 real    :: muD								! 液滴粘性係数
 real    :: DrpInArea							! 液滴投入面積
 real    :: DrpInVel							! 液滴投入速度
 real    :: IceTime, IceTimeMax						! 着氷時間
 integer :: IceStep, IceStepMax						! 計算ステップ
 integer :: ExpCaseNum							! 実験ケース
 integer :: nDrpSpl, nDrpBou						! スプラッシュ・バウンドの液滴数
 integer :: nDrp2Imp							! 2回衝突した液滴数
 integer :: nDrpBrk							! 分裂した液滴数
 logical :: fTime, fSteady, fSlip
 ! ディレクトリ名 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character :: GrdInDir * 50, GrdOutDir * 50, OSGDir * 50, &
 &            FlwIniDir * 50, FlwCalInDir * 50, FlwCalOutDir * 50, FlwViewDir * 50, IceViewDir * 50, &
 &            DrpTraDir * 50, DrpImpDir * 50, IceCalInDir * 50, IceCalOutDir * 50, VldDir * 50
 ! ファイル名 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, parameter :: ExpCaseFile          * 19 = 'Input_ExpCaseNumber'
 character, parameter :: ExpConditionFile     * 19 = 'Input_ExpCondition'
 character, parameter :: CalSetFile           * 10 = 'CalSetting'
 character, parameter :: ND_CalSetFile        * 13 = 'ND_CalSetting'
 character, parameter :: RslFile              * 10 = 'Resolution'
 character, parameter :: IceRslFile           * 13 = 'IceResolution'
 character, parameter :: CtypePointFile	      * 14 = 'CtypeGridPoint'
 character, parameter :: GrdFile              *  4 = 'Grid'
 character, parameter :: OverAreaFile         * 11 = 'OversetArea'
 character, parameter :: OverCoeFile          * 18 = 'OversetCoefficient'
 character, parameter :: MetFile              *  7 = 'Metrics'
 character, parameter :: IniFlxFile           * 11 = 'InitialFlux'
 character, parameter :: FlxFile              *  4 = 'Flux'
 character, parameter :: PhyFile              *  7 = 'Physics'
 character, parameter :: ND_RefFile           *  6 = 'ND_Ref'
 character, parameter :: ND_SutherlandFile    * 13 = 'ND_Sutherland'
 character, parameter :: ND_InflowFile        * 18 = 'ND_InflowCondition'
 character, parameter :: ND_GrdFile           *  7 = 'ND_Grid'
 character, parameter :: ND_MetFile           * 10 = 'ND_Metrics'
 character, parameter :: ND_IniFlxFile        * 14 = 'ND_InitialFlux'
 character, parameter :: ND_FlxFile           *  7 = 'ND_Flux'
 character, parameter :: ND_DrpImpiDataFile   * 18 = 'ND_ImpingementData'
 character, parameter :: ND_CollectionFile    * 20 = 'ND_CollectionEfficiency'
 character, parameter :: FlwCalCountFile      * 12 = 'FlowCalCount'
 character, parameter :: FlwCalLogFile        *  7 = 'FlowLog'
 character, parameter :: DrpCalLogFile        *  7 = 'DropLog'
 character, parameter :: DrpTrajectoryFile    * 14 = 'DropTrajectory'
 character, parameter :: DrpImpiAreaFile      * 15 = 'ImpingementArea'
 character, parameter :: DrpImpiDataFile      * 15 = 'ImpingementData'
 character, parameter :: DrpInConditionFile   * 15 = 'DropInCondition'
 character, parameter :: CollectionFile       * 20 = 'CollectionEfficiency'
 character, parameter :: IceCalLogFile        *  6 = 'IceLog'
 character, parameter :: IceThickTemFile      * 11 = 'IceThickTem'
 character, parameter :: IceMassFlxFile       * 11 = 'IceMassFlux'
 character, parameter :: IceBladeFile         *  8 = 'IceBlade'
 character, parameter :: IceStepFile          * 17 = 'Input_IceTimeStep'
 character, parameter :: WaterBladeFile       * 10 = 'WaterBlade'
 character, parameter :: MessingerFile        * 13 = 'MessingerPara'
 character, parameter :: ExMessingerFile      * 15 = 'ExMessingerPara'
 character, parameter :: IceLimitPointFile    * 13 = 'IceLimitPoint'
 character, parameter :: IceInPointFile       * 10 = 'IceInPoint'
 character, parameter :: RoughFlagFile        * 13 = 'RoughnessFlag'
 character :: BlkName(ms:me) * 5
! 内部手続き開始 ***************************************************************************************
contains
!*******************************************************************************************************
!******** C 型格子の分割点入力									********
!*******************************************************************************************************
subroutine Input_CtypeGridPoint(strname, i1, i2, i3)
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*)
 integer  , intent(out) :: i1, i2, i3
 ! 処理開始 ********************************************************************************************
 open(1, file = trim(strname), form = 'formatted', status = 'old')
  read(1, '(i4,2(x,i4))') i1, i2, i3
 close(1)
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_CtypeGridPoint
!*******************************************************************************************************
!******** C 型格子の分割点出力									********
!*******************************************************************************************************
subroutine Output_CtypeGridPoint(strname, i1, i2, i3)
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*)
 integer  , intent(in) :: i1, i2, i3
 ! 処理開始 ********************************************************************************************
 open(1, file = trim(strname), form = 'formatted', status = 'replace')
  write(1, '(i4,2(x,i4))') i1, i2, i3
 close(1)
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_CtypeGridPoint
!*******************************************************************************************************
!******** 着氷限界割点入力									********
!*******************************************************************************************************
subroutine Input_IceLimitPoint(strname, i1, i2)
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in)  :: strname*(*)
 integer  , intent(out) :: i1, i2
 ! 処理開始 ********************************************************************************************
 open(1, file = trim(strname), form = 'formatted', status = 'old')
  read(1, *) i1
  read(1, *) i2
 close(1)
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_IceLimitPoint
!*******************************************************************************************************
!******** 着氷限界点出力									********
!*******************************************************************************************************
subroutine Output_IceLimitPoint(strname, i1, i2)
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*)
 integer  , intent(in) :: i1, i2
 ! 処理開始 ********************************************************************************************
 open(1, file = trim(strname), form = 'formatted', status = 'replace')
  write(1, *) i1
  write(1, *) i2
 close(1)
 ! 処理終了 ********************************************************************************************
 return
end subroutine Output_IceLimitPoint
!*******************************************************************************************************
!******** 計算条件設定ファイルの入力								********
!*******************************************************************************************************
subroutine Input_CalSetting(strname)
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*)
 ! 処理開始 ********************************************************************************************
 open(1, file = trim(strname), form = 'formatted', status = 'old')
  read(1, '(i2)') ExpCaseNum
  read(1, '(i2,x,i2,2(x,i10))') IceStep, IceStepMax, nCount, nDrop
  read(1, '(e16.8e3,x,e16.8e3)') IceTime, dti
  read(1, '(e16.8e3,2(x,e16.8e3))') Span, Chord, AOA
  read(1, '(e16.8e3,2(x,e16.8e3))') VelExp, PsExp, TsExp
  read(1, '(e16.8e3,5(x,e16.8e3))') LWC, MVD, Rhod, Sigd, mud, IceTimeMax
  read(1, '(e16.8e3,4(x,i10))') Cn, nRunge, nCalMax, nOutputLog, nOutputCount
  read(1, '(i3,3(x,e16.8e3))') nTVD, eTVD, LmtPro, LmtAve
  read(1, '(i3,2(x,l1))') TurbNum, fSteady, fTime
  read(1, '(i3,x,l1)') BCNum, fSlip
  read(1, '(i3,5(x,i2))') ThermoNum, RoughNum, RunbackNum, DropShedNum, IceShedNum, DragNum
  read(1, '(e16.8e3,5(x,e16.8e3))') Rg, gamma, Pr, Prt, Ret, Cmu
  read(1, '(e16.8e3,2(x,e16.8e3))') muSth, TsSth, s1
  read(1, '(e16.8e3,2(x,e16.8e3))') aRef, LRef, RhoRef
  read(1, '(e16.8e3,5(x,i10))') Cnd, nDrpIn, nDrpCalMax, nDrpFile, nDrpOutputLog, nDrpOutputCount
  read(1, '(4i10)') nDrpSpl, nDrpBou, nDrp2Imp, nDrpBrk
  read(1, '(e16.8e3,4(x,e16.8e3))') VelIn, TtIn, PtIn, TsOut, PsOut
 close(1)
 ! 処理終了 ********************************************************************************************
end subroutine Input_CalSetting
!*******************************************************************************************************
!******** 計算条件設定ファイルの出力								********
!*******************************************************************************************************
subroutine Output_CalSetting(strname)
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*)
 ! 処理開始 ********************************************************************************************
 open(1, file = trim(strname), form = 'formatted', status = 'replace')
  write(1, '(i2)') ExpCaseNum
  write(1, '(i2,x,i2,2(x,i10))') IceStep, IceStepMax, nCount, nDrop
  write(1, '(e16.8e3,x,e16.8e3)') IceTime, dti
  write(1, '(e16.8e3,2(x,e16.8e3))') Span, Chord, AOA
  write(1, '(e16.8e3,2(x,e16.8e3))') VelExp, PsExp, TsExp
  write(1, '(e16.8e3,5(x,e16.8e3))') LWC, MVD, Rhod, Sigd, mud, IceTimeMax
  write(1, '(e16.8e3,4(x,i10))') Cn, nRunge, nCalMax, nOutputLog, nOutputCount
  write(1, '(i3,3(x,e16.8e3))') nTVD, eTVD, LmtPro, LmtAve
  write(1, '(i3,2(x,l1))') TurbNum, fSteady, fTime
  write(1, '(i3,x,l1)') BCNum, fSlip
  write(1, '(i3,5(x,i2))') ThermoNum, RoughNum, RunbackNum, DropShedNum, IceShedNum, DragNum
  write(1, '(e16.8e3,5(x,e16.8e3))') Rg, gamma, Pr, Prt, Ret, Cmu
  write(1, '(e16.8e3,2(x,e16.8e3))') muSth, TsSth, s1
  write(1, '(e16.8e3,2(x,e16.8e3))') aRef, LRef, RhoRef
  write(1, '(e16.8e3,5(x,i10))') Cnd, nDrpIn, nDrpCalMax, nDrpFile, nDrpOutputLog, nDrpOutputCount
  write(1, '(4i10)') nDrpSpl, nDrpBou, nDrp2Imp, nDrpBrk
  write(1, '(e16.8e3,4(x,e16.8e3))') VelIn, TtIn, PtIn, TsOut, PsOut
 close(1)
 ! 処理終了 ********************************************************************************************
end subroutine Output_CalSetting
!*******************************************************************************************************
!******** 実験条件入力										********
!*******************************************************************************************************
subroutine Input_ExpCondition(strname)
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 character, intent(in) :: strname*(*)
 ! 処理開始 ********************************************************************************************
 open(1, file = trim(strname), form = 'formatted', status = 'old')
  read(1, *) Chord							! [m]
  read(1, *) TsExp							! [℃]
  read(1, *) VelExp							! [m/s]
  read(1, *) PsExp							! [kPa]
  read(1, *) MVD							! [μm]
  read(1, *) LWC							! [g/m^3]
  read(1, *) IceTimeMax							! [min.]
  read(1, *) Span							! [m]
  read(1, *) AOA							! [deg.]
  read(1, *) RhoD							! [g/cm^3]
  read(1, *) SigD							! [N/m]
  read(1, *) muD							! [N・s/m^2]
 close(1)
 TsExp      = TsExp + IceTs
 PsExp      = PsExp * 1.0e+3
 MVD        = MVD * 1.0e-6
 LWC        = LWC * 1.0e-3
 IceTimeMax = IceTimeMax * 60.0
 AOA        = AOA * pi / 180.0
 RhoD       = RhoD * 1.0e+3
 ! 処理終了 ********************************************************************************************
 return
end subroutine Input_ExpCondition
!*******************************************************************************************************
!******** ブロック名設定 									********
!*******************************************************************************************************
subroutine Set_BlockName
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: m
 ! 処理開始 ********************************************************************************************
 BlkName(1) = 'Main_'
 BlkName(2) = 'Sub_'
 do m = ms, me
  BlkName(m) = trim(BlkName(m))
 enddo
 ! 処理終了 ********************************************************************************************
 return
end subroutine Set_BlockName
!*******************************************************************************************************
!******** 座標系の無次元化                                              			********
!*******************************************************************************************************
subroutine NondimensionalizedCoord3D( &
&            is, ie, js, je, ks, ke, x, y, z )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer, intent(in)    :: is, ie, js, je, ks, ke
 real   , intent(inout) :: x(is:ie, js:je, ks:ke)
 real   , intent(inout) :: y(is:ie, js:je, ks:ke)
 real   , intent(inout) :: z(is:ie, js:je, ks:ke)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i, j, k
 ! 処理開始 ********************************************************************************************
 !$omp parallel do default(shared) private(i, j, k)
 do k = ks, ke
 do j = js, je
 do i = is, ie
  x(i,j,k) = x(i,j,k) / LRef
  y(i,j,k) = y(i,j,k) / LRef
  z(i,j,k) = z(i,j,k) / LRef
 enddo
 enddo
 enddo
 !$omp end parallel do
 ! 処理終了 ********************************************************************************************
 return
end subroutine NondimensionalizedCoord3D
!*******************************************************************************************************
!******** 物理量の無次元化                                              			********
!*******************************************************************************************************
subroutine NondimensionalizedPhysics3D( &
&            is, ie, js, je, ks, ke, rho, u, v, w, p, t, mu, kin, eps, mut )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer, intent(in)    :: is, ie, js, je, ks, ke
 real   , intent(inout) :: rho(is:ie, js:je, ks:ke)
 real   , intent(inout) :: u(is:ie, js:je, ks:ke)
 real   , intent(inout) :: v(is:ie, js:je, ks:ke)
 real   , intent(inout) :: w(is:ie, js:je, ks:ke)
 real   , intent(inout) :: p(is:ie, js:je, ks:ke)
 real   , intent(inout) :: t(is:ie, js:je, ks:ke)
 real   , intent(inout) :: kin(is:ie, js:je, ks:ke)
 real   , intent(inout) :: eps(is:ie, js:je, ks:ke)
 real   , intent(inout) :: mu(is:ie, js:je, ks:ke)
 real   , intent(inout) :: mut(is:ie, js:je, ks:ke)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i, j, k
 ! 処理開始 ********************************************************************************************
 !$omp parallel do default(shared) private(i, j, k)
 do k = ks, ke
 do j = js, je
 do i = is, ie
  rho(i,j,k) = rho(i,j,k) / RhoRef
  u(i,j,k)   = u(i,j,k)   / aRef
  v(i,j,k)   = v(i,j,k)   / aRef
  w(i,j,k)   = w(i,j,k)   / aRef
  p(i,j,k)   = p(i,j,k)   / (RhoRef * aRef**2)
  t(i,j,k)   = t(i,j,k)   / aRef**2
  mu(i,j,k)  = mu(i,j,k)  / (RhoRef * aRef * LRef)
  kin(i,j,k) = kin(i,j,k) / aRef**2
  eps(i,j,k) = eps(i,j,k) / (aRef**3 / LRef)
  mut(i,j,k) = mut(i,j,k) / (RhoRef * aRef * LRef)
 enddo
 enddo
 enddo
 !$omp end parallel do
 ! 処理終了 ********************************************************************************************
 return
end subroutine NondimensionalizedPhysics3D
!*******************************************************************************************************
!******** 座標系の有次元化                                              			********
!*******************************************************************************************************
subroutine DimensionalizedCoord3D( &
&            is, ie, js, je, ks, ke, x, y, z )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer, intent(in)    :: is, ie, js, je, ks, ke
 real   , intent(inout) :: x(is:ie, js:je, ks:ke)
 real   , intent(inout) :: y(is:ie, js:je, ks:ke)
 real   , intent(inout) :: z(is:ie, js:je, ks:ke)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i, j, k
 ! 処理開始 ********************************************************************************************
 !$omp parallel do default(shared) private(i, j, k)
 do k = ks, ke
 do j = js, je
 do i = is, ie
  x(i,j,k) = x(i,j,k) * LRef
  y(i,j,k) = y(i,j,k) * LRef
  z(i,j,k) = z(i,j,k) * LRef
 enddo
 enddo
 enddo
 !$omp end parallel do
 ! 処理終了 ********************************************************************************************
 return
end subroutine DimensionalizedCoord3D
!*******************************************************************************************************
!******** 物理量の有次元化                                              			********
!*******************************************************************************************************
subroutine DimensionalizedPhysics3D( &
&            is, ie, js, je, ks, ke, rho, u, v, w, p, t, mu, kin, eps, mut )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer, intent(in)    :: is, ie, js, je, ks, ke
 real   , intent(inout) :: rho(is:ie, js:je, ks:ke)
 real   , intent(inout) :: u(is:ie, js:je, ks:ke)
 real   , intent(inout) :: v(is:ie, js:je, ks:ke)
 real   , intent(inout) :: w(is:ie, js:je, ks:ke)
 real   , intent(inout) :: p(is:ie, js:je, ks:ke)
 real   , intent(inout) :: t(is:ie, js:je, ks:ke)
 real   , intent(inout) :: kin(is:ie, js:je, ks:ke)
 real   , intent(inout) :: eps(is:ie, js:je, ks:ke)
 real   , intent(inout) :: mu(is:ie, js:je, ks:ke)
 real   , intent(inout) :: mut(is:ie, js:je, ks:ke)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer :: i, j, k
 ! 処理開始 ********************************************************************************************
 !$omp parallel do default(shared) private(i, j, k)
 do k = ks, ke
 do j = js, je
 do i = is, ie
  rho(i,j,k) = rho(i,j,k) * RhoRef
  u(i,j,k)   = u(i,j,k)   * aRef
  v(i,j,k)   = v(i,j,k)   * aRef
  w(i,j,k)   = w(i,j,k)   * aRef
  p(i,j,k)   = p(i,j,k)   * (RhoRef * aRef**2)
  t(i,j,k)   = t(i,j,k)   * aRef**2
  mu(i,j,k)  = mu(i,j,k)  * (RhoRef * aRef * LRef)
  kin(i,j,k) = kin(i,j,k) * aRef**2
  eps(i,j,k) = eps(i,j,k) * (aRef**3 / LRef)
  mut(i,j,k) = mut(i,j,k) * (RhoRef * aRef * LRef)
 enddo
 enddo
 enddo
 !$omp end parallel do
 ! 処理終了 ********************************************************************************************
 return
end subroutine DimensionalizedPhysics3D
!*******************************************************************************************************
!******** 数値流束のスムージング 								********
!*******************************************************************************************************
subroutine SmoothingFlux3D( &
 &           is, ie, js, je, ks, ke, ls, le, jac, qh )
 ! 変数宣言 ********************************************************************************************
 implicit none
 ! 引数変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 integer, intent(in)    :: is, ie, js, je, ks, ke, ls, le
 real   , intent(in)    :: jac(is:ie, js:je, ks:ke)
 real   , intent(inout) :: qh (is:ie, js:je, ks:ke, ls:le)
 ! 局所変数 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 real   , pointer :: q0(:, :, :, :)
 integer :: i, j, k, l
 ! 処理開始 ********************************************************************************************
 ! メモリ確保 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 allocate( q0(is:ie, js:je, ks:ke, ls:le) )
 ! 元の物理量を保存 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 do k = ks, ke
 do j = js, je
 do i = is, ie
  do l = ls + 1, le
   q0(i,j,k,l) = qh(i,j,k,l) / qh(i,j,k,1)
  enddo
  q0(i,j,k,1) = qh(i,j,k,1) * jac(i,j,k)
 enddo
 enddo
 enddo
 ! 周囲点の平均値を外挿 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 do k = ks + 1, ke - 1
 do j = js + 1, je - 1
 do i = is + 1, ie - 1
  qh(i,j,k,1) = ( q0(i  ,j  ,k-1,1) + q0(i  ,j-1,k  ,1) + q0(i-1,j  ,k  ,1) &
  &             + q0(i+1,j  ,k  ,1) + q0(i  ,j+1,k  ,1) + q0(i  ,j  ,k+1,1) &
  &             ) * InvSix / jac(i,j,k)
  do l = ls + 1, le
   qh(i,j,k,l) = ( q0(i  ,j  ,k-1,l) + q0(i  ,j-1,k  ,l) + q0(i-1,j  ,k  ,l) &
   &             + q0(i+1,j  ,k  ,l) + q0(i  ,j+1,k  ,l) + q0(i  ,j  ,k+1,l) &
   &             ) * InvSix * qh(i,j,k,1)
  enddo
 enddo
 enddo
 enddo
 ! メモリ解放 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 deallocate(q0)
 ! 処理終了 ********************************************************************************************
 return
end subroutine SmoothingFlux3D
! 定義終了 *********************************************************************************************
end module Package_NACA
```

